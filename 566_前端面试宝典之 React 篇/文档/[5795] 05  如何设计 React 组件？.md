<p data-nodeid="34530" class="">在第 01 讲中，我们知道了&nbsp;React&nbsp;通过组件化的方式，解决了工程实践中代码如何组织的问题，但它并没有指出组件之间应该按照什么样的方式去组合，本讲我们一起来探讨这个问题，即“如何设计 React 组件”。</p>
<h3 data-nodeid="34531">破题</h3>
<p data-nodeid="34532">“如何设计 React 组件？”其实就是在考察你是否了解 React 组件的设计模式。</p>
<p data-nodeid="34533">你有没有发现在实际的工程实践中，如果缺乏一个指导性的设计模式，而直接开发，代码往往会非常凌乱。常见的情况就是：</p>
<ul data-nodeid="34534">
<li data-nodeid="34535">
<p data-nodeid="34536">将一个页面写成一个组件；</p>
</li>
<li data-nodeid="34537">
<p data-nodeid="34538">一个组件包含两三千行的代码。</p>
</li>
</ul>
<p data-nodeid="34539">这些都没有明显的模块划分，缺乏组合的思想。所以如何将组件更好地组合，这是需要探讨的第一个问题。</p>
<p data-nodeid="34540">在明确了“如何组合”这一核心主题后，我们需要思考的是，如何将核心主题以更好的形式展示出来，因为平铺直叙地罗列知识，那内容是非常干瘪的。而基于不同的业务场景，组件的组合形式是不一样的，所以如果结合丰富场景来展示“如何组合”的方式，可以让表述变得有血有肉，也显得你经验十足。</p>
<p data-nodeid="34541">这里你就需要先搞清楚基于场景的设计分类了。</p>
<h3 data-nodeid="34542">承题</h3>
<p data-nodeid="34543">通过以上的分析，我们可以得出“如何设计 React 组件？”这一题的答题套路是“一个主题，多个场景”，即围绕“如何组合”这一核心主题，通过列举场景的方式展现设计模式的分类及用途。</p>
<p data-nodeid="34544">我们先来了解下 React 的组件有哪些分类，这里可以直接采用 React 社区中非常经典的分类模式：</p>
<ul data-nodeid="34545">
<li data-nodeid="34546">
<p data-nodeid="34547">把只作展示、独立运行、不额外增加功能的组件，称为<strong data-nodeid="34700">哑组件</strong>，或<strong data-nodeid="34701">无状态组件</strong>，还有一种叫法是<strong data-nodeid="34702">展示组件</strong>；</p>
</li>
<li data-nodeid="34548">
<p data-nodeid="34549">把处理业务逻辑与数据状态的组件称为有<strong data-nodeid="34712">状态组件</strong>，或<strong data-nodeid="34713">灵巧组件</strong>，灵巧组件一定包含至少一个灵巧组件或者展示组件。</p>
</li>
</ul>
<p data-nodeid="34550">从分类中可以看出<strong data-nodeid="34719">展示组件的复用性更强，灵巧组件则更专注于业务本身</strong>。那么基于以上的思路，你可以整理出如下的知识导图：</p>
<p data-nodeid="36697"><img src="https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIYmAVjAWAAUY2rGM2bc188.png" alt="react面试05金句.png" data-nodeid="36701"></p>
<p data-nodeid="36698" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/1C/Ciqc1F_TIY-ANgywAAB0DSyjFv4894.png" alt="图片1.png" data-nodeid="36704"></p>




<p data-nodeid="34552">接下来我将结合各个场景来为你展开讲解这些组件。</p>
<h3 data-nodeid="34553">入题</h3>
<p data-nodeid="34554">无论是怎样的设计，始终是不能脱离工程实践进行探讨的。回到前端工程中来，如果使用 create-react-app 初始化项目，通常会有类似这样的目录结构：</p>
<pre class="lang-java" data-nodeid="34555"><code data-language="java">.
├── README.md
├── <span class="hljs-keyword">package</span>.json
├── <span class="hljs-keyword">public</span>
│&nbsp; &nbsp;├── favicon.ico
│&nbsp; &nbsp;├── index.html
│&nbsp; &nbsp;├── logo192.png
│&nbsp; &nbsp;├── logo512.png
│&nbsp; &nbsp;├── manifest.json
│&nbsp; &nbsp;└── robots.txt
├── src
│&nbsp; &nbsp;├── App.css
│&nbsp; &nbsp;├── App.js
│&nbsp; &nbsp;├── App.test.js
│&nbsp; &nbsp;├── index.css
│&nbsp; &nbsp;├── index.js
│&nbsp; &nbsp;├── logo.svg
│&nbsp; &nbsp;├── reportWebVitals.js
│&nbsp; &nbsp;└── setupTests.js
└── yarn.lock
</code></pre>
<p data-nodeid="34556">在源码目录，也就是 src 目录中，所有组件就像衣服散落在房间里一样堆在了一起，如果继续添置衣物，可以想象这个房间最后会变得有多乱。就像每件衣服总有它适用的场合，组件也有同样的分类。</p>
<p data-nodeid="34557">我先带你从功能最薄弱的展示组件开始梳理，其次是展示组件中装饰作用的小物件。</p>
<h4 data-nodeid="34558">展示组件</h4>
<p data-nodeid="34559">展示组件内部是没有状态管理的，正如其名，就像一个个“装饰物”一样，完全受制于外部的 props 控制。展示组件具有极强的<strong data-nodeid="34738">通用性</strong>，<strong data-nodeid="34739">复用率</strong>也很高，往往与当前的前端工程关系相对薄弱，甚至可以做到跨项目级的复用。</p>
<p data-nodeid="34560">我们先来看一下展示组件中最常用的代理组件。</p>
<p data-nodeid="34561"><strong data-nodeid="34744">代理组件</strong></p>
<p data-nodeid="34562"><strong data-nodeid="34753">代理组件常用于封装常用属性</strong>，<strong data-nodeid="34754">减少重复代码</strong>。关于代理组件你应该不陌生，可能经常会写。</p>
<p data-nodeid="34563">举一个最常见的例子，当需要定义一个按钮的时候，需要在按钮上添加 button 属性，代码如下：</p>
<pre class="lang-java" data-nodeid="34564"><code data-language="java">&lt;button type=<span class="hljs-string">"button"</span>&gt;
</code></pre>
<p data-nodeid="34565">当然在 React 中使用的时候，不可能每次都写这样一段代码，非常麻烦。常见的做法是<strong data-nodeid="34761">封装</strong>：</p>
<pre class="lang-java" data-nodeid="34566"><code data-language="java"><span class="hljs-keyword">const</span> Button = props =&gt;
&nbsp; &lt;button type=<span class="hljs-string">"button"</span> {...props}&gt;
</code></pre>
<p data-nodeid="34567">在开发中使用 Button 组件替代原生的 button，可以确保 type 保证一致。</p>
<p data-nodeid="34568">在使用 Antd 开发时，你也会采用类似的设计模式，大致情况如下：</p>
<pre class="lang-java" data-nodeid="34569"><code data-language="java"><span class="hljs-keyword">import</span> { Button as AntdButton } from from <span class="hljs-string">'antd'</span>
<span class="hljs-keyword">const</span> Button = props =&gt;
  &lt;AntdButton size=<span class="hljs-string">"small"</span> type=<span class="hljs-string">"primary"</span> {...props}&gt;

export <span class="hljs-keyword">default</span> Button
</code></pre>
<p data-nodeid="34570">虽然进行封装感觉是多此一举，但切断了外部组件库的<strong data-nodeid="34769">强依赖特性</strong>。在大厂中引入外部组件库需要考虑两点：</p>
<ul data-nodeid="34571">
<li data-nodeid="34572">
<p data-nodeid="34573">如果当前组件库不能使用了，是否能实现业务上的无痛切换；</p>
</li>
<li data-nodeid="34574">
<p data-nodeid="34575">如果需要批量修改基础组件的字段，如何解决？</p>
</li>
</ul>
<p data-nodeid="34576">代理组件的设计模式很好地解决了上面两个问题。从业务上看，代理组件隔绝了 Antd，仅仅是一个组件 Props API 层的交互。这一层如若未来需要替换，是可以保证兼容、快速替换的，而不需要在原有的代码库中查找修改。其次，如果要修改基础组件的颜色、大小、间距，代理组件也可以相对优雅地解决，使得这些修改都内聚在当前的 Button 组件中，而非散落在其他地方。</p>
<p data-nodeid="34577">基于展示组件的思想，可以封装类似的其他组件，比如样式组件。</p>
<p data-nodeid="34578"><strong data-nodeid="34777">样式组件</strong></p>
<p data-nodeid="34579">样式组件也是一种代理组件，只是又细分了处理样式领域，将当前的关注点分离到当前组件内。你是否还记得在第 02 讲中提到过“关注点分离”的概念，其中就说到“将代码分隔为不同部分，其中每一部分都会有自己的关注焦点”。</p>
<p data-nodeid="34580">但在工程实践中，我们并不会因为一个按钮需要协商 className 而封装成一个组件，就像下面这样：</p>
<pre class="lang-java" data-nodeid="34581"><code data-language="java"><span class="hljs-keyword">const</span> Button = props =&gt; (
  &lt;button type=<span class="hljs-string">"button"</span> className=<span class="hljs-string">"btn btn-primary"</span>&gt;
)
</code></pre>
<p data-nodeid="34582">这并没有什么意义。真实工程项目的样式管理往往是复杂的，它更接近于下面这个例子：</p>
<pre class="lang-java" data-nodeid="34583"><code data-language="java"><span class="hljs-keyword">import</span> classnames from <span class="hljs-string">"classnames"</span>;

<span class="hljs-keyword">const</span> StyleButton = ({ className, primary, isHighLighted,  ...props }) =&gt; (
&nbsp; &lt;Button
&nbsp; &nbsp; type=<span class="hljs-string">"button"</span>
&nbsp; &nbsp; className={classnames(<span class="hljs-string">"btn"</span>, {
     btn-primary: primary,
     highLight: isHighLighted,
}, className)}
&nbsp; &nbsp; {...props}
&nbsp; /&gt;
);
</code></pre>
<p data-nodeid="34584">复杂的样式管理对于 Button 是没有意义的，如果直接使用 Button，在属性上修改，对工程代码而言就是编写大量的面条代码。而 StyleButton 的思路是将样式判断逻辑分离到自身上，面向未来改动的时候会更为友好。</p>
<p data-nodeid="34585">接下来可以看下基于样式组件的优化设计。</p>
<p data-nodeid="34586"><strong data-nodeid="34786">布局组件</strong></p>
<p data-nodeid="34587">布局组件的基本设计与样式组件完全一样，但它基于自身特性做了一个小小的优化。</p>
<p data-nodeid="34588">首先来看下它的基础使用案例，主要用于安放其他组件，类似于这样的用法：</p>
<pre class="lang-java" data-nodeid="34589"><code data-language="java">&lt;Layout
&nbsp; Top={&lt;NavigationBar /&gt;}
  Content={&lt;Article /&gt;}
&nbsp; Bottom={&lt;BottomBar /&gt;}
/&gt;
</code></pre>
<p data-nodeid="34590">布局本身是确定的，不需要根据外部状态的变化去修改内部组件。所以这也是一个可以减少渲染的优化点。（当然，这里的样式结构写得比较简单）</p>
<pre class="lang-java" data-nodeid="34591"><code data-language="java">class Layout extends React.Component {
&nbsp; shouldComponentUpdate() {
&nbsp; &nbsp; return false;
&nbsp; }
&nbsp; render() {
&nbsp; &nbsp; &lt;div&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.NavigationBar}&lt;/div&gt;
&nbsp; &nbsp; &nbsp; &lt;div&gt;{this.props.Article}&lt;/div&gt;
      &lt;div&gt;{this.props.BottomBar}&lt;/div&gt;
&nbsp; &nbsp; &lt;/div&gt;
&nbsp; }
}
</code></pre>
<p data-nodeid="34592">由于布局组件无需更新，所以对应到第 3 讲中提到的生命周期，就可以通过写死<strong data-nodeid="34799">shouldComponentUpdate</strong> 的返回值直接阻断渲染过程。对于大型前端工程，类似的小心思可以带来性能上的提升。当然，这也是基于代理组件<strong data-nodeid="34800">更易于维护</strong>而带来的好处。</p>
<h4 data-nodeid="34593">灵巧组件</h4>
<p data-nodeid="34594">由于灵巧组件面向业务，所以相对于展示组件来说，其功能更为丰富、复杂性更高，而复用度更低。<strong data-nodeid="34811">展示组件专注于组件本身特性</strong>，<strong data-nodeid="34812">灵巧组件更专注于组合组件</strong>。那么最常见的案例则是容器组件。</p>
<p data-nodeid="34595"><strong data-nodeid="34816">容器组件</strong></p>
<p data-nodeid="34596">容器组件几乎没有复用性，它主要用在两个方面：<strong data-nodeid="34822">拉取数据与组合组件</strong>。可以看这样一个例子：</p>
<pre class="lang-java" data-nodeid="34597"><code data-language="java">const CardList = ({ cards }) =&gt; (
&nbsp; &lt;div&gt;
&nbsp; &nbsp; {cards.map(card =&gt; (
&nbsp; &nbsp; &nbsp; &lt;CardLayout
        header={&lt;Avatar url={card.avatarUrl} /&gt;}
        Content={&lt;Card {...card} /&gt;}
      /&gt;
&nbsp; &nbsp; &nbsp; &nbsp; {comment.body}-{comment.author}
&nbsp; &nbsp; ))}
&nbsp; &lt;/div&gt;
);
</code></pre>
<p data-nodeid="34598">这是一个 CardList 组件，负责将 cards 数据渲染出来，接下来将获取网络数据。如下代码所示：</p>
<pre class="lang-java" data-nodeid="34599"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardListContainer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
&nbsp; state = { cards: [] }
&nbsp;
&nbsp; <span class="hljs-function">async <span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">const</span> response = <span class="hljs-function">await <span class="hljs-title">fetch</span><span class="hljs-params">(<span class="hljs-string">'/api/cards'</span>)</span>
    <span class="hljs-keyword">this</span>.<span class="hljs-title">setState</span><span class="hljs-params">({cards: response})</span>
&nbsp; }
&nbsp;
&nbsp; <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> &lt;CardList cards={<span class="hljs-keyword">this</span>.state.cards} /&gt;
&nbsp; }
}
</code></pre>
<p data-nodeid="34600">像这样切分代码后，你会发现容器组件内非常干净，没有冗余的样式与逻辑处理。你有没有发现这也是采取了关注点分离的策略？其实这一策略还可以直接应用到你的工作中。因为互联网人的工作常常是多线并行，如果想把事做得更漂亮，可以尝试把它切分成多个片段，让自己的关注点在短时间内更为集中，从而做到高效快速地处理。</p>
<p data-nodeid="34601">回到组件的问题上来，那么对复用性更强的业务逻辑采用什么方式处理呢？</p>
<p data-nodeid="34602"><strong data-nodeid="34829">高阶组件</strong></p>
<p data-nodeid="34603">React 的官方文档将高阶组件称为 React 中<strong data-nodeid="34835">复用组件逻辑的高级技术</strong>。高阶组件本身并不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。简而言之，高阶组件的参数是组件，返回值为新组件的函数。</p>
<p data-nodeid="34604">这样听起来有一些高阶函数的味儿了。那什么是<strong data-nodeid="34841">高阶函数</strong>呢？如果一个函数可以接收另一个函数作为参数，且在执行后返回一个函数，这种函数就称为高阶函数。在 React 的社区生态中，有很多基于高阶函数设计的库，比如 reselector 就是其中之一。</p>
<p data-nodeid="34605">思想一脉相承，React 团队在组件方向也汲取了同样的设计模式。源自高阶函数的高阶组件，可以同样优雅地抽取公共逻辑。</p>
<p data-nodeid="34606"><strong data-nodeid="34846">抽取公共逻辑</strong></p>
<p data-nodeid="34607">用一个常见的例子来说，就是登录态的判断。假设当前项目有订单页面、用户信息页面及购物车首页，那么对于订单页面与用户信息页面都需要检查当前是否已登录，如果没有登录，则应该跳转登录页。</p>
<p data-nodeid="34608">一般的思路类似于：</p>
<pre class="lang-java" data-nodeid="34609"><code data-language="java"><span class="hljs-keyword">const</span> checkLogin = () =&gt; {
  <span class="hljs-keyword">return</span> !!localStorage.getItem(<span class="hljs-string">'token'</span>)
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
   ...
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">if</span>(!checkLogin) {
      <span class="hljs-comment">// 重定向跳转登录页面</span>
    }
  }
  ...
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  componentDidMount() {
    <span class="hljs-keyword">if</span>(!checkLogin) {
      <span class="hljs-comment">// 重定向跳转登录页面</span>
    }
  }
  ...
 }
</code></pre>
<p data-nodeid="34610">虽然已经抽取了一个函数，但还是需要在对应的页面添加<strong data-nodeid="34854">登录态的判断逻辑</strong>。然而如果有高阶组件的话，情况会完全不同。</p>
<pre class="lang-javascript" data-nodeid="34611"><code data-language="javascript"><span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> !!localStorage.getItem(<span class="hljs-string">'token'</span>)
}
<span class="hljs-keyword">const</span> checkLogin = <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
              <span class="hljs-keyword">return</span> checkLogin() ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...props</span>} /&gt;</span></span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LoginPage</span> /&gt;</span></span>;
          }
<span class="hljs-comment">// 函数写法</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
<span class="hljs-keyword">const</span> UserPage = checkLogin(RawUserPage)
<span class="hljs-comment">// 装饰器写法</span>
@checkLogin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@checkLogin
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
&nbsp; ...
}
</code></pre>
<p data-nodeid="34612">从上面的例子中可以看出无论<strong data-nodeid="34864">采用函数</strong>还是<strong data-nodeid="34865">装饰器</strong>的写法，都使得重复代码量下降了一个维度。</p>
<p data-nodeid="34613">还有一个非常经典的场景就是<strong data-nodeid="34871">页面埋点统计</strong>。如果使用装饰器编写的话，大概是这样的：</p>
<pre class="lang-javascript" data-nodeid="34614"><code data-language="javascript"><span class="hljs-keyword">const</span> trackPageView = (pageName) = { 
   <span class="hljs-comment">// 发送埋点信息请求</span>
   ... 
}
<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
  };
}
@PV(<span class="hljs-string">'用户页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@PV(<span class="hljs-string">'购物车页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CartPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
@PV(<span class="hljs-string">'订单页面'</span>)
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ..
}
</code></pre>
<p data-nodeid="34615">就连埋点这样的烦琐操作都变得优雅了起来。那我想同时使用 checkLogin 与 PV 怎么办呢？这里涉及到了一个新的概念，就是链式调用。</p>
<p data-nodeid="34616"><strong data-nodeid="34876">链式调用</strong></p>
<p data-nodeid="34617">由于高阶组件返回的是一个新的组件，所以链式调用是默认支持的。基于 checkLogin 与 PV 两个例子，链式使用是这样的：</p>
<pre class="lang-java" data-nodeid="34618"><code data-language="java"><span class="hljs-comment">// 函数调用方式</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RawUserPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
<span class="hljs-keyword">const</span> UserPage = checkLogin(PV(<span class="hljs-string">'用户页面'</span>)(RawUserPage))
<span class="hljs-comment">// 装饰器调用方式</span>
<span class="hljs-meta">@checkLogin</span>
<span class="hljs-meta">@PV('用户页面')</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  ...
}
</code></pre>
<p data-nodeid="34619">在链式调用后，装饰器会按照从外向内、从上往下的顺序进行执行。</p>
<p data-nodeid="34620">除了抽取公用逻辑以外，还有一种修改渲染结果的方式，被称为<strong data-nodeid="34883">渲染劫持。</strong></p>
<p data-nodeid="34621"><strong data-nodeid="34887">渲染劫持</strong></p>
<p data-nodeid="34622">渲染劫持可以通过控制 render 函数修改输出内容，常见的场景是显示加载元素，如下情况所示：</p>
<pre class="lang-javascript" data-nodeid="34623"><code data-language="javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLoading</span>(<span class="hljs-params">WrappedComponent</span>) </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; render() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.props.isLoading) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.render();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; };
}
</code></pre>
<p data-nodeid="34624">通过高阶函数中继承原组件的方式，劫持修改 render 函数，篡改返回修改，达到显示 Loading 的效果。</p>
<p data-nodeid="34625">但高阶组件并非万能，它同样也有缺陷。</p>
<p data-nodeid="34626"><strong data-nodeid="34894">缺陷</strong></p>
<p data-nodeid="34627"><strong data-nodeid="34898">丢失静态函数</strong></p>
<p data-nodeid="34628">由于被包裹了一层，所以静态函数在外层是无法获取的。如下面的案例中 getUser 是无法被调用的。</p>
<pre class="lang-java" data-nodeid="34629"><code data-language="java"><span class="hljs-comment">// UserPage.jsx</span>
<span class="hljs-meta">@PV('用户页面')</span>
export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPage</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>{
      ...
  } 
}
<span class="hljs-comment">// page.js</span>
<span class="hljs-keyword">import</span> UserPage from <span class="hljs-string">'./UserPage'</span>
UserPage.checkLogin() <span class="hljs-comment">// 调用失败，并不存在。</span>
</code></pre>
<p data-nodeid="34630">如果希望外界能够被调用，那么可以在 PV 函数中将静态函数复制出来。</p>
<pre class="lang-javascript" data-nodeid="34631"><code data-language="javascript"><span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
    &nbsp;Wrap.getUser = WrappedComponent.getUser;
     <span class="hljs-keyword">return</span> Wrap;
  };
 }
</code></pre>
<p data-nodeid="34632">这样做确实能解决静态函数在外部无法调用的问题，但一个类的静态函数可能会有很多，都需要一一手动复制么？其实也有更为简便的处理方案。社区中早就有了现成的工具，通过 hoist-non-react-statics 来处理，可以自动复制所有静态函数。如下代码所示。</p>
<pre class="lang-javascript" data-nodeid="34633"><code data-language="javascript"><span class="hljs-keyword">import</span> hoistNonReactStatics <span class="hljs-keyword">from</span> <span class="hljs-string">'hoist-non-react-statics'</span>;
<span class="hljs-keyword">const</span> PV = <span class="hljs-function">(<span class="hljs-params">pageName</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">WrappedComponent</span>) =&gt;</span> {
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
      componentDidMount() {
        trackPageView(pageName)
      }
 
      render() {
        <span class="hljs-keyword">return</span> (
          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
        );
      }
    }
     hoistNonReactStatics(Wrap, WrappedComponent);
     <span class="hljs-keyword">return</span> Wrap;
  };
 }
</code></pre>
<p data-nodeid="34634">虽然缺少官方的解决方案，但社区方案弥补了不足。除了静态函数的问题以外，还有 refs 属性不能透传的问题。</p>
<p data-nodeid="34635"><strong data-nodeid="34906">refs 属性不能透传</strong></p>
<p data-nodeid="34636">ref 属性由于被高阶组件包裹了一次，所以需要进行特殊处理才能获取。React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题，以下是官方文档中的一个案例：</p>
<pre class="lang-javascript" data-nodeid="34637"><code data-language="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">withLog</span>(<span class="hljs-params">Component</span>) </span>{
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogProps</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    componentDidUpdate(prevProps) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'old props:'</span>, prevProps);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'new props:'</span>, <span class="hljs-keyword">this</span>.props);
    }
    render() {
      <span class="hljs-keyword">const</span> {forwardedRef, ...rest} = <span class="hljs-keyword">this</span>.props;
      <span class="hljs-comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{forwardedRef}</span> {<span class="hljs-attr">...rest</span>} /&gt;</span></span>;
    }
  }
  <span class="hljs-comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span>
  <span class="hljs-comment">// 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span>
  <span class="hljs-comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span>
  <span class="hljs-keyword">return</span> React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">LogProps</span> {<span class="hljs-attr">...props</span>} <span class="hljs-attr">forwardedRef</span>=<span class="hljs-string">{ref}</span> /&gt;</span></span>;
  });
}
</code></pre>
<p data-nodeid="34638">这段代码读起来会有点儿头皮发麻，它正确的阅读顺序应该是从最底下的 React.forwardRef 部分开始，通过 forwardedRef 转发 ref 到 LogProps 内部。</p>
<h4 data-nodeid="34639">工程实践</h4>
<p data-nodeid="34640">通过以上的梳理，接下来看一下如何在目录中给组件安排位置。</p>
<pre class="lang-java" data-nodeid="34641"><code data-language="java">src
├── components
│&nbsp; &nbsp;├── basic
│&nbsp; &nbsp;├── container
│&nbsp; &nbsp;└── hoc
└── pages
</code></pre>
<ul data-nodeid="34642">
<li data-nodeid="34643">
<p data-nodeid="34644">首先将最基本的展示组件放入 basic 目录中；</p>
</li>
<li data-nodeid="34645">
<p data-nodeid="34646">然后将容器组件放入 container；</p>
</li>
<li data-nodeid="34647">
<p data-nodeid="34648">高阶组件放入 hoc 中；</p>
</li>
<li data-nodeid="34649">
<p data-nodeid="34650">将页面外层组件放在页面目录中；</p>
</li>
<li data-nodeid="34651">
<p data-nodeid="34652">通过目录级别完成切分。</p>
</li>
</ul>
<p data-nodeid="34653">在开发中，针对 basic 组件，建议使用类似 Storybook 的工具进行组件管理。因为Storybook 可以有组织地、高效地构建基础组件，有兴趣的话可以查阅下它的<a href="https://storybook.js.org" data-nodeid="34919">官网</a>。</p>
<h3 data-nodeid="34654">答题</h3>
<p data-nodeid="34655">通过以上的归类分析，关于 React 组件设计，我们的脑海中就有比较清晰的认知了。</p>
<blockquote data-nodeid="34656">
<p data-nodeid="34657">React 组件应从设计与工程实践两个方向进行探讨。</p>
<p data-nodeid="34658">从设计上而言，社区主流分类的方案是展示组件与灵巧组件。</p>
<p data-nodeid="34659">展示组件内部没有状态管理，仅仅用于最简单的展示表达。展示组件中最基础的一类组件称作代理组件。代理组件常用于封装常用属性、减少重复代码。很经典的场景就是引入 Antd 的 Button 时，你再自己封一层。如果未来需要替换掉 Antd 或者需要在所有的 Button 上添加一个属性，都会非常方便。基于代理组件的思想还可以继续分类，分为样式组件与布局组件两种，分别是将样式与布局内聚在自己组件内部。</p>
<p data-nodeid="34660">灵巧组件由于面向业务，其功能更为丰富，复杂性更高，复用度低于展示组件。最经典的灵巧组件是容器组件。在开发中，我们经常会将网络请求与事件处理放在容器组件中进行。容器组件也为组合其他组件预留了一个恰当的空间。还有一类灵巧组件是高阶组件。高阶组件被 React 官方称为 React 中复用组件逻辑的高级技术，它常用于抽取公共业务逻辑或者提供某些公用能力。常用的场景包括检查登录态，或者为埋点提供封装，减少样板代码量。高阶组件可以组合完成链式调用，如果基于装饰器使用，就更为方便了。高阶组件中还有一个经典用法就是反向劫持，通过重写渲染函数的方式实现某些功能，比如场景的页面加载圈等。但高阶组件也有两个缺陷，第一个是静态方法不能被外部直接调用，需要通过向上层组件复制的方式调用，社区有提供解决方案，使用 hoist-non-react-statics 可以解决；第二个是 refs 不能透传，使用 React.forwardRef API 可以解决。</p>
<p data-nodeid="34661">从工程实践而言，通过文件夹划分的方式切分代码。我初步常用的分割方式是将页面单独建立一个目录，将复用性略高的 components 建立一个目录，在下面分别建立 basic、container 和 hoc 三类。这样可以保证无法复用的业务逻辑代码尽量留在 Page 中，而可以抽象复用的部分放入 components 中。其中 basic 文件夹放展示组件，由于展示组件本身与业务关联性较低，所以可以使用 Storybook 进行组件的开发管理，提升项目的工程化管理能力。</p>
</blockquote>
<p data-nodeid="34662">还可以通过以下知识导图来检验你的学习成果，看是否能将每部分补充完整。</p>
<p data-nodeid="37575" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/84/27/CgqCHl_TIbaAEiBdAAEujtJGnY8994.png" alt="图片2 (1).png" data-nodeid="37582"></p>

<h3 data-nodeid="34664">进阶</h3>
<p data-nodeid="34665"><strong data-nodeid="34937">“如何在渲染劫持中为原本的渲染结果添加新的样式？”</strong> 这个问题也经常被追问，其实并不难，但是有可能考察手写代码，所以这里我会做一些提示。</p>
<p data-nodeid="34666">首先回滚上面的案例，在调用 super.render 的时候就可以拿到原本的渲染结果。</p>
<pre class="lang-java" data-nodeid="34667"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">withLoading</span><span class="hljs-params">(WrappedComponent)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WrappedComponent</span> </span>{
        render() {
            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.props.isLoading) {
                <span class="hljs-keyword">return</span> &lt;Loading /&gt;;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.render();
            }
        }
    };
}
</code></pre>
<p data-nodeid="34668">那 super.render() 返回的是什么呢？你可以结合 JSX 一讲中的内容思考下。</p>
<h3 data-nodeid="34669">总结</h3>
<p data-nodeid="34670">在本讲中主要对 React 组件的设计模式进行了梳理与回顾，并探讨了设计模式在工程实践中的作用。</p>
<p data-nodeid="34671">在面试中面试官不仅希望听到设计模式有哪些，社区的推荐方式有哪些，更希望听到<strong data-nodeid="34947">模式具体用在哪儿</strong>。如果你知道具体的场景，就会显得更有经验。设计模式并非有确定的标准答案，社区流行的分类方式也并非万能。如果你有自己的见解，在面试中与面试官进行探讨，也是非常值得鼓励的。</p>
<p data-nodeid="34672">下一讲我将会介绍 React 中的一个关于 setState 的经典面试题：“setState 是同步更新还是异步更新”。</p>
<p data-nodeid="34673"><a href="https://shenceyun.lagou.com/t/mka" data-nodeid="34953"><img src="https://s0.lgstatic.com/i/image/M00/73/68/Ciqc1F_F_CeAHYQKAASyC72ZqWw053.png" alt="Drawing 2.png" data-nodeid="34952"></a><br>
《大前端高薪训练营》</p>
<p data-nodeid="34674" class="">对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。<a href="https://shenceyun.lagou.com/t/mka" data-nodeid="34959">点击链接</a>，快来领取！</p>

---

### 精选评论

##### **举：
> 高阶组件做渲染劫持，有大用，在 Saas 产品被实施交付给企业客户之后，往往需要在标准产品之上进行定制化开发，由于采用 SPA 的方式，前端代码被bundle了，客户有不能对源代码进行破坏性修改(不利于后续版本升级)，因此基于 React 高阶函数的渲染劫持，可以推出无侵入的二次开发方案。即当组件检测到满足某个条件时，渲染定制化代码，否则渲染标准化代码。

##### **辉：
> 请教下老师，高阶组件实现的功能，在函数式组件中是否有类似的写法呢，或者说函数式组件的写法中是否有高阶组件呢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 可以的，这里篇幅有限不好展开说明，可以看这篇 《Higher Order Components in a React Hooks World》。

##### **者：
> 如何在渲染劫持中为原本的渲染结果添加新的样式：function">Wrapper(WrapperedComponent){">return">class">extends">WrapperedComponent{">render(){">const">element">super.render()">//被冻结了，不可直接修改">const">newElement">Object.assign({},">element)">const">newProps">Object.assign({},">element.props)">newProps.style{">color:">'red'}">newElement.props">newProps">return">newElement}}}

##### *瑞：
> super.render 对于函数组件有效吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 函数组件没有 super.render，函数不是类哦

##### console_man：
> 老师太厉害了，有代码辅助说明，绝对的好文，谢谢老师。

##### *瑞：
> shouldComponentUpdate 写死返回 false ，难道不会阻止子组件的重渲染吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 会阻止，这里的案例是要阻止父组件带来的影响。因为子组件会自行去拉取数据更新。

##### *盼：
> 思路真棒

