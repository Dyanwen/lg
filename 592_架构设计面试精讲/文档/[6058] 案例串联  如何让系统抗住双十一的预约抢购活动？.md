<p data-nodeid="33178">到目前为止，我们讨论了很多的面试思路，比如 02 讲中关于架构设计的“四步回答法”，不过大部分内容都是比较独立的知识点（比如分布式事务、分布式锁……）为了让你更深入掌握前几讲内容，把相对独立的知识串联起来，我们今天就来回顾、梳理近期学习的内容，通过“电商预约抢购”的场景，用前几讲内容，做一道完整的架构设计题。</p>
<h3 data-nodeid="33179">案例背景</h3>
<p data-nodeid="33180">在大促活动期间，“预约抢购”已经是各大电商平台的主要促销手段，京东自然也会和一些大的供应商合作，推出一些低价的爆款产品，比如 2019 年的 “1499 元抢购飞天茅台”活动，就让很多人每天准时准点拿着手机拼人品。</p>
<p data-nodeid="33181">那这类电商领域的大促抢购场景涉及专栏的哪些内容呢？它们是怎么通过架构设计的方式组合在一起，实现一个完整的需求流程呢？这就是今天要讨论的话题。</p>
<p data-nodeid="33182">我们先把需求梳理一下，总的来说，实现一个抢购系统大概可以分为四个阶段。</p>
<p data-nodeid="33183"><img alt="Drawing 0.png" src="https://s0.lgstatic.com/i/image/M00/8F/E1/Ciqc1GAJU5eAH5_nAAPlPlxEHeY549.png" data-nodeid="33272"></p>
<ul data-nodeid="33184">
<li data-nodeid="33185">
<p data-nodeid="33186"><strong data-nodeid="33277">商品预约</strong>：用户进入商品详情页面，获取购买资格，并等待商品抢购倒计时。</p>
</li>
<li data-nodeid="33187">
<p data-nodeid="33188"><strong data-nodeid="33282">等待抢购</strong>：等待商品抢购倒计时，直到商品开放抢购。</p>
</li>
<li data-nodeid="33189">
<p data-nodeid="33190"><strong data-nodeid="33287">商品抢购</strong>：商品抢购倒计时结束，用户提交抢购订单，排队等待抢购结果，抢购成功后，扣减系统库存，生成抢购订单。</p>
</li>
<li data-nodeid="33191">
<p data-nodeid="33192"><strong data-nodeid="33292">订单支付</strong>：等待用户支付成功后，系统更新订单状态，通知用户购买成功。</p>
</li>
</ul>
<p data-nodeid="33193">接下来，我们就针对各阶段容易出现的问题，来分析其中的技术考点和解决方案。</p>
<h3 data-nodeid="33194">商品预约阶段</h3>
<p data-nodeid="33195">这几年，很多电商平台为了方便流量运营，改造了传统秒杀场景，通过先预约再抢购的方式预热商品，并根据预约量调整运营策略。而且在预约抢购的活动中，为了增加商品售卖量，会允许抢购前，预约资格超过实际的库存数量。</p>
<p data-nodeid="33196">那么问题来了：如何在高并发量的情况下，让每个用户都能得到抢购资格呢？<strong data-nodeid="33303">这是预约抢购场景第一个技术考察点。</strong> 那你可以基于“06 | 分布式系统中，如何回答锁的实现原理？”来控制抢购资格的发放。</p>
<p data-nodeid="33197">我们基于 Redis 实现分布式锁（这是最常用的方式），在加锁的过程中，实际上是给 Key 键设置一个值，为避免死锁，还要给 Key 键设置一个过期时间。</p>
<pre class="lang-basic" data-nodeid="33198"><code data-language="basic">SET lock_key unique_value NX PX 10000
</code></pre>
<ul data-nodeid="33199">
<li data-nodeid="33200">
<p data-nodeid="33201">lock_key 就是 key 键；</p>
</li>
<li data-nodeid="33202">
<p data-nodeid="33203">unique_value 是客户端生成的唯一的标识；</p>
</li>
<li data-nodeid="33204">
<p data-nodeid="33205">NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</p>
</li>
<li data-nodeid="33206">
<p data-nodeid="33207">PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</p>
</li>
</ul>
<p data-nodeid="33208">而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。而这个时候， unique_value 的作用就体现出来，你可以通过 Lua 脚本判断 unique_value 是否为加锁客户端。</p>
<p data-nodeid="33209">选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。</p>
<pre class="lang-lua" data-nodeid="33210"><code data-language="lua">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放
<span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">"get"</span>,KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">"del"</span>,KEYS[<span class="hljs-number">1</span>])
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p data-nodeid="33211">这样一来，就通过使用 SET 命令和 Lua 脚本在 Redis 单节点上完成了分布式锁的加锁和解锁。但你要注意，此方案是基于单节点的 Redis 实例实现的，如果此时 Redis 实例发生故障宕机，那么锁变量就没有了，客户端也就无法进行锁操作，就会影响到业务的正常执行。<br>
所以，基于 Redis 实现分布式锁时，你还要掌握如何保证锁的可靠性，也就是怎么基于多个 Redis 节点实现分布式锁（这部分也可以参考 06 讲中的内容）。</p>
<h3 data-nodeid="33212">等待抢购阶段</h3>
<p data-nodeid="33213">用户预约成功之后，在商品详情页面中，会存在一个抢购倒计时，这个倒计时的初始时间是从服务端获取的，用户点击购买按钮时，系统还会去服务端验证是否已经到了抢购时间。</p>
<p data-nodeid="33214">在等待抢购阶段，流量突增，因为在抢购商品之前（尤其是临近开始抢购之前的一分钟内），大部分用户会频繁刷新商品详情页，<strong data-nodeid="33337">商品详情页面的读请求量剧增，</strong> 如果商品详情页面没有做好流量控制，就容易成为整个预约抢购系统中的性能瓶颈点。</p>
<p data-nodeid="33215">那么问题来了：如何解决等待抢购时间内的流量突增问题呢？有两个解决思路。</p>
<ul data-nodeid="33216">
<li data-nodeid="33217">
<p data-nodeid="33218"><strong data-nodeid="33343">页面静态化</strong>：提前对抢购商品的详情页面做静态化，生成一个静态页面，再把页面放到距离用户最近的 CDN 节点中，这样一来，当浏览器访问页面时，就会自动缓存该页面的静态资源文件（对于静态化技术，很多页面端的模板引擎都支持这样的功能，我就不展开讲了）。</p>
</li>
<li data-nodeid="33219">
<p data-nodeid="33220"><strong data-nodeid="33364">服务端限流</strong>：对商品详情页中的动态请求接口设置最大并发访问数量（具体的数量根据上线前的性能压测为准），防止超出预期的请求集中访问系统，造成系统压力过载。操作上，你可以在商品详情页的后端系统入口层（如网关系统）中进行接口限流，如果使用 Nginx 来做反向代理，可以直接基于 Nginx 配置限流算法，比如 Nginx 的 ngx_http_limit_req_module（限制单位时间内所有 IP 的请求数量）和 ngx_stream_limit_conn_module（限制单位时间内单个 IP 的请求数量）两个模块就提供了限流控制的功能，所以你还要提前掌握限流策略的原理，如令牌桶算法的原理。</p>
</li>
</ul>
<h3 data-nodeid="33221">商品抢购阶段</h3>
<p data-nodeid="33222">在商品抢购阶段，用户会点击提交订单，这时，抢购系统会先校验库存，当库存足够时，系统会先扣减库存，然后再生成订单。在这个过程中，短时间之内提交订单的写流量非常高，所以为了做流量削峰，会将提单请求暂存在消息队列中，并提示用户“抢购排队中……”然后再由后端服务异步处理用户的请求。</p>
<p data-nodeid="33223">而你可以基于数据库和缓存两种方式，来实现校验库存和扣减库存的操作。</p>
<p data-nodeid="33224">但因为抢购场景的瞬时流量极高，一般不会直接基于数据库来实现（因为每次操作数据库，即使通过消息队列做了流量削峰，对数据库来说压力也很大，会产生性能瓶颈）。如果非要基于数据库的话，你要通过分布式锁来优化扣减库存的并发操作，但此阶段的分布式锁对可靠性的要求会极高（因为在大促抢购阶段，小的可用性故障，都可能造成大的线上事故），所以基于单节点 Redis 实现的分布式锁不合适，你要选择多节点 Redis 实现分布式锁，或者选型 ZooKeeper。</p>
<p data-nodeid="33225">为了避免上述问题，我们一般基于缓存来存储库存，实现扣减库存的操作。这样在提交订单时，库存的查询和锁定就不会给数据库带来性能瓶颈。不过你仍要注意，基于缓存（如 Redis）的库存扣减操作，仍要考虑缓存系统的单点问题，就算是多节点存储库存，也要引入锁的策略，保证 Redis 实现库存的一致性。</p>
<p data-nodeid="33226">实现了校验库存和扣减库存之后，最后一步是生成抢购订单。由于数据库表会承载订单数据，一旦出现瞬时流量，磁盘 I/O、数据库请求连接数等资源都会出现性能瓶颈，你可以考虑对订单表分库分表，通过对用户 ID 字段进行 Hash 取模，实现分库分表，提高系统的并发能力。</p>
<p data-nodeid="33227">从“商品抢购阶段的架构设计”中我们可以总结出三个技术考点：<strong data-nodeid="33375">流量削峰、扣减库存、分库分表。</strong></p>
<ul data-nodeid="33228">
<li data-nodeid="33229">
<p data-nodeid="33230"><strong data-nodeid="33379">“流量削峰”的面试考点</strong></p>
</li>
</ul>
<p data-nodeid="33231">流量削峰是由于正式抢购场景下，短时间内的提单请求非常高，所以引入消息队列做异步化，然后在抢购系统的后端服务中，启动若干个队列处理消息队列中的提单请求，再执行校验库存、下单等逻辑。</p>
<p data-nodeid="33232">那么如何快速处理消息队列中的提单请求，避免出现大量的消息积压，就是本阶段的考点之一了，方案可以参考“08 | MQ：如何回答消息队列的丢失、重复与积压问题？”</p>
<ul data-nodeid="33233">
<li data-nodeid="33234">
<p data-nodeid="33235"><strong data-nodeid="33387">“扣减库存”的面试考点</strong></p>
</li>
</ul>
<p data-nodeid="33236">我刚刚提到，当基于 Redis 实现库存的扣减时，要考虑怎么解决 Redis 的单点问题。而如果基于 Redis 集群来实现扣减库存，还要解决 Redis 在哨兵模式部署的情况下，因为主从切换带来的数据不一致的问题。这就涉及“06 | 分布式系统中，如何回答锁的实现原理？”中的内容。</p>
<ul data-nodeid="33237">
<li data-nodeid="33238">
<p data-nodeid="33239"><strong data-nodeid="33394">“分库分表”的面试考点</strong></p>
</li>
</ul>
<p data-nodeid="33240">生成订单后如何实现分库分表？你可以参考“04 | 亿级商品存储下，如何深度回答分布式系统的原理性问题？”中的解决方案。</p>
<p data-nodeid="33241">当然还有一个容易忽略的问题：带宽的影响。由于抢购入口的请求量会非常大，可能会占用大量带宽，为了不影响提交订单的请求，有时会从网络工程的角度解决，通过单独的子域名绑定独立的网络服务器，这里就会涉及 DNS 的设计与优化手段。</p>
<h3 data-nodeid="33242">订单支付阶段</h3>
<p data-nodeid="33243">在用户支付订单完成之后，一般会由支付平台回调系统接口，更新订单状态。在支付回调成功之后，抢购系统还会通过异步通知的方式，实现订单更新之外的非核心业务处理，比如积分累计、短信通知等，此阶段可以基于 MQ 实现业务的异步操作。</p>
<p data-nodeid="33244"><img alt="已改拉勾_架构面试精讲-20210112(1).png" src="https://s0.lgstatic.com/i/image2/M01/09/34/CgpVE2AN_qGANrtxAABtOAVpLik784.png" data-nodeid="33405"></p>
<div class="te-preview-highlight" data-nodeid="35071"><p style="text-align:center"><span style="color:#d8d8d8"><span style="color:#b8b8b8">订单支付后操作</span></span></p></div>


<p data-nodeid="33246">不过针对服务的异常（如宕机），会存在请求数据丢失的可能，比如当支付回调系统后，修改订单状态成功了，但是在异步通知积分系统，更新用户累计积分时，订单系统挂掉了，此时 MQ 还没有收到这条消息，那么这条消息数据就无法还原了。</p>
<p data-nodeid="33247"><img alt="已改拉勾_架构面试精讲-20210112(2).png" src="https://s0.lgstatic.com/i/image2/M01/09/32/Cip5yGAN_ruAPSKGAACFk7CsEOk016.png" data-nodeid="33411"></p>
<div data-nodeid="33989"><p style="text-align:center"><span style="color:#b8b8b8">订单支付后操作（异常）</span></p></div>

<p data-nodeid="33249">所以你还要考虑“05 | 海量并发场景下，如何回答分布式事务一致性问题？”中，可靠消息投递机制：先做消息的本地存储，再通过异步重试机制，来实现消息的补偿。比如当支付平台回调订单系统，然后在更新状态的同时，插入一个消息，之后再返回第三方支付操作成功的结果。最后，通过数据库中的这条消息，再异步推送其他系统，完成后续的工作。</p>
<p data-nodeid="33250"><img alt="已改拉勾_架构面试精讲-20210112(3).png" src="https://s0.lgstatic.com/i/image2/M01/09/34/CgpVE2AN_tGABacCAACGq-H_pKs054.png" data-nodeid="33419"></p>
<div data-nodeid="33448"><p style="text-align:center"><span style="color:#b8b8b8">订单支付后操作（新方案）</span></p></div>

<h3 data-nodeid="33252">总结</h3>
<p data-nodeid="33253">今天，我们用前几讲的内容实现了一个完整的预约抢购的系统设计，为了加深你的理解，我总结了每个阶段的注意点。</p>
<ul data-nodeid="33254">
<li data-nodeid="33255">
<p data-nodeid="33256"><strong data-nodeid="33426">商品预约阶段</strong>：要掌握如何在高并发的场景下通过锁的方式，让每一个用户都获取到抢购资格，结合业务场景对于并发控制的需求诉求和成本的考虑，在商品预约阶段，你可以基于 Redis 来实现分布式锁。</p>
</li>
<li data-nodeid="33257">
<p data-nodeid="33258"><strong data-nodeid="33431">等待抢购阶段</strong>：此阶段对页面的查询请求会很高，尤其是临近抢购倒计时的流量突增，解决方案是做页面静态化和服务端限流。</p>
</li>
<li data-nodeid="33259">
<p data-nodeid="33260"><strong data-nodeid="33436">商品抢购阶段</strong>：商品抢购是整个流程中涉及技术点最多的阶段，瞬时流量会带来极大的压力，所以通过 MQ 做了同步转异步，实现对流量的削峰，从而让请求排队等待，然后有序且有限地进入到后端服务，而你必须掌握消息队列的丢失、重复和积压问题的解决方案；另外在扣减库存的时候，为了解决扣减存储不超售的问题，同样还需要引入锁的机制。</p>
</li>
<li data-nodeid="33261">
<p data-nodeid="33262"><strong data-nodeid="33441">订单支付阶段</strong>：在用户支付完成后，系统通常还需要处理一些非核心操作，你可以通过 MQ 通知的方式来实现系统间的解耦和异步通信，但依旧要保证消息的可靠性（当然也可以通过 RPC 同步调用的方式来实现），所以你也要掌握 RPC 和 MQ 的相关知识点。</p>
</li>
</ul>
<p data-nodeid="33263">总的来说，互联网中大数据里的存储设计（如商品与订单数据的存储设计），你可以参考 04 讲；关于秒杀或抢购场景下的库存扣减设计，你可以参考 06 讲；分布式系统之间的事务一致性的架构设计，你可以参考 05 讲；关于架构设计中的服务强依赖的设计，一般会通过 RPC 远程同步调用的方式实现，你可以参考07讲；系统解耦，流量削峰的设计问题，你可以参考 08讲。</p>
<p data-nodeid="33264"><strong data-nodeid="33447">留个作业</strong>：用户提交订单抢到商品后，此时系统的库存已经扣减掉了，但是订单中的状态还是未支付，如果此时用户是恶意的行为，只抢购不支付，那么你怎么优化架构设计来应对这样的操作呢？欢迎把答案写到留言区，和我一起讨论，我们下一讲见。</p>

---

### 精选评论

##### *鹏：
> 订单生成后创建延时任务，比如使用RabbitMQ的私信队列实现。任务到期后检查订单状态，未支付的及时取消订单，并回退库存。同时针对这种账号可以设置黑名单机制，降低其抢购成功率甚至直接拉黑。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 赞，方案可尝试

##### *铁：
> 支付成功回调时的同时，触发检查超期支付的数据并进入清理过程，退库存的同时还得避免和减库存并发

##### **1889：
> 扣减库存时用Redis集群只能保证可用性，主从复制造成的数据不一致是加锁能够解决的吗，我记得Redist天然就不保证数据一致性的， 没太懂 请老师明示

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; Redis是AP模式，所以不保证数据同步的强一致，你的理解是Redis做高可用的时候，主和从之间的数据同步一致性问题，而文中介绍的是站在系统的角度做扣减库的操作，来减少并发扣减的动作。

##### **阳：
> 老师好，商品抢购阶段如果通过缓存来减库存的话，那么后续订单生成失败该如何处理？也就是说如何保证减掉的库存与生成订单的一致性？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 如果订单生成失败，处理的方法可以异步线程补充库存，或者直接失败，根据业务来决定。

##### **声：
> 可以通过Redis 的 sorted set 来作为延时队列，保存订单的信息。然后通过线程不停的去获取队列的订单信息，进行业务操作。老师，这里有个问题，在用户在预约的时候就获得锁，那预约人数多的话，会不会影响性能？这个锁是在什么时候释放呢，是在支付成功之后释放吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 预约抢购阶段技术方案很多，可以基于队列，也可以基于锁，或者二者结合，当然锁的性能是相对偏低的，预约会持续一段很长时间，本身就是为了分散写入压力，所以相对于秒杀的瞬时流量来说是很低的。锁是为了锁住库存，和支付无关，在生成预约单后即可释放。

##### *广：
> 这种情况通常是通过定时任务判断特定时间内未完成支付的订单将失效

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 可以

##### 我：
> 老师，你讲的很好，有没有从单纯从业务出发的一个代码示范？这样更好理解

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你好，浮生，很高兴你的这几次评论，立足于咱们课程的主题，重点在于系统设计上的原理方案理解，如果有不好理解的原理，我会辅助于图或代码。另外，如果需要，我后续会推出实战的课程。

##### **赞：
> 我尝试回答下作业：1、接商用验证码，类似防作弊系统，防止黄牛刷单2、即使有漏网之鱼被放进来了，秒杀成功但是未支付，也没关系，对秒杀成功未支付的订单做超时处理，比如10分钟，10分钟后就将商品库存自动还回去，这样其他正常用户在秒杀失败之后，发现又可以继续秒杀抢购

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 方案不错哦

##### **润：
> 课后题：1,可以和业务约定有一定比例的超卖2，超过一定时间未支付的订单，自动取消

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 回答的不错，很赞！继续加油

##### **润：
> 库存扣减貌似没讲，我们系统一般用Redis的incrby

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 开发上Redis的原子增减操作并不复杂，核心要理解设计原理，如果面试反问你 incrby 如何实现的原子操作？

##### *凯：
> 针对占下库存但不支付的情况，可以设计一个支付时间倒计时，这个时间往往比较短，例如可以是整个抢购活动总时间的1/5，当支付时间过期后关闭订单同时释放库存。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 超时时间是一种方案，在大促抢购的时候可以缩短支付倒计时

##### *锋：
> 对于抢购不支付，➕超时时间控制

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 赞

