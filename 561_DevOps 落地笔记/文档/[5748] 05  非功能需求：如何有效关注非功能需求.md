<p data-nodeid="8300" class="">你好，我是 DevOps 亮哥，上一讲主要介绍了看板方法以及如何使用看板方法来解决软件研发过程中出现的团队过载、工作不均、任务延期等问题。通过学习前面几个课时介绍的知识，你的团队开始源源不断地交付用户价值。用户对交付的功能非常满意，但等到系统上线后经常出现<strong data-nodeid="8426">服务不可用</strong>的情况，比如：服务出现单点故障，这个时候运维团队就要处理这些焦头烂额问题了。这是因为在软件开发过程中，团队关注的一直都是用户需要的功能，忽略了那些能够让产品维持工作的非功能需求。今天介绍的内容——<strong data-nodeid="8427">有效关注非功能需求</strong>，就是教我们要在关注功能需求的同时，也要关注非功能需求。帮你彻底改善软件系统的可用性和性能。</p>
<h3 data-nodeid="8301">什么是非功能需求</h3>
<p data-nodeid="8302">当谈起需求，很多人都认为是“用户需求”，需求也分为不同的种类。需求的分类可以参考由惠普的 Robert Grady 设计的 <strong data-nodeid="8434">FURPS+</strong> 需求分类模型：</p>
<ul data-nodeid="8303">
<li data-nodeid="8304">
<p data-nodeid="8305">功能性（Functionality）；</p>
</li>
<li data-nodeid="8306">
<p data-nodeid="8307">易用性（Usability）；</p>
</li>
<li data-nodeid="8308">
<p data-nodeid="8309">可靠性（Reliability）；</p>
</li>
<li data-nodeid="8310">
<p data-nodeid="8311">性能（Performance）；</p>
</li>
<li data-nodeid="8312">
<p data-nodeid="8313">可支持性（Supportabilit）。</p>
</li>
</ul>
<p data-nodeid="8314">FURPS+中的“+”号指的是其他需要关注的方面，比如：</p>
<ul data-nodeid="8315">
<li data-nodeid="8316">
<p data-nodeid="8317">设计需求（Design Requirements）；</p>
</li>
<li data-nodeid="8318">
<p data-nodeid="8319">实现需求（Implementation Requirements）；</p>
</li>
<li data-nodeid="8320">
<p data-nodeid="8321">接口需求（Interface Requirements）；</p>
</li>
<li data-nodeid="8322">
<p data-nodeid="8323">物理需求（Physical Requirements）。</p>
</li>
</ul>
<p data-nodeid="8324">该需求分类模型包含了功能性需求和非功能性需求。功能性需求指的是<strong data-nodeid="8454">产品功能</strong>，比如：聊天功能，支付功能等。非功能性需求是整个<strong data-nodeid="8455">系统交付的标准</strong>，比如系统可靠，性能高等。</p>
<p data-nodeid="8325"><strong data-nodeid="8460">功能需求</strong>通常很容易定义、度量和测试，一般可以描述为特定系统执行特定功能的需求。就像前面课时中提到的用户故事，作为用户，当我在地址栏里输入内容时，显示所有可用的地址列表。因此，功能需求通常被视为系统“应该做什么（What）”。</p>
<p data-nodeid="8326">非功能需求则较难定义、度量、测试和跟踪，这也是经常被忽略的原因。一般可以描述为系统如何提供功能。比如，当用户在地址栏里输入内容时，要快速的显示所有的地址列表（性能）。因此，非功能需求通常被视为系统“应该如何做（How）”。</p>
<h3 data-nodeid="8327">为什么要关注非功能需求？</h3>
<p data-nodeid="8328">在《敏捷宣言》里讲到，“可工作的软件，胜过面面俱到的文档”。这里的“<strong data-nodeid="8476">可工作</strong>”是对交付到用户手中的软件最重要的<strong data-nodeid="8477">度量标准</strong>，软件不仅要具备用户需要的功能，还要能够持续不断的使用该功能。但实际情况却不尽如人意，这是因为我们在开发软件的时候，总是关注功能性的需求，而忽略非功能性的需求。我举个例子，下面这张图是一座冰山，当一个管理家庭地址的需求被提出后，用户需要的功能是新增、编辑、删除和查询家庭地址，但在这几个功能需求的背后却是表单重复提交验证、浏览器兼容、性能、用户身份认证等<strong data-nodeid="8478">隐藏需求</strong>。没有这些隐藏需求，一般情况下用户也能使用该功能，但在使用的过程中，就会出现各种问题，令用户体验非常不好。</p>
<p data-nodeid="8329"><img src="https://s0.lgstatic.com/i/image/M00/75/36/Ciqc1F_HZWCARkQgAALf1mOgdwo080.png" alt="Drawing 0.png" data-nodeid="8481"></p>
<p data-nodeid="8330">随着敏捷开发方法的采用，这一问题已经有所转变。比如，将非功能需求和功能需求一起纳入流程管控等措施。在 DevOps 实践中，这个转变更进了一步，产品负责人要关注<strong data-nodeid="8491">整个产品需求</strong>，包括功能需求和非功能需求。只有从源头上重视非功能需求的开发，团队才能真正交付 <strong data-nodeid="8492">“可工作”</strong> 的软件。下面介绍一下在软件开发流程中，如何关注并落实非功能需求。</p>
<h3 data-nodeid="8331">如何关注非功能需求？</h3>
<p data-nodeid="8332">在软件开发过程中，明确<strong data-nodeid="8499">定义的非功能需求的实现</strong>是用于评估整个软件成功的关键。功能需求的实现表示用户可以使用该软件提供的功能，非功能需求的实现表示用户可以一直使用该功能。定义明确的非功能需求，不仅容易度量和测试，而且团队也能更好地了解这个需求离实现还有多远。</p>
<h4 data-nodeid="8333">非功能需求的管理</h4>
<p data-nodeid="8334">既然非功能需求对于系统交付非常重要，那么在系统一开始团队中的每个人都要考虑非功能需求，以及它们对系统架构，系统交付时间，测试策略和总成本的影响。</p>
<p data-nodeid="8335"><strong data-nodeid="8505">需求管理</strong></p>
<p data-nodeid="8336">非功能需求和功能需求一样，它们也有实际的业务价值，在需求管理阶段就要将其纳入<strong data-nodeid="8511">统一的流程管理</strong>。比如“管理家庭地址”的需求，在进行“新增地址”功能需求排期的同时，也要考虑“表单验证”“表单重复提交验证”“身份认证和授权”“浏览器兼容性”等非功能需求。因此，需要创建一些具体的任务来管理这些非功能需求，或者在其他功能需求中加入非功能需求的验收条件。</p>
<p data-nodeid="8337"><strong data-nodeid="8515">跨团队协作</strong></p>
<p data-nodeid="8338">非功能需求又被称为“<strong data-nodeid="8525">跨功能需求</strong>”，因此在非功能需求的讨论、方案的制定，验证条件等方面，都需要其他团队一起来完成。安全性相关的需要安全团队，性能、可扩展性相关的需要架构团队，验收方面需要测试团队，监控告警方面需要运维团队。跨团队协作不容易，我的建议是将这件事情写到<strong data-nodeid="8526">每个团队的 OKR 里</strong>，这样大家的目标就一致了，实施起来会更加容易。</p>
<p data-nodeid="8339"><strong data-nodeid="8530">权衡利弊</strong></p>
<p data-nodeid="8340">非功能需求的实现是有成本的，而且它们之间可能彼此排斥。比如，对安全性要求高的系统往往易用性就不会太好。在理想情况下，每个人都想开发出具有高安全性、高性能、高扩展性、高易用性的系统。但是，在实际开发中，考虑到系统的交付时间，系统的总成本，往往会根据非功能需求的实现难度，做出权衡。</p>
<h4 data-nodeid="8341">非功能需求的分析</h4>
<p data-nodeid="8342">非功能需求的分析也是非常重要的一部分。在进行需求分析的时候，不仅要分析出系统所提供的功能需求，同时也要知道这些功能存在的限制条件。</p>
<p data-nodeid="8343">这里介绍一个<strong data-nodeid="8547">四层非功能需求分析法</strong>。该方法包含<strong data-nodeid="8548">一些规则和非功能需求分析的过程</strong>。通过这种方法，我们可以确定系统提供的功能，子功能和每个子功能需要具备的非功能需求。有利于从不同的视图识别所有的非功能需求。这种方法的目标是<strong data-nodeid="8549">找出任何系统中都非常重要的非功能需求</strong>。如下图所示。</p>
<p data-nodeid="8807" class=""><img src="https://s0.lgstatic.com/i/image/M00/7C/FA/CgqCHl_N7IyAALJZAABufoNWK5I008.png" alt="image.png" data-nodeid="8810"></p>

<p data-nodeid="8345">任何一个系统的需求都可以总结为下面这句话：<strong data-nodeid="8569">每个&lt;系统&gt;提供&lt;功能&gt;给&lt;关系人&gt;，每个&lt;功能&gt;必须满足&lt;条件&gt;才能满足&lt;关系人&gt;的需求。</strong></p>
<p data-nodeid="8346">正如前面提到，<strong data-nodeid="8575">功能需求表示系统应该做什么（What），非功能需求表示系统应该如何做（How）。</strong> 上图利用分层的方法非常清晰地将系统具备的功能需求和非功能需求表示出来。前面三层是功能需求的拆解，第四层是每个子功能具备的条件，即非功能需求。</p>
<p data-nodeid="8347">整个非功能需求的分析过程可以分为下面四个步骤：</p>
<p data-nodeid="8348"><strong data-nodeid="8580">step1：识别系统中的关系人；</strong></p>
<p data-nodeid="8349"><strong data-nodeid="8584">step2：基于开发人员的知识和经验，从关系人角度制定功能目标；</strong></p>
<p data-nodeid="8350"><strong data-nodeid="8588">step3：拆解功能为子功能；</strong></p>
<p data-nodeid="8351"><strong data-nodeid="8592">step4：识别每个子功能中的非功能需求。</strong></p>
<p data-nodeid="8352">下面利用四层非功能需求分析法分析开头的 <strong data-nodeid="8598">“管理家庭地址”</strong> 的需求，结果如下图所示：</p>
<p data-nodeid="9825" class=""><img src="https://s0.lgstatic.com/i/image/M00/7C/EF/Ciqc1F_N7JaAEEogAAB35ZeU-MA644.png" alt="image (1).png" data-nodeid="9832"></p>

<p data-nodeid="8354">经过这个分析过程，就非常清楚地知道哪些功能需求需要具备哪些非功能需求，可以基于分析结果编写用户故事以及验证标准。</p>
<h4 data-nodeid="8355">非功能需求的度量</h4>
<p data-nodeid="8356">为了使系统能够达到验收的标准，在定义非功能性需求的时候就需要是可度量的，这样团队才能知道非功能性需求当前值是多少，离满足要求还差多少。上面提到非功能需求是指系统应该如何做，即对系统属性和质量的描述，比如：<strong data-nodeid="8609">可扩展性、可靠性、高性能</strong>等，这些都属于定性的描述。定性的描述缺少量化的指标，是不可度量的，这一点团队在定义非功能性需求时应该注意。</p>
<p data-nodeid="8357">还是以上面的例子为例：</p>
<p data-nodeid="8358">"<strong data-nodeid="8618">快速地</strong>显示所有的地址列表"，这就是一个定性的描述，它是不容易度量的，也是不容易测试的，不知道要达到多快才能满足要求。</p>
<p data-nodeid="8359">修改后：</p>
<p data-nodeid="8360">“<strong data-nodeid="8629">0.1s</strong>显示所有的地址列表”，这就是一个<strong data-nodeid="8630">定量的描述</strong>，提出了对该非功能需求的度量、测试和验收标准。只要能在 0.1s 内显示所有的地址列表，就能满足要求。假如在一次测试时得到的结果是 0.2s，团队也很清楚地知道还需要再提高 0.1s 才能满足要求。</p>
<p data-nodeid="8361">常见非功能需求的度量指标有：</p>
<ul data-nodeid="8362">
<li data-nodeid="8363">
<p data-nodeid="8364"><strong data-nodeid="8636">吞吐量：</strong> TPS（Transactions Per Second）每秒处理事务数，QPS（Queries Per Second）每秒查询数，RT（Response Time）响应时间。</p>
</li>
<li data-nodeid="8365">
<p data-nodeid="8366"><strong data-nodeid="8641">可靠性：</strong> MTTF（Mean Time to Failure）平均无故障时间，MTTR（Mean Time to Repair）平均故障恢复时间，MTBF（Mean Time Between Failure）平均故障间隔时间等。</p>
</li>
<li data-nodeid="8367">
<p data-nodeid="8368"><strong data-nodeid="8646">扩展性：</strong> 随着服务器数、服务数或线程数的增加，单个请求的响应时间和并发用户数。</p>
</li>
</ul>
<p data-nodeid="8369">目前在监控或统计系统中都会包含上面的度量指标，如下图是请求 QPS 变化趋势图：</p>
<p data-nodeid="10855" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/7C/FA/CgqCHl_N7KGALowAAAFu-DWyD34166.png" alt="image (2).png" data-nodeid="10862"></p>

<h4 data-nodeid="8371">非功能需求的设计</h4>
<p data-nodeid="8372">非功能需求在设计时可以遵循下面两个原则。</p>
<p data-nodeid="8373"><strong data-nodeid="8658">1. 面向对象设计的 SOLID 原则。</strong></p>
<p data-nodeid="8374">SOLID 原则是由 Robert C. Martin 于 2000 年编写的面向对象设计的五个原则。后来，人们将这五个原则的首字母组成缩略词，也就是<strong data-nodeid="8664">SOLID</strong>，并被业界广为流传。这五个原则是：</p>
<ul data-nodeid="8375">
<li data-nodeid="8376">
<p data-nodeid="8377"><strong data-nodeid="8669">单一责任原则（Single responsibility principle）</strong>，指一个类有且只有一个职责。这个原则增强了类的灵活性和可维护性；</p>
</li>
<li data-nodeid="8378">
<p data-nodeid="8379"><strong data-nodeid="8674">开闭原则（Open/closed principle）</strong>，指一个类对外扩展开放，对修改关闭。这个原则增强了类的可扩展性和可维护性；</p>
</li>
<li data-nodeid="8380">
<p data-nodeid="8381">**里氏代换原则（Liskov substitution principle），**指程序中使用基类进行定义，在运行时再确定其子类类型，用子类对象替换父类对象，这个原则增强了类的灵活性和可扩展性；</p>
</li>
<li data-nodeid="8382">
<p data-nodeid="8383"><strong data-nodeid="8685">接口分离原则（Interface segregation principle）</strong>，指类的依赖关系应该建立在最小接口上，即建立单一接口，而不是臃肿庞大的接口，这个原则增强了类的可维护性和可扩展性；</p>
</li>
<li data-nodeid="8384">
<p data-nodeid="8385"><strong data-nodeid="8690">依赖倒置原则（Dependency inversion principle</strong>），指高层模块依赖抽象类或接口，而不是具体的类，这个原则增强了类的可扩展性。</p>
</li>
</ul>
<p data-nodeid="8386">SOLID 原则处理的是面向对象中的<strong data-nodeid="8696">类、接口、继承</strong>等元素，能够更好地满足面向对象设计中的非功能性需求。</p>
<p data-nodeid="8387"><strong data-nodeid="8702">2. 微服务设计的 IDEALS 原则</strong></p>
<p data-nodeid="8388">如今，随着微服务架构的广泛应用，SOLID 原则并不能完全适用于分布式系统中的**“微服务”**这一元素。Paulo Merson 提出了一套微服务设计的核心原则，即 IDEALS 原则。IDEALS 是这几个原则首字母组成的缩略词。原则如下：</p>
<ul data-nodeid="8389">
<li data-nodeid="8390">
<p data-nodeid="8391"><strong data-nodeid="8714">接口分离（Interface segregation）</strong> 指的是不同类型的客户端，如，移动应用程序、Web应用程序、CLI程序，能够通过适合其要求的协议与服务端交互；</p>
</li>
<li data-nodeid="8392">
<p data-nodeid="8393"><strong data-nodeid="8719">可部署性（Deployability (is on you)）</strong> 指的是在微服务时代，也就是 DevOps 时代，开发人员需要在打包、部署和运行微服务方面做出关键的设计决策和技术选择；</p>
</li>
<li data-nodeid="8394">
<p data-nodeid="8395"><strong data-nodeid="8724">事件驱动（Event-driven）</strong> 指的是在任何时候，都应该通过异步消息或事件进行调用，而不是同步调用；</p>
</li>
<li data-nodeid="8396">
<p data-nodeid="8397"><strong data-nodeid="8729">可用性胜于一致性（Availability over consistency）</strong> 指的是最终用户更看重系统的可用性而不是强一致性，他们对最终一致性也很满意；</p>
</li>
<li data-nodeid="8398">
<p data-nodeid="8399"><strong data-nodeid="8734">松耦合（Loose coupling）</strong> 指的是服务之间相互依赖的程度，对于基于服务的系统来说，传入耦合与传出耦合的设计是一个重要问题；</p>
</li>
<li data-nodeid="8400">
<p data-nodeid="8401"><strong data-nodeid="8739">单一责任（Single responsibility）</strong> 指的是服务内聚性，一个服务只包含单一职责，功能庞大服务在维护和部署方面都会变得繁重。</p>
</li>
</ul>
<p data-nodeid="8402">SOLID 原则和 IDEALS 原则是在进行系统架构设计时需要遵循的<strong data-nodeid="8745">核心原则</strong>，可以有效地提高系统在非功能性方面的质量要求。</p>
<h4 data-nodeid="8403">非功能需求的测试</h4>
<p data-nodeid="8404">前面也提到，非功能需求是验证系统是否满足要求的衡量标准。这里以**“响应时间”**为例，简单介绍一下非功能需求的测试方法。</p>
<p data-nodeid="8405"><strong data-nodeid="8757">定义基准</strong></p>
<p data-nodeid="8406">目标明确的基准式测试有利于判断局部代码优化为系统带来的具体影响，例如，在添加数据缓存后，与基准数据比较，响应时间到底提升了多少。</p>
<p data-nodeid="8407"><strong data-nodeid="8762">定义场景</strong></p>
<p data-nodeid="8408">把系统的一个具体使用场景作为一个测试。不同使用场景对测试的要求和验收标准不一样，同样是响应时间这个指标，当数据量在 1000 和 1000 万时的标准是不一样的，当并发用户数在 1000 和 1000 万时的标准也是不一样的。</p>
<p data-nodeid="8409"><strong data-nodeid="8767">定义成功与失败</strong></p>
<p data-nodeid="8410">测试的成功与失败与场景也是强相关的，成功与失败不过是当前测试值与目标基准值的一个比较。因此，成功与失败不是关键，基于场景的基准值的设定是关键。该值的设定可以通过“<strong data-nodeid="8773">预估+核验</strong>”的方式，在开始时先预估一个初始值作为最低验收标准，当测试通过了最低验收标准，就把验收标准提高一点，调整该测试的成功门槛。如果测试失败，如果最低验收标准高于需求中定义的门槛，那么只要降低最低验收标准是被接受的，直接降低就可以了，否则就要优化代码直到满足最低验收标准。</p>
<h4 data-nodeid="8411">非功能需求的监控</h4>
<p data-nodeid="8412">当系统在生产环境运行时，对系统的监控是也是很重要的一部分。有一些<strong data-nodeid="8785">开源APM（Application Performance Management，应用性能管理）<strong data-nodeid="8784">工具能够追踪</strong>每个请求的完整调用链路</strong>，收集调用链路上的每个服务的性能数据，并通过页面进行展示。常用的有Skywalking、Zipkin、Pinpoint 等。如下图是 Pinpoint 的监控界面。</p>
<p data-nodeid="8413"><img src="https://s0.lgstatic.com/i/image/M00/75/36/Ciqc1F_HZd6ATBfVAAKvcpwZAX4082.png" alt="Drawing 4.png" data-nodeid="8788"></p>
<p data-nodeid="8414">图中右侧显示的是 ApiGateway 这个服务的响应时间汇总信息，响应时间在 1s 内的有 600 个，大于 5s 的有 41 个，还可以针对每个请求查看完整的调用链，对于排查慢请求的问题非常有帮助。</p>
<h3 data-nodeid="8415">总结</h3>
<p data-nodeid="8416" class="">本课时从非功能需求会导致哪些问题入手，描述了目前软件开发中过于关注功能需求，而忽略非功能需求的现象，从而提议软件开发人员在进行软件开发时要关注非功能需求。并在随后的内容里，从非功能需求的<strong data-nodeid="8804">管理、分析、度量、设计、测试</strong>和<strong data-nodeid="8805">监控</strong>等方面，简单而全面地描述了如何关注非功能需求。由于篇幅有限，并不能面面俱到，以非功能需求作为一个课题来讲，也是希望软件从业人员能够对非功能需求引起重视，开发出满足用户需要的、<strong data-nodeid="8806">“可工作”</strong> 的软件。</p>

---

### 精选评论

##### **洲：
> 现实工作长注重与业务功能的开发，对非功能需求整体不是很在意，总感觉少了点什么，这层窗户纸被亮哥点透了

