<p data-nodeid="42138">上一课时我们分析了限流的常用策略，下面来看一下，高可用的另外两大撒手锏：降级和熔断，关于这两种技术手段如何实施，又有哪些区别呢？</p>
<h3 data-nodeid="42139">高可用之降级</h3>
<p data-nodeid="42140">我们在第 39 课时提过服务降级是电商大促等高并发场景的常见稳定性手段，那你有没有想过，为什么在大促时要开启降级，平时不去应用呢？</p>
<p data-nodeid="42141">在大促场景下，请求量剧增，可我们的系统资源是有限的，服务器资源是企业的固定成本，这个成本不可能无限扩张，所以说，<strong data-nodeid="42244">降级是解决系统资源不足和海量业务请求之间的矛盾</strong>。</p>
<p data-nodeid="42142">降级的具体实现手段是，在暴增的流量请求下，对一些非核心流程业务、非关键业务，进行有策略的放弃，以此来释放系统资源，保证核心业务的正常运行。我们在第 34 课时中提过二八策略，换一个角度，服务降级就是尽量避免这种系统资源分配的不平衡，打破二八策略，让更多的机器资源，承载主要的业务请求。</p>
<p data-nodeid="42143">就如同我们之前的例子中，电商大促时限制退款，但平时并不会限制，所以服务降级不是一个常态策略，而是应对非正常情况下的应急策略。服务降级的结果，通常是对一些业务请求，返回一个统一的结果，你可以理解为是一种 FailOver 快速失败的策略。</p>
<p data-nodeid="42144">举个例子，我们都有在 12306 网站购票的经历，在早期春运抢票时，会有大量的购票者进入请求，如果火车票服务不能支撑，你想一想，是直接失败好呢，还是返回一个空的信息好呢？一般都会返回一个空的信息，这其实是一种限流后的策略，我们从一个广义的角度去理解，限流也是一种服务降级手段，是针对部分请求的降级。</p>
<p data-nodeid="42145">一般来说，降级针对的目标，一般是业务闭环中的一些次要功能，比如大促时的评论、退款功能，从一致性的角度，因为强一致性的保证需要很多系统资源，降级可能会降低某些业务场景的一致性。</p>
<p data-nodeid="42146">具体在进行服务降级操作时，要注意哪些点呢？首先需要注意梳理核心流程，知道哪些业务是可以被牺牲的，比如双十一大家都忙着抢购，这时候一些订单评论之类的边缘功能，就很少有人去使用。另外，要明确开启时间，在系统水位到达一定程度时开启。还记得我们在第 16 课时提到的分布式配置中心吗？降级一般是通过配置的形式，做成一个开关，在高并发的场景中打开开关，开启降级。</p>
<h3 data-nodeid="42147">高可用之熔断</h3>
<p data-nodeid="42148">不知道你有没有股票投资的经验，在很多证券市场上，在大盘发生非常大幅度的波动时，为了保护投资者的利益，维护正常的市场秩序，会采取自动停盘机制，也就是我们常说的<strong data-nodeid="42256">股市熔断</strong>。</p>
<p data-nodeid="42149">在高可用设计中，也有熔断的技术手段，熔断模式保护的是业务系统不被外部大流量或者下游系统的异常而拖垮。</p>
<p data-nodeid="42150">通过添加合理的熔断策略，可以防止系统不断地去请求可能超时和失败的下游业务，跳过下游服务的异常场景，防止被拖垮，也就是防止出现服务雪崩的情况。</p>
<p data-nodeid="42151">熔断策略其实是一种熔断器模式，你可以想象一下家里应用的电路过载保护器，不过熔断器的设计要更复杂，一个设计完善的熔断策略，可以在下游服务异常时关闭调用，在下游服务恢复正常时，逐渐恢复流量。</p>
<p data-nodeid="42152">下面我举一个例子，假设你开发了一个电商的订单服务，你的服务要依赖下游很多其他模块的服务，比如评论服务。现在有一个订单查询的场景，QPS 非常高，但是恰好评论服务因为某些原因部分机器宕机，出现大量调用失败的情况。如果没有熔断机制，订单系统可能会在失败后多次重试，最终导致大量请求阻塞，产生级联的失败，并且影响订单系统的上游服务，出现类似服务雪崩的问题，导致整个系统的响应变慢，可用性降低。</p>
<p data-nodeid="42153">如果开启了熔断，订单服务可以在下游调用出现部分异常时，调节流量请求，比如在出现 10% 的失败后，减少 50% 的流量请求，如果继续出现 50% 的异常，则减少 80% 的流量请求；相应的，在检测的下游服务正常后，首先恢复 30% 的流量，然后是 50% 的流量，接下来是全部流量。</p>
<p data-nodeid="42154">对于熔断策略的具体实现，我建议你查看 Alibaba Sentinel 或者 Netflix Hystrix 的设计，熔断器的实现其实是数据结构中有限状态机（Finite-state Machines，FSM）的一种应用，关于 FSM 的具体分析和应用，不是本课时的目标，因为 FSM 不光在算法领域有应用，在复杂系统设计时，为了更好的标识状态流转，用有限状态机来描述会特别清晰。</p>
<p data-nodeid="42155">熔断器的恢复时间，也就是平均故障恢复时间，称为 MTTR，在稳定性设计中是一个常见的指标，在 Hystrix 的断路器设计中，有以下几个状态。</p>
<ul data-nodeid="42156">
<li data-nodeid="42157">
<p data-nodeid="42158">Closed：熔断器关闭状态，比如系统检测到下游失败到了 50% 的阈值，会开启熔断。</p>
</li>
<li data-nodeid="42159">
<p data-nodeid="42160">Open：熔断器打开状态，此时对下游的调用在内部直接返回错误，不发出请求，但是在一定的时间周期以后，会进入下一个半熔断状态。</p>
</li>
<li data-nodeid="42161">
<p data-nodeid="42162">Half-Open：半熔断状态，允许少量的服务请求，如果调用都成功（或一定比例）则认为恢复了，关闭熔断器，否则认为还没好，又回到熔断器打开状态。</p>
</li>
</ul>
<p data-nodeid="42163">在系统具体实现中，降级和熔断推荐使用成熟的中间件，包括 Sentinel 和 Hystrix，以及 resilience4j，关于这几种组件的应用细节，这里暂不做展开分析，我一直觉得，授人以鱼不如授人以渔，在解决了原理层面以后，如何实现就变得简单很多。</p>
<p data-nodeid="42164">我在工作中应用 Sentinel 比较多，你可以在<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D" data-nodeid="42271">Sentinel 官网</a>看到详细的介绍，下面是对这几种组件的对比，来自阿里巴巴 Sentinel 开发团队的分享，作为补充资料：</p>
<table data-nodeid="42166">
<thead data-nodeid="42167">
<tr data-nodeid="42168">
<th data-nodeid="42170"></th>
<th data-org-content="Sentinel" data-nodeid="42171">Sentinel</th>
<th data-org-content="Hystrix" data-nodeid="42172">Hystrix</th>
<th data-org-content="resilience4j" data-nodeid="42173">resilience4j</th>
</tr>
</thead>
<tbody data-nodeid="42178">
<tr data-nodeid="42179">
<td data-org-content="隔离策略" data-nodeid="42180">隔离策略</td>
<td data-org-content="信号量隔离（并发线程数限流）" data-nodeid="42181">信号量隔离（并发线程数限流）</td>
<td data-org-content="线程池隔离/信号量隔离" data-nodeid="42182">线程池隔离/信号量隔离</td>
<td data-org-content="信号量隔离" data-nodeid="42183">信号量隔离</td>
</tr>
<tr data-nodeid="42184">
<td data-org-content="熔断降级策略" data-nodeid="42185">熔断降级策略</td>
<td data-org-content="基于响应时间、异常比率、异常数" data-nodeid="42186">基于响应时间、异常比率、异常数</td>
<td data-org-content="基于异常比率" data-nodeid="42187">基于异常比率</td>
<td data-org-content="基于异常比率、响应时间" data-nodeid="42188">基于异常比率、响应时间</td>
</tr>
<tr data-nodeid="42189">
<td data-org-content="实时统计实现" data-nodeid="42190">实时统计实现</td>
<td data-org-content="滑动窗口（LeapArray）" data-nodeid="42191">滑动窗口（LeapArray）</td>
<td data-org-content="滑动窗口（基于 RxJava）" data-nodeid="42192">滑动窗口（基于 RxJava）</td>
<td data-org-content="Ring Bit Buffer" data-nodeid="42193">Ring Bit Buffer</td>
</tr>
<tr data-nodeid="42194">
<td data-org-content="动态规则配置" data-nodeid="42195">动态规则配置</td>
<td data-org-content="支持多种数据源" data-nodeid="42196">支持多种数据源</td>
<td data-org-content="支持多种数据源" data-nodeid="42197">支持多种数据源</td>
<td data-org-content="有限支持" data-nodeid="42198">有限支持</td>
</tr>
<tr data-nodeid="42199">
<td data-org-content="扩展性" data-nodeid="42200">扩展性</td>
<td data-org-content="多个扩展点" data-nodeid="42201">多个扩展点</td>
<td data-org-content="插件的形式" data-nodeid="42202">插件的形式</td>
<td data-org-content="接口的形式" data-nodeid="42203">接口的形式</td>
</tr>
<tr data-nodeid="42204">
<td data-org-content="基于注解的支持" data-nodeid="42205">基于注解的支持</td>
<td data-org-content="支持" data-nodeid="42206">支持</td>
<td data-org-content="支持" data-nodeid="42207">支持</td>
<td data-org-content="支持" data-nodeid="42208">支持</td>
</tr>
<tr data-nodeid="42209">
<td data-org-content="限流" data-nodeid="42210">限流</td>
<td data-org-content="基于 QPS，支持基于调用关系的限流" data-nodeid="42211">基于 QPS，支持基于调用关系的限流</td>
<td data-org-content="有限的支持" data-nodeid="42212">有限的支持</td>
<td data-org-content="Rate Limiter" data-nodeid="42213">Rate Limiter</td>
</tr>
<tr data-nodeid="42214">
<td data-org-content="流量整形" data-nodeid="42215">流量整形</td>
<td data-org-content="支持预热模式、匀速器模式、预热排队模式" data-nodeid="42216">支持预热模式、匀速器模式、预热排队模式</td>
<td data-org-content="不支持" data-nodeid="42217">不支持</td>
<td data-org-content="简单的 Rate Limiter 模式" data-nodeid="42218">简单的 Rate Limiter 模式</td>
</tr>
<tr data-nodeid="42219">
<td data-org-content="系统自适应保护" data-nodeid="42220">系统自适应保护</td>
<td data-org-content="支持" data-nodeid="42221">支持</td>
<td data-org-content="不支持" data-nodeid="42222">不支持</td>
<td data-org-content="不支持" data-nodeid="42223">不支持</td>
</tr>
<tr data-nodeid="42224">
<td data-org-content="控制台" data-nodeid="42225">控制台</td>
<td data-org-content="提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等" data-nodeid="42226">提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td>
<td data-org-content="简单的监控查看" data-nodeid="42227">简单的监控查看</td>
<td data-org-content="不提供控制台，可对接其他监控系统" data-nodeid="42228">不提供控制台，可对接其他监控系统</td>
</tr>
</tbody>
</table>
<h3 data-nodeid="42229">总结</h3>
<p data-nodeid="42230">以上就是这一课时的内容，和大家总结了降级和熔断的概念，应用场景和实现手段，通过一些应用实例进行了对比。</p>
<p data-nodeid="42231">不知道你有没有发现，在系统设计中，特别是高可用模块，和生活里的一些博弈策略息息相关，不是一个纯技术领域的工作。比如在中国象棋策略中，有个成语叫作丢车保帅，和服务降级有异曲同工之妙，敌人已经攻打过来了，这时候是保护元帅不被将军，还是丢弃一些军备，下次还能卷土重来呢？而服务降级就是放弃一些非关键功能，保证整体系统的运行。</p>
<p data-nodeid="42232">这一课时中，我也列举了股票熔断、漏电保护器等生活实例，希望大家可以扩展思考一下，高可用设计中的博弈在生活中有哪些体现，也欢迎留言分享你的观点。</p>

---

### 精选评论


