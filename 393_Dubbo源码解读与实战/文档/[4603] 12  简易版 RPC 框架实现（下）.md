<p data-nodeid="5511" class="">在上一课时中，我们介绍了整个简易 RPC 框架项目的结构和工作原理，并且介绍了简易 RPC 框架底层的协议结构、序列化/反序列化实现、压缩实现以及编解码器的具体实现。本课时我们将继续自底向上，介绍简易 RPC 框架的剩余部分实现。</p>
<h3 data-nodeid="5512">transport 相关实现</h3>
<p data-nodeid="5513">正如前文介绍 Netty 线程模型的时候提到，我们不能在 Netty 的 I/O 线程中执行耗时的业务逻辑。在 Demo RPC 框架的 Server 端接收到请求时，首先会通过上面介绍的 DemoRpcDecoder 反序列化得到请求消息，之后我们会通过一个自定义的 ChannelHandler（DemoRpcServerHandler）将请求提交给业务线程池进行处理。</p>
<p data-nodeid="5514">在 Demo RPC 框架的 Client 端接收到响应消息的时候，也是先通过 DemoRpcDecoder 反序列化得到响应消息，之后通过一个自定义的 ChannelHandler（DemoRpcClientHandler）将响应返回给上层业务。</p>
<p data-nodeid="5515">DemoRpcServerHandler 和 DemoRpcClientHandler 都继承自 SimpleChannelInboundHandler，如下图所示：</p>
<p data-nodeid="5516"><img src="https://s0.lgstatic.com/i/image/M00/4A/7F/Ciqc1F9R3QOAbbKRAAD4lAEEjtg767.png" alt="Drawing 0.png" data-nodeid="5581"></p>
<div data-nodeid="5517"><p style="text-align:center">DemoRpcClientHandler 和 DemoRpcServerHandler 的继承关系图</p></div>
<p data-nodeid="5518">下面我们就来看一下这两个自定义的 ChannelHandler 实现：</p>
<pre class="lang-java" data-nodeid="5519"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoRpcServerHandler</span> <span class="hljs-keyword">extends</span> 
      <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Message</span>&lt;<span class="hljs-title">Request</span>&gt;&gt; </span>{
    <span class="hljs-comment">// 业务线程池</span>
    <span class="hljs-keyword">static</span> Executor executor = Executors.newCachedThreadPool();
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelHandlerContext ctx, 
          Message&lt;Request&gt; message)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">byte</span> extraInfo = message.getHeader().getExtraInfo();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (Constants.isHeartBeat(extraInfo)) { <span class="hljs-comment">// 心跳消息，直接返回即可</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; channelHandlerContext.writeAndFlush(message);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 非心跳消息，直接封装成Runnable提交到业务线程</span>
&nbsp; &nbsp; &nbsp; &nbsp; executor.execute(<span class="hljs-keyword">new</span> InvokeRunnable(message, cxt));
&nbsp; &nbsp; }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoRpcClientHandler</span> <span class="hljs-keyword">extends</span> 
      <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">Message</span>&lt;<span class="hljs-title">Response</span>&gt;&gt; </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, 
        Message&lt;Response&gt; message)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; NettyResponseFuture responseFuture = 
              Connection.IN_FLIGHT_REQUEST_MAP
                  .remove(message.getHeader().getMessageId());
&nbsp; &nbsp; &nbsp; &nbsp; Response response = message.getContent();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 心跳消息特殊处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (response == <span class="hljs-keyword">null</span> &amp;&amp; Constants.isHeartBeat(
                  message.getHeader().getExtraInfo())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response = <span class="hljs-keyword">new</span> Response();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; response.setCode(Constants.HEARTBEAT_CODE);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; responseFuture.getPromise().setSuccess(response);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5520">注意，这里有两个点需要特别说明一下。一个点是 Server 端的 InvokeRunnable，在这个 Runnable 任务中会根据请求的 serviceName、methodName 以及参数信息，调用相应的方法：</p>
<pre class="lang-java" data-nodeid="5521"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InvokeRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">private</span> ChannelHandlerContext ctx;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> Message&lt;Request&gt; message;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; Response response = <span class="hljs-keyword">new</span> Response();
&nbsp; &nbsp; &nbsp; &nbsp; Object result = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Request request = message.getContent();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String serviceName = request.getServiceName();
            <span class="hljs-comment">// 这里提供BeanManager对所有业务Bean进行管理，其底层在内存中维护了</span>
            <span class="hljs-comment">// 一个业务Bean实例的集合。感兴趣的同学可以尝试接入Spring等容器管</span>
            <span class="hljs-comment">// 理业务Bean</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object bean = BeanManager.getBean(serviceName);
            <span class="hljs-comment">// 下面通过反射调用Bean中的相应方法</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Method method = bean.getClass().getMethod(
                request.getMethodName(), request.getArgTypes());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = method.invoke(bean, request.getArgs());
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Exception e) { <span class="hljs-comment">// 省略异常处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">finally</span> {
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; response.setResult(result); <span class="hljs-comment">// 设置响应结果</span>
        <span class="hljs-comment">// 将响应消息返回给客户端</span>
&nbsp; &nbsp; &nbsp; &nbsp; ctx.writeAndFlush(<span class="hljs-keyword">new</span> Message(message.getHeader(), response));
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5522">另一个点是 Client 端的 Connection，它是用来暂存已发送出去但未得到响应的请求，这样，在响应返回时，就可以查找到相应的请求以及 Future，从而将响应结果返回给上层业务逻辑，具体实现如下：</p>
<pre class="lang-java" data-nodeid="5523"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicLong ID_GENERATOR = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);
&nbsp; &nbsp; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;Long, NettyResponseFuture&lt;Response&gt;&gt; 
        IN_FLIGHT_REQUEST_MAP = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
&nbsp; &nbsp; <span class="hljs-keyword">private</span> ChannelFuture future;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> AtomicBoolean isConnected = <span class="hljs-keyword">new</span> AtomicBoolean();
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Connection</span><span class="hljs-params">(ChannelFuture future, <span class="hljs-keyword">boolean</span> isConnected)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.future = future;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.isConnected.set(isConnected);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> NettyResponseFuture&lt;Response&gt; <span class="hljs-title">request</span><span class="hljs-params">(Message&lt;Request&gt; message, <span class="hljs-keyword">long</span> timeOut)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 生成并设置消息ID</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">long</span> messageId = ID_GENERATOR.incrementAndGet();
&nbsp; &nbsp; &nbsp; &nbsp; message.getHeader().setMessageId(messageId);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建消息关联的Future</span>
&nbsp; &nbsp; &nbsp; &nbsp; NettyResponseFuture responseFuture = <span class="hljs-keyword">new</span> NettyResponseFuture(System.currentTimeMillis(),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeOut, message, future.channel(), <span class="hljs-keyword">new</span> DefaultPromise(<span class="hljs-keyword">new</span> DefaultEventLoop()));
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将消息ID和关联的Future记录到IN_FLIGHT_REQUEST_MAP集合中</span>
&nbsp; &nbsp; &nbsp; &nbsp; IN_FLIGHT_REQUEST_MAP.put(messageId, responseFuture);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; future.channel().writeAndFlush(message); <span class="hljs-comment">// 发送请求</span>
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Exception e) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 发送请求异常时，删除对应的Future</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IN_FLIGHT_REQUEST_MAP.remove(messageId);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> e;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> responseFuture;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 省略getter/setter以及close()方法</span>
}
</code></pre>
<p data-nodeid="5524">我们可以看到，Connection 中没有定时清理 IN_FLIGHT_REQUEST_MAP 集合的操作，在无法正常获取响应的时候，就会导致 IN_FLIGHT_REQUEST_MAP 不断膨胀，最终 OOM。你也可以添加一个时间轮定时器，定时清理过期的请求消息，这里我们就不再展开讲述了。</p>
<p data-nodeid="5525">完成自定义 ChannelHandler 的编写之后，我们需要再定义两个类—— DemoRpcClient 和 DemoRpcServer，分别作为 Client 和 Server 的启动入口。<strong data-nodeid="5602">DemoRpcClient 的实现如下：</strong></p>
<pre class="lang-java" data-nodeid="5526"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoRpcClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">protected</span> Bootstrap clientBootstrap;
&nbsp; &nbsp; <span class="hljs-keyword">protected</span> EventLoopGroup group;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> String host;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoRpcClient</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.host = host;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.port = port;
&nbsp; &nbsp; &nbsp; &nbsp; clientBootstrap = <span class="hljs-keyword">new</span> Bootstrap();
        <span class="hljs-comment">// 创建并配置客户端Bootstrap</span>
&nbsp; &nbsp; &nbsp; &nbsp; group = NettyEventLoopFactory.eventLoopGroup(
            Constants.DEFAULT_IO_THREADS, <span class="hljs-string">"NettyClientWorker"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; clientBootstrap.group(group)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .channel(NioSocketChannel.class)
                // 指定ChannelHandler的顺序
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch.pipeline().addLast(<span class="hljs-string">"demo-rpc-encoder"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcEncoder());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch.pipeline().addLast(<span class="hljs-string">"demo-rpc-decoder"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcDecoder());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch.pipeline().addLast(<span class="hljs-string">"client-handler"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcClientHandler());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">// 连接指定的地址和端口</span>
&nbsp; &nbsp; &nbsp; &nbsp; ChannelFuture connect = clientBootstrap.connect(host, port);
&nbsp; &nbsp; &nbsp; &nbsp; connect.awaitUninterruptibly();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> connect;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; group.shutdownGracefully();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5527">通过 DemoRpcClient 的代码我们可以看到其 ChannelHandler 的执行顺序如下：</p>
<p data-nodeid="5528"><img src="https://s0.lgstatic.com/i/image/M00/4A/81/Ciqc1F9R35eARBOdAAEUxDl6DGE227.png" alt="Lark20200904-143159.png" data-nodeid="5606"></p>
<div data-nodeid="5529"><p style="text-align:center">客户端 ChannelHandler 结构图</p></div>
<p data-nodeid="5530">另外，在创建EventLoopGroup时并没有直接使用NioEventLoopGroup，而是在 NettyEventLoopFactory 中根据当前操作系统进行选择，对于 Linux 系统，会使用 EpollEventLoopGroup，其他系统则使用 NioEventLoopGroup。</p>
<p data-nodeid="5531">接下来我们再看<strong data-nodeid="5613">DemoRpcServer 的具体实现</strong>：</p>
<pre class="lang-java" data-nodeid="5532"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoRpcServer</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">private</span> EventLoopGroup bossGroup;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> EventLoopGroup workerGroup;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> ServerBootstrap serverBootstrap;
&nbsp; &nbsp; <span class="hljs-keyword">private</span> Channel channel;
&nbsp; &nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> port;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoRpcServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.port = port;
        <span class="hljs-comment">// 创建boss和worker两个EventLoopGroup，注意一些小细节， </span>
        <span class="hljs-comment">// workerGroup 是按照中的线程数是按照 CPU 核数计算得到的，</span>
&nbsp; &nbsp; &nbsp; &nbsp; bossGroup = NettyEventLoopFactory.eventLoopGroup(<span class="hljs-number">1</span>, <span class="hljs-string">"boos"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; workerGroup = NettyEventLoopFactory.eventLoopGroup( 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Math.min(Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>,
                 <span class="hljs-number">32</span>), <span class="hljs-string">"worker"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; serverBootstrap = <span class="hljs-keyword">new</span> ServerBootstrap().group(bossGroup, 
                    workerGroup).channel(NioServerSocketChannel.class)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .handler(<span class="hljs-keyword">new</span> LoggingHandler(LogLevel.INFO))
                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()
                  { <span class="hljs-comment">// 指定每个Channel上注册的ChannelHandler以及顺序</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ch.pipeline().addLast(<span class="hljs-string">"demp-rpc-decoder"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcDecoder());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ch.pipeline().addLast(<span class="hljs-string">"demo-rpc-encoder"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcEncoder());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ch.pipeline().addLast(<span class="hljs-string">"server-handler"</span>, 
                            <span class="hljs-keyword">new</span> DemoRpcServerHandler());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;});
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; ChannelFuture channelFuture = serverBootstrap.bind(port);
&nbsp; &nbsp; &nbsp; &nbsp; channel = channelFuture.channel();
&nbsp; &nbsp; &nbsp; &nbsp; channel.closeFuture();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> channelFuture;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5533">通过对 DemoRpcServer 实现的分析，我们可以知道每个 Channel 上的 ChannelHandler 顺序如下：</p>
<p data-nodeid="5534"><img src="https://s0.lgstatic.com/i/image/M00/4A/8C/CgqCHl9R34eAEosNAAEZMNHAB1c561.png" alt="Lark20200904-143204.png" data-nodeid="5617"></p>
<div data-nodeid="5535"><p style="text-align:center">服务端 ChannelHandler 结构图</p></div>
<h3 data-nodeid="5536">registry 相关实现</h3>
<p data-nodeid="5537">介绍完客户端和服务端的通信之后，我们再来看简易 RPC 框架的另一个基础能力——服务注册与服务发现能力，对应 demo-rpc 项目源码中的 registry 包。</p>
<p data-nodeid="5538">registry 包主要是依赖 Apache Curator 实现了一个简易版本的 ZooKeeper 客户端，并基于 ZooKeeper 实现了注册中心最基本的两个功能：Provider 注册以及 Consumer 订阅。</p>
<p data-nodeid="5539">这里我们先定义一个 Registry 接口，其中提供了注册以及查询服务实例的方法，如下图所示：</p>
<p data-nodeid="5540"><img src="https://s0.lgstatic.com/i/image/M00/4A/7F/Ciqc1F9R3WuAd1UPAAA82c309GI280.png" alt="Drawing 3.png" data-nodeid="5624"></p>
<p data-nodeid="5541">ZooKeeperRegistry 是基于 curator-x-discovery 对 Registry 接口的实现类型，其中封装了之前课时介绍的 ServiceDiscovery，并在其上添加了 ServiceCache 缓存提高查询效率。ZooKeeperRegistry 的具体实现如下：</p>
<pre class="lang-js" data-nodeid="5542"><code data-language="js">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperRegistry</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Registry</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
&nbsp; &nbsp; private InstanceSerializer serializer = 
          <span class="hljs-keyword">new</span> JsonInstanceSerializer&lt;&gt;(ServerInfo.class);
&nbsp; &nbsp; private ServiceDiscovery&lt;T&gt; serviceDiscovery;
&nbsp; &nbsp; private ServiceCache&lt;T&gt; serviceCache;
&nbsp; &nbsp; private <span class="hljs-built_in">String</span> address = <span class="hljs-string">"localhost:2181"</span>;
&nbsp; &nbsp; public <span class="hljs-keyword">void</span> start() throws Exception {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">String</span> root = <span class="hljs-string">"/demo/rpc"</span>;
        <span class="hljs-comment">// 初始化CuratorFramework</span>
&nbsp; &nbsp; &nbsp; &nbsp; CuratorFramework client = CuratorFrameworkFactory
            .newClient(address, <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));
        client.start(); <span class="hljs-comment">// 启动Curator客户端</span>
        client.blockUntilConnected();  <span class="hljs-comment">// 阻塞当前线程，等待连接成</span>
&nbsp; &nbsp; &nbsp; &nbsp; client.createContainers(root);
        <span class="hljs-comment">// 初始化ServiceDiscovery</span>
&nbsp; &nbsp; &nbsp; &nbsp; serviceDiscovery = ServiceDiscoveryBuilder
                .builder(ServerInfo.class)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .client(client).basePath(root)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .serializer(serializer)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();
&nbsp; &nbsp; &nbsp; &nbsp; serviceDiscovery.start(); <span class="hljs-comment">// 启动ServiceDiscovery</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建ServiceCache，监Zookeeper相应节点的变化，也方便后续的读取</span>
&nbsp; &nbsp; &nbsp; &nbsp; serviceCache = serviceDiscovery.serviceCacheBuilder()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .name(root)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .build();
&nbsp; &nbsp; &nbsp; &nbsp; serviceCache.start(); <span class="hljs-comment">// 启动ServiceCache</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; @Override
&nbsp; &nbsp; public <span class="hljs-keyword">void</span> registerService(ServiceInstance&lt;T&gt; service)
             throws Exception {
&nbsp; &nbsp; &nbsp; &nbsp; serviceDiscovery.registerService(service);
&nbsp; &nbsp; }
&nbsp; &nbsp; @Override
&nbsp; &nbsp; public <span class="hljs-keyword">void</span> unregisterService(ServiceInstance service) 
          throws Exception {
&nbsp; &nbsp; &nbsp; &nbsp; serviceDiscovery.unregisterService(service);
&nbsp; &nbsp; }
&nbsp; &nbsp; @Override
&nbsp; &nbsp; public List&lt;ServiceInstance&lt;T&gt;&gt; queryForInstances(
            <span class="hljs-built_in">String</span> name) throws Exception {
        <span class="hljs-comment">// 直接根据name进行过滤ServiceCache中的缓存数据 </span>
        <span class="hljs-keyword">return</span> serviceCache.getInstances().stream()
            .filter(s -&gt; s.getName().equals(name))
                .collect(Collectors.toList());
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5543">通过对 ZooKeeperRegistry的分析可以得知，它是基于 Curator 中的 ServiceDiscovery 组件与 ZooKeeper 进行交互的，并且对 Registry 接口的实现也是通过直接调用 ServiceDiscovery 的相关方法实现的。在查询时，直接读取 ServiceCache 中的缓存数据，ServiceCache 底层在本地维护了一个 ConcurrentHashMap 缓存，通过 PathChildrenCache 监听 ZooKeeper 中各个子节点的变化，同步更新本地缓存。这里我们简单看一下 ServiceCache 的核心实现：</p>
<pre class="lang-java" data-nodeid="5544"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceCacheImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ServiceCache</span>&lt;<span class="hljs-title">T</span>&gt;, 
  <span class="hljs-title">PathChildrenCacheListener</span></span>{<span class="hljs-comment">//实现PathChildrenCacheListener接口</span>
    <span class="hljs-comment">// 关联的ServiceDiscovery实例</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscoveryImpl&lt;T&gt;&nbsp;&nbsp;discovery;
    <span class="hljs-comment">// 底层的PathChildrenCache，用于监听子节点的变化</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PathChildrenCache cache; 
    <span class="hljs-comment">// 本地缓存</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, ServiceInstance&lt;T&gt;&gt;&nbsp;instances 
      = Maps.newConcurrentMap();

    <span class="hljs-keyword">public</span> List&lt;ServiceInstance&lt;T&gt;&gt; getInstances(){ <span class="hljs-comment">// 返回本地缓存内容</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> Lists.newArrayList(instances.values());
&nbsp; &nbsp; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, 
          PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception</span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">switch</span>(event.getType()){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> CHILD_ADDED:
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> CHILD_UPDATED:{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addInstance(event.getData(), <span class="hljs-keyword">false</span>); <span class="hljs-comment">// 更新本地缓存</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notifyListeners = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">case</span> CHILD_REMOVED:{ <span class="hljs-comment">// 更新本地缓存</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instances.remove(instanceIdFromData(event.getData()));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notifyListeners = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
        ... <span class="hljs-comment">// 通知ServiceCache上注册的监听器</span>
&nbsp; &nbsp; }
}
</code></pre>
<h3 data-nodeid="5545">proxy 相关实现</h3>
<p data-nodeid="5546">在简易版 Demo RPC 框架中，Proxy 主要是为 Client 端创建一个代理，帮助客户端程序屏蔽底层的网络操作以及与注册中心之间的交互。</p>
<p data-nodeid="5547">简易版 Demo RPC 使用 JDK 动态代理的方式生成代理，这里需要编写一个 InvocationHandler 接口的实现，即下面的 DemoRpcProxy。其中有两个核心方法：一个是 newInstance() 方法，用于生成代理对象；另一个是 invoke() 方法，当调用目标对象的时候，会执行 invoke() 方法中的代理逻辑。</p>
<p data-nodeid="5548">下面是 DemoRpcProxy 的具体实现：</p>
<pre class="lang-java" data-nodeid="5549"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoRpcProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>{
    <span class="hljs-comment">// 需要代理的服务(接口)名称</span>
    <span class="hljs-keyword">private</span> String serviceName;
    <span class="hljs-comment">// 用于与Zookeeper交互，其中自带缓存</span>
    <span class="hljs-keyword">private</span> Registry&lt;ServerInfo&gt; registry;
   &nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoRpcProxy</span><span class="hljs-params">(String serviceName, Registry&lt;ServerInfo&gt; 
            registry)</span> <span class="hljs-keyword">throws</span> Exception </span>{ <span class="hljs-comment">// 初始化上述两个字段</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.serviceName = serviceName;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.registry = registry;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;T&gt; clazz, 
        Registry&lt;ServerInfo&gt; registry)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建代理对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(Thread.currentThread()
            .getContextClassLoader(), <span class="hljs-keyword">new</span> Class[]{clazz},
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">new</span> DemoRpcProxy(clazz.getName(), registry));
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>
           <span class="hljs-keyword">throws</span> Throwable </span>{
        <span class="hljs-comment">// 从Zookeeper缓存中获取可用的Server地址,并随机从中选择一个</span>
        List&lt;ServiceInstance&lt;ServerInfo&gt;&gt; serviceInstances = 
              registry.queryForInstances(serviceName);
&nbsp; &nbsp; &nbsp; &nbsp; ServiceInstance&lt;ServerInfo&gt; serviceInstance = serviceInstances
            .get(ThreadLocalRandom.current()
                .nextInt(serviceInstances.size()));
        <span class="hljs-comment">// 创建请求消息，然后调用remoteCall()方法请求上面选定的Server端</span>
&nbsp; &nbsp; &nbsp; &nbsp; String methodName = method.getName();
&nbsp; &nbsp; &nbsp; &nbsp; Header header =<span class="hljs-keyword">new</span> Header(MAGIC, VERSION_1...);
&nbsp; &nbsp; &nbsp; &nbsp; Message&lt;Request&gt; message = <span class="hljs-keyword">new</span> Message(header, 
            <span class="hljs-keyword">new</span> Request(serviceName, methodName, args));
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> remoteCall(serviceInstance.getPayload(), message);
&nbsp; &nbsp; }

&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">remoteCall</span><span class="hljs-params">(ServerInfo serverInfo, 
            Message message)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (serverInfo == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"get available server error"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
        <span class="hljs-comment">// 创建DemoRpcClient连接指定的Server端</span>
&nbsp; &nbsp; &nbsp; &nbsp; DemoRpcClient demoRpcClient = <span class="hljs-keyword">new</span> DemoRpcClient(
              serverInfo.getHost(), serverInfo.getPort());
&nbsp; &nbsp; &nbsp; &nbsp; ChannelFuture channelFuture = demoRpcClient.connect()
              .awaitUninterruptibly();
        <span class="hljs-comment">// 创建对应的Connection对象，并发送请求</span>
&nbsp; &nbsp; &nbsp; &nbsp; Connection connection = <span class="hljs-keyword">new</span> Connection(channelFuture, <span class="hljs-keyword">true</span>);
&nbsp; &nbsp; &nbsp; &nbsp; NettyResponseFuture responseFuture =
             connection.request(message, Constants.DEFAULT_TIMEOUT);
        <span class="hljs-comment">// 等待请求对应的响应</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> responseFuture.getPromise().get(
            Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5550">从 DemoRpcProxy 的实现中我们可以看到，它依赖了 ServiceInstanceCache 获取ZooKeeper 中注册的 Server 端地址，同时依赖了 DemoRpcClient 与Server 端进行通信，上层调用方拿到这个代理对象后，就可以像调用本地方法一样进行调用，而不再关心底层网络通信和服务发现的细节。当然，这个简易版 DemoRpcProxy 的实现还有很多可以优化的地方，例如：</p>
<ul data-nodeid="5551">
<li data-nodeid="5552">
<p data-nodeid="5553">缓存 DemoRpcClient 客户端对象以及相应的 Connection 对象，不必每次进行创建。</p>
</li>
<li data-nodeid="5554">
<p data-nodeid="5555">可以添加失败重试机制，在请求出现超时的时候，进行重试。</p>
</li>
<li data-nodeid="5556">
<p data-nodeid="5557">可以添加更加复杂和灵活的负载均衡机制，例如，根据 Hash 值散列进行负载均衡、根据节点 load 情况进行负载均衡等。</p>
</li>
</ul>
<p data-nodeid="5558">你若感兴趣的话可以尝试进行扩展，以实现一个更加完善的代理层。</p>
<h3 data-nodeid="5559">使用方接入</h3>
<p data-nodeid="5560">介绍完 Demo RPC 的核心实现之后，下面我们讲解下Demo RPC 框架的使用方式。这里涉及Consumer、DemoServiceImp、Provider三个类以及 DemoService 业务接口。</p>
<p data-nodeid="5561"><img src="https://s0.lgstatic.com/i/image/M00/4A/7F/Ciqc1F9R3YiAXV8hAAAtXArd3J0997.png" alt="Drawing 4.png" data-nodeid="5640"></p>
<div data-nodeid="5562"><p style="text-align:center">使用接入的相关类</p></div>
<p data-nodeid="5563">首先，我们定义<strong data-nodeid="5646">DemoService 接口</strong>作为业务 Server 接口，具体定义如下：</p>
<pre class="lang-java" data-nodeid="5564"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DemoService</span> </span>{
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String param)</span></span>;
}
</code></pre>
<p data-nodeid="5565"><strong data-nodeid="5651">DemoServiceImpl</strong>对 DemoService 接口的实现也非常简单，如下所示，将参数做简单修改后返回：</p>
<pre class="lang-java" data-nodeid="5566"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String param)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">"hello:"</span> + param;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5567">了解完相应的业务接口和实现之后，我们再来看<strong data-nodeid="5657">Provider</strong>的实现，它的角色类似于 Dubbo 中的 Provider，其会创建 DemoServiceImpl 这个业务 Bean 并将自身的地址信息暴露出去，如下所示：</p>
<pre class="lang-java" data-nodeid="5568"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Provider</span> </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
        <span class="hljs-comment">// 创建DemoServiceImpl，并注册到BeanManager中</span>
&nbsp; &nbsp; &nbsp; &nbsp; BeanManager.registerBean(<span class="hljs-string">"demoService"</span>, 
                <span class="hljs-keyword">new</span> DemoServiceImpl());
        <span class="hljs-comment">// 创建ZookeeperRegistry，并将Provider的地址信息封装成ServerInfo</span>
        <span class="hljs-comment">//&nbsp;对象注册到Zookeeper</span>
        ZookeeperRegistry&lt;ServerInfo&gt; discovery = 
                <span class="hljs-keyword">new</span> ZookeeperRegistry&lt;&gt;();
        discovery.start();
&nbsp; &nbsp; &nbsp; &nbsp; ServerInfo serverInfo = <span class="hljs-keyword">new</span> ServerInfo(<span class="hljs-string">"127.0.0.1"</span>, <span class="hljs-number">20880</span>);
&nbsp; &nbsp; &nbsp; &nbsp; discovery.registerService(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;ServiceInstance.&lt;ServerInfo&gt;builder().name(<span class="hljs-string">"demoService"</span>)
                .payload(serverInfo).build());
        <span class="hljs-comment">// 启动DemoRpcServer，等待Client的请求</span>
&nbsp; &nbsp; &nbsp; &nbsp; DemoRpcServer rpcServer = <span class="hljs-keyword">new</span> DemoRpcServer(<span class="hljs-number">20880</span>);
&nbsp; &nbsp; &nbsp; &nbsp; rpcServer.start();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="5569">最后是Consumer，它类似于 Dubbo 中的 Consumer，其会订阅 Provider 地址信息，然后根据这些信息选择一个 Provider 建立连接，发送请求并得到响应，这些过程在 Proxy 中都予以了封装，那Consumer 的实现就很简单了，可参考如下示例代码：</p>
<pre class="lang-java" data-nodeid="5570"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建ZookeeperRegistr对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; ZookeeperRegistry&lt;ServerInfo&gt; discovery = <span class="hljs-keyword">new</span> ZookeeperRegistry&lt;&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建代理对象，通过代理调用远端Server</span>
&nbsp; &nbsp; &nbsp; &nbsp; DemoService demoService = DemoRpcProxy.newInstance(DemoService.class, discovery);
&nbsp; &nbsp; &nbsp; &nbsp; // 调用sayHello()方法，并输出结果
&nbsp; &nbsp; &nbsp; &nbsp; String result = demoService.sayHello("hello");
&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(result);
&nbsp; &nbsp; }
}
</code></pre>
<h3 data-nodeid="5571">总结</h3>
<p data-nodeid="5572">本课时我们首先介绍了简易 RPC 框架中的<strong data-nodeid="5685">transport 包</strong>，它在上一课时介绍的编解码器基础之上，<strong data-nodeid="5686">实现了服务端和客户端的通信能力</strong>。之后讲解了<strong data-nodeid="5687">registry 包</strong>如何实现与 ZooKeeper 的交互，<strong data-nodeid="5688">完善了简易 RPC 框架的服务注册与服务发现的能力</strong>。接下来又分析了<strong data-nodeid="5689">proxy 包</strong>的实现，其中通过 JDK 动态代理的方式，<strong data-nodeid="5690">帮接入方屏蔽了底层网络通信的复杂性</strong>。最后，我们编写了一个简单的 DemoService 业务接口，以及相应的 Provider 和 Consumer 接入简易 RPC 框架。</p>
<p data-nodeid="6239">在本课时最后，留给你一个小问题：在 transport 中创建 EventLoopGroup 的时候，为什么针对 Linux 系统使用的 EventLoopGroup会有所不同呢？期待你的留言。</p>
<p data-nodeid="6240" class="te-preview-highlight"><span style="color:#ab4642">简易版 RPC 框架 Demo 的链接：<a href="https://github.com/xxxlxy2008/demo-prc" data-nodeid="6246">https://github.com/xxxlxy2008/demo-prc</a> 。</span></p>

---

### 精选评论

##### *阳：
> 能给一下简易版RPC框架源代码的链接吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 为方便同学们查看，我已经放到GitHub上了：https://github.com/xxxlxy2008/demo-prc

##### **伟：
> 完整的代码工程可以提供不

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 百度网盘:https://pan.baidu.com/s/1H864XJRN1wpHSlWO5Yltmg 密码:83dh

##### 魏：
> 写的太棒了

##### **鹏：
> 干货满满

##### *震：
> 不同操作系统使用的EventLoopGroup不同，可能跟性能有关，当然都是选择最优的，不知道对不对

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 对的，要深入了解的话，可以参考下面的三个文章：
【https://blog.csdn.net/CHS007chs/article/details/99549230】

【https://blog.csdn.net/alex_xfboy/article/details/89643638】

【https://blog.csdn.net/xiaoqi030611a/article/details/8820875】

##### **8001：
> 牛，学着写

