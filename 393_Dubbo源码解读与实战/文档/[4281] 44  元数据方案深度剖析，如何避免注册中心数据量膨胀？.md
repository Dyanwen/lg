<p data-nodeid="19664" class="">在上一课时，我们详细介绍了 Dubbo 传统架构面临的挑战，以及 Dubbo 2.7.5 版本引入的服务自省方案是如何应对这些挑战的。</p>
<p data-nodeid="19665">本课时我们将从服务自省方案的基础设施开始介绍其具体实现。我们首先会介绍元数据相关的基础类的定义，然后介绍元数据的上报以及元数据服务的相关内容，同时还会介绍 Service ID 与 Service Name 是如何映射的。</p>
<h3 data-nodeid="19666">ServiceInstance</h3>
<p data-nodeid="19667"><strong data-nodeid="19830">Service Instance 唯一标识一个服务实例</strong>，在 Dubbo 的源码中对应 ServiceInstance 接口，该接口的具体定义如下：</p>
<pre class="lang-java" data-nodeid="19668"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceInstance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 唯一标识</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getId</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance所属的Service Name</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getServiceName</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance的host</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getHost</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance的port</span>
&nbsp; &nbsp; <span class="hljs-function">Integer <span class="hljs-title">getPort</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 当前ServiceInstance的状态</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEnabled</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 检测当前ServiceInstance的状态</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHealthy</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance关联的元数据，这些元数据以KV格式存储</span>
&nbsp; &nbsp; <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getMetadata</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 计算当前ServiceInstance对象的hashCode值</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 比较两个ServiceInstance对象</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object another)</span></span>;
}
</code></pre>
<p data-nodeid="19669"><strong data-nodeid="19835">DefaultServiceInstance 是 ServiceInstance 的唯一实现</strong>，DefaultServiceInstance 是一个普通的 POJO 类，其中的核心字段如下。</p>
<ul data-nodeid="19670">
<li data-nodeid="19671">
<p data-nodeid="19672">id（String 类型）：ServiceInstance 唯一标识。</p>
</li>
<li data-nodeid="19673">
<p data-nodeid="19674">serviceName（String 类型）：ServiceInstance 关联的 Service Name。</p>
</li>
<li data-nodeid="19675">
<p data-nodeid="19676">host（String 类型）：ServiceInstance 的 host。</p>
</li>
<li data-nodeid="19677">
<p data-nodeid="19678">port（Integer 类型）：ServiceInstance 的 port。</p>
</li>
<li data-nodeid="19679">
<p data-nodeid="19680">enabled（boolean 类型）：ServiceInstance 是否可用的状态。</p>
</li>
<li data-nodeid="19681">
<p data-nodeid="19682">healthy（boolean 类型）：ServiceInstance 的健康状态。</p>
</li>
<li data-nodeid="19683">
<p data-nodeid="19684">metadata（Map&lt;String, String&gt; 类型）：ServiceInstance 关联的元数据。</p>
</li>
</ul>
<h3 data-nodeid="19685">ServiceDefinition</h3>
<p data-nodeid="19686">Dubbo 元数据服务与我们业务中发布的 Dubbo 服务无异，<strong data-nodeid="19851">Consumer 端可以调用一个 ServiceInstance 的元数据服务获取其发布的全部服务的元数据</strong>。</p>
<p data-nodeid="19687">说到元数据，就不得不提到 ServiceDefinition 这个类，它可以来描述一个服务接口的定义，其核心字段如下。</p>
<ul data-nodeid="19688">
<li data-nodeid="19689">
<p data-nodeid="19690">canonicalName（String 类型）：接口的完全限定名称。</p>
</li>
<li data-nodeid="19691">
<p data-nodeid="19692">codeSource（String 类型）：服务接口所在的完整路径。</p>
</li>
<li data-nodeid="19693">
<p data-nodeid="19694">methods（List 类型）：接口中定义的全部方法描述信息。在 MethodDefinition 中记录了方法的名称、参数类型、返回值类型以及方法参数涉及的所有 TypeDefinition。</p>
</li>
<li data-nodeid="19695">
<p data-nodeid="19696">types（List 类型）：接口定义中涉及的全部类型描述信息，包括方法的参数和字段，如果遇到复杂类型，TypeDefinition 会递归获取复杂类型内部的字段。在 dubbo-metadata-api 模块中，提供了多种类型对应的 TypeBuilder 用于创建对应的 TypeDefinition，对于没有特定 TypeBuilder 实现的类型，会使用 DefaultTypeBuilder。</p>
</li>
</ul>
<p data-nodeid="20091" class=""><img src="https://s0.lgstatic.com/i/image/M00/8C/22/CgqCHl_lrYOAIzjeAAFEk3cUdpg570.png" alt="6.png" data-nodeid="20095"></p>
<div data-nodeid="20092"><p style="text-align:center">TypeBuilder 接口实现关系图</p></div>


<p data-nodeid="19699"><strong data-nodeid="19866">在服务发布的时候，会将服务的 URL 中的部分数据封装为 FullServiceDefinition 对象，然后作为元数据存储起来</strong>。FullServiceDefinition 继承了 ServiceDefinition，并在 ServiceDefinition 基础之上扩展了 params 集合（Map&lt;String, String&gt; 类型），用来存储 URL 上的参数。</p>
<h3 data-nodeid="19700">MetadataService</h3>
<p data-nodeid="19701" class="">接下来看 MetadataService 接口，在上一讲我们提到<strong data-nodeid="19873">Dubbo 中的每个 ServiceInstance 都会发布 MetadataService 接口供 Consumer 端查询元数据</strong>，下图展示了 MetadataService 接口的继承关系：</p>
<p data-nodeid="20950" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/FC/CgpVE1_lrZGANC4vAAGdcllZU9o940.png" alt="1.png" data-nodeid="20954"></p>
<div data-nodeid="20951"><p style="text-align:center">MetadataService 接口继承关系图</p></div>


<p data-nodeid="19704">在 MetadataService 接口中定义了查询当前 ServiceInstance 发布的元数据的相关方法，具体如下所示：</p>
<pre class="lang-java" data-nodeid="19705"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataService</span> </span>{
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">serviceName</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 获取当前ServiceInstance所属服务的名称</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">version</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> VERSION; <span class="hljs-comment">// 获取当前MetadataService接口的版本</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance订阅的全部URL</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> SortedSet&lt;String&gt; <span class="hljs-title">getSubscribedURLs</span><span class="hljs-params">()</span></span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">"This operation is not supported for consumer."</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取当前ServiceInstance发布的全部URL</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExportedURLs(ALL_SERVICE_INTERFACES);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 根据服务接口查找当前ServiceInstance暴露的全部接口</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(String serviceInterface)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExportedURLs(serviceInterface, <span class="hljs-keyword">null</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 根据服务接口和group两个条件查找当前ServiceInstance暴露的全部接口</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(String serviceInterface, String group)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExportedURLs(serviceInterface, group, <span class="hljs-keyword">null</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 根据服务接口、group和version三个条件查找当前ServiceInstance暴露的全部接口</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(String serviceInterface, String group, String version)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExportedURLs(serviceInterface, group, version, <span class="hljs-keyword">null</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 根据服务接口、group、version和protocol四个条件查找当前ServiceInstance暴露的全部接口</span>
&nbsp; &nbsp; <span class="hljs-function">SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span></span>;

&nbsp; &nbsp; <span class="hljs-comment">// 根据指定条件查询ServiceDefinition</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getServiceDefinition</span><span class="hljs-params">(String interfaceName, String version, String group)</span></span>;
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getServiceDefinition</span><span class="hljs-params">(String serviceKey)</span></span>;
}
</code></pre>
<p data-nodeid="19706"><strong data-nodeid="19882">在 MetadataService 接口中定义的都是查询元数据的方法，在其子接口 WritableMetadataService 中添加了一些发布元数据的写方法</strong>，具体定义如下：</p>
<pre class="lang-java" data-nodeid="19707"><code data-language="java"><span class="hljs-meta">@SPI(DEFAULT_METADATA_STORAGE_TYPE)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WritableMetadataService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MetadataService</span> </span>{
&nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">serviceName</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// ServiceName默认是从ApplicationModel中获取</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// ExtensionLoader、DubboBootstrap以及ApplicationModel是单个Dubbo进程范围内的单例对象，</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// ExtensionLoader用于Dubbo SPI机制加载扩展实现，DubboBootstrap用于启动Dubbo进程，</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// ApplicationModel用于表示一个Dubbo实例，其中维护了多个ProviderModel对象表示当前Dubbo实例发布的服务，</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 维护了多个ConsumerModel对象表示当前Dubbo实例引用的服务。</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> ApplicationModel.getApplication();
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">exportURL</span><span class="hljs-params">(URL url)</span></span>; <span class="hljs-comment">// 发布该URL所代表的服务</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unexportURL</span><span class="hljs-params">(URL url)</span></span>; <span class="hljs-comment">// 注销该URL所代表的服务</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">refreshMetadata</span><span class="hljs-params">(String exportedRevision, String subscribedRevision)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 刷新元数据</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">subscribeURL</span><span class="hljs-params">(URL url)</span></span>; <span class="hljs-comment">// 订阅该URL所代表的服务</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unsubscribeURL</span><span class="hljs-params">(URL url)</span></span>; <span class="hljs-comment">// 取消订阅该URL所代表的服务</span>
&nbsp; &nbsp; <span class="hljs-comment">// 发布Provider端的ServiceDefinition</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">publishServiceDefinition</span><span class="hljs-params">(URL providerUrl)</span></span>;

&nbsp; &nbsp; <span class="hljs-comment">// 获取WritableMetadataService的默认扩展实现</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">static</span> WritableMetadataService <span class="hljs-title">getDefaultExtension</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExtensionLoader(WritableMetadataService.class).getDefaultExtension();
&nbsp; &nbsp; }
&nbsp; &nbsp; // 获取WritableMetadataService接口指定的扩展实现（无指定扩展名称，则返回默认扩展实现）
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">static</span> WritableMetadataService <span class="hljs-title">getExtension</span><span class="hljs-params">(String name)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExtensionLoader(WritableMetadataService.class).getOrDefaultExtension(name);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19708">WritableMetadataService 接口被 @SPI 注解修饰，是一个扩展接口，在前面的继承关系图中也可以看出，<strong data-nodeid="19888">它有两个比较基础的扩展实现，分别是 InMemoryWritableMetadataService（默认扩展实现） 和 RemoteWritableMetadataServiceDelegate，对应扩展名分别是 local 和 remote</strong>。</p>
<p data-nodeid="19709">下面我们先来看 InMemoryWritableMetadataService 的实现，其中维护了三个核心集合。</p>
<ul data-nodeid="19710">
<li data-nodeid="19711">
<p data-nodeid="19712">exportedServiceURLs（ConcurrentSkipListMap&lt;String, SortedSet<code data-backticks="1" data-nodeid="19893">&lt;URL&gt;</code>&gt; 类型）：用于记录当前 ServiceInstance 发布的 URL 集合，其中 Key 是 ServiceKey（即 interface、group 和 version 三部分构成），Value 是对应的 URL 集合。</p>
</li>
<li data-nodeid="19713">
<p data-nodeid="19714">subscribedServiceURLs（ConcurrentSkipListMap&lt;String, SortedSet<code data-backticks="1" data-nodeid="19899">&lt;URL&gt;</code>&gt; 类型）：用于记录当前 ServiceInstance 引用的 URL 集合，其中 Key 是 ServiceKey（即 interface、group 和 version 三部分构成），Value 是对应的 URL 集合。</p>
</li>
<li data-nodeid="19715">
<p data-nodeid="19716">serviceDefinitions（ConcurrentSkipListMap&lt;String, String&gt; 类型）：用于记录当前 ServiceInstance 发布的 ServiceDefinition 信息，其中 Key 为 Provider URL 的ServiceKey，Value 为对应的 ServiceDefinition 对象序列化之后的 JSON 字符串。</p>
</li>
</ul>
<p data-nodeid="19717">InMemoryWritableMetadataService 对 getExportedURLs()、getSubscribedURLs() 以及 getServiceDefinition() 方法的实现，就是<strong data-nodeid="19914">查询</strong>上述三个集合的数据；对 (un)exportURL()、(un)subscribeURL() 和 publishServiceDefinition() 方法的实现，就是<strong data-nodeid="19915">增删</strong>上述三个集合的数据。</p>
<p data-nodeid="19718">(un)exportURL()、(un)subscribeURL() 等方法都是非常简单的集合操作，我们就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/dubbo" data-nodeid="19919">源码</a>进行学习。 这里我们重点来看一下 publishServiceDefinition() 方法对 ServiceDefinition 的处理：</p>
<pre class="lang-java" data-nodeid="19719"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishServiceDefinition</span><span class="hljs-params">(URL providerUrl)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取服务接口</span>
&nbsp; &nbsp; String interfaceName = providerUrl.getParameter(INTERFACE_KEY);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(interfaceName)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !ProtocolUtils.isGeneric(providerUrl.getParameter(GENERIC_KEY))) {
&nbsp; &nbsp; &nbsp; &nbsp; Class interfaceClass = Class.forName(interfaceName);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建服务接口对应的ServiceDefinition对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; ServiceDefinition serviceDefinition = ServiceDefinitionBuilder.build(interfaceClass);
&nbsp; &nbsp; &nbsp; &nbsp; Gson gson = <span class="hljs-keyword">new</span> Gson();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将ServiceDefinition对象序列化为JSON对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; String data = gson.toJson(serviceDefinition);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将ServiceDefinition对象序列化之后的JSON字符串记录到serviceDefinitions集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; serviceDefinitions.put(providerUrl.getServiceKey(), data);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19720"><strong data-nodeid="19925">在 RemoteWritableMetadataService 实现中封装了一个 InMemoryWritableMetadataService 对象，并对 publishServiceDefinition() 方法进行了覆盖</strong>，具体实现如下：</p>
<pre class="lang-java" data-nodeid="19721"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishServiceDefinition</span><span class="hljs-params">(URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取URL中的side参数值，决定调用publishProvider()还是publishConsumer()方法</span>
&nbsp; &nbsp; String side = url.getParameter(SIDE_KEY);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (PROVIDER_SIDE.equalsIgnoreCase(side)) {
&nbsp; &nbsp; &nbsp; &nbsp; publishProvider(url);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; publishConsumer(url);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19722">在 publishProvider() 方法中，首先会根据 Provider URL 创建对应的 FullServiceDefinition 对象，然后通过 MetadataReport 进行上报，具体实现如下：</p>
<pre class="lang-java" data-nodeid="19723"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishProvider</span><span class="hljs-params">(URL providerUrl)</span> <span class="hljs-keyword">throws</span> RpcException </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 删除pid、timestamp、bind.ip、bind.port等参数</span>
&nbsp; &nbsp; providerUrl = providerUrl.removeParameters(PID_KEY, TIMESTAMP_KEY, Constants.BIND_IP_KEY,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constants.BIND_PORT_KEY, TIMESTAMP_KEY);

&nbsp; &nbsp; <span class="hljs-comment">// 获取服务接口名称</span>
&nbsp; &nbsp; String interfaceName = providerUrl.getParameter(INTERFACE_KEY);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(interfaceName)) {
&nbsp; &nbsp; &nbsp; &nbsp; Class interfaceClass = Class.forName(interfaceName); <span class="hljs-comment">// 反射</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建服务接口对应的FullServiceDefinition对象，URL中的参数会记录到FullServiceDefinition的params集合中</span>
&nbsp; &nbsp; &nbsp; &nbsp; FullServiceDefinition fullServiceDefinition = ServiceDefinitionBuilder.buildFullDefinition(interfaceClass,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; providerUrl.getParameters());
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 获取MetadataReport并上报FullServiceDefinition</span>
&nbsp; &nbsp; &nbsp; &nbsp; getMetadataReport().storeProviderMetadata(<span class="hljs-keyword">new</span> MetadataIdentifier(providerUrl.getServiceInterface(),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; providerUrl.getParameter(VERSION_KEY), providerUrl.getParameter(GROUP_KEY),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROVIDER_SIDE, providerUrl.getParameter(APPLICATION_KEY)), fullServiceDefinition);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19724">publishConsumer() 方法则相对比较简单：首先会清理 Consumer URL 中 pid、timestamp 等参数，然后将 Consumer URL 中的参数集合进行上报。</p>
<p data-nodeid="19725">不过，在 RemoteWritableMetadataService 中的 exportURL()、subscribeURL()、getExportedURLs()、getServiceDefinition() 等一系列方法都是空实现，这是为什么呢？其实我们从 RemoteWritableMetadataServiceDelegate 中就可以找到答案，注意，<strong data-nodeid="19933">RemoteWritableMetadataServiceDelegate 才是 MetadataService 接口的 remote 扩展实现</strong>。</p>
<p data-nodeid="19726"><strong data-nodeid="19938">在 RemoteWritableMetadataServiceDelegate 中同时维护了一个 InMemoryWritableMetadataService 对象和 RemoteWritableMetadataService 对象</strong>，exportURL()、subscribeURL() 等发布订阅相关的方法会同时委托给这两个 MetadataService 对象，getExportedURLs()、getServiceDefinition() 等查询方法则只会调用 InMemoryWritableMetadataService 对象进行查询。这里我们以 exportURL() 方法为例进行说明：</p>
<pre class="lang-java" data-nodeid="19727"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exportURL</span><span class="hljs-params">(URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> doFunction(WritableMetadataService::exportURL, url);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doFunction</span><span class="hljs-params">(BiFunction&lt;WritableMetadataService, URL, Boolean&gt; func, URL url)</span> </span>{
    <span class="hljs-comment">// 同时调用InMemoryWritableMetadataService对象和RemoteWritableMetadataService对象的exportURL()方法</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> func.apply(defaultWritableMetadataService, url) &amp;&amp; func.apply(remoteWritableMetadataService, url);
}
</code></pre>
<h3 data-nodeid="19728">MetadataReport</h3>
<p data-nodeid="19729">元数据中心是 Dubbo 2.7.0 版本之后新增的一项优化，其主要目的是将 URL 中的一部分内容存储到元数据中心，从而减少注册中心的压力。</p>
<p data-nodeid="19730"><strong data-nodeid="19945">元数据中心的数据只是给本端自己使用的，改动不需要告知对端</strong>，例如，Provider 修改了元数据，不需要实时通知 Consumer。这样，在注册中心存储的数据量减少的同时，还减少了因为配置修改导致的注册中心频繁通知监听者情况的发生，很好地减轻了注册中心的压力。</p>
<p data-nodeid="19731"><strong data-nodeid="19950">MetadataReport 接口是 Dubbo 节点与元数据中心交互的桥梁</strong>，其继承关系如下图所示：</p>
<p data-nodeid="21809" class=""><img src="https://s0.lgstatic.com/i/image2/M01/03/FA/Cip5yF_lramAYf82AAFkkbA0N2g785.png" alt="2.png" data-nodeid="21813"></p>
<div data-nodeid="21810"><p style="text-align:center">MetadataReport 继承关系图</p></div>


<p data-nodeid="19734">我们先来看一下 MetadataReport 接口的核心定义：</p>
<pre class="lang-java" data-nodeid="19735"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataReport</span> </span>{
    <span class="hljs-comment">// 存储Provider元数据</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">storeProviderMetadata</span><span class="hljs-params">(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 存储Consumer元数据</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">storeConsumerMetadata</span><span class="hljs-params">(MetadataIdentifier consumerMetadataIdentifier, Map&lt;String, String&gt; serviceParameterMap)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 存储、删除Service元数据</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveServiceMetadata</span><span class="hljs-params">(ServiceMetadataIdentifier metadataIdentifier, URL url)</span></span>;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeServiceMetadata</span><span class="hljs-params">(ServiceMetadataIdentifier metadataIdentifier)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 查询暴露的URL</span>
&nbsp; &nbsp; <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(ServiceMetadataIdentifier metadataIdentifier)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 查询订阅数据</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">saveSubscribedData</span><span class="hljs-params">(SubscriberMetadataIdentifier subscriberMetadataIdentifier, Set&lt;String&gt; urls)</span></span>;
&nbsp; &nbsp; <span class="hljs-function">List&lt;String&gt; <span class="hljs-title">getSubscribedURLs</span><span class="hljs-params">(SubscriberMetadataIdentifier subscriberMetadataIdentifier)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 查询ServiceDefinition</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getServiceDefinition</span><span class="hljs-params">(MetadataIdentifier metadataIdentifier)</span></span>;
}
</code></pre>
<p data-nodeid="19736">了解了 MetadataReport 接口定义的核心行为之后，接下来我们就按照其实现的顺序来介绍：先来分析 AbstractMetadataReport 抽象类提供的公共实现，然后以 ZookeeperMetadataReport 这个具体实现为例，介绍 MetadataReport 如何与 ZooKeeper 配合实现元数据上报。</p>
<h4 data-nodeid="19737">1. AbstractMetadataReport</h4>
<p data-nodeid="19738"><strong data-nodeid="19963">AbstractMetadataReport 中提供了所有 MetadataReport 的公共实现</strong>，其核心字段如下：</p>
<pre class="lang-java" data-nodeid="19739"><code data-language="java"><span class="hljs-keyword">private</span> URL reportURL; <span class="hljs-comment">// 元数据中心的URL，其中包含元数据中心的地址</span>
<span class="hljs-comment">// 本地磁盘缓存，用来缓存上报的元数据</span>
File file;
<span class="hljs-keyword">final</span> Properties properties = <span class="hljs-keyword">new</span> Properties();
<span class="hljs-comment">// 内存缓存</span>
<span class="hljs-keyword">final</span> Map&lt;MetadataIdentifier, Object&gt; allMetadataReports = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">4</span>);
<span class="hljs-comment">// 该线程池除了用来同步本地内存缓存与文件缓存，还会用来完成异步上报的功能</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService reportCacheExecutor = Executors.newFixedThreadPool(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"DubboSaveMetadataReport"</span>, <span class="hljs-keyword">true</span>));
<span class="hljs-comment">// 用来暂存上报失败的元数据，后面会有定时任务进行重试</span>
<span class="hljs-keyword">final</span> Map&lt;MetadataIdentifier, Object&gt; failedReports = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">4</span>);
<span class="hljs-keyword">boolean</span> syncReport; <span class="hljs-comment">// 是否同步上报元数据</span>
<span class="hljs-comment">// 记录最近一次元数据上报的版本，单调递增</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong lastCacheChanged = <span class="hljs-keyword">new</span> AtomicLong();
<span class="hljs-comment">// 用于重试的定时任务</span>
<span class="hljs-keyword">public</span> MetadataReportRetry metadataReportRetry;
<span class="hljs-comment">// 当前MetadataReport实例是否已经初始化</span>
<span class="hljs-keyword">private</span> AtomicBoolean initialized = <span class="hljs-keyword">new</span> AtomicBoolean(<span class="hljs-keyword">false</span>);
</code></pre>
<p data-nodeid="19740">在 AbstractMetadataReport 的构造方法中，首先会初始化本地的文件缓存，然后创建 MetadataReportRetry 重试任务，并启动一个周期性刷新的定时任务，具体实现如下：</p>
<pre class="lang-java" data-nodeid="19741"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractMetadataReport</span><span class="hljs-params">(URL reportServerURL)</span> </span>{
&nbsp; &nbsp; setUrl(reportServerURL);
&nbsp; &nbsp; <span class="hljs-comment">// 默认的本地文件缓存</span>
&nbsp; &nbsp; String defaultFilename = System.getProperty(<span class="hljs-string">"user.home"</span>) + <span class="hljs-string">"/.dubbo/dubbo-metadata-"</span> + reportServerURL.getParameter(APPLICATION_KEY) + <span class="hljs-string">"-"</span> + reportServerURL.getAddress().replaceAll(<span class="hljs-string">":"</span>, <span class="hljs-string">"-"</span>) + <span class="hljs-string">".cache"</span>;
&nbsp; &nbsp; String filename = reportServerURL.getParameter(FILE_KEY, defaultFilename);
&nbsp; &nbsp; File file = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (ConfigUtils.isNotEmpty(filename)) {
&nbsp; &nbsp; &nbsp; &nbsp; file = <span class="hljs-keyword">new</span> File(filename);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="hljs-keyword">null</span> &amp;&amp; !file.getParentFile().exists()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!file.getParentFile().mkdirs()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"..."</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!initialized.getAndSet(<span class="hljs-keyword">true</span>) &amp;&amp; file.exists()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file.delete();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.file = file;
&nbsp; &nbsp; <span class="hljs-comment">// 将file文件中的内容加载到properties字段中</span>
&nbsp; &nbsp; loadProperties();
&nbsp; &nbsp; <span class="hljs-comment">// 是否同步上报元数据</span>
&nbsp; &nbsp; syncReport = reportServerURL.getParameter(SYNC_REPORT_KEY, <span class="hljs-keyword">false</span>);
&nbsp; &nbsp; <span class="hljs-comment">// 创建重试任务</span>
&nbsp; &nbsp; metadataReportRetry = <span class="hljs-keyword">new</span> MetadataReportRetry(reportServerURL.getParameter(RETRY_TIMES_KEY, DEFAULT_METADATA_REPORT_RETRY_TIMES),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reportServerURL.getParameter(RETRY_PERIOD_KEY, DEFAULT_METADATA_REPORT_RETRY_PERIOD));
&nbsp; &nbsp; <span class="hljs-comment">// 是否周期性地上报元数据</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (reportServerURL.getParameter(CYCLE_REPORT_KEY, DEFAULT_METADATA_REPORT_CYCLE_REPORT)) {
&nbsp; &nbsp; &nbsp; &nbsp; ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"DubboMetadataReportTimer"</span>, <span class="hljs-keyword">true</span>));
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 默认每隔1天将本地元数据全部刷新到元数据中心</span>
&nbsp; &nbsp; &nbsp; &nbsp; scheduler.scheduleAtFixedRate(<span class="hljs-keyword">this</span>::publishAll, calculateStartTime(), ONE_DAY_IN_MILLISECONDS, TimeUnit.MILLISECONDS);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19742">在 AbstractMetadataReport.storeProviderMetadata() 方法中，首先会根据 syncReport 字段值决定是同步上报还是异步上报：如果是同步上报，则在当前线程执行上报操作；如果是异步上报，则在 reportCacheExecutor 线程池中执行上报操作。具体的上报操作是在storeProviderMetadataTask() 方法中完成的：</p>
<pre class="lang-java" data-nodeid="19743"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeProviderMetadataTask</span><span class="hljs-params">(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将元数据记录到allMetadataReports集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; allMetadataReports.put(providerMetadataIdentifier, serviceDefinition);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果之前上报失败，则在failedReports集合中有记录，这里上报成功之后会将其删除</span>
&nbsp; &nbsp; &nbsp; &nbsp; failedReports.remove(providerMetadataIdentifier);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将元数据序列化成JSON字符串</span>
&nbsp; &nbsp; &nbsp; &nbsp; Gson gson = <span class="hljs-keyword">new</span> Gson();
&nbsp; &nbsp; &nbsp; &nbsp; String data = gson.toJson(serviceDefinition);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 上报序列化后的元数据</span>
&nbsp; &nbsp; &nbsp; &nbsp; doStoreProviderMetadata(providerMetadataIdentifier, data);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将序列化后的元数据保存到本地文件缓存中</span>
&nbsp; &nbsp; &nbsp; &nbsp; saveProperties(providerMetadataIdentifier, data, <span class="hljs-keyword">true</span>, !syncReport);
&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Exception e) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果上报失败，则在failedReports集合中进行记录，然后由metadataReportRetry任务中进行重试</span>
&nbsp; &nbsp; &nbsp; &nbsp; failedReports.put(providerMetadataIdentifier, serviceDefinition);
&nbsp; &nbsp; &nbsp; &nbsp; metadataReportRetry.startRetryTask();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19744">我们可以看到这里调用了 doStoreProviderMetadata() 方法和 saveProperties() 方法。其中， doStoreProviderMetadata() 方法是一个抽象方法，对于不同的元数据中心实现有不同的实现，这个方法的具体实现在后面会展开分析。saveProperties() 方法中会更新 properties 字段，递增本地缓存文件的版本号，最后（同步/异步）执行 SaveProperties 任务，更新本地缓存文件的内容，具体实现如下：</p>
<pre class="lang-java" data-nodeid="19745"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveProperties</span><span class="hljs-params">(MetadataIdentifier metadataIdentifier, String value, <span class="hljs-keyword">boolean</span> add, <span class="hljs-keyword">boolean</span> sync)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (file == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (add) { <span class="hljs-comment">// 更新properties中的元数据</span>
&nbsp; &nbsp; &nbsp; &nbsp; properties.setProperty(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY), value);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; properties.remove(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY));
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 递增版本</span>
&nbsp; &nbsp; <span class="hljs-keyword">long</span> version = lastCacheChanged.incrementAndGet();
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (sync) { <span class="hljs-comment">// 同步更新本地缓存文件</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">new</span> SaveProperties(version).run();
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 异步更新本地缓存文件</span>
&nbsp; &nbsp; &nbsp; &nbsp; reportCacheExecutor.execute(<span class="hljs-keyword">new</span> SaveProperties(version));
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19746">下面我们再来看 SaveProperties 任务的核心方法—— doSaveProperties() 方法，该方法中<strong data-nodeid="19972">实现了刷新本地缓存文件的全部操作</strong>。</p>
<pre class="lang-java" data-nodeid="19747"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSaveProperties</span><span class="hljs-params">(<span class="hljs-keyword">long</span> version)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (version &lt; lastCacheChanged.get()) { <span class="hljs-comment">// 对比当前版本号和此次SaveProperties任务的版本号</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (file == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 检测本地缓存文件是否存在</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建lock文件</span>
&nbsp; &nbsp; &nbsp; &nbsp; File lockfile = <span class="hljs-keyword">new</span> File(file.getAbsolutePath() + <span class="hljs-string">".lock"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!lockfile.exists()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockfile.createNewFile();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> (RandomAccessFile raf = <span class="hljs-keyword">new</span> RandomAccessFile(lockfile, <span class="hljs-string">"rw"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FileChannel channel = raf.getChannel()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FileLock lock = channel.tryLock(); <span class="hljs-comment">// 对lock文件加锁</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (lock == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Can not lock the metadataReport cache file "</span> + file.getAbsolutePath() + <span class="hljs-string">", ignore and retry later, maybe multi java process use the file, please config: dubbo.metadata.file=xxx.properties"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!file.exists()) { <span class="hljs-comment">// 保证本地缓存文件存在</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file.createNewFile();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将properties中的元数据保存到本地缓存文件中</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> (FileOutputStream outputFile = <span class="hljs-keyword">new</span> FileOutputStream(file)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; properties.store(outputFile, <span class="hljs-string">"Dubbo metadataReport Cache"</span>);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">finally</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.release(); <span class="hljs-comment">// 释放lock文件上的锁</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Throwable e) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (version &lt; lastCacheChanged.get()) { <span class="hljs-comment">// 比较版本号</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 如果写文件失败，则重新提交SaveProperties任务，再次尝试</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reportCacheExecutor.execute(<span class="hljs-keyword">new</span> SaveProperties(lastCacheChanged.incrementAndGet()));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19748">了解了刷新本地缓存文件的核心逻辑之后，我们再来看 AbstractMetadataReport 中<strong data-nodeid="19978">失败重试</strong>的逻辑。MetadataReportRetry 中维护了如下核心字段：</p>
<pre class="lang-java" data-nodeid="19749"><code data-language="java"><span class="hljs-comment">// 执行重试任务的线程池</span>
ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"DubboMetadataReportRetryTimer"</span>, <span class="hljs-keyword">true</span>));
<span class="hljs-comment">// 重试任务关联的Future对象</span>
<span class="hljs-keyword">volatile</span> ScheduledFuture retryScheduledFuture;
<span class="hljs-comment">// 记录重试任务的次数</span>
<span class="hljs-keyword">final</span> AtomicInteger retryCounter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);
<span class="hljs-comment">// 重试任务的时间间隔</span>
<span class="hljs-keyword">long</span> retryPeriod;
<span class="hljs-comment">// 无失败上报的元数据之后，重试任务会再执行600次，才会销毁</span>
<span class="hljs-keyword">int</span> retryTimesIfNonFail = <span class="hljs-number">600</span>;
<span class="hljs-comment">// 失败重试的次数上限，默认为100次，即重试失败100次之后会放弃</span>
<span class="hljs-keyword">int</span> retryLimit;
</code></pre>
<p data-nodeid="19750">在 startRetryTask() 方法中，MetadataReportRetry 会创建一个重试任务，并提交到 retryExecutor 线程池中等待执行（如果已存在重试任务，则不会创建新任务）。在重试任务中会调用 AbstractMetadataReport.retry() 方法完成重新上报，当然也会判断 retryLimit 等执行条件，具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/dubbo" data-nodeid="19982">源码</a>进行学习。</p>
<p data-nodeid="19751">AbstractMetadataReport.retry() 方法的具体实现如下：</p>
<pre class="lang-java" data-nodeid="19752"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">retry</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> doHandleMetadataCollection(failedReports);
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doHandleMetadataCollection</span><span class="hljs-params">(Map&lt;MetadataIdentifier, Object&gt; metadataMap)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (metadataMap.isEmpty()) { <span class="hljs-comment">// 没有上报失败的元数据</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 遍历failedReports集合中失败上报的元数据，逐个调用storeProviderMetadata()方法或storeConsumerMetadata()方法重新上报</span>
&nbsp; &nbsp; Iterator&lt;Map.Entry&lt;MetadataIdentifier, Object&gt;&gt; iterable = metadataMap.entrySet().iterator();
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (iterable.hasNext()) {
&nbsp; &nbsp; &nbsp; &nbsp; Map.Entry&lt;MetadataIdentifier, Object&gt; item = iterable.next();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (PROVIDER_SIDE.equals(item.getKey().getSide())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.storeProviderMetadata(item.getKey(), (FullServiceDefinition) item.getValue());
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (CONSUMER_SIDE.equals(item.getKey().getSide())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.storeConsumerMetadata(item.getKey(), (Map) item.getValue());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
</code></pre>
<p data-nodeid="19753">在 AbstractMetadataReport 的构造方法中，会根据 reportServerURL（也就是后面的 metadataReportURL）参数启动一个“天”级别的定时任务，该定时任务会执行 publishAll() 方法，其中会通过 doHandleMetadataCollection() 方法将 allMetadataReports 集合中的全部元数据重新进行上报。该定时任务默认是在凌晨 02:00~06:00 启动，每天执行一次。</p>
<p data-nodeid="19754">到此为止，AbstractMetadataReport 为子类实现的公共能力就介绍完了，其他方法都是委托给了相应的 do*() 方法，这些 do*() 方法都是在 AbstractMetadataReport 子类中实现的。</p>
<p data-nodeid="19755"><img src="https://s0.lgstatic.com/i/image/M00/8B/DD/CgqCHl_hcauAR9AQAAG7kMJSlc8827.png" alt="Drawing 3.png" data-nodeid="19995"></p>
<h4 data-nodeid="19756">2. BaseMetadataIdentifier</h4>
<p data-nodeid="19757">在 AbstractMetadataReport 上报元数据的时候，元数据对应的 Key 都是BaseMetadataIdentifier 类型的对象，其继承关系如下图所示：</p>
<p data-nodeid="22668" class=""><img src="https://s0.lgstatic.com/i/image/M00/8C/17/Ciqc1F_lrb-Ad3a5AAGJ2ySdyBE643.png" alt="3.png" data-nodeid="22672"></p>
<div data-nodeid="22669"><p style="text-align:center">BaseMetadataIdentifier 继承关系图</p></div>


<ul data-nodeid="19760">
<li data-nodeid="19761">
<p data-nodeid="19762">MetadataIdentifier 中包含了服务接口、version、group、side 和 application 五个核心字段。</p>
</li>
<li data-nodeid="19763">
<p data-nodeid="19764">ServiceMetadataIdentifier 中包含了服务接口、version、group、side、revision 和 protocol 六个核心字段。</p>
</li>
<li data-nodeid="19765">
<p data-nodeid="19766">SubscriberMetadataIdentifier 中包含了服务接口、version、group、side 和 revision 五个核心字段。</p>
</li>
</ul>
<h4 data-nodeid="19767">3. MetadataReportFactory &amp; MetadataReportInstance</h4>
<p data-nodeid="19768">MetadataReportFactory 是用来创建 MetadataReport 实例的工厂，具体定义如下：</p>
<pre class="lang-java" data-nodeid="19769"><code data-language="java"><span class="hljs-meta">@SPI("redis")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataReportFactory</span> </span>{
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({"protocol"})</span>
&nbsp; &nbsp; <span class="hljs-function">MetadataReport <span class="hljs-title">getMetadataReport</span><span class="hljs-params">(URL url)</span></span>;
}
</code></pre>
<p data-nodeid="19770">MetadataReportFactory 是个扩展接口，从 @SPI 注解的默认值可以看出<strong data-nodeid="20019">Dubbo 默认使用 Redis 实现元数据中心</strong>。<br>
Dubbo 提供了针对 ZooKeeper、Redis、Consul 等作为元数据中心的 MetadataReportFactory 实现，如下图所示：</p>
<p data-nodeid="23527" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/8C/22/CgqCHl_lrcmAEIYBAAFSOVpEU1Y779.png" alt="4.png" data-nodeid="23531"></p>
<div data-nodeid="23528"><p style="text-align:center">MetadataReportFactory 继承关系图</p></div>


<p data-nodeid="19773">这些 MetadataReportFactory 实现都继承了 AbstractMetadataReportFactory，在 AbstractMetadataReportFactory 提供了缓存 MetadataReport 实现的功能，并定义了一个 createMetadataReport() 抽象方法供子类实现。另外，AbstractMetadataReportFactory 实现了 MetadataReportFactory 接口的 getMetadataReport() 方法，下面我们就来简单看一下该方法的实现：</p>
<pre class="lang-java" data-nodeid="19774"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> MetadataReport <span class="hljs-title">getMetadataReport</span><span class="hljs-params">(URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 清理export、refer参数</span>
&nbsp; &nbsp; url = url.setPath(MetadataReport.class.getName())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .removeParameters(EXPORT_KEY, REFER_KEY);
&nbsp; &nbsp; String key = url.toServiceString();
&nbsp; &nbsp; LOCK.lock();
&nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; // 从SERVICE_STORE_MAP集合（ConcurrentHashMap&lt;String, MetadataReport&gt;类型）中查询是否已经缓存有对应的MetadataReport对象
&nbsp; &nbsp; &nbsp; &nbsp; MetadataReport metadataReport = SERVICE_STORE_MAP.get(key);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (metadataReport != <span class="hljs-keyword">null</span>) { // 直接返回缓存的MetadataReport对象
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> metadataReport;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建新的MetadataReport对象，createMetadataReport()方法由子类具体实现</span>
&nbsp; &nbsp; &nbsp; &nbsp; metadataReport = createMetadataReport(url);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将MetadataReport缓存到SERVICE_STORE_MAP集合中</span>
&nbsp; &nbsp; &nbsp; &nbsp; SERVICE_STORE_MAP.put(key, metadataReport);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> metadataReport;
&nbsp; &nbsp; } <span class="hljs-keyword">finally</span> {
&nbsp; &nbsp; &nbsp; &nbsp; LOCK.unlock();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19775">MetadataReportInstance 是一个单例对象，其中会获取 MetadataReportFactory 的适配器，并根据 init() 方法传入的 metadataReportURL 选择对应的 MetadataReportFactory 创建 MetadataReport 实例，这也是当前 Dubbo 进程全局唯一的 MetadataReport 实例。</p>
<p data-nodeid="19776">MetadataReportInstance 的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/dubbo" data-nodeid="20028">源码</a>进行学习。</p>
<h4 data-nodeid="19777">4. ZookeeperMetadataReport</h4>
<p data-nodeid="19778">下面我们来看 dubbo-metadata-report-zookeeper 模块是如何接入 ZooKeeper 作为元数据中心的。</p>
<p data-nodeid="19779">我们首先关注 dubbo-metadata-report-zookeeper 模块的 SPI 文件，可以看到 ZookeeperMetadataReportFactory 的扩展名称是 zookeeper：</p>
<pre class="lang-java" data-nodeid="19780"><code data-language="java">zookeeper=org.apache.dubbo.metadata.store.zookeeper.ZookeeperMetadataReportFactory
</code></pre>
<p data-nodeid="19781">在 ZookeeperMetadataReportFactory 的 createMetadataReport() 方法中会创建 ZookeeperMetadataReport 这个 MetadataReport 实现类的对象。</p>
<p data-nodeid="19782"><strong data-nodeid="20040">在 ZookeeperMetadataReport 中维护了一个 ZookeeperClient 实例用来和 ZooKeeper 进行交互</strong>。ZookeeperMetadataReport 读写元数据的根目录是 metadataReportURL 的 group 参数值，默认值为 dubbo。</p>
<p data-nodeid="19783">下面再来看 ZookeeperMetadataReport 对 AbstractMetadataReport 中各个 do*() 方法的实现，这些方法核心都是通过 ZookeeperClient 创建、查询、删除对应的 ZNode 节点，没有什么复杂的逻辑，<strong data-nodeid="20048">关键是明确一下操作的 ZNode 节点的 path 是什么</strong>。</p>
<p data-nodeid="19784">doStoreProviderMetadata() 方法和 doStoreConsumerMetadata() 方法会调用 storeMetadata() 创建相应的 ZNode 节点：</p>
<pre class="lang-java" data-nodeid="19785"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeMetadata</span><span class="hljs-params">(MetadataIdentifier metadataIdentifier, String v)</span> </span>{
&nbsp; &nbsp; zkClient.create(getNodePath(metadataIdentifier), v, <span class="hljs-keyword">false</span>);
}
<span class="hljs-function">String <span class="hljs-title">getNodePath</span><span class="hljs-params">(BaseMetadataIdentifier metadataIdentifier)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> toRootDir() + metadataIdentifier.getUniqueKey(KeyTypeEnum.PATH);
}
</code></pre>
<p data-nodeid="19786">MetadataIdentifier 对象对应 ZNode 节点的 path 默认格式是 :</p>
<pre class="lang-java" data-nodeid="19787"><code data-language="java">/dubbo/metadata/服务接口/version/group/side/application
</code></pre>
<p data-nodeid="19788">对应 ZNode 节点的 Value 是 ServiceDefinition 序列化后的 JSON 字符串。</p>
<p data-nodeid="19789">doSaveMetadata()、doRemoveMetadata() 以及 doGetExportedURLs() 方法参数是 ServiceMetadataIdentifier 对象，对应的 ZNode 节点 path 是：</p>
<pre class="lang-java" data-nodeid="19790"><code data-language="java">/dubbo/metadata/服务接口/version/group/side/protocol/revision
</code></pre>
<p data-nodeid="19791">doSaveSubscriberData()、doGetSubscribedURLs() 方法的参数是 SubscriberMetadataIdentifier 对象，对应的 ZNode 节点 path 是：</p>
<pre class="lang-java" data-nodeid="19792"><code data-language="java">/dubbo/metadata/服务接口/version/group/side/revision
</code></pre>
<h3 data-nodeid="19793">MetadataServiceExporter</h3>
<p data-nodeid="19794">了解了 MetadataService 接口的核心功能和底层实现之后，我们接着再来看 MetadataServiceExporter 接口，这个接口<strong data-nodeid="20060">负责将 MetadataService 接口作为一个 Dubbo 服务发布出去</strong>。</p>
<p data-nodeid="19795">下面来看 MetadataServiceExporter 接口的具体定义：</p>
<pre class="lang-java" data-nodeid="19796"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MetadataServiceExporter</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 将MetadataService作为一个Dubbo服务发布出去</span>
&nbsp; &nbsp; <span class="hljs-function">MetadataServiceExporter <span class="hljs-title">export</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 注销掉MetadataService服务</span>
&nbsp; &nbsp; <span class="hljs-function">MetadataServiceExporter <span class="hljs-title">unexport</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// MetadataService可能以多种协议发布，这里返回发布MetadataService服务的所有URL</span>
&nbsp; &nbsp; <span class="hljs-function">List&lt;URL&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 检测MetadataService服务是否已经发布</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isExported</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="19797"><strong data-nodeid="20066">MetadataServiceExporter 只有 ConfigurableMetadataServiceExporter 这一个实现</strong>，如下图所示：</p>
<p data-nodeid="19798"><img src="https://s0.lgstatic.com/i/image2/M01/03/B6/Cip5yF_hcfmAMtHdAABVR_mzQyg047.png" alt="Drawing 6.png" data-nodeid="20069"></p>
<div data-nodeid="19799"><p style="text-align:center">MetadataServiceExporter 继承关系图</p></div>
<p data-nodeid="19800">ConfigurableMetadataServiceExporter 的核心实现是 export() 方法，其中会创建一个 ServiceConfig 对象完成 MetadataService 服务的发布：</p>
<pre class="lang-java" data-nodeid="19801"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableMetadataServiceExporter <span class="hljs-title">export</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!isExported()) {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建ServiceConfig对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; ServiceConfig&lt;MetadataService&gt; serviceConfig = <span class="hljs-keyword">new</span> ServiceConfig&lt;&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setApplication(getApplicationConfig());
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setRegistries(getRegistries());
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setProtocol(generateMetadataProtocol()); <span class="hljs-comment">// 设置Protocol（默认是Dubbo）</span>
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setInterface(MetadataService.class); // 设置服务接口
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setRef(metadataService); // 设置MetadataService对象
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setGroup(getApplicationConfig().getName()); // 设置group
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.setVersion(metadataService.version()); // 设置version
&nbsp; &nbsp; &nbsp; &nbsp; // 发布MetadataService服务，ServiceConfig发布服务的流程在前面已经详细分析过了，这里不再展开
&nbsp; &nbsp; &nbsp; &nbsp; serviceConfig.export();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.serviceConfig = serviceConfig;
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; ... <span class="hljs-comment">// 输出日志</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
</code></pre>
<h3 data-nodeid="19802">ServiceNameMapping</h3>
<p data-nodeid="19803"><strong data-nodeid="20076">ServiceNameMapping 接口的主要功能是实现 Service ID 到 Service Name 之间的转换，底层会依赖配置中心实现数据存储和查询</strong>。ServiceNameMapping 接口的定义如下：</p>
<pre class="lang-java" data-nodeid="19804"><code data-language="java"><span class="hljs-meta">@SPI("default")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceNameMapping</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 服务接口、group、version、protocol四部分构成了Service ID，并与当前Service Name之间形成映射，记录到配置中心</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 根据服务接口、group、version、protocol四部分构成的Service ID，查询对应的Service Name</span>
&nbsp; &nbsp; <span class="hljs-function">Set&lt;String&gt; <span class="hljs-title">get</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 获取默认的ServiceNameMapping接口的扩展实现</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">static</span> ServiceNameMapping <span class="hljs-title">getDefaultExtension</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getExtensionLoader(ServiceNameMapping.class).getDefaultExtension();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="19805"><strong data-nodeid="20081">DynamicConfigurationServiceNameMapping 是 ServiceNameMapping 的默认实现</strong>，也是唯一实现，其中会依赖 DynamicConfiguration 读写配置中心，完成 Service ID 和 Service Name 的映射。首先来看 DynamicConfigurationServiceNameMapping 的 map() 方法：</p>
<pre class="lang-java" data-nodeid="19806"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">map</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 跳过MetadataService接口的处理</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (IGNORED_SERVICE_INTERFACES.contains(serviceInterface)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取DynamicConfiguration对象</span>
&nbsp; &nbsp; DynamicConfiguration dynamicConfiguration = DynamicConfiguration.getDynamicConfiguration();
&nbsp; &nbsp; <span class="hljs-comment">// 从ApplicationModel中获取Service Name</span>
&nbsp; &nbsp; String key = getName();&nbsp;
&nbsp; &nbsp; String content = valueOf(System.currentTimeMillis());
&nbsp; &nbsp; execute(() -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 在配置中心创建映射关系，这里的buildGroup()方法虽然接收四个参数，但是只使用了serviceInterface</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 也就是使用创建了服务接口到Service Name的映射</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 可以暂时将配置中心理解为一个KV存储，这里的Key是buildGroup()方法返回值+Service Name构成的，value是content（即时间戳）</span>
&nbsp; &nbsp; &nbsp; &nbsp; dynamicConfiguration.publishConfig(key, buildGroup(serviceInterface, group, version, protocol), content);
&nbsp; &nbsp; });
}
</code></pre>
<p data-nodeid="19807">在 DynamicConfigurationServiceNameMapping.get() 方法中，会根据传入的服务接口名称、group、version、protocol 组成 Service ID，查找对应的 Service Name，如下所示：</p>
<pre class="lang-java" data-nodeid="19808"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">get</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取DynamicConfiguration对象</span>
&nbsp; &nbsp; DynamicConfiguration dynamicConfiguration = DynamicConfiguration.getDynamicConfiguration();
&nbsp; &nbsp; <span class="hljs-comment">// 根据Service ID从配置查找Service Name</span>
&nbsp; &nbsp; Set&lt;String&gt; serviceNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
&nbsp; &nbsp; execute(() -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; Set&lt;String&gt; keys = dynamicConfiguration.getConfigKeys(buildGroup(serviceInterface, group, version, protocol));
&nbsp; &nbsp; &nbsp; &nbsp; serviceNames.addAll(keys);
&nbsp; &nbsp; });
&nbsp; &nbsp; <span class="hljs-comment">// 返回查找到的全部Service Name</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> Collections.unmodifiableSet(serviceNames);
}
</code></pre>
<h3 data-nodeid="19809">总结</h3>
<p data-nodeid="19810">本课时我们重点介绍了服务自省架构中元数据相关的实现。</p>
<ul data-nodeid="19811">
<li data-nodeid="19812">
<p data-nodeid="19813">首先我们介绍了 ServiceInstance 和 ServiceDefinition 是如何抽象一个服务实例以及服务定义的。</p>
</li>
<li data-nodeid="19814">
<p data-nodeid="19815">紧接着讲解了元数据服务接口的定义，也就是 MetadataService 接口及核心的扩展实现。</p>
</li>
<li data-nodeid="19816">
<p data-nodeid="19817">接下来详细分析了 MetadataReport 接口的实现，了解了它是如何与元数据中心配合，实现元数据上报功能的。</p>
</li>
<li data-nodeid="19818">
<p data-nodeid="19819">然后还说明了 MetadataServiceExporter 的实现，了解了发布元数据服务的核心原理。</p>
</li>
<li data-nodeid="19820">
<p data-nodeid="19821">最后，我们介绍了 ServiceNameMapping 接口以及其默认实现，它实现了 Service ID 与 Service Name 的映射，也是服务自省架构中不可或缺的一部分。</p>
</li>
</ul>
<p data-nodeid="19822" class="">下一课时，我们将继续介绍服务实例注册相关的实现，记得按时来听课。</p>

---

### 精选评论


