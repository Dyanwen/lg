<p data-nodeid="7545" class="">在前面的课程中，我们深入介绍了 Dubbo 架构中的 Dubbo Remoting 层的相关内容，了解了 Dubbo 底层的网络模型以及线程模型。从本课时开始，我们就开始介绍 Dubbo Remoting 上面的一层—— Protocol 层（如下图所示），<strong data-nodeid="7612">Protocol 层是 Remoting 层的使用者</strong>，会通过 Exchangers 门面类创建 ExchangeClient 以及 ExchangeServer，还会创建相应的 ChannelHandler 实现以及 Codec2 实现并交给 Exchange 层进行装饰。</p>
<p data-nodeid="7546"><img src="https://s0.lgstatic.com/i/image/M00/5D/C4/Ciqc1F-FS2eAdVorABDINpNLpXY061.png" alt="Drawing 0.png" data-nodeid="7615"></p>
<div data-nodeid="7547"><p style="text-align:center">Dubbo 架构中 Protocol 层的位置图</p></div>
<p data-nodeid="7548"><strong data-nodeid="7620">Protocol 层在 Dubbo 源码中对应的是 dubbo-rpc 模块</strong>，该模块的结构如下图所示：</p>
<p data-nodeid="7549"><img src="https://s0.lgstatic.com/i/image/M00/5D/C4/Ciqc1F-FS4aAMyvkAABpKhWTC9Q132.png" alt="Drawing 1.png" data-nodeid="7623"></p>
<div data-nodeid="7550"><p style="text-align:center">dubbo-rpc 模块结构图</p></div>
<p data-nodeid="7551">我们可以看到有很多模块，和 dubbo-remoting 模块类似，其中 <strong data-nodeid="7629">dubbo-rpc-api 是对具体协议、服务暴露、服务引用、代理等的抽象，是整个 Protocol 层的核心</strong>。剩余的模块，例如，dubbo-rpc-dubbo、dubbo-rpc-grpc、dubbo-rpc-http 等，都是 Dubbo 支持的具体协议，可以看作dubbo-rpc-api 模块的具体实现。</p>
<h3 data-nodeid="7552">dubbo-rpc-api</h3>
<p data-nodeid="7553">这里我们首先来看 dubbo-rpc-api 模块的包结构，如下图所示：</p>
<p data-nodeid="7554"><img src="https://s0.lgstatic.com/i/image/M00/5D/CF/CgqCHl-FS5CAP7kCAADYKrhf28A273.png" alt="Drawing 2.png" data-nodeid="7634"></p>
<div data-nodeid="7555"><p style="text-align:center">dubbo-rpc-api 模块的包结构图</p></div>
<p data-nodeid="7556">根据上图展示的 dubbo-rpc-api 模块的结构，我们可以看到 dubbo-rpc-api 模块包括了以下几个核心包。</p>
<ul data-nodeid="7557">
<li data-nodeid="7558">
<p data-nodeid="7559">filter 包：在进行服务引用时会进行一系列的过滤，其中包括了很多过滤器。</p>
</li>
<li data-nodeid="7560">
<p data-nodeid="7561">listener 包：在服务发布和服务引用的过程中，我们可以添加一些 Listener 来监听相应的事件，与 Listener 相关的接口 Adapter、Wrapper 实现就在这个包内。</p>
</li>
<li data-nodeid="7562">
<p data-nodeid="7563">protocol 包：一些实现了 Protocol 接口以及 Invoker 接口的抽象类位于该包之中，它们主要是为 Protocol 接口的具体实现以及 Invoker 接口的具体实现提供一些公共逻辑。</p>
</li>
<li data-nodeid="7564">
<p data-nodeid="7565">proxy 包：提供了创建代理的能力，在这个包中支持 JDK 动态代理以及 Javassist 字节码两种方式生成本地代理类。</p>
</li>
<li data-nodeid="7566">
<p data-nodeid="7567">support 包：包括了 RpcUtils 工具类、Mock 相关的 Protocol 实现以及 Invoker 实现。</p>
</li>
</ul>
<p data-nodeid="7568">没有在上述 package 中的接口和类，是更为核心的抽象接口，上述 package 内的类更多的是这些接口的实现类。下面我们就来介绍这些在 org.apache.dubbo.rpc 包下的核心接口。</p>
<h3 data-nodeid="7569">核心接口</h3>
<p data-nodeid="7570">在 Dubbo RPC 层中涉及的核心接口有 Invoker、Invocation、Protocol、Result、Exporter、ProtocolServer、Filter 等，这些接口分别抽象了 Dubbo RPC 层的不同概念，看似相互独立，但又相互协同，一起构建出了 DubboRPC 层的骨架。下面我们将逐一介绍这些核心接口的含义。</p>
<p data-nodeid="7571">首先要介绍的是 Dubbo 中非常重要的一个接口——<strong data-nodeid="7649">Invoker 接口</strong>。可以说，Invoker 渗透在整个 Dubbo 代码实现里，Dubbo 中的很多设计思路都会向 Invoker 这个概念靠拢，但这对于刚接触这部分代码的同学们来说，可能不是很友好。</p>
<p data-nodeid="7572">这里我们借助如下这样一个精简的示意图来对比说明两种最关键的 Invoker：服务提供 Invoker 和服务消费 Invoker。</p>
<p data-nodeid="7573"><img src="https://s0.lgstatic.com/i/image/M00/5D/D2/Ciqc1F-FWQuAb1ypAAC0qPg0sWQ701.png" alt="Lark20201013-153553.png" data-nodeid="7653"></p>
<div data-nodeid="7574"><p style="text-align:center">Invoker 核心示意图</p></div>
<p data-nodeid="7575">以 dubbo-demo-annotation-consumer 这个示例项目中的 Consumer 为例，它会拿到一个 DemoService 对象，如下所示，这其实是一个代理（即上图中的 Proxy），这个 Proxy 底层就会通过 Invoker 完成网络调用：</p>
<pre class="lang-java" data-nodeid="7576"><code data-language="java"><span class="hljs-meta">@Component("demoServiceComponent")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceComponent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>{
&nbsp; &nbsp; <span class="hljs-meta">@Reference</span>
&nbsp; &nbsp; <span class="hljs-keyword">private</span> DemoService demoService;
&nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> demoService.sayHello(name);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="7577">紧接着我们再来看一个 dubbo-demo-annotation-provider 示例中的 Provider 实现：</p>
<pre class="lang-java" data-nodeid="7578"><code data-language="java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DemoService</span> </span>{
&nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello "</span> + name + <span class="hljs-string">", response from provider: "</span> + RpcContext.getContext().getLocalAddress();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="7716" class="">这里的 DemoServiceImpl 类会被封装成为一个 AbstractProxyInvoker 实例，并新生成对应的 Exporter 实例。当 Dubbo Protocol 层收到一个请求之后，会找到这个 Exporter 实例，并调用其对应的 AbstractProxyInvoker 实例，从而完成 Provider 逻辑的调用。这里我先帮你找出了最重要的两类 Invoker ，简单介绍了它们工作场景，当然 Dubbo 中还有其他类型的 Invoker，后面我们再一一介绍。</p>

<p data-nodeid="7580">下面来看 Invoker 这个接口的具体定义，如下所示：</p>
<pre class="lang-java" data-nodeid="7581"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Invoker</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 服务接口</span>
&nbsp; &nbsp; <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getInterface</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 进行一次调用，也有人称之为一次"会话"，你可以理解为一次调用</span>
&nbsp; &nbsp; <span class="hljs-function">Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
}
</code></pre>
<p data-nodeid="7582"><strong data-nodeid="7662">Invocation 接口</strong>是 Invoker.invoke() 方法的参数，抽象了一次 RPC 调用的目标服务和方法信息、相关参数信息、具体的参数值以及一些附加信息，具体定义如下：</p>
<pre class="lang-java" data-nodeid="7583"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Invocation</span> </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 调用Service的唯一标识</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getTargetServiceUniqueName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 调用的方法名称</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getMethodName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">//&nbsp;调用的服务名称</span>
&nbsp; &nbsp; <span class="hljs-function">String <span class="hljs-title">getServiceName</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 参数类型集合</span>
&nbsp; &nbsp; Class&lt;?&gt;[] getParameterTypes();
    <span class="hljs-comment">// 参数签名集合</span>
&nbsp; &nbsp; <span class="hljs-keyword">default</span> String[] getCompatibleParamSignatures() {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> Stream.of(getParameterTypes())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(Class::getName)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .toArray(String[]::<span class="hljs-keyword">new</span>);
&nbsp; &nbsp; }
    <span class="hljs-comment">// 此次调用具体的参数值</span>
&nbsp; &nbsp; Object[] getArguments();
&nbsp; &nbsp; <span class="hljs-comment">// 此次调用关联的Invoker对象</span>
&nbsp; &nbsp; Invoker&lt;?&gt; getInvoker();
    <span class="hljs-comment">// Invoker对象可以设置一些KV属性，这些属性并不会传递给Provider</span>
&nbsp; &nbsp; <span class="hljs-function">Object <span class="hljs-title">put</span><span class="hljs-params">(Object key, Object value)</span></span>;
&nbsp; &nbsp; <span class="hljs-function">Object <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span></span>;
&nbsp; &nbsp; <span class="hljs-function">Map&lt;Object, Object&gt; <span class="hljs-title">getAttributes</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// Invocation可以携带一个KV信息作为附加信息，一并传递给Provider，</span>
    <span class="hljs-comment">// 注意与 attribute 的区分</span>
    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getAttachments</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getObjectAttachments</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachment</span><span class="hljs-params">(String key, String value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachment</span><span class="hljs-params">(String key, Object value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setObjectAttachment</span><span class="hljs-params">(String key, Object value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachmentIfAbsent</span><span class="hljs-params">(String key, String value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachmentIfAbsent</span><span class="hljs-params">(String key, Object value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setObjectAttachmentIfAbsent</span><span class="hljs-params">(String key, Object value)</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getAttachment</span><span class="hljs-params">(String key)</span></span>;
    <span class="hljs-function">Object <span class="hljs-title">getObjectAttachment</span><span class="hljs-params">(String key)</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getAttachment</span><span class="hljs-params">(String key, String defaultValue)</span></span>;
    <span class="hljs-function">Object <span class="hljs-title">getObjectAttachment</span><span class="hljs-params">(String key, Object defaultValue)</span></span>;
}
</code></pre>
<p data-nodeid="7584"><strong data-nodeid="7667">Result 接口</strong>是 Invoker.invoke() 方法的返回值，抽象了一次调用的返回值，其中包含了被调用方返回值（或是异常）以及附加信息，我们也可以添加回调方法，在 RPC 调用方法结束时会触发这些回调。Result 接口的具体定义如下：</p>
<pre class="lang-java" data-nodeid="7585"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Result</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Serializable</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取/设置此次调用的返回值</span>
&nbsp; &nbsp; <span class="hljs-function">Object <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(Object value)</span></span>;
    <span class="hljs-comment">// 如果此次调用发生异常，则可以通过下面三个方法获取</span>
&nbsp; &nbsp; <span class="hljs-function">Throwable <span class="hljs-title">getException</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setException</span><span class="hljs-params">(Throwable t)</span></span>;
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasException</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// recreate()方法是一个复合操作，如果此次调用发生异常，则直接抛出异常，</span>
    <span class="hljs-comment">// 如果没有异常，则返回结果</span>
&nbsp; &nbsp; <span class="hljs-function">Object <span class="hljs-title">recreate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable</span>;
    <span class="hljs-comment">// 添加一个回调，当RPC调用完成时，会触发这里添加的回调</span>
&nbsp;&nbsp; &nbsp;<span class="hljs-function">Result <span class="hljs-title">whenCompleteWithContext</span><span class="hljs-params">(BiConsumer&lt;Result, Throwable&gt; fn)</span></span>;
&nbsp; &nbsp; &lt;U&gt; <span class="hljs-function">CompletableFuture&lt;U&gt; <span class="hljs-title">thenApply</span><span class="hljs-params">(Function&lt;Result, ? extends U&gt; fn)</span></span>;
    <span class="hljs-comment">// 阻塞线程，等待此次RPC调用完成(或是超时)</span>
&nbsp; &nbsp; <span class="hljs-function">Result <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException</span>;
&nbsp; &nbsp; <span class="hljs-function">Result <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;
    <span class="hljs-comment">// Result中同样可以携带附加信息</span>
    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getAttachments</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">Map&lt;String, Object&gt; <span class="hljs-title">getObjectAttachments</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAttachments</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addObjectAttachments</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachments</span><span class="hljs-params">(Map&lt;String, String&gt; map)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setObjectAttachments</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getAttachment</span><span class="hljs-params">(String key)</span></span>;
    <span class="hljs-function">Object <span class="hljs-title">getObjectAttachment</span><span class="hljs-params">(String key)</span></span>;
    <span class="hljs-function">String <span class="hljs-title">getAttachment</span><span class="hljs-params">(String key, String defaultValue)</span></span>;
    <span class="hljs-function">Object <span class="hljs-title">getObjectAttachment</span><span class="hljs-params">(String key, Object defaultValue)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachment</span><span class="hljs-params">(String key, String value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setAttachment</span><span class="hljs-params">(String key, Object value)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setObjectAttachment</span><span class="hljs-params">(String key, Object valu
}
</span></span></code></pre>
<p data-nodeid="7586">在上面介绍 Provider 端的 Invoker 时提到，我们的业务接口实现会被包装成一个 AbstractProxyInvoker 对象，然后由 Exporter 暴露出去，让 Consumer 可以调用到该服务。Exporter 暴露 Invoker 的实现，说白了，就是让 Provider 能够根据请求的各种信息，找到对应的 Invoker。我们可以维护一个 Map，其中 Key 可以根据请求中的信息构建，Value 为封装相应服务 Bean 的 Exporter 对象，这样就可以实现上述服务发布的要求了。</p>
<p data-nodeid="7587">我们先来看 <strong data-nodeid="7674">Exporter 接口</strong>的定义：</p>
<pre class="lang-java" data-nodeid="7588"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Exporter</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-comment">// 获取底层封装的Invoker对象</span>
&nbsp; &nbsp; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 取消发布底层的Invoker对象</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unexport</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="7589">为了监听服务发布事件以及取消暴露事件，Dubbo 定义了一个 SPI 扩展接口——<strong data-nodeid="7680">ExporterListener 接口</strong>，其定义如下：</p>
<pre class="lang-java" data-nodeid="7590"><code data-language="java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExporterListener</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 当有服务发布的时候，会触发该方法</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">exported</span><span class="hljs-params">(Exporter&lt;?&gt; exporter)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 当有服务取消发布的时候，会触发该方法</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unexported</span><span class="hljs-params">(Exporter&lt;?&gt; exporter)</span></span>;
}
</code></pre>
<p data-nodeid="7591">虽然 ExporterListener 是个扩展接口，但是 Dubbo 本身并没有提供什么有用的扩展实现，我们需要自己提供具体实现监听感兴趣的事情。</p>
<p data-nodeid="7592">相应地，我们可以添加 InvokerListener 监听器，监听 Consumer 引用服务时触发的事件，<strong data-nodeid="7687">InvokerListener 接口</strong>的定义如下：</p>
<pre class="lang-java" data-nodeid="7593"><code data-language="java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvokerListener</span> </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 当服务引用的时候，会触发该方法</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">referred</span><span class="hljs-params">(Invoker&lt;?&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 当销毁引用的服务时，会触发该方法</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroyed</span><span class="hljs-params">(Invoker&lt;?&gt; invoker)</span></span>;
}
</code></pre>
<p data-nodeid="7594"><strong data-nodeid="7692">Protocol 接口</strong>是整个 Dubbo Protocol 层的核心接口之一，其中定义了 export() 和 refer() 两个核心方法，具体定义如下：</p>
<pre class="lang-java" data-nodeid="7595"><code data-language="java"><span class="hljs-meta">@SPI("dubbo")</span> <span class="hljs-comment">// 默认使用DubboProtocol实现</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Protocol</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 默认端口</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDefaultPort</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 将一个Invoker暴露出去，export()方法实现需要是幂等的，</span>
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">//&nbsp;即同一个服务暴露多次和暴露一次的效果是相同的</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 引用一个Invoker，refer()方法会根据参数返回一个Invoker对象，</span>
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Consumer端可以通过这个Invoker请求到Provider端的服务</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">refer</span><span class="hljs-params">(Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 销毁export()方法以及refer()方法使用到的Invoker对象，释放</span>
    <span class="hljs-comment">// 当前Protocol对象底层占用的资源</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 返回当前Protocol底层的全部ProtocolServer</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">default</span> List&lt;ProtocolServer&gt; <span class="hljs-title">getServers</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> Collections.emptyList();
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="7596">在 Protocol 接口的实现中，export() 方法并不是简单地将 Invoker 对象包装成 Exporter 对象返回，其中还涉及代理对象的创建、底层 Server 的启动等操作；refer() 方法除了根据传入的 type 类型以及 URL 参数查询 Invoker 之外，还涉及相关 Client 的创建等操作。</p>
<p data-nodeid="8060" class="">Dubbo 在 Protocol 层专门定义了一个 <strong data-nodeid="8066">ProxyFactory 接口</strong>，作为创建代理对象的工厂。ProxyFactory 接口是一个扩展接口，其中定义了 getProxy() 方法为 Invoker 创建代理对象，还定义了 getInvoker() 方法将代理对象反向封装成 Invoker 对象。</p>

<pre class="lang-java" data-nodeid="7598"><code data-language="java"><span class="hljs-meta">@SPI("javassist")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProxyFactory</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 为传入的Invoker对象创建代理对象</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker, <span class="hljs-keyword">boolean</span> generic)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 将传入的代理对象封装成Invoker对象，可以暂时理解为getProxy()的逆操作</span>
&nbsp; &nbsp; <span class="hljs-meta">@Adaptive({PROXY_KEY})</span>
&nbsp; &nbsp; &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
}
</code></pre>
<p data-nodeid="8409" class="">看到 ProxyFactory 上的 @SPI 注解，我们知道其默认实现使用 javassist 来创建代码对象，当然，Dubbo 还提供了其他方式来创建代码，例如 JDK 动态代理。</p>

<p data-nodeid="7600"><strong data-nodeid="7705">ProtocolServer 接口</strong>是对前文介绍的 RemotingServer 的一层简单封装，其实现也都非常简单，这里就不再展开。</p>
<p data-nodeid="8753" class="">最后一个要介绍的核心接口是 <strong data-nodeid="8759">Filter 接口</strong>。关于 Filter，相信做过 Java Web 编程的同学们会非常熟悉这个基础概念，Java Web 开发中的 Filter 是用来拦截 HTTP 请求的，Dubbo 中的 Filter 接口功能与之类似，是用来拦截 Dubbo 请求的。</p>

<p data-nodeid="9102" class="">在 Dubbo 的 Filter 接口中，定义了一个 invoke() 方法将请求传递给后续的 Invoker 进行处理（后续的这个 Invoker 对象可能是一个 Filter 封装而成的）。Filter 接口的具体定义如下：</p>

<pre class="lang-java" data-nodeid="7603"><code data-language="java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filter</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 将请求传给后续的Invoker进行处理</span>
&nbsp; &nbsp; <span class="hljs-function">Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Listener</span> </span>{ <span class="hljs-comment">// 用于监听响应以及异常</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Result appResponse, Invoker&lt;?&gt; invoker, Invocation invocation)</span></span>;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable t, Invoker&lt;?&gt; invoker, Invocation invocation)</span></span>;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="7604">Filter 也是一个扩展接口，Dubbo 提供了丰富的 Filter 实现来进行功能扩展，当然我们也可以提供自己的 Filter 实现来扩展 Dubbo 的功能。</p>
<h3 data-nodeid="7605">总结</h3>
<p data-nodeid="7606" class="">本课时我们首先介绍了 Dubbo RPC 层在整个 Dubbo 框架中所处的位置，然后说明了 dubbo-rpc-api 层的结构以及其中各个包提供的基本功能。接下来，我们还详细介绍了 Dubbo RPC 层中涉及的核心接口，包括 Invoker、Invocation、Protocol、Result、ProxyFactory、ProtocolServer 等核心接口，以及 ExporterListener、Filter 等扩展类的接口。</p>

---

### 精选评论


