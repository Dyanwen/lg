<p data-nodeid="55375">在课程第二部分（13~15 课时）中介绍 Dubbo 传统框架中的注册中心部分实现时，我们提到了 Registry、RegistryFactory 等与注册中心交互的接口。<strong data-nodeid="55383">为了将 ServiceDiscovery 接口的功能与 Registry 融合，Dubbo 提供了一个 ServiceDiscoveryRegistry 实现</strong>，继承关系如下所示：</p>





<p data-nodeid="56667" class=""><img src="https://s0.lgstatic.com/i/image/M00/8C/35/Ciqc1F_pe3KAQs8SAAPkHLoWbUM655.png" alt="Drawing 0.png" data-nodeid="56671"></p>
<div data-nodeid="56668"><p style="text-align:center">ServiceDiscoveryRegistry 、ServiceDiscoveryRegistryFactory 继承关系图</p></div>



<p data-nodeid="54370">由图我们可以看到：ServiceDiscoveryRegistryFactory（扩展名称是 service-discovery-registry）是 ServiceDiscoveryRegistry 对应的工厂类，继承了 AbstractRegistryFactory 提供的公共能力。</p>
<p data-nodeid="54371"><strong data-nodeid="54533">ServiceDiscoveryRegistry 是一个面向服务实例（ServiceInstance）的注册中心实现</strong>，其底层依赖前面两个课时介绍的 ServiceDiscovery、WritableMetadataService 等组件。</p>
<p data-nodeid="54372">ServiceDiscoveryRegistry 中的核心字段有如下几个。</p>
<ul data-nodeid="54373">
<li data-nodeid="54374">
<p data-nodeid="54375">serviceDiscovery（ServiceDiscovery 类型）：用于 ServiceInstance 的发布和订阅。</p>
</li>
<li data-nodeid="54376">
<p data-nodeid="54377">subscribedServices（Set<string> 类型）：记录了当前订阅的服务名称。</string></p>
</li>
<li data-nodeid="54378">
<p data-nodeid="54379">serviceNameMapping（ServiceNameMapping 类型）：用于 Service ID 与 Service Name 之间的转换。</p>
</li>
<li data-nodeid="54380">
<p data-nodeid="54381">writableMetadataService（WritableMetadataService 类型）：用于发布和查询元数据。</p>
</li>
<li data-nodeid="54382">
<p data-nodeid="54383">registeredListeners（Set<string> 类型）：记录了注册的 ServiceInstancesChangedListener 的唯一标识。</string></p>
</li>
<li data-nodeid="54384">
<p data-nodeid="54385">subscribedURLsSynthesizers（List<subscribedurlssynthesizer> 类型）：将 ServiceInstance 的信息与元数据进行合并，得到订阅服务的完整 URL。</subscribedurlssynthesizer></p>
</li>
</ul>
<p data-nodeid="54386">在 ServiceDiscoveryRegistry 的构造方法中，会初始化上述字段：</p>
<pre class="lang-java" data-nodeid="54387"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceDiscoveryRegistry</span><span class="hljs-params">(URL registryURL)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 初始化父类，其中包括FailbackRegistry中的时间轮和重试定时任务以及AbstractRegistry中的本地文件缓存等</span>
&nbsp; &nbsp; <span class="hljs-keyword">super</span>(registryURL);
&nbsp; &nbsp; <span class="hljs-comment">// 初始化ServiceDiscovery对象</span>
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.serviceDiscovery = createServiceDiscovery(registryURL);
&nbsp; &nbsp; <span class="hljs-comment">// 从registryURL中解析出subscribed-services参数，并按照逗号切分，得到subscribedServices集合</span>
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.subscribedServices = parseServices(registryURL.getParameter(SUBSCRIBED_SERVICE_NAMES_KEY));
&nbsp; &nbsp; <span class="hljs-comment">// 获取DefaultServiceNameMapping对象</span>
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.serviceNameMapping = ServiceNameMapping.getDefaultExtension();
&nbsp; &nbsp; <span class="hljs-comment">// 初始化WritableMetadataService对象</span>
&nbsp; &nbsp; String metadataStorageType = getMetadataStorageType(registryURL);
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.writableMetadataService = WritableMetadataService.getExtension(metadataStorageType);
&nbsp; &nbsp; <span class="hljs-comment">// 获取目前支持的全部SubscribedURLsSynthesizer实现，并初始化</span>
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.subscribedURLsSynthesizers = initSubscribedURLsSynthesizers();
}
</code></pre>
<p data-nodeid="54388">在 createServiceDiscovery() 方法中，不仅会加载 ServiceDiscovery 的相应实现，还会在外层添加 EventPublishingServiceDiscovery 装饰器，在 register()、initialize() 等方法前后触发相应的事件，具体实现如下：</p>
<pre class="lang-java" data-nodeid="54389"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ServiceDiscovery <span class="hljs-title">createServiceDiscovery</span><span class="hljs-params">(URL registryURL)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 根据registryURL获取对应的ServiceDiscovery实现</span>
&nbsp; &nbsp; ServiceDiscovery originalServiceDiscovery = getServiceDiscovery(registryURL);
&nbsp; &nbsp; <span class="hljs-comment">// ServiceDiscovery外层添加一层EventPublishingServiceDiscovery修饰器，</span>
&nbsp; &nbsp; <span class="hljs-comment">// EventPublishingServiceDiscovery会在register()、initialize()等方法前后触发相应的事件，</span>
&nbsp; &nbsp; <span class="hljs-comment">// 例如，在register()方法的前后分别会触发ServiceInstancePreRegisteredEvent和ServiceInstanceRegisteredEvent</span>
&nbsp; &nbsp; ServiceDiscovery serviceDiscovery = enhanceEventPublishing(originalServiceDiscovery);
&nbsp; &nbsp; execute(() -&gt; { <span class="hljs-comment">// 初始化ServiceDiscovery</span>
&nbsp; &nbsp; &nbsp; &nbsp; serviceDiscovery.initialize(registryURL.addParameter(INTERFACE_KEY, ServiceDiscovery.class.getName())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .removeParameter(REGISTRY_TYPE_KEY));
&nbsp; &nbsp; });
&nbsp; &nbsp; <span class="hljs-keyword">return</span> serviceDiscovery;
}
</code></pre>
<p data-nodeid="54390">Registry 接口的核心是服务发布和订阅，ServiceDiscoveryRegistry 既然实现了 Registry 接口，必然也要实现了服务注册和发布的功能。</p>
<h3 data-nodeid="54391">服务注册</h3>
<p data-nodeid="54392">在 ServiceDiscoveryRegistry 的 register() 中，首先会检测待发布 URL 中的 side 参数，然后调用父类的 register() 方法。我们知道 FailbackRegistry.register() 方法会回调子类的 doRegister() 方法，而 ServiceDiscoveryRegistry.doRegister() 方法直接依赖 WritableMetadataService 的 exportURL() 方法，完成元数据的发布。</p>
<pre class="lang-java" data-nodeid="54393"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!shouldRegister(url)) { <span class="hljs-comment">// 检测URL中的side参数是否为provider</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">super</span>.register(url);
}

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">(URL url)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 将元数据发布到MetadataService</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (writableMetadataService.exportURL(url)) {
&nbsp; &nbsp; &nbsp; &nbsp; ... <span class="hljs-comment">// 输出INFO日志</span>
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; ... <span class="hljs-comment">// 输出WARN日志</span>
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="54394">ServiceDiscoveryRegistry.unregister() 方法的实现逻辑也是类似的，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/dubbo" data-nodeid="54555">源码</a>进行学习。</p>
<h3 data-nodeid="54395">服务订阅</h3>
<p data-nodeid="54396">接下来看 ServiceDiscoveryRegistry.subscribe() 方法的实现，其中也是首先会检测待发布 URL 中的 side 参数，然后调用父类的 subscribe() 方法。我们知道 FailbackRegistry.subscribe() 方法会回调子类的 doSubscribe() 方法。在 ServiceDiscoveryRegistry 的 doSubscribe() 方法中，会执行如下完整的订阅流程：</p>
<ol data-nodeid="54397">
<li data-nodeid="54398">
<p data-nodeid="54399">调用 WriteMetadataService.subscribeURL() 方法在 subscribedServiceURLs 集合中记录当前订阅的 URL；</p>
</li>
<li data-nodeid="54400">
<p data-nodeid="54401">通过订阅的 URL 获取 Service Name；</p>
</li>
<li data-nodeid="54402">
<p data-nodeid="54403">根据 Service Name 获取 ServiceInstance 集合；</p>
</li>
<li data-nodeid="54404">
<p data-nodeid="54405">根据 ServiceInstance 调用相应的 MetadataService 服务，获取元数据，其中涉及历史数据的清理和缓存更新等操作；</p>
</li>
<li data-nodeid="54406">
<p data-nodeid="54407">将 ServiceInstance 信息以及对应的元数据信息进行合并，得到完整的 URL；</p>
</li>
<li data-nodeid="54408">
<p data-nodeid="54409">触发 NotifyListener 监听器；</p>
</li>
<li data-nodeid="54410">
<p data-nodeid="54411">添加 ServiceInstancesChangedListener 监听器。</p>
</li>
</ol>
<p data-nodeid="54412">下面来看 ServiceDiscoveryRegistry.doSubscribe() 方法的具体实现：</p>
<pre class="lang-java" data-nodeid="54413"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeURLs</span><span class="hljs-params">(URL url, NotifyListener listener)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 记录该订阅的URL</span>
&nbsp; &nbsp; writableMetadataService.subscribeURL(url);
&nbsp; &nbsp; <span class="hljs-comment">// 获取订阅的Service Name</span>
&nbsp; &nbsp; Set&lt;String&gt; serviceNames = getServices(url);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(serviceNames)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"..."</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 执行后续的订阅操作</span>
&nbsp; &nbsp; serviceNames.forEach(serviceName -&gt; subscribeURLs(url, listener, serviceName));
}
</code></pre>
<p data-nodeid="54414">我们这就展开一步步来解析上面的这个流程。</p>
<h4 data-nodeid="57312" class="">1. 获取 Service Name</h4>

<p data-nodeid="54418">首先来看 getServices() 方法的具体实现：它会首先根据 subscribeURL 的 provided-by 参数值获取订阅的 Service Name 集合，如果获取失败，则根据 Service ID 获取对应的 Service Name 集合；如果此时依旧获取失败，则尝试从 registryURL 中的 subscribed-services 参数值获取 Service Name 集合。下面来看 getServices() 方法的具体实现：</p>
<pre class="lang-java" data-nodeid="54419"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;String&gt; <span class="hljs-title">getServices</span><span class="hljs-params">(URL subscribedURL)</span> </span>{
&nbsp; &nbsp; Set&lt;String&gt; subscribedServices = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();
&nbsp; &nbsp; <span class="hljs-comment">// 首先尝试从subscribeURL中获取provided-by参数值，其中封装了全部Service Name</span>
&nbsp; &nbsp; String serviceNames = subscribedURL.getParameter(PROVIDED_BY);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(serviceNames)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 解析provided-by参数值，得到全部的Service Name集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; subscribedServices = parseServices(serviceNames);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (isEmpty(subscribedServices)) {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果没有指定provided-by参数，则尝试通过subscribedURL构造Service ID，</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 然后通过ServiceNameMapping的get()方法查找Service Name</span>
&nbsp; &nbsp; &nbsp; &nbsp; subscribedServices = findMappedServices(subscribedURL);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (isEmpty(subscribedServices)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果subscribedServices依旧为空，则返回registryURL中的subscribed-services参数值</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subscribedServices = getSubscribedServices();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> subscribedServices;
}
</code></pre>
<h4 data-nodeid="57950" class="">2. 查找 Service Instance</h4>

<p data-nodeid="54423">接下来看 subscribeURLs(url, listener, serviceName) 这个重载的具体实现，其中会根据 Service Name 从 ServiceDiscovery 中查找对应的 ServiceInstance 集合，以及注册ServiceInstancesChangedListener 监听。</p>
<pre class="lang-java" data-nodeid="54424"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeURLs</span><span class="hljs-params">(URL url, NotifyListener listener, String serviceName)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 根据Service Name获取ServiceInstance对象</span>
&nbsp; &nbsp; List&lt;ServiceInstance&gt; serviceInstances = serviceDiscovery.getInstances(serviceName);
&nbsp; &nbsp; <span class="hljs-comment">// 调用另一个subscribeURLs()方法重载</span>
&nbsp; &nbsp; subscribeURLs(url, listener, serviceName, serviceInstances);
&nbsp; &nbsp; <span class="hljs-comment">// 添加ServiceInstancesChangedListener监听器</span>
&nbsp; &nbsp; registerServiceInstancesChangedListener(url, <span class="hljs-keyword">new</span> ServiceInstancesChangedListener(serviceName) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-meta">@Override</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(ServiceInstancesChangedEvent event)</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subscribeURLs(url, listener, event.getServiceName(), <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(event.getServiceInstances()));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; });
}
</code></pre>
<p data-nodeid="54425">在 subscribeURLs(url, listener, serviceName, serviceInstances) 这个重载中，主要是根据前面获取的 ServiceInstance 实例集合，构造对应的、完整的 subscribedURL 集合，并触发传入的 NotifyListener 监听器，如下所示：</p>
<pre class="lang-java" data-nodeid="54426"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subscribeURLs</span><span class="hljs-params">(URL subscribedURL, NotifyListener listener, String serviceName,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Collection&lt;ServiceInstance&gt; serviceInstances)</span> </span>{
&nbsp; &nbsp; List&lt;URL&gt; subscribedURLs = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&nbsp; &nbsp; <span class="hljs-comment">// 尝试通过MetadataService获取subscribedURL集合</span>
&nbsp; &nbsp; subscribedURLs.addAll(getExportedURLs(subscribedURL, serviceInstances));
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (subscribedURLs.isEmpty()) { <span class="hljs-comment">// 如果上面的尝试失败</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 尝试通过SubscribedURLsSynthesizer获取subscribedURL集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; subscribedURLs.addAll(synthesizeSubscribedURLs(subscribedURL, serviceInstances));
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 触发NotifyListener监听器</span>
&nbsp; &nbsp; listener.notify(subscribedURLs);
}
</code></pre>
<p data-nodeid="54427">这里构造完整 subscribedURL 可以分为两个分支。</p>
<ul data-nodeid="54428">
<li data-nodeid="54429">
<p data-nodeid="54430">第一个分支：结合传入的 subscribedURL 以及从元数据中获取每个 ServiceInstance 的对应参数，组装成每个 ServiceInstance 对应的完整 subscribeURL。<strong data-nodeid="54579">该部分实现在 getExportedURLs() 方法中，也是订阅操作的核心</strong>。</p>
</li>
<li data-nodeid="54431">
<p data-nodeid="54432">第二个分支：当上述操作无法获得完整的 subscribeURL 集合时，会使用 SubscribedURLsSynthesizer，基于 subscribedURL 拼凑出每个 ServiceInstance 对应的完整的 subscribedURL。<strong data-nodeid="54585">该部分实现在 synthesizeSubscribedURLs() 方法中，目前主要针对 rest 协议</strong>。</p>
</li>
</ul>
<h4 data-nodeid="58584" class="">3. getExportedURLs() 方法核心实现</h4>

<p data-nodeid="54436">getExportedURLs() 方法主要围绕 serviceRevisionExportedURLsCache 这个集合展开的，它是一个 Map&lt;String, Map&lt;String, List<url>&gt;&gt; 类型的集合，其中第一层 Key 是 Service Name，第二层 Key 是 Revision，最终的 Value 值是 Service Name 对应的最新的 URL 集合。</url></p>
<h5 data-nodeid="59214" class="">（1）清理过期 URL</h5>

<p data-nodeid="54438">在 getExportedURLs() 方法中，首先会调用 expungeStaleRevisionExportedURLs() 方法销毁全部已过期的 URL 信息，具体实现如下：</p>
<pre class="lang-java" data-nodeid="54439"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">expungeStaleRevisionExportedURLs</span><span class="hljs-params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 从第一个ServiceInstance即可获取Service Name</span>
&nbsp; &nbsp; String serviceName = serviceInstances.get(<span class="hljs-number">0</span>).getServiceName();
&nbsp; &nbsp; <span class="hljs-comment">// 获取该Service Name当前在serviceRevisionExportedURLsCache中对应的URL集合</span>
&nbsp; &nbsp; Map&lt;String, List&lt;URL&gt;&gt; revisionExportedURLsMap = serviceRevisionExportedURLsCache
&nbsp; &nbsp; &nbsp; &nbsp; .computeIfAbsent(serviceName, s -&gt; <span class="hljs-keyword">new</span> LinkedHashMap());
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (revisionExportedURLsMap.isEmpty()) { <span class="hljs-comment">// 没有缓存任何URL，则无须后续清理操作，直接返回即可</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取Service Name在serviceRevisionExportedURLsCache中缓存的修订版本</span>
&nbsp; &nbsp; Set&lt;String&gt; existedRevisions = revisionExportedURLsMap.keySet();
&nbsp; &nbsp; <span class="hljs-comment">// 从ServiceInstance中获取当前最新的修订版本</span>
&nbsp; &nbsp; Set&lt;String&gt; currentRevisions = serviceInstances.stream()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(ServiceInstanceMetadataUtils::getExportedServicesRevision)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .collect(Collectors.toSet());
&nbsp; &nbsp; <span class="hljs-comment">// 获取要删除的陈旧修订版本：staleRevisions = existedRevisions(copy) - currentRevisions</span>
&nbsp; &nbsp; Set&lt;String&gt; staleRevisions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(existedRevisions);
&nbsp; &nbsp; staleRevisions.removeAll(currentRevisions);
&nbsp; &nbsp; <span class="hljs-comment">// 从revisionExportedURLsMap中删除staleRevisions集合中所有Key对应的URL集合</span>
&nbsp; &nbsp; staleRevisions.forEach(revisionExportedURLsMap::remove);
}
</code></pre>
<p data-nodeid="54440">我们看到这里是通过 ServiceInstanceMetadataUtils 工具类从每个 ServiceInstance 的 metadata 集合中获取最新的修订版本（Key 为 dubbo.exported-services.revision），那么该修订版本的信息是在哪里写入的呢？我们来看一个新接口—— ServiceInstanceCustomizer，具体定义如下：</p>
<pre class="lang-java" data-nodeid="54441"><code data-language="java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ServiceInstanceCustomizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Prioritized</span> </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ServiceInstance serviceInstance)</span></span>;
}
</code></pre>
<p data-nodeid="54442">关于 ServiceInstanceCustomizer 接口，这里需要关注三个点：①该接口被 @SPI 注解修饰，是一个扩展点；②该接口继承了 Prioritized 接口；③该接口中定义的 customize() 方法可以用来自定义 ServiceInstance 信息，其中就包括控制 metadata 集合中的数据。</p>
<p data-nodeid="54443">也就说，<strong data-nodeid="54603">ServiceInstanceCustomizer 的多个实现可以按序调用，实现 ServiceInstance 的自定义</strong>。下图展示了 ServiceInstanceCustomizer 接口的所有实现类：</p>
<p data-nodeid="60471" class=""><img src="https://s0.lgstatic.com/i/image2/M01/04/1A/CgpVE1_pe6SAT90SAAC2xP9_c7c171.png" alt="Drawing 1.png" data-nodeid="60475"></p>
<div data-nodeid="60472"><p style="text-align:center">ServiceInstanceCustomizer 继承关系图</p></div>



<p data-nodeid="54446">我们首先来看 ServiceInstanceMetadataCustomizer 这个抽象类，它主要是对 ServiceInstance 中 metadata 这个 KV 集合进行自定义修改，这部分逻辑在 customize() 方法中，如下所示：</p>
<pre class="lang-java" data-nodeid="54447"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取ServiceInstance对象的metadata字段</span>
&nbsp; &nbsp; Map&lt;String, String&gt; metadata = serviceInstance.getMetadata();
&nbsp; &nbsp; <span class="hljs-comment">// 生成要添加到metadata集合的KV值</span>
&nbsp; &nbsp; String propertyName = resolveMetadataPropertyName(serviceInstance);
&nbsp; &nbsp; String propertyValue = resolveMetadataPropertyValue(serviceInstance);
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 判断待添加的KV值是否为空</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!isBlank(propertyName) &amp;&amp; !isBlank(propertyValue)) {
&nbsp; &nbsp; &nbsp; &nbsp; String existedValue = metadata.get(propertyName);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">boolean</span> put = existedValue == <span class="hljs-keyword">null</span> || isOverride();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (put) { <span class="hljs-comment">// 是否覆盖原值</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metadata.put(propertyName, propertyValue);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="54448">生成 KV 值的 resolveMetadataPropertyName()、resolveMetadataPropertyValue() 方法以及 isOverride() 方法都是抽象方法，在 ServiceInstanceMetadataCustomizer 子类中实现。</p>
<p data-nodeid="54449">在 ExportedServicesRevisionMetadataCustomizer 这个实现中，resolveMetadataPropertyName() 方法返回 "dubbo.exported-services.revision" 固定字符串，resolveMetadataPropertyValue() 方法会通过 WritableMetadataService 获取当前 ServiceInstance 对象发布的全部 URL，然后计算 revision 值。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54450"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">resolveMetadataPropertyValue</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 从ServiceInstance对象的metadata集合中获取当前ServiceInstance存储元数据的方式（local还是remote）</span>
&nbsp; &nbsp; String metadataStorageType = getMetadataStorageType(serviceInstance);
&nbsp; &nbsp; <span class="hljs-comment">// 获取相应的WritableMetadataService对象，并获取当前ServiceInstance发布的全部元数据</span>
&nbsp; &nbsp; WritableMetadataService writableMetadataService = getExtension(metadataStorageType);
&nbsp; &nbsp; SortedSet&lt;String&gt; exportedURLs = writableMetadataService.getExportedURLs();
&nbsp; &nbsp; <span class="hljs-comment">// 计算整个exportedURLs集合的revision值</span>
&nbsp; &nbsp; URLRevisionResolver resolver = <span class="hljs-keyword">new</span> URLRevisionResolver();
&nbsp; &nbsp; <span class="hljs-keyword">return</span> resolver.resolve(exportedURLs);
}
</code></pre>
<p data-nodeid="54451">这里需要说明下计算 revision 值的核心实现：首先获取每个服务接口的方法签名以及对应 URL 参数集合，然后计算 hashCode 并加和返回，如果通过上述方式没有拿到 revision 值，则返回 "N/A" 占位符字符串。URLRevisionResolver.resolve() 方法的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/dubbo" data-nodeid="54622">源码</a>进行学习。</p>
<p data-nodeid="54452">在 SubscribedServicesRevisionMetadataCustomizer 这个实现中，resolveMetadataPropertyName() 方法返回的是 "dubbo.subscribed-services.revision" 固定字符串，resolveMetadataPropertyValue() 方法会通过 WritableMetadataService 获取当前 ServiceInstance 对象引用的全部 URL，然后计算 revision 值并返回。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54453"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">resolveMetadataPropertyValue</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; String metadataStorageType = getMetadataStorageType(serviceInstance);
&nbsp; &nbsp; WritableMetadataService writableMetadataService = getExtension(metadataStorageType);
&nbsp; &nbsp; <span class="hljs-comment">// 获取subscribedServiceURLs集合</span>
&nbsp; &nbsp; SortedSet&lt;String&gt; subscribedURLs = writableMetadataService.getSubscribedURLs();
&nbsp; &nbsp; URLRevisionResolver resolver = <span class="hljs-keyword">new</span> URLRevisionResolver();
&nbsp; &nbsp; <span class="hljs-comment">// 计算revision值</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> resolver.resolve(subscribedURLs);
}
</code></pre>
<p data-nodeid="54454">在 MetadataServiceURLParamsMetadataCustomizer 这个实现中，resolveMetadataPropertyName() 方法返回 "dubbo.metadata-service.url-params" 固定字符串，resolveMetadataPropertyValue() 方法返回 MetadataService 服务 URL 的参数。</p>
<p data-nodeid="54455">对于 RefreshServiceMetadataCustomizer 这个实现，我们首先关注其执行顺序， 它覆盖了 getPriority() 方法，具体实现如下：</p>
<pre class="lang-java" data-nodeid="54456"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">return</span> MIN_PRIORITY; <span class="hljs-comment">// 执行优先级最低</span>
}
</code></pre>
<p data-nodeid="54457">这就保证了 RefreshServiceMetadataCustomizer 在前面介绍的 ServiceInstanceMetadataCustomizer 实现之后执行（ServiceInstanceMetadataCustomizer 的优先级为 NORMAL_PRIORITY）。</p>
<p data-nodeid="54458">customize() 方法的实现中，RefreshServiceMetadataCustomizer 会分别获取该 ServiceInstance 发布服务的 URL revision 以及引用服务的 URL revision，并更新到元数据中心。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54459"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; String metadataStoredType = getMetadataStorageType(serviceInstance);
&nbsp; &nbsp; WritableMetadataService writableMetadataService = getExtension(metadataStoredType);
&nbsp; &nbsp; <span class="hljs-comment">// 从ServiceInstance.metadata集合中获取两个revision，并调用refreshMetadata()方法进行更新</span>
&nbsp; &nbsp; writableMetadataService.refreshMetadata(getExportedServicesRevision(serviceInstance),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getSubscribedServicesRevision(serviceInstance));
}
</code></pre>
<p data-nodeid="54460">在 WritableMetadataService 接口的实现中，只有 RemoteWritableMetadataService 实现了 refreshMetadata() 方法，其中会判断两个 revision 值是否发生变化，如果发生了变化，则将相应的 URL 集合更新到元数据中心。如下所示：</p>
<pre class="lang-java" data-nodeid="54461"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">refreshMetadata</span><span class="hljs-params">(String exportedRevision, String subscribedRevision)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 比较当前ServiceInstance的exportedRevision是否发生变化</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(exportedRevision) &amp;&amp; !exportedRevision.equals(<span class="hljs-keyword">this</span>.exportedRevision)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 发生变化的话，会更新exportedRevision字段，同时将exportedServiceURLs集合中的URL更新到元数据中心</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.exportedRevision = exportedRevision;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">boolean</span> executeResult = saveServiceMetadata();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!executeResult) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="hljs-keyword">false</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 比较当前ServiceInstance的subscribedRevision是否发生变化&nbsp;</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(subscribedRevision) &amp;&amp; !subscribedRevision.equals(<span class="hljs-keyword">this</span>.subscribedRevision)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; CollectionUtils.isNotEmpty(writableMetadataService.getSubscribedURLs())) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 发生变化的话，会更新subscribedRevision字段，同时将subscribedServiceURLs集合中的URL更新到元数据中心</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.subscribedRevision = subscribedRevision;
&nbsp; &nbsp; &nbsp; &nbsp; SubscriberMetadataIdentifier metadataIdentifier = <span class="hljs-keyword">new</span> SubscriberMetadataIdentifier();
&nbsp; &nbsp; &nbsp; &nbsp; metadataIdentifier.setApplication(serviceName());
&nbsp; &nbsp; &nbsp; &nbsp; metadataIdentifier.setRevision(subscribedRevision);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">boolean</span> executeResult = throwableAction(getMetadataReport()::saveSubscribedData, metadataIdentifier,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writableMetadataService.getSubscribedURLs());
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!executeResult) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="hljs-keyword">false</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p data-nodeid="54462">在 EventListener 接口的实现中有一个名为 CustomizableServiceInstanceListener 的实现，它会监听 ServiceInstancePreRegisteredEvent，在其 onEvent() 方法中，加载全部 ServiceInstanceCustomizer 实现，并调用全部 customize() 方法完成 ServiceInstance 的自定义。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54463"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(ServiceInstancePreRegisteredEvent event)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 加载全部ServiceInstanceCustomizer实现</span>
&nbsp; &nbsp; ExtensionLoader&lt;ServiceInstanceCustomizer&gt; loader =
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExtensionLoader.getExtensionLoader(ServiceInstanceCustomizer.class);
&nbsp; &nbsp; // 按序实现ServiceInstance自定义
&nbsp; &nbsp; loader.getSupportedExtensionInstances().forEach(customizer -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; customizer.customize(event.getServiceInstance());
&nbsp; &nbsp; });
}
</code></pre>
<h5 data-nodeid="61102" class="">（2）更新 Revision 缓存</h5>

<p data-nodeid="54465">介绍完 ServiceInstanceMetadataCustomizer 的内容之后，下面我们回到 ServiceDiscoveryRegistry 继续分析。</p>
<p data-nodeid="54466">在清理完过期的修订版本 URL 之后，接下来会<strong data-nodeid="54648">检测所有 ServiceInstance 的 revision 值是否已经存在于 serviceRevisionExportedURLsCache 缓存中</strong>，如果某个 ServiceInstance 的 revision 值没有在该缓存中，则会调用该 ServiceInstance 发布的 MetadataService 接口进行查询，这部分逻辑在 initializeRevisionExportedURLs() 方法中实现。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54467"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;URL&gt; <span class="hljs-title">initializeRevisionExportedURLs</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (serviceInstance == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 判空</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> emptyList();
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 获取Service Name</span>
&nbsp; &nbsp; String serviceName = serviceInstance.getServiceName();
&nbsp; &nbsp; <span class="hljs-comment">// 获取该ServiceInstance.metadata中携带的revision值</span>
&nbsp; &nbsp; String revision = getExportedServicesRevision(serviceInstance);
&nbsp; &nbsp; <span class="hljs-comment">// 从serviceRevisionExportedURLsCache集合中获取该revision值对应的URL集合</span>
&nbsp; &nbsp; Map&lt;String, List&lt;URL&gt;&gt; revisionExportedURLsMap = getRevisionExportedURLsMap(serviceName);
&nbsp; &nbsp; List&lt;URL&gt; revisionExportedURLs = revisionExportedURLsMap.get(revision);

&nbsp; &nbsp; <span class="hljs-keyword">if</span> (revisionExportedURLs == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// serviceRevisionExportedURLsCache缓存没有命中&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 调用该ServiceInstance对应的MetadataService服务，获取其发布的URL集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; revisionExportedURLs = getExportedURLs(serviceInstance);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (revisionExportedURLs != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 调用MetadataService服务成功之后，更新到serviceRevisionExportedURLsCache缓存中</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revisionExportedURLsMap.put(revision, revisionExportedURLs);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 命中serviceRevisionExportedURLsCache缓存</span>
&nbsp; &nbsp; &nbsp; &nbsp; ... <span class="hljs-comment">// 打印日志</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> revisionExportedURLs;
}
</code></pre>
<h5 data-nodeid="61730" class="">（3）请求 MetadataService 服务</h5>

<p data-nodeid="54469">这里我们可以看到，请求某个 ServiceInstance 的 MetadataService 接口的实现是在 getExportedURLs() 方法中实现的，与我们前面整个课程介绍的请求普通业务接口的原理类似。具体实现如下：</p>
<pre class="lang-java" data-nodeid="54470"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;URL&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(ServiceInstance providerServiceInstance)</span> </span>{
&nbsp; &nbsp; List&lt;URL&gt; exportedURLs = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 获取指定ServiceInstance实例存储元数据的类型</span>
&nbsp; &nbsp; String metadataStorageType = getMetadataStorageType(providerServiceInstance);
&nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 创建MetadataService接口的本地代理</span>
&nbsp; &nbsp; &nbsp; &nbsp; MetadataService metadataService = MetadataServiceProxyFactory.getExtension(metadataStorageType)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .getProxy(providerServiceInstance);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (metadataService != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 通过本地代理，请求该ServiceInstance的MetadataService服务</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortedSet&lt;String&gt; urls = metadataService.getExportedURLs();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exportedURLs = toURLs(urls);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Throwable e) {
&nbsp; &nbsp; &nbsp; &nbsp; exportedURLs = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 置空exportedURLs</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> exportedURLs;
}
</code></pre>
<p data-nodeid="54471">这里涉及一个新的接口——<strong data-nodeid="54656">MetadataServiceProxyFactory，它是用来创建 MetadataService 本地代理的工厂类</strong>，继承关系如下所示：</p>
<p data-nodeid="62983" class=""><img src="https://s0.lgstatic.com/i/image2/M01/04/1A/CgpVE1_pe72AFUTPAADh6TOy_Ak061.png" alt="Drawing 2.png" data-nodeid="62987"></p>
<div data-nodeid="62984"><p style="text-align:center">MetadataServiceProxyFactory 继承关系图</p></div>



<p data-nodeid="54474">在 BaseMetadataServiceProxyFactory 中提供了缓存 MetadataService 本地代理的公共功能，其中维护了一个 proxies 集合（HashMap&lt;String, MetadataService&gt; 类型），Key 是 Service Name 与一个 ServiceInstance 的 revision 值的组合，Value 是该 ServiceInstance 对应的 MetadataService 服务的本地代理对象。创建 MetadataService 本地代理的功能是在 createProxy() 抽象方法中实现的，这个方法由 BaseMetadataServiceProxyFactory 的子类具体实现。</p>
<p data-nodeid="54475"><strong data-nodeid="54667">下面来看 BaseMetadataServiceProxyFactory 的两个实现——DefaultMetadataServiceProxyFactory 和 RemoteMetadataServiceProxyFactory。</strong></p>
<p data-nodeid="54476">DefaultMetadataServiceProxyFactory 在其 createProxy() 方法中，会先通过 MetadataServiceURLBuilder 获取 MetadataService 接口的 URL，然后通过 Protocol 接口引用指定 ServiceInstance 发布的 MetadataService 服务，得到对应的 Invoker 对象，最后通过 ProxyFactory 在 Invoker 对象的基础上创建 MetadataService 本地代理。</p>
<pre class="lang-java" data-nodeid="54477"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">protected</span> MetadataService <span class="hljs-title">createProxy</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; MetadataServiceURLBuilder builder = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; ExtensionLoader&lt;MetadataServiceURLBuilder&gt; loader
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = ExtensionLoader.getExtensionLoader(MetadataServiceURLBuilder.class);
&nbsp; &nbsp; Map&lt;String, String&gt; metadata = serviceInstance.getMetadata();
&nbsp; &nbsp; // 在使用Spring Cloud的时候，metadata集合中会包含METADATA_SERVICE_URLS_PROPERTY_NAME整个Key
&nbsp; &nbsp; String dubboURLsJSON = metadata.get(METADATA_SERVICE_URLS_PROPERTY_NAME);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(dubboURLsJSON)) {
&nbsp; &nbsp; &nbsp; &nbsp; builder = loader.getExtension(SpringCloudMetadataServiceURLBuilder.NAME);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; builder = loader.getExtension(StandardMetadataServiceURLBuilder.NAME);
&nbsp; &nbsp; }
    <span class="hljs-comment">// 构造MetadataService服务对应的URL集合</span>
&nbsp; &nbsp; List&lt;URL&gt; urls = builder.build(serviceInstance); 
&nbsp; &nbsp; <span class="hljs-comment">// 引用服务，创建Invoker，注意，即使MetadataService接口使用了多种协议，这里也只会使用第一种协议</span>
&nbsp; &nbsp; Invoker&lt;MetadataService&gt; invoker = protocol.refer(MetadataService.class, urls.get(<span class="hljs-number">0</span>));
&nbsp; &nbsp; <span class="hljs-comment">// 创建MetadataService的本地代理对象</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> proxyFactory.getProxy(invoker);
}
</code></pre>
<p data-nodeid="54478">这里我们来看 MetadataServiceURLBuilder 接口中创建 MetadataService 服务对应的 URL 的逻辑，下图展示了 MetadataServiceURLBuilder 接口的实现：</p>
<p data-nodeid="64235" class=""><img src="https://s0.lgstatic.com/i/image/M00/8C/35/Ciqc1F_pe8eARHUJAACyQ5kof-I149.png" alt="Drawing 3.png" data-nodeid="64239"></p>
<div data-nodeid="64236"><p style="text-align:center">MetadataServiceURLBuilder 继承关系图</p></div>



<p data-nodeid="54481">其中，SpringCloudMetadataServiceURLBuilder 是兼容 Spring Cloud 的实现，这里就不深入分析了。我们重点来看 StandardMetadataServiceURLBuilder 的实现，其中会根据 ServiceInstance.metadata 携带的 URL 参数、Service Name、ServiceInstance 的 host 等信息构造 MetadataService 服务对应 URL，如下所示：</p>
<pre class="lang-java" data-nodeid="54482"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;URL&gt; <span class="hljs-title">build</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 从metadata集合中获取"dubbo.metadata-service.url-params"这个Key对应的Value值，</span>
&nbsp; &nbsp; <span class="hljs-comment">// 这个Key是在MetadataServiceURLParamsMetadataCustomizer中写入的</span>
&nbsp; &nbsp; Map&lt;String, Map&lt;String, String&gt;&gt; paramsMap = getMetadataServiceURLsParams(serviceInstance);
&nbsp; &nbsp; List&lt;URL&gt; urls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(paramsMap.size());
&nbsp; &nbsp; <span class="hljs-comment">// 获取Service Name</span>
&nbsp; &nbsp; String serviceName = serviceInstance.getServiceName();
&nbsp; &nbsp; <span class="hljs-comment">// 获取ServiceInstance监听的host</span>
&nbsp; &nbsp; String host = serviceInstance.getHost();
&nbsp; &nbsp; <span class="hljs-comment">// MetadataService接口可能被发布成多种协议，遍历paramsMap集合，为每种协议都生成对应的URL</span>
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Map&lt;String, String&gt;&gt; entry : paramsMap.entrySet()) {
&nbsp; &nbsp; &nbsp; &nbsp; String protocol = entry.getKey();
&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, String&gt; params = entry.getValue();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> port = Integer.parseInt(params.get(PORT_KEY));
&nbsp; &nbsp; &nbsp; &nbsp; URLBuilder urlBuilder = <span class="hljs-keyword">new</span> URLBuilder()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setHost(host)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setPort(port)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setProtocol(protocol)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setPath(MetadataService.class.getName());
&nbsp; &nbsp; &nbsp; &nbsp; params.forEach((name, value) -&gt; urlBuilder.addParameter(name, valueOf(value)));
&nbsp; &nbsp; &nbsp; &nbsp; urlBuilder.addParameter(GROUP_KEY, serviceName);
&nbsp; &nbsp; &nbsp; &nbsp; urls.add(urlBuilder.build());
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> urls;
}
</code></pre>
<p data-nodeid="54483">接下来我们看 RemoteMetadataServiceProxyFactory 这个实现类，其中的 createProxy() 方法会直接创建一个 RemoteMetadataServiceProxy 对象并返回。在前面第 44 课时介绍 MetadataService 接口的时候，我们重点介绍的是 WritableMetadataService 这个子接口下的实现，并没有提及 RemoteMetadataServiceProxy 这个实现。下图是 RemoteMetadataServiceProxy 在继承体系中的位置：</p>
<p data-nodeid="65483" class=""><img src="https://s0.lgstatic.com/i/image/M00/8C/35/Ciqc1F_pe9GAEnNjAAA4bEzwZzw039.png" alt="Drawing 4.png" data-nodeid="65487"></p>
<div data-nodeid="65484"><p style="text-align:center">RemoteMetadataServiceProxy 继承关系图</p></div>



<p data-nodeid="54486">RemoteMetadataServiceProxy 作为 RemoteWritableMetadataService 的本地代理，其 getExportedURLs()、getServiceDefinition() 等方法的实现，完全依赖于 MetadataReport 进行实现。这里以 getExportedURLs() 方法为例：</p>
<pre class="lang-java" data-nodeid="54487"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> SortedSet&lt;String&gt; <span class="hljs-title">getExportedURLs</span><span class="hljs-params">(String serviceInterface, String group, String version, String protocol)</span> </span>{
    <span class="hljs-comment">// 通过getMetadataReport()方法获取MetadataReport实现对象，并通过其getExportedURLs()方法进行查询，查询条件封装成ServiceMetadataIdentifier传入，其中包括服务接口、group、version以及revision等一系列信息，以ZookeeperMetadataReport实现为例真正有用的信息是revision和protocol</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> toSortedStrings(getMetadataReport().getExportedURLs(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">new</span> ServiceMetadataIdentifier(serviceInterface, group, version, PROVIDER_SIDE, revision, protocol)));
}
</code></pre>
<p data-nodeid="54488">到此为止，serviceRevisionExportedURLsCache 缓存中各个修订版本的 URL 已经更新到最新数据。</p>
<h4 data-nodeid="54489">（4）生成 SubcribedURL</h4>
<p data-nodeid="54490">在拿到最新修订版本的 URL 集合之后，接下来会调用 cloneExportedURLs() 方法，结合模板 URL（也就是 subscribedURL）以及各个 ServiceInstance 发布出来的元数据，生成要订阅服务的最终 subscribedURL 集合。</p>
<pre class="lang-java" data-nodeid="54491"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;URL&gt; <span class="hljs-title">cloneExportedURLs</span><span class="hljs-params">(URL subscribedURL, Collection&lt;ServiceInstance&gt; serviceInstances)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (isEmpty(serviceInstances)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> emptyList();
&nbsp; &nbsp; }
&nbsp; &nbsp; List&lt;URL&gt; clonedExportedURLs = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&nbsp; &nbsp; serviceInstances.forEach(serviceInstance -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 获取该ServiceInstance的host</span>
&nbsp; &nbsp; &nbsp; &nbsp; String host = serviceInstance.getHost();
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 获取该ServiceInstance的模板URL集合，getTemplateExportedURLs()方法会根据Service Name以及当前ServiceInstance的revision</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 从serviceRevisionExportedURLsCache缓存中获取对应的URL集合，另外，还会根据subscribedURL的protocol、group、version等参数进行过滤</span>
&nbsp; &nbsp; &nbsp; &nbsp; getTemplateExportedURLs(subscribedURL, serviceInstance)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .stream()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 删除timestamp、pid等参数</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(templateURL -&gt; templateURL.removeParameter(TIMESTAMP_KEY))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(templateURL -&gt; templateURL.removeParameter(PID_KEY))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .map(templateURL -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 从ServiceInstance.metadata集合中获取该protocol对应的端口号</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String protocol = templateURL.getProtocol();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> port = getProtocolPort(serviceInstance, protocol);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (Objects.equals(templateURL.getHost(), host)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; Objects.equals(templateURL.getPort(), port)) { <span class="hljs-comment">// use templateURL if equals</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> templateURL;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 覆盖host、port参数</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; URLBuilder clonedURLBuilder = from(templateURL)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setHost(host)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setPort(port);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> clonedURLBuilder.build();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; })
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .forEach(clonedExportedURLs::add); <span class="hljs-comment">// 记录新生成的URL</span>
&nbsp; &nbsp; });
&nbsp; &nbsp; <span class="hljs-keyword">return</span> clonedExportedURLs;
}
</code></pre>
<p data-nodeid="54492">在 getProtocolPort() 方法中会从 ServiceInstance.metadata 集合中获取 endpoints 列表（Key 为 dubbo.endpoints），具体实现如下：</p>
<pre class="lang-java" data-nodeid="54493"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">getProtocolPort</span><span class="hljs-params">(ServiceInstance serviceInstance, String protocol)</span> </span>{
&nbsp; &nbsp; Map&lt;String, String&gt; metadata = serviceInstance.getMetadata();
&nbsp; &nbsp; <span class="hljs-comment">// 从metadata集合中进行查询</span>
&nbsp; &nbsp; String rawEndpoints = metadata.get(<span class="hljs-string">"dubbo.endpoints"</span>);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(rawEndpoints)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将JSON格式的数据进行反序列化，这里的Endpoint是ServiceDiscoveryRegistry的内部类，只有port和protocol两个字段</span>
&nbsp; &nbsp; &nbsp; &nbsp; List&lt;Endpoint&gt; endpoints = JSON.parseArray(rawEndpoints, Endpoint.class);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (Endpoint endpoint : endpoints) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 根据Protocol获取对应的<span class="hljs-function">port
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-title">if</span> <span class="hljs-params">(endpoint.getProtocol()</span>.<span class="hljs-title">equals</span><span class="hljs-params">(protocol)</span>) </span>{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> endpoint.getPort();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
}
</code></pre>
<p data-nodeid="54494">在 ServiceInstance.metadata 集合中设置 Endpoint 集合的 ServiceInstanceCustomizer 接口的另一个实现—— ProtocolPortsMetadataCustomizer，主要是为了将不同 Protocol 监听的不同端口通知到 Consumer 端。ProtocolPortsMetadataCustomizer.customize() 方法的具体实现如下：</p>
<pre class="lang-java" data-nodeid="54495"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ServiceInstance serviceInstance)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取WritableMetadataService</span>
&nbsp; &nbsp; String metadataStoredType = getMetadataStorageType(serviceInstance);
&nbsp; &nbsp; WritableMetadataService writableMetadataService = getExtension(metadataStoredType);
&nbsp; &nbsp; Map&lt;String, Integer&gt; protocols = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
&nbsp; &nbsp; <span class="hljs-comment">// 先获取将当前ServiceInstance发布的各种Protocol对应的URL</span>
&nbsp; &nbsp; writableMetadataService.getExportedURLs()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .stream().map(URL::valueOf)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 过滤掉MetadataService接口</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .filter(url -&gt; !MetadataService.class.getName().equals(url.getServiceInterface()))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .forEach(url -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 记录Protocol与port之间的映射关系
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; protocols.put(url.getProtocol(), url.getPort());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });
&nbsp; &nbsp; // 将protocols这个Map中的映射关系转换成Endpoint对象，然后再序列化成JSON字符串，并设置到该ServiceInstance的metadata集合中
&nbsp; &nbsp; setEndpoints(serviceInstance, protocols);
}
</code></pre>
<p data-nodeid="54496">到此为止，整个 getExportedURLs() 方法的核心流程就介绍完了。</p>
<h4 data-nodeid="66108" class="te-preview-highlight">4. SubscribedURLsSynthesizer</h4>

<p data-nodeid="54500">最后，我们再来看看 synthesizeSubscribedURLs() 方法的相关实现，其中使用到 SubscribedURLsSynthesizer 这个接口，具体定义如下：</p>
<pre class="lang-java" data-nodeid="54501"><code data-language="java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SubscribedURLsSynthesizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Prioritized</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 是否支持该类型的URL</span>
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(URL subscribedURL)</span></span>;
&nbsp; &nbsp; <span class="hljs-comment">// 根据subscribedURL以及ServiceInstance的信息，合成完整subscribedURL集合</span>
&nbsp; &nbsp; <span class="hljs-function">List&lt;URL&gt; <span class="hljs-title">synthesize</span><span class="hljs-params">(URL subscribedURL, Collection&lt;ServiceInstance&gt; serviceInstances)</span></span>;
}
</code></pre>
<p data-nodeid="54502">目前 Dubbo 只提供了 rest 协议的实现—— RestProtocolSubscribedURLsSynthesizer，其中会根据 subscribedURL 中的服务接口以及 ServiceInstance 的 host、port、Service Name 等合成完整的 URL，具体实现如下：</p>
<pre class="lang-java" data-nodeid="54503"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;URL&gt; <span class="hljs-title">synthesize</span><span class="hljs-params">(URL subscribedURL, Collection&lt;ServiceInstance&gt; serviceInstances)</span> </span>{
&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 获取Protocol</span>
&nbsp; &nbsp; String protocol = subscribedURL.getParameter(PROTOCOL_KEY); 
&nbsp; &nbsp; <span class="hljs-keyword">return</span> serviceInstances.stream().map(serviceInstance -&gt; {
&nbsp; &nbsp; &nbsp; &nbsp; URLBuilder urlBuilder = <span class="hljs-keyword">new</span> URLBuilder()
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setProtocol(protocol)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 使用ServiceInstance的host、port</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setHost(serviceInstance.getHost())&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setPort(serviceInstance.getPort())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 设置业务接口</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .setPath(subscribedURL.getServiceInterface())&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .addParameter(SIDE_KEY, PROVIDER)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 设置Service Name</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .addParameter(APPLICATION_KEY, serviceInstance.getServiceName())
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .addParameter(REGISTER_KEY, TRUE.toString());
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> urlBuilder.build();
&nbsp; &nbsp; }).collect(Collectors.toList());
}
</code></pre>
<p data-nodeid="54504">到这里，关于整个 ServiceDiscoveryRegistry 的内容，我们就介绍完了。</p>
<h3 data-nodeid="54505">总结</h3>
<p data-nodeid="54506">本课时我们重点介绍了 Dubbo 服务自省架构中服务发布、服务订阅功能与传统 Dubbo 架构中Registry 接口的兼容实现，也就是 ServiceDiscoveryRegistry 的核心实现。</p>
<p data-nodeid="54507">首先我们讲解了 ServiceDiscoveryRegistry 对服务注册的核心实现，然后详细介绍了 ServiceDiscoveryRegistry 对服务订阅功能的实现，其中涉及 Service Instance 和 Service Name 的查询、MetadataService 服务调用等操作，最终得到 SubcribedURL。</p>
<p data-nodeid="54508">下一课时，我们将开始介绍 Dubbo 服务自省架构中配置中心的相关内容，记得按时来听课。</p>

---

### 精选评论


