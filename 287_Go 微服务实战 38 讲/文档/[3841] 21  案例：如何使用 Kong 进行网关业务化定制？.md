<p data-nodeid="23701">在上一课时中，我们对比了几款市面上流行的微服务网关，那么本课时我们就基于其中一款，也就是 Kong 来重点介绍微服务网关是如何搭建和实现的。</p>
<h3 data-nodeid="23702">为什么使用 Kong</h3>
<p data-nodeid="23703">当我们对原有业务系统进行微服务改造时，客户端（包括移动端和 Web 端等）如何与各个微服务进行交互这个问题需要我们认真考虑，服务数量的增加会导致一些基础功能的实现变得困难，如认证授权、负载均衡和服务间通信管理。</p>
<p data-nodeid="23704">但微服务网关所提供的访问限制、安全、流量控制、分析监控、日志、请求转发、合成和协议转换功能，可以使得开发者更加集中精力在各个业务服务的实现上，从而避免将大量时间花在考虑如何解决这些问题上。</p>
<p data-nodeid="26715" class="">在业内流行的微服务网关组件中，基于 Nginx 的<strong data-nodeid="26725">Kong</strong>表现突出。<strong data-nodeid="26726">Kong 是 Mashape 开源的高性能、高可用 API 网关</strong>，也可以认为是 API 服务管理层。它可以通过插件扩展已有功能，这些插件（使用 Lua 编写）在 API 请求响应循环的生命周期中被执行。除此之外，Kong 本身还提供了包括 HTTP 基本认证、密钥认证、CORS、TCP、UDP、文件日志、API 请求限流、请求转发及 Nginx 监控等基本功能。</p>


<p data-nodeid="23706">在用 Kong 进行实践之前，我们得先介绍一些 Kong 中常用的术语，因为这些术语在实践中会经常用得到。</p>
<ul data-nodeid="23707">
<li data-nodeid="23708">
<p data-nodeid="23709"><strong data-nodeid="23891">Route</strong>：请求的转发规则，按照 Hostname 和 PATH，将请求转发给 Service。</p>
</li>
<li data-nodeid="23710">
<p data-nodeid="23711"><strong data-nodeid="23896">Services</strong>：多个 Upstream 的集合，是 Route 的转发目标。</p>
</li>
<li data-nodeid="23712">
<p data-nodeid="23713"><strong data-nodeid="23901">Consumer</strong>：API 的用户，记录用户信息。</p>
</li>
<li data-nodeid="23714">
<p data-nodeid="23715"><strong data-nodeid="23906">Plugin</strong>：插件，可以是全局的，也可以绑定到 Service、Router 或者 Consumer。</p>
</li>
<li data-nodeid="23716">
<p data-nodeid="23717"><strong data-nodeid="23911">Certificate</strong>：HTTPS 配置的证书。</p>
</li>
<li data-nodeid="23718">
<p data-nodeid="23719"><strong data-nodeid="23916">SNI</strong>：域名与 Certificate 的绑定，指定了一个域名对应的 HTTPS 证书。</p>
</li>
<li data-nodeid="23720">
<p data-nodeid="23721"><strong data-nodeid="23921">Upstream</strong>：上游对象用来表示虚拟主机名，拥有多个服务（目标）时，会对请求进行负载均衡。</p>
</li>
<li data-nodeid="23722">
<p data-nodeid="23723"><strong data-nodeid="23926">Target</strong>：最终处理请求的 Backend 服务。</p>
</li>
</ul>
<h3 data-nodeid="23724">安装实践</h3>
<p data-nodeid="28413">Kong 支持多种安装方式，目前最新版本是 Kong 2.1，官方支持包括 Docker、K8s 等方式的安装：</p>
<p data-nodeid="29267"><img src="https://s0.lgstatic.com/i/image/M00/4C/BF/Ciqc1F9YkrGAY0bFAAIc9mSzUGU720.png" alt="Drawing 0.png" data-nodeid="29271"></p>
<div data-nodeid="29268" class=""><p style="text-align:center">Kong 的多种安装方式</p></div>





<p data-nodeid="23728">除了官方提供的安装方式，还有社区提供的安装方式：Microsoft Azure、Kongverge 等，详细情况你可参见该网址：https://konghq.com/install/ 。</p>
<p data-nodeid="23729">为了方便，这里我们就选择基于 Docker 的方式安装，选择的 Kong 版本为 1.1.2。docker-compose.yml 中定义的镜像、依赖和参数如下所示：</p>
<pre class="lang-java" data-nodeid="32651"><code data-language="java">version: <span class="hljs-string">"3.7"</span>
services:
  kong:
    image: kong:<span class="hljs-number">1.1</span>.<span class="hljs-number">2</span>
    environment:
     - <span class="hljs-string">"KONG_DATABASE=postgres"</span>
     - <span class="hljs-string">"KONG_PG_HOST=kong-database"</span>
     - <span class="hljs-string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span>
     - <span class="hljs-string">"KONG_PROXY_ACCESS_LOG=/dev/stdout"</span>
     - <span class="hljs-string">"KONG_ADMIN_ACCESS_LOG=/dev/stdout"</span>
     - <span class="hljs-string">"KONG_PROXY_ERROR_LOG=/dev/stderr"</span>
     - <span class="hljs-string">"KONG_ADMIN_ERROR_LOG=/dev/stderr"</span>
     - <span class="hljs-string">"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl"</span>
    ports:
     - <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span>
     - <span class="hljs-number">8443</span>:<span class="hljs-number">8443</span>
     - <span class="hljs-number">8001</span>:<span class="hljs-number">8001</span>
     - <span class="hljs-number">8444</span>:<span class="hljs-number">8444</span>
    networks:
     - kong-net
    depends_on:
      - kong-database
  konga:
    image: pantsel/konga
    environment:
     - <span class="hljs-string">"TOKEN_SECRET=blueskykong.com"</span>
     - <span class="hljs-string">"NODE_ENV=production"</span>
    ports:
     - <span class="hljs-number">8080</span>:<span class="hljs-number">1337</span>
    networks:
     - kong-net
    depends_on:
      - kong-database
  kong-database:
    image: postgres:<span class="hljs-number">9.6</span>
    ports:
      - <span class="hljs-string">"5432:5432"</span>
    environment:
      - POSTGRES_USER=kong
      - POSTGRES_DB=kong
    networks:
      - kong-net
    volumes:
      - /etc/localtime:/etc/localtime:ro
      - /data/data/postgresql:/<span class="hljs-keyword">var</span>/lib/postgresql/data
networks:
  kong-net:
    external: <span class="hljs-keyword">true</span>
</code></pre>




<p data-nodeid="23731">如上的 docker-compose.yml 会启动三个容器服务：Kong、Konga 和 Kong-database。这三个容器之间的通信需要增加 network 段，把容器放在同一个网段内，相关链接修改为容器名称来访问：</p>
<pre class="lang-js" data-nodeid="34341"><code data-language="js">docker network create kong-net
</code></pre>


<p data-nodeid="23733">所启动的三个容器服务，除了 Kong 之外的另两个服务：<strong data-nodeid="23953">Konga</strong>是 Kong 的 Dashboard，它是基于 JavaScript 的<strong data-nodeid="23954">客户端管理工具</strong>，对外暴露的端口为 8080；<strong data-nodeid="23955">Kong-database</strong>是 Kong 的<strong data-nodeid="23956">数据库服务</strong>，它用于存储配置信息，此处使用的是 Postgres。</p>
<p data-nodeid="23734">这里要注意的是，在启动 Kong 容器之前，需要保持数据库的 Docker 容器在运行状态，并执行如下初始化数据库的操作：</p>
<pre class="lang-js" data-nodeid="36031"><code data-language="js">docker run --rm \
     --network=kong-net \
     -e <span class="hljs-string">"KONG_DATABASE=postgres"</span> \
     -e <span class="hljs-string">"KONG_PG_HOST=kong-database"</span> \
     <span class="hljs-attr">kong</span>:latest kong migrations bootstrap
</code></pre>


<p data-nodeid="23736">数据库初始化成功后，再次启动 docker-compose.yml 服务就可以了。我们看到 Kong 映射出多个端口，默认情况下，Kong 监听的端口为：</p>
<ul data-nodeid="23737">
<li data-nodeid="23738">
<p data-nodeid="23739"><strong data-nodeid="23963">8000</strong>。此端口是 Kong 用来监听来自客户端传入的 HTTP 请求，并将此请求转发到上游服务器；Kong 根据配置的路由规则转发到真实的后台服务地址。</p>
</li>
<li data-nodeid="23740">
<p data-nodeid="23741"><strong data-nodeid="23968">8443</strong>。此端口是 Kong 用来监听来自客户端传入的 HTTPS 请求，跟 8000 端口的功能类似，还会转发 HTTPS 请求。我们可以通过修改配置文件来禁用 HTTPS 的功能。</p>
</li>
<li data-nodeid="23742">
<p data-nodeid="23743"><strong data-nodeid="23973">8001</strong>。Kong 提供的管理 API 端口，通过此端口，管理者可以对 Kong 的监听服务进行配置，插件设置、API 的增删改查以及负载均衡等一系列的配置都是通过 8001 端口进行管理的。</p>
</li>
<li data-nodeid="23744">
<p data-nodeid="23745"><strong data-nodeid="23978">8444</strong>。通过此端口，管理者可以对 HTTPS 请求进行监控。</p>
</li>
</ul>
<p data-nodeid="23746">容器都启动好之后，下面我们来验证一下：</p>
<pre class="lang-js" data-nodeid="37721"><code data-language="js">$ curl -i http:<span class="hljs-comment">//localhost:8001/</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-attr">Date</span>: Sat, <span class="hljs-number">20</span> Jul <span class="hljs-number">2019</span> <span class="hljs-number">08</span>:<span class="hljs-number">39</span>:<span class="hljs-number">08</span> GMT
Content-Type: application/json; charset=utf<span class="hljs-number">-8</span>
<span class="hljs-attr">Connection</span>: keep-alive
Access-Control-Allow-Origin: *
Server: kong/<span class="hljs-number">1.1</span><span class="hljs-number">.2</span>
Content-Length: <span class="hljs-number">5785</span>
...
</code></pre>


<p data-nodeid="39404">本地访问 8001 端口，返回如上的结果，表示安装正确，可以正常使用 Kong。在浏览器中输入 http://localhost:8080 即可访问 Konga 的管理界面（如下图），如果你第一次登录使用，则需要创建管理员账号和密码。</p>
<p data-nodeid="40256"><img src="https://s0.lgstatic.com/i/image/M00/4C/CA/CgqCHl9YktiAZMK3AANSs-0i4uA386.png" alt="Drawing 1.png" data-nodeid="40260"></p>
<div data-nodeid="40257" class=""><p style="text-align:center">Konga 的管理界面</p></div>





<p data-nodeid="23751">至此，Kong 以及管理工具都已安装完成。下面我们将会通过创建服务、创建路由、安装插件等过程的讲解，进入 API Gateway 的具体实践。</p>
<h4 data-nodeid="42789" class="">1. 创建服务</h4>

<p data-nodeid="23755">正如我们在前面术语部分的介绍，服务 Services 是上游服务的抽象，可以是一个应用，或者具体某个接口。Kong 提供了管理接口，我们可以通过请求 8001 管理接口直接创建，也可以通过安装的管理界面，这二者的实现效果是一样的。</p>
<pre class="lang-js" data-nodeid="41946"><code data-language="js">curl -i -X POST \
--url http:<span class="hljs-comment">//localhost:8001/services/ \</span>
--data <span class="hljs-string">'name=aoho-blog'</span> \
--data <span class="hljs-string">'url=http://blueskykong.com/'</span>
</code></pre>


<p data-nodeid="44461">这里我们创建了一个服务名为 aoho-blog 的后端服务，指定转发的地址为 http://blueskykong.com。可以在管理界面中看到如下的记录：</p>
<p data-nodeid="45307"><img src="https://s0.lgstatic.com/i/image/M00/4C/BF/Ciqc1F9YkvmAN0m3AAEzz-ZOr6U607.png" alt="Drawing 2.png" data-nodeid="45311"></p>
<div data-nodeid="45308" class=""><p style="text-align:center">Kong 服务列表</p></div>





<p data-nodeid="23760">在创建服务的同时，我们还可以设置其中的一些参数，如 Retries（重试次数）、Connect timeout（连接的超时时间）、Write/Read timeout（写/读超时时间）等。</p>
<h4 data-nodeid="46988" class="">2. 创建路由</h4>


<p data-nodeid="23764">创建好服务之后，我们需要创建具体的 API 路由。路由是请求的转发规则，根据 Hostname 和 PATH，将请求转发。</p>
<pre class="lang-js" data-nodeid="48655"><code data-language="js">curl -i -X POST \
--url http:<span class="hljs-comment">//localhost:8001/services/aoho-blog/routes \</span>
--data <span class="hljs-string">'hosts[]=blueskykong.com'</span> \
--data <span class="hljs-string">'paths[]=/api/blog'</span>
</code></pre>


<p data-nodeid="50314">如上所示，我们在 aoho-blog 中创建了一个访问 /api/blog 的路由，在管理界面可以看到相应的记录：</p>
<p data-nodeid="51154"><img src="https://s0.lgstatic.com/i/image/M00/4C/BF/Ciqc1F9YkwqAY1q1AAKbhE-tEOc498.png" alt="Drawing 3.png" data-nodeid="51158"></p>
<div data-nodeid="51155" class=""><p style="text-align:center">Kong 路由记录</p></div>





<p data-nodeid="53638">创建好路由之后，我们就可以访问 /api/blog，如下图：</p>
<p data-nodeid="53639" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/CgqCHl9YkxWATDtOAAXihFAhkAA332.png" alt="Drawing 4.png" data-nodeid="53644"></p>
<div data-nodeid="53640"><p style="text-align:center">访问 /api/blog</p></div>




<p data-nodeid="23772">Kong 默认通过 8000 端口处理代理的请求。成功的响应意味着 Kong 会将 http://localhost:8000 的请求转发到配置的 URL，并将响应转发给我们。需要注意的是，如果 API 暴露的地址与前面 Host 定义的地址（blueskykong.com）不一致，就需要在请求的 Headers 里面加入 Header，Kong 根据上面请求中定义的<code data-backticks="1" data-nodeid="24007">Header:Host</code>，执行此操作。</p>
<p data-nodeid="23773">创建了服务和路由之后，我们已经能够将客户端的请求转发到对应的服务，但微服务网关还承担了很多基础的功能，如安全认证、限流、分析监控等功能，因此还需要应用 Kong 的插件来实现这些功能。</p>
<h3 data-nodeid="23774">安装 Kong 插件</h3>
<p data-nodeid="23775">请求到达 Kong 网关，我们可以在请求转发给服务端应用之前，应用 Kong 自带的插件对请求进行处理，如身份认证、API 限流、黑白名单校验和日志切面等。同时，我们也可以按照 Kong 的教程文档，定制属于自己的插件。这部分我们主要选择其中的三个插件示例应用，至于其余的插件应用，你可以参考这个网址：https://docs.konghq.com/hub/。</p>
<h4 data-nodeid="54473" class="">1. JWT 认证插件</h4>

<p data-nodeid="23779"><strong data-nodeid="24017">JWT（JSON Web Token）是一种流行的跨域身份验证解决方案</strong>。作为一个开放的标准（RFC 7519），JWT 定义了一种简洁的、自包含的方法用于通信双方之间以 JSON 对象的形式安全地传递信息。因为数字签名的存在，这些信息是可信的。</p>
<p data-nodeid="23780">JWT 最大的优点就是能让业务无状态化，让 Token 作为业务请求的必须信息随着请求一并传输过来，服务端不用再去存储 session 信息，尤其是在分布式系统中。Kong 提供了 JWT 认证插件，用以验证包含 HS256 或 RS256 签名的 JWT 请求。每个消费者都将拥有 JWT 凭证（公钥和密钥），这些凭证必须用于签署其 JWT。JWT 令牌可以通过请求字符串、Cookie 或者认证头部传递，Kong 将会验证令牌的签名，通过则转发，否则直接丢弃请求。</p>
<p data-nodeid="23781">我们在前面配置的路由基础上，增加 JWT 认证插件：</p>
<pre class="lang-js" data-nodeid="56124"><code data-language="js">curl -X POST http:<span class="hljs-comment">//localhost:8001/routes/e33d6aeb-4f35-4219-86c2- a41e879eda36/plugins \</span>
--data <span class="hljs-string">"name=jwt"</span>
</code></pre>


<p data-nodeid="58587">可以看到，在插件列表增加了相应的记录：</p>
<p data-nodeid="58588" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/BF/Ciqc1F9YkyiASlg2AAGmffFE8Pc088.png" alt="Drawing 5.png" data-nodeid="58593"></p>
<div data-nodeid="58589"><p style="text-align:center">Kong 插件列表</p></div>





<p data-nodeid="23786">在增加了 JWT 插件之后，就没法直接访问 /api/blog 接口了，接口返回 "message": "Unauthorized"，提示客户端要访问的话则需要提供 JWT 的认证信息。因此，我们需要创建用户：</p>
<pre class="lang-js" data-nodeid="69276"><code data-language="js">curl -i -X POST \
--url http:<span class="hljs-comment">//localhost:8001/consumers/  \</span>
--data <span class="hljs-string">"username=aoho"</span>
</code></pre>


<p data-nodeid="60232">如上我们就创建了一个名为 aoho 的用户。</p>
<p data-nodeid="61062"><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/CgqCHl9YkzSAabYOAAE1TLmVwy0554.png" alt="Drawing 6.png" data-nodeid="61066"></p>
<div data-nodeid="61063" class=""><p style="text-align:center">Kong 创建用户</p></div>





<p data-nodeid="23791">创建好用户之后，需要获取用户 JWT 凭证，执行如下的调用：</p>
<pre class="lang-dart" data-nodeid="67634"><code data-language="dart">$ curl -i -X POST \
--url http:<span class="hljs-comment">//localhost:8001/consumers/aoho/jwt \</span>
--header <span class="hljs-string">"Content-Type: application/x-www-form-urlencoded"</span>
# 响应
{
    <span class="hljs-string">"rsa_public_key"</span>: <span class="hljs-keyword">null</span>,
    <span class="hljs-string">"created_at"</span>: <span class="hljs-number">1563566125</span>,
    <span class="hljs-string">"consumer"</span>: {
        <span class="hljs-string">"id"</span>: <span class="hljs-string">"8c0e1ab4-8411-42fc-ab80-5eccf472d2fd"</span>
    },
    <span class="hljs-string">"id"</span>: <span class="hljs-string">"1d69281d-5083-4db0-b42f-37b74e6d20ad"</span>,
    <span class="hljs-string">"algorithm"</span>: <span class="hljs-string">"HS256"</span>,
    <span class="hljs-string">"secret"</span>: <span class="hljs-string">"olsIeVjfVSF4RuQuylTMX4x53NDAOQyO"</span>,
    <span class="hljs-string">"key"</span>: <span class="hljs-string">"TOjHFM4m1qQuPPReb8BTWAYCdM38xi3C"</span>
}
</code></pre>








<p data-nodeid="72542">使用 key 和 secret 在 https://jwt.io 可以生成 JWT 凭证信息。在实际的使用过程中，我们通过编码实现，此处为了演示使用网页工具生成 Token。</p>
<p data-nodeid="72543" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk1aAeU1AAAMrh-FCi34569.png" alt="Drawing 7.png" data-nodeid="72548"></p>
<div data-nodeid="72544"><p style="text-align:center">生成 JWT Token</p></div>





<p data-nodeid="74174">上图中画线部分即为 JWT 凭证的 key 和 secret。然后我们将生成的 Token，配置到请求的认证头部，再次执行请求：</p>
<p data-nodeid="74175" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk16AciV4AAW93EOSJKU956.png" alt="Drawing 8.png" data-nodeid="74180"></p>
<div data-nodeid="74176"><p style="text-align:center">带有 JWT 令牌的合法请求</p></div>





<p data-nodeid="23799">可以看到，我们能够正常请求相应的 API 接口，JWT 认证插件应用成功。Kong 的 JWT 认证插件使用比较简单，但在实践过程中，我们还需要考虑如何跟自身的用户认证系统进行结合。</p>
<h4 data-nodeid="75817" class="">2. Prometheus 可视化监控</h4>


<p data-nodeid="23803"><strong data-nodeid="24056">Prometheus 是一套开源的系统监控报警框架</strong>。它启发于 Google 的 BorgMon 监控系统，由工作在 SoundCloud 的员工在 2012 年作为社区开源项目进行开发，并于 2015 年正式发布。</p>
<p data-nodeid="23804">作为新一代的监控框架，Prometheus 适用于记录时间序列数据，并且它还具有强大的多维度数据模型、灵活而强大的查询语句、易于管理和伸缩等特点。</p>
<p data-nodeid="23805">Kong 官方提供的 Prometheus 插件，可用的 metric（指标）有如下：</p>
<ul data-nodeid="23806">
<li data-nodeid="23807">
<p data-nodeid="23808"><strong data-nodeid="24063">状态码</strong>。上游服务返回的 HTTP 状态码。</p>
</li>
<li data-nodeid="23809">
<p data-nodeid="23810"><strong data-nodeid="24068">时延柱状图</strong>。Kong 中的时延都将被记录，包括请求（完整请求的时延）、Kong（Kong 用来路由、验证和运行其他插件所花费的时间）和上游（上游服务所花费时间来响应请求）。</p>
</li>
<li data-nodeid="23811">
<p data-nodeid="23812"><strong data-nodeid="24073">Bandwidth</strong>。流经 Kong 的总带宽（出口/入口）。</p>
</li>
<li data-nodeid="23813">
<p data-nodeid="23814"><strong data-nodeid="24078">DB 可达性</strong>。Kong 节点是否能访问其 DB。</p>
</li>
<li data-nodeid="23815">
<p data-nodeid="23816"><strong data-nodeid="24083">Connections</strong>。各种 Nginx 连接指标，如 Active、读取、写入和接收连接。</p>
</li>
</ul>
<p data-nodeid="23817">我们在 Service 为 aoho-blog 安装 Prometheus 插件：</p>
<pre class="lang-js" data-nodeid="77444"><code data-language="js">curl -X POST http:<span class="hljs-comment">//localhost:8001/services/aoho-blog/plugins \</span>
--data <span class="hljs-string">"name=prometheus"</span> 
</code></pre>


<p data-nodeid="81099">从管理界面可以看到，我们已经成功将 Prometheus 插件绑定到 aoho-blog 服务上。</p>
<p data-nodeid="82742" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk3uAWOwcAAGdkZ8tvKs339.png" alt="Drawing 9.png" data-nodeid="82746"></p>
<div data-nodeid="82743"><p style="text-align:center">Prometheus 插件</p></div>













<p data-nodeid="23822">通过访问<code data-backticks="1" data-nodeid="24091">/metrics</code>接口返回收集度量数据：</p>
<pre class="lang-js" data-nodeid="83963"><code data-language="js">$ curl -i http:<span class="hljs-comment">//localhost:8001/metrics</span>
HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
<span class="hljs-attr">Server</span>: openresty/<span class="hljs-number">1.13</span><span class="hljs-number">.6</span><span class="hljs-number">.2</span>
<span class="hljs-attr">Date</span>: Sun, <span class="hljs-number">21</span> Jul <span class="hljs-number">2019</span> <span class="hljs-number">09</span>:<span class="hljs-number">48</span>:<span class="hljs-number">42</span> GMT
Content-Type: text/plain; charset=UTF<span class="hljs-number">-8</span>
Transfer-Encoding: chunked
<span class="hljs-attr">Connection</span>: keep-alive
Access-Control-Allow-Origin: *
kong_bandwidth{type=<span class="hljs-string">"egress"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">178718</span>
kong_bandwidth{type=<span class="hljs-string">"ingress"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">1799</span>
kong_datastore_reachable <span class="hljs-number">1</span>
kong_http_status{code=<span class="hljs-string">"200"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">4</span>
kong_http_status{code=<span class="hljs-string">"401"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">1</span>
kong_latency_bucket{type=<span class="hljs-string">"kong"</span>,service=<span class="hljs-string">"aoho-blog"</span>,le=<span class="hljs-string">"00005.0"</span>} <span class="hljs-number">1</span>
kong_latency_bucket{type=<span class="hljs-string">"kong"</span>,service=<span class="hljs-string">"aoho-blog"</span>,le=<span class="hljs-string">"00007.0"</span>} <span class="hljs-number">1</span>
...
kong_latency_bucket{type=<span class="hljs-string">"upstream"</span>,service=<span class="hljs-string">"aoho-blog"</span>,le=<span class="hljs-string">"00300.0"</span>} <span class="hljs-number">4</span>
kong_latency_bucket{type=<span class="hljs-string">"upstream"</span>,service=<span class="hljs-string">"aoho-blog"</span>,le=<span class="hljs-string">"00400.0"</span>} <span class="hljs-number">4</span>
...
kong_latency_count{type=<span class="hljs-string">"kong"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">5</span>
kong_latency_count{type=<span class="hljs-string">"request"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">5</span>
kong_latency_count{type=<span class="hljs-string">"upstream"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">4</span>
kong_latency_sum{type=<span class="hljs-string">"kong"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">409</span>
kong_latency_sum{type=<span class="hljs-string">"request"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">1497</span>
kong_latency_sum{type=<span class="hljs-string">"upstream"</span>,service=<span class="hljs-string">"aoho-blog"</span>} <span class="hljs-number">1047</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"accepted"</span>} <span class="hljs-number">2691</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"active"</span>} <span class="hljs-number">2</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"handled"</span>} <span class="hljs-number">2691</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"reading"</span>} <span class="hljs-number">0</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"total"</span>} <span class="hljs-number">2637</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"waiting"</span>} <span class="hljs-number">1</span>
kong_nginx_http_current_connections{state=<span class="hljs-string">"writing"</span>} <span class="hljs-number">1</span>
kong_nginx_metric_errors_total <span class="hljs-number">0</span>
</code></pre>


<p data-nodeid="23824">返回的响应太长，有省略，从响应可以看到 Prometheus 插件提供的 metric 都有体现。Prometheus 插件导出的度量标准，可以在 Grafana（一个跨平台的开源的度量分析和可视化工具）中绘制，“Prometheus + Grafana” 的组合是目前较为流行的监控系统。</p>
<h4 data-nodeid="85588" class="">3. 链路追踪 Zipkin 插件</h4>


<p data-nodeid="86396" class=""><strong data-nodeid="86401">Zipkin 是由 Twitter 开源的分布式实时链路追踪组件。</strong> Zipkin 收集来自各个异构系统的实时监控数据，用来追踪与分析微服务架构下的请求，应用系统则需要向 Zipkin 报告链路信息。Kong 的 Zipkin 插件将 Kong 作为 zipkin-client，zipkin-client 组装好 Zipkin 需要的数据包发送到 zipkin-server。Zipkin 插件会将请求打上如下标签，并推送到 Zipkin 服务端：</p>

<ul data-nodeid="23829">
<li data-nodeid="23830">
<p data-nodeid="23831">span.kind (sent to Zipkin as “kind”)</p>
</li>
<li data-nodeid="23832">
<p data-nodeid="23833">http.method</p>
</li>
<li data-nodeid="23834">
<p data-nodeid="23835">http.status_code</p>
</li>
<li data-nodeid="23836">
<p data-nodeid="23837">http.url</p>
</li>
<li data-nodeid="23838">
<p data-nodeid="23839">peer.ipv4</p>
</li>
<li data-nodeid="23840">
<p data-nodeid="23841">peer.ipv6</p>
</li>
<li data-nodeid="23842">
<p data-nodeid="23843">peer.port</p>
</li>
<li data-nodeid="23844">
<p data-nodeid="23845">peer.hostname</p>
</li>
<li data-nodeid="23846">
<p data-nodeid="23847">peer.service</p>
</li>
</ul>
<p data-nodeid="23848">关于链路追踪和 Zipkin 的具体信息，到后面的链路追踪课时我们会详细讲解，本课时我们就旨在介绍如何在 Kong 中使用 Zipkin 插件追踪所有请求的链路。</p>
<p data-nodeid="23849">首先开启 Zipkin 插件，将插件绑定到路由上（这里可以绑定为全局的插件）。</p>
<pre class="lang-js" data-nodeid="88019"><code data-language="js">curl -X POST http:<span class="hljs-comment">//kong:8001/routes/e33d6aeb-4f35-4219- 86c2-a41e879eda36/plugins \</span>
    --data <span class="hljs-string">"name=zipkin"</span>  \
    --data <span class="hljs-string">"config.http_endpoint=http://localhost:9411/api/v2/spans"</span> \
    --data <span class="hljs-string">"config.sample_ratio=1"</span>
</code></pre>


<p data-nodeid="90434">如上配置了 Zipkin Collector 的地址和采样率，为了测试效果明显，设置采样率为 100%，但在实际生产环境中还是要谨慎使用 100% 的采样率配置，采样率对系统吞吐量会有影响。</p>
<p data-nodeid="90435" class=""><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk5mAHGfXAAGx7YEHLuU160.png" alt="Drawing 10.png" data-nodeid="90440"></p>
<div data-nodeid="90436"><p style="text-align:center">Zipkin 插件</p></div>





<p data-nodeid="92047">可以看到，Zipkin 插件已经应用到指定的路由上。下面我们将会执行请求 /api/blog 接口，打开 http://localhost:9411 界面如下：</p>
<p data-nodeid="94475"><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk6CAK4oOAAF5XrN-wD4791.png" alt="Drawing 11.png" data-nodeid="94479"></p>
<div data-nodeid="94476" class=""><p style="text-align:center">Zipkin 链路追踪</p></div>





<p data-nodeid="93661">这时 Zipkin 已经将请求记录，我们可以点开查看其链路详情：</p>
<p data-nodeid="95284"><img src="https://s0.lgstatic.com/i/image/M00/4C/C0/Ciqc1F9Yk7WAc_rEAAGV1LU8BgU968.png" alt="Drawing 12.png" data-nodeid="95288"></p>
<div data-nodeid="95285" class=""><p style="text-align:center">链路详情</p></div>





<p data-nodeid="23860">从链路调用可以知道，请求到达 Kong 之后，都经历了哪些服务和 Span，以及每个 Span 所花费的时间等信息。</p>
<h3 data-nodeid="23861">小结</h3>
<p data-nodeid="23862">本课时我们重点介绍了微服务网关 Kong 的相关概念和安装实践，并在此基础上安装实践了其中具有代表性的三个 Kong 插件：JWT 认证插件、Prometheus 可视化监控和链路追踪 Zipkin 插件。Kong 官方对自身的定位也是适用于混合云平台的下一代 API 管理平台，其在功能方面很强大。因此，基于 Kong 的丰富生态和配套的工具，我们可以快速构建一个微服务网关，作为服务端的统一入口。</p>
<p data-nodeid="23863">学习完本课时，你觉得还需要自定义哪些 Kong 网关的插件，欢迎你在留言区和我分享。</p>

---

### 精选评论

##### 13213：
> yml文件中需要指定-e "KONG_PG_PASSWORD=kong_test"

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个与你的pg设置有关了，笔者这个版本不需要加。

##### **1609：
> 老师，Traefik和Kong有什么区别呢？

