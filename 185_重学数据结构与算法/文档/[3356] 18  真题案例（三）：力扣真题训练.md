<p data-nodeid="1785" class="">在备战公司面试的时候，相信你一定也刷过力扣（leetcode）的题目吧。力扣的题目种类多样，而且有虚拟社区功能，因此很多同学都喜欢在上面分享习题答案。</p>
<p data-nodeid="1786">毫无疑问，如果你完整地刷过力扣题库，在一定程度上能够提高你面试通过的可能性。因此，在本课时，我选择了不同类型、不同层次的力扣真题，我会通过这些题目进一步讲述和分析解决数据结构问题的方法。</p>
<h3 data-nodeid="1787">力扣真题训练</h3>
<p data-nodeid="1788">在看真题前，我们再重复一遍通用的解题方法论，它可以分为以下 4 个步骤：</p>
<ol data-nodeid="1789">
<li data-nodeid="1790">
<p data-nodeid="1791"><strong data-nodeid="1905">复杂度分析</strong>。估算问题中复杂度的上限和下限。</p>
</li>
<li data-nodeid="1792">
<p data-nodeid="1793"><strong data-nodeid="1910">定位问题</strong>。根据问题类型，确定采用何种算法思维。</p>
</li>
<li data-nodeid="1794">
<p data-nodeid="1795"><strong data-nodeid="1915">数据操作分析</strong>。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。</p>
</li>
<li data-nodeid="1796">
<p data-nodeid="1797"><strong data-nodeid="1920">编码实现</strong>。</p>
</li>
</ol>
<h4 data-nodeid="1798">例题 1：删除排序数组中的重复项</h4>
<p data-nodeid="1799"><strong data-nodeid="1926">【题目】</strong> 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后的数组和新的长度，你不需要考虑数组中超出新长度后面的元素。</p>
<p data-nodeid="1800">要求：空间复杂度为 O(1)，即不要使用额外的数组空间。</p>
<p data-nodeid="1801">例如，给定数组 nums = [1,1,2]，函数应该返回新的长度 2，并且原数组 nums 的前两个元素被修改为 1, 2。又如，给定 nums = [0,0,1,1,1,2,2,3,3,4]，函数应该返回新的长度 5，并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p>
<p data-nodeid="1802"><strong data-nodeid="1941">【解析】</strong> 这个题目比较简单，应该是送分题。不过，面试过程中的送分题也是送命题。这是因为，如果送分题没有拿下，就会显得非常说不过去。</p>
<p data-nodeid="1803"><strong data-nodeid="1946">我们先来看一下复杂度</strong>。这里并没有限定时间复杂度，仅仅是要求了空间上不能定义新的数组。</p>
<p data-nodeid="1804"><strong data-nodeid="1951">然后我们来定位问题</strong>。显然这是一个数据去重的问题。</p>
<p data-nodeid="1805"><strong data-nodeid="1956">按照解题步骤，接下来我们需要做数据操作分析。</strong> 在一个去重问题中，每次遍历的新的数据，都需要与已有的不重复数据进行对比。这时候，就需要查找了。整体来看，遍历嵌套查找，就是 O(n²) 的复杂度。如果要降低时间复杂度，那么可以在查找上入手，比如使用哈希表。不过很可惜，使用了哈希表之后，空间复杂度就是 O(n)。幸运的是，原数组是有序的，这就可以让查找的动作非常简单了。</p>
<p data-nodeid="1806">因此，解决方案上就是，一次循环嵌套查找完成。查找不可使用哈希表，但由于数组有序，时间复杂度是 O(1)。因此整体的时间复杂度就是 O(n)。</p>
<p data-nodeid="1807">我们来看一下具体方案。既然是一次循环，那么就需要一个 for 循环对整个数组进行遍历。每轮遍历的动作是查找 nums[i] 是否已经出现过。因为数组有序，因此只需要去对比 nums[i] 和当前去重数组的最大值是否相等即可。我们用一个 temp 变量保存去重数组的最大值。</p>
<p data-nodeid="1808">如果二者不等，则说明是一个新的数据。我们就需要把这个新数据放到去重数组的最后，并且修改 temp 变量的值，再修改当前去重数组的长度变量 len。直到遍历完，就得到了结果。</p>
<p data-nodeid="1809"><img src="https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4AaAIRWPAATuBR6nG1c878.gif" alt="1.gif" data-nodeid="1970"></p>
<p data-nodeid="1810"><strong data-nodeid="1975">最后，我们按照上面的思路进行编码开发，代码如下</strong>：</p>
<pre class="lang-java" data-nodeid="1811"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-keyword">int</span>[] nums = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>};
    <span class="hljs-keyword">int</span> temp = nums[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) {
        <span class="hljs-keyword">if</span> (nums[i] != temp) {
            nums[len] = nums[i];
            temp = nums[i];
            len++;
        }
    }
    System.out.println(len);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
        System.out.println(nums[i]);
    }
}
</code></pre>
<p data-nodeid="1812"><strong data-nodeid="1980">我们对代码进行解读。</strong> 在这段代码中，第 3～4 行进行了初始化，得到的 temp 变量是数组第一个元素，len 变量为 1。</p>
<p data-nodeid="1813">接着进入 for 循环。如果当前元素与去重的最大值不等（第 6 行），则新元素放入去重数组中（第 7 行），并且更新去重数组的最大值（第 8 行），再让去重数组的长度加 1（第 9 行）。最后得到结果后，再打印出来，第 12～15 行。</p>
<h4 data-nodeid="1814">例题 2：查找两个有序数组合并后的中位数</h4>
<p data-nodeid="1815"><strong data-nodeid="1987">【题目】</strong> 两个有序数组查找合并之后的中位数。给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组合在一起之后的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p data-nodeid="1816">你可以假设 nums1 和 nums2 不会同时为空，所有的数字全都不相等。还可以再假设，如果数字个数为偶数个，中位数就是中间偏左的那个元素。</p>
<p data-nodeid="1817">例如：nums1 = [1, 3, 5, 7, 9]</p>
<p data-nodeid="1818">nums2 = [2, 4, 8, 12]</p>
<p data-nodeid="1819">输出 5。</p>
<p data-nodeid="1820"><strong data-nodeid="2002">【解析】</strong> 这个题目是我个人非常喜欢的，原因是，它所有的解法和思路，都隐含在了题目的描述中。如果你具备很强的分析和解决问题的能力，那么一定可以找到最优解法。</p>
<p data-nodeid="1821"><strong data-nodeid="2007">我们先看一下复杂度的分析</strong>。这里的 nums1 和 nums2 都是有序的，这让我们第一时间就想到了归并排序。方法很简单，我们把两个数组合并，就得到了合在一起后的有序数组。这个动作的时间复杂度是 O(m+n)。接着，我们从数组中就可以直接取出中位数了。很可惜，这并不满足题目的时间复杂度 O(log(m + n)) 的要求。</p>
<p data-nodeid="1822"><strong data-nodeid="2012">接着，我们来看一下这个问题的定位</strong>。题目中有一个关键字，那就是“找出”。很显然，我们要找的目标就藏在 nums1 或 nums2 中。这明显就是一个查找问题。而在查找问题中，我们学过的知识是分治法下的二分查找。</p>
<p data-nodeid="1823">回想一下，二分查找适用的重要条件就是，原数组有序。恰好，在这个问题中 nums1 和 nums2 分别都是有序的。而且二分查找的时间复杂度是 O(logn)，这和题目中给出的时间复杂度 O(log(m + n)) 的要求也是不谋而合。因此，经过分析，我们可以大胆猜测，此题极有可能要用到二分查找。</p>
<p data-nodeid="1824"><strong data-nodeid="2018">我们再来看一下数据结构方面</strong>。如果要用二分查找，就需要用到若干个指针，去约束查找范围。除此以外，并不需要去定义复杂的数据结构。也就是说，空间复杂度是 O(1) 。</p>
<p data-nodeid="1825">好了，接下来，我们就来看一下二分查找如何能解决这个问题。二分查找需要一个分裂点，去把原来的大问题，拆分成两个部分，并在其中一部分继续执行二分查找。既然是查找中位数，我们不妨先试试以中位数作为切分点，看看会产生什么结果。如下图所示：</p>
<p data-nodeid="1826"><img src="https://s0.lgstatic.com/i/image/M00/32/DD/Ciqc1F8O4BWAJgOUAABMJW6Ihfk508.png" alt="2.png" data-nodeid="2022"></p>
<p data-nodeid="1827">经过切分后，两个数组分别被拆分为 3 个部分，合在一起是 6 个部分。二分查找的思路是，需要从这 6 个部分中，剔除掉一些，让查找的范围缩小。那么，我们来思考一个问题，在这 6 个部分中，目标中位数一定不会发生在哪几个部分呢？</p>
<p data-nodeid="1828"><strong data-nodeid="2028">中位数有一个重要的特质，那就是比中位数小的数字个数，和比中位数大的数字个数，是相等的</strong>。围绕这个性质来看，中位数就一定不会发生在 C 和 D 的区间。</p>
<p data-nodeid="1829">如果中位数在 C 部分，那么在 nums1 中，比中位数小的数字就会更多一些。因为 4 &lt; 5（nums2 的中位数小于 nums1 的中位数），所以在 nums2 中，比中位数小的数字也会更多一些（最不济也就是一样多）。因此，整体来看，中位数不可能在 C 部分。同理，中位数也不会发生在 D 部分。</p>
<p data-nodeid="1830">接下来，我们就可以在查找范围内，剔除掉 C 部分（永远比中位数大的数字）和 D 部分（永远比中位数小的数字），这样我们就成功地完成了一次二分动作，缩小了查找范围。然而这样并没结束。剔除掉了 C 和 D 之后，中位数有可能发生改变。这是因为，C 部分的数字个数和 D 部分数字的个数是不相等的。剔除不相等数量的“小数”和“大数”后，会造成中位数的改变。</p>
<p data-nodeid="1831">为了解决这个问题，我们需要对剔除的策略进行修改。一个可行的方法是，如果 C 部分数字更少为 p 个，则剔除 C 部分；并只剔除 D 部分中的 p 个数字。这样就能保证，经过一次二分后，剔除之后的数组的中位数不变。</p>
<p data-nodeid="1832"><img src="https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4CKAd3GfAAA88tCPFHQ522.png" alt="3.png" data-nodeid="2036"></p>
<p data-nodeid="1833">应该剔除 C 部分和 D 部分。但 D 部分更少，因此剔除 D 和 C 中的 9。</p>
<p data-nodeid="1834" class="">二分查找还需要考虑终止条件。对于这个题目，终止条件必然是某个数组小到无法继续二分的时候。这是因为，每次二分剔除掉的是更少的那个部分。因此，在终止条件中，查找范围应该是一个大数组和一个只有 1～2 个元素的小数组。这样就需要根据大数组的奇偶性和小数组的数量，拆开 4 个可能性：</p>
<p data-nodeid="1835"><strong data-nodeid="2055">可能性一</strong>：nums1 奇数个，nums2 只有 1 个元素。例如，nums1 = [a, b, <strong data-nodeid="2056">c</strong>, d, e]，nums2 = [m]。此时，有以下 3 种可能性：</p>
<ol data-nodeid="1836">
<li data-nodeid="1837">
<p data-nodeid="1838">如果 m &lt; b，则结果为 b；</p>
</li>
<li data-nodeid="1839">
<p data-nodeid="1840">如果 b &lt; m &lt; c，则结果为 m；</p>
</li>
<li data-nodeid="1841">
<p data-nodeid="1842" class="">如果 m &gt; c，则结果为 c。</p>
</li>
</ol>
<p data-nodeid="1843" class="">这 3 个情况，可以利用 "A?B:C" 合并为一个表达式，即 m &lt; b ? b : (m &lt; c ? m : c)。</p>
<p data-nodeid="1844"><strong data-nodeid="2091">可能性二</strong>：nums1 偶数个，nums2 只有 1 个元素。例如，nums1 = [a, b, <strong data-nodeid="2092">c</strong>, d, e, f]，nums2 = [m]。此时，有以下 3 种可能性：</p>
<ol data-nodeid="1845">
<li data-nodeid="1846">
<p data-nodeid="1847">如果 m &lt; c，则结果为 c；</p>
</li>
<li data-nodeid="1848">
<p data-nodeid="1849">如果 c &lt; m &lt; d，则结果为 m；</p>
</li>
<li data-nodeid="1850">
<p data-nodeid="1851" class="">如果m &gt; d，则结果为 d。</p>
</li>
</ol>
<p data-nodeid="1852">这 3 个情况，可以利用"A?B:C"合并为一个表达式，即 m &lt; c ? c : (m &lt; d? m : d)。</p>
<p data-nodeid="1853"><strong data-nodeid="2130">可能性三</strong>：nums1 奇数个，nums2 有 2 个元素。例如，nums1 = [a, b, <strong data-nodeid="2131">c</strong>, d, e]，nums2 = [<strong data-nodeid="2132">m</strong>,n]。此时，有以下 6 种可能性：</p>
<ol data-nodeid="1854">
<li data-nodeid="1855">
<p data-nodeid="1856">如果 n &lt; b，则结果为 b；</p>
</li>
<li data-nodeid="1857">
<p data-nodeid="1858">如果 b &lt; n &lt; c，则结果为 n；</p>
</li>
<li data-nodeid="1859">
<p data-nodeid="1860">如果 c &lt; n &lt; d，则结果为 max(c,m)；</p>
</li>
<li data-nodeid="1861">
<p data-nodeid="1862">如果 n &gt; d，m &lt; c，则结果为 c；</p>
</li>
<li data-nodeid="1863">
<p data-nodeid="1864">如果 n &gt; d，c &lt; m &lt; d，则结果为 m；</p>
</li>
<li data-nodeid="1865">
<p data-nodeid="1866">如果 n &gt; d，m &gt; d，则结果为 d。</p>
</li>
</ol>
<p data-nodeid="1867">其中，4～6 可以合并为，如果 n &gt; d，则返回 m &lt; c ? c : (m &lt; d ? m : d)。</p>
<p data-nodeid="1868" class=""><img src="https://s0.lgstatic.com/i/image/M00/32/6C/Ciqc1F8Odd-AdDghAAAd2xZYP1g802.png" alt="image (4).png" data-nodeid="2162"></p>
<p data-nodeid="1869"><strong data-nodeid="2182">可能性四</strong>：nums1 偶数个，nums2 有 2 个元素。例如，nums1 = [a, b, <strong data-nodeid="2183">c</strong>, d, e, f]，nums2 = [<strong data-nodeid="2184">m</strong>,n]。此时，有以下 6 种可能性：</p>
<ol data-nodeid="1870">
<li data-nodeid="1871">
<p data-nodeid="1872">如果 n &lt; b，则结果为 b；</p>
</li>
<li data-nodeid="1873">
<p data-nodeid="1874" class="">如果 b &lt; n &lt; c，则结果为 n；</p>
</li>
<li data-nodeid="1875">
<p data-nodeid="1876" class="">如果 c &lt; n &lt; d，则结果为 max(c,m)；</p>
</li>
<li data-nodeid="1877">
<p data-nodeid="1878" class="">如果 n &gt; d，m &lt; c，则结果为 c；</p>
</li>
<li data-nodeid="1879">
<p data-nodeid="1880">如果 n &gt; d，c &lt; m &lt; d，则结果为 m；</p>
</li>
<li data-nodeid="1881">
<p data-nodeid="1882">如果 n &gt; d，m &gt; d，则结果为 d。与可能性 3 完全一致。</p>
</li>
</ol>
<p data-nodeid="1883">不难发现，终止条件都是 if 和 else 的判断，虽然逻辑有点复杂，但时间复杂度是 O(1) 。为了简便，我们可以假定，nums1 的数字数量永远是不少于 nums2 的数字数量。</p>
<p data-nodeid="1884"><strong data-nodeid="2212">因此，我们可以编写如下的代码</strong>：</p>
<pre class="lang-java" data-nodeid="2231"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-keyword">int</span>[] nums1 = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
    <span class="hljs-keyword">int</span>[] nums2 = {<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>};
    <span class="hljs-keyword">int</span> median = getMedian(nums1,<span class="hljs-number">0</span>, nums1.length-<span class="hljs-number">1</span>, nums2, <span class="hljs-number">0</span>, nums2.length-<span class="hljs-number">1</span>);
    System.out.println(median);
}


<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMedian</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> begina, <span class="hljs-keyword">int</span> enda, <span class="hljs-keyword">int</span>[] b, <span class="hljs-keyword">int</span> beginb, <span class="hljs-keyword">int</span> endb )</span> </span>{
    <span class="hljs-keyword">if</span> (enda - begina == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> a[begina] &gt; b[beginb] ? b[beginb] : a[begina];
    }
    <span class="hljs-keyword">if</span> (enda - begina == <span class="hljs-number">1</span>){
        <span class="hljs-keyword">if</span> (a[begina] &lt; b[beginb]) {
            <span class="hljs-keyword">return</span> b[beginb] &gt; a[enda] ? a[enda] : b[beginb];
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> a[begina] &lt; b[endb] ? a[begina] : b[endb];
        }
    }
    <span class="hljs-keyword">if</span> (endb-beginb &lt; <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">if</span> ((endb - beginb == <span class="hljs-number">0</span>) &amp;&amp; (enda - begina)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">int</span> m = b[beginb];
            <span class="hljs-keyword">int</span> bb = a[(enda + begina)/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">int</span> c = a[(enda + begina)/<span class="hljs-number">2</span>];
            <span class="hljs-keyword">return</span> (m &lt; bb) ? bb : (m &lt; c ? m : c);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((endb - beginb == <span class="hljs-number">0</span>) &amp;&amp; (enda - begina)%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">int</span> m = b[beginb];
            <span class="hljs-keyword">int</span> c = a[(enda + begina)/<span class="hljs-number">2</span>];
            <span class="hljs-keyword">int</span> d = a[(enda + begina)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">return</span> m &lt; c ? c : (m &lt; d ? m : d);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> m = b[beginb];
            <span class="hljs-keyword">int</span> n = b[endb];
            <span class="hljs-keyword">int</span> bb = a[(enda + begina)/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>];
            <span class="hljs-keyword">int</span> c = a[(enda + begina)/<span class="hljs-number">2</span>];
            <span class="hljs-keyword">int</span> d = a[(enda + begina)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (n&lt;bb) {
                <span class="hljs-keyword">return</span> bb;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n&gt;bb &amp;&amp; n &lt; c) {
                <span class="hljs-keyword">return</span> n;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; c &amp;&amp; n &lt; d) {
                <span class="hljs-keyword">return</span> m &gt; c ? m : c;
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> m &lt; c ? c : (m&lt;d ? m : d);
            }
        }
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">int</span> mida = (enda + begina)/<span class="hljs-number">2</span>;
        <span class="hljs-keyword">int</span> midb = (endb + beginb)/<span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (a[mida] &lt; b[midb]) {
            <span class="hljs-keyword">int</span> step = endb - midb;
            <span class="hljs-keyword">return</span> getMedian(a,begina + step, enda, b, beginb, endb - step);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> step = midb - beginb;
            <span class="hljs-keyword">return</span> getMedian(a,begina,enda - step, b, beginb+ step, endb );
        }
    }
</code></pre>

<p data-nodeid="1886"><strong data-nodeid="2217">我们对代码进行解读</strong>。在第 1～6 行是主函数，进入 getMedian() 中，入参分别是 nums1 数组，nums1 数组搜索范围的起止索引；nums2 数组，nums2 数组搜索范围的起止索引。并进入第 8 行的函数中。</p>
<p data-nodeid="1887">在 getMedian() 函数中，第 53～64 行是二分策略，第 9～52 行是终止条件。我们先看二分部分。通过第 56 行，判断 a 和 b 的中位数的大小关系，决策剔除哪个部分。并在第 58 行和 62 行，递归地执行二分动作缩小范围。</p>
<p data-nodeid="1888">终止条件的第一种可能性在第 21～26 行，第二种可能性在 27～32 行，第三种和第四种可能性完全一致，在 33～52 行。另外，在 9～19 行中处理了两个特殊情况，分别是第 9～11 行，处理了两个数组都只剩 1 个元素的情况；第 12～19 行，处理了两个数组都只剩 2 个元素的情况。</p>
<p data-nodeid="1889">这段代码的逻辑并不复杂，但写起来还是有很多情况需要考虑的。希望你能认真阅读。</p>
<h3 data-nodeid="1890"><strong data-nodeid="2224">总结</strong></h3>
<p data-nodeid="1891">综合来看，力扣的题目还是比较受到行业的认可的。一方面是它的题库内题目数量多，另一方面是很多人会在上面提交相同题目的不同解法和答案。但对初学者来说，它还是有一些不友好的。这主要在于，它的定位只是题库，并不能提供完整的解决问题的思维逻辑和方法论。</p>
<p data-nodeid="1892">本课时，虽然我们只是举了两个例题，但其背后解题的思考方法是通用的。建议你能围绕本课程学到的解题方法，利用空闲时间去把力扣热门的题目都练习一遍。</p>
<h3 data-nodeid="1893">练习题</h3>
<p data-nodeid="1894">最后，我们再给出一道练习题。给定一个链表，删除链表的倒数第 n 个节点。</p>
<p data-nodeid="1895">例如，给定一个链表: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, 和 n = 2。当删除了倒数第二个节点后，链表变为 1 -&gt; 2 -&gt; 3 -&gt; 5。</p>
<p data-nodeid="1896" class="">你可以假设，给定的 n 是有效的。额外要求就是，要在一趟扫描中实现，即时间复杂度是 O(n)。这里给你一个提示，可以采用快慢指针的方法。</p>

---

### 精选评论

##### **博：
> 快指针先走n步，再一起走，当快指针走到尾，慢指针就在倒数第n个节点了。

##### 裘：
> 请问老师，{12349}{5678}这两组数据的中位数不是5吗，不就是在D区吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 首先要比较二者的中位数。你给的例子分别是3和6。因为3<6，所以A区和F区应该被删掉等量的数字。

##### **飞：
> 看了两遍，终于是把案例二的思路看懂了，尤其是删除等量数字，😩😩😩

##### **军：
> 例题 2：查找两个有序数组合并后的中位数----------按二分和剔除中位数不可能存在的部分 的逻辑，有逻辑上分析可以把终止条件设置为：直至较短的数组只剩1个元素。这样终止的可能性就只有 一和二，三和四不用考虑了。

##### *川：
> 例2中的中位数可能出现在C或D区，没有绝对。如n1=｛1,3,5,6,9｝，n2=｛2,7,8,12｝，C区为6和9，这个中位数就是6。同样的构造数据，也可能出现在D区。

##### **兵：
> 例题2终于明白删除的原理的……

##### **看：
> 老师请问例题2 为啥不能先把两个数组用归并排序组合在一起 ，在用二分查找找中位数

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这样做，时间复杂度是O(n)，空间复杂度也是O(n)

##### **用户6542：
> 快慢指针，快指针先走完，慢指针刚好走到一半，就可以得到链表长度，再比较跟n的距离，继续走就到了

