<p data-nodeid="102269" class="">作为一个 Java 程序员，你应该已经具备了使用 JDBC 操作数据库的基础技能。在使用 JDBC 的时候，你会发现 JDBC 的数据类型与 Java 语言中的数据类型虽然有点对应关系，如下图所示，但还是无法做到一一对应，也自然无法做到自动映射。</p>
<p data-nodeid="102270"><img src="https://s0.lgstatic.com/i/image6/M00/02/E6/Cgp9HWAeMiSAcga0AAEpsa9onlg651.png" alt="Drawing 0.png" data-nodeid="102365"></p>
<div data-nodeid="102271"><p style="text-align:center">数据库类型与 Java 类型对应图表</p></div>
<p data-nodeid="102272">在使用 PreparedStatement 执行 SQL 语句之前，都是需要手动调用 setInt()、setString() 等 set 方法绑定参数，这不仅仅是告诉 JDBC 一个 SQL 模板中哪个占位符需要使用哪个实参，还会将数据从 Java 类型转换成 JDBC 类型。当从 ResultSet 中获取数据的时候，则是一个逆过程，数据会从 JDBC 类型转换为 Java 类型。</p>
<p data-nodeid="102273">可以使用 MyBatis 中的<strong data-nodeid="102372">类型转换器</strong>，完成上述两次类型转换，如下图所示：</p>
<p data-nodeid="102274"><img src="https://s0.lgstatic.com/i/image6/M00/02/E4/CioPOWAeMi6AdTRAAAENMX_HsyU054.png" alt="Drawing 1.png" data-nodeid="102375"></p>
<div data-nodeid="102275"><p style="text-align:center">JDBC 类型数据与 Java 类型数据转换示意图</p></div>
<h3 data-nodeid="102276">深入 TypeHandler</h3>
<p data-nodeid="102277">说了这么多，类型转换器到底是怎么定义的呢？其实，<strong data-nodeid="102382">MyBatis 中的类型转换器就是 TypeHandler 这个接口</strong>，其定义如下：</p>
<pre class="lang-java" data-nodeid="102278"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TypeHandler</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
&nbsp; <span class="hljs-comment">// 在通过PreparedStatement为SQL语句绑定参数时，会将传入的实参数据由JdbcType类型转换成Java类型</span>
&nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-keyword">int</span> i, T parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
&nbsp; <span class="hljs-comment">// 从ResultSet中获取数据时会使用getResult()方法，其中会将读取到的数据由Java类型转换成JdbcType类型</span>
&nbsp; <span class="hljs-function">T <span class="hljs-title">getResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
&nbsp; <span class="hljs-function">T <span class="hljs-title">getResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
&nbsp; <span class="hljs-function">T <span class="hljs-title">getResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
}
</code></pre>
<p data-nodeid="102279"><strong data-nodeid="102387">MyBatis 中定义了 BaseTypeHandler 抽象类来实现一些 TypeHandler 的公共逻辑</strong>，BaseTypeHandler 在实现 TypeHandler 的同时，还实现了 TypeReference 抽象类。其继承关系如下图所示：</p>
<p data-nodeid="102280"><img src="https://s0.lgstatic.com/i/image6/M00/02/E4/CioPOWAeMkCANy6LAABJPBfXPJY527.png" alt="Drawing 2.png" data-nodeid="102390"></p>
<div data-nodeid="102281"><p style="text-align:center">TypeHandler 继承关系图</p></div>
<p data-nodeid="102282">在 BaseTypeHandler 中，简单实现了 TypeHandler 接口的 setParameter() 方法和 getResult() 方法。</p>
<ul data-nodeid="102283">
<li data-nodeid="102284">
<p data-nodeid="102285">在 setParameter() 实现中，会判断传入的 parameter 实参是否为空，如果为空，则调用 PreparedStatement.setNull() 方法进行设置；如果不为空，则委托 setNonNullParameter() 这个抽象方法进行处理，setNonNullParameter() 方法由 BaseTypeHandler 的子类提供具体实现。</p>
</li>
<li data-nodeid="102286">
<p data-nodeid="102287">在 getResult() 的三个重载实现中，会直接调用相应的 getNullableResult() 抽象方法，这里有三个重载的 getNullableResult() 抽象方法，它们都由 BaseTypeHandler 的子类提供具体实现。</p>
</li>
</ul>
<p data-nodeid="102288">BaseTypeHandler 的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis" data-nodeid="102397">源码</a>进行学习。</p>
<p data-nodeid="102289">下图展示了 BaseTypeHandler 的全部实现类，虽然实现类比较多，但是它们的实现方式大同小异。</p>
<p data-nodeid="102290"><img src="https://s0.lgstatic.com/i/image6/M00/02/E6/Cgp9HWAeMkuAI22uAApwhcDLfQ4596.png" alt="Drawing 3.png" data-nodeid="102402"></p>
<div data-nodeid="102291"><p style="text-align:center">BaseTypeHandler 实现类示意图</p></div>
<p data-nodeid="102292">这里我们以 LongTypeHandler 为例进行分析，具体实现如下：</p>
<pre class="lang-java" data-nodeid="102293"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongTypeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTypeHandler</span>&lt;<span class="hljs-title">Long</span>&gt; </span>{
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNonNullParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-keyword">int</span> i, Long parameter, JdbcType jdbcType)</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 调用PreparedStatement.setLong()实现参数绑定</span>
&nbsp; &nbsp; &nbsp; &nbsp; ps.setLong(i, parameter);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 调用ResultSet.getLong()获取指定列值</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">long</span> result = rs.getLong(columnName);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span> &amp;&amp; rs.wasNull() ? <span class="hljs-keyword">null</span> : result;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> columnIndex)</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 调用ResultSet.getLong()获取指定列值</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">long</span> result = rs.getLong(columnIndex);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span> &amp;&amp; rs.wasNull() ? <span class="hljs-keyword">null</span> : result;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-keyword">int</span> columnIndex)</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 调用ResultSet.getLong()获取指定列值</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">long</span> result = cs.getLong(columnIndex);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> result == <span class="hljs-number">0</span> &amp;&amp; cs.wasNull() ? <span class="hljs-keyword">null</span> : result;
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="102294">可以看到：LongTypeHandler 的核心还是通过 PreparedStatement.setLong() 方法以及 ResultSet.getLong() 方法实现的。至于其他 BaseTypeHandler 的核心实现，同样也是依赖了 JDBC 的 API，这里就不再展开介绍了。</p>
<h3 data-nodeid="102295">TypeHandler 注册</h3>
<p data-nodeid="102296">了解了 TypeHandler 接口实现类的核心原理之后，我们就来解决下面两个问题：</p>
<ul data-nodeid="102297">
<li data-nodeid="102298">
<p data-nodeid="102299">MyBatis 如何管理这么多的 TypeHandler 接口实现呢？</p>
</li>
<li data-nodeid="102300">
<p data-nodeid="102301">如何在合适的场景中使用合适的 TypeHandler 实现进行类型转换呢？</p>
</li>
</ul>
<p data-nodeid="102302">你若使用过 MyBatis 的话，应该知道我们可以在 mybatis-config.xml 中通过 标签配置自定义的 TypeHandler 实现，也可以在 Mapper.xml 配置文件定义 的时候指定 typeHandler 属性。无论是哪种配置方式，MyBatis 都会在初始化过程中，获取所有已知的 TypeHandler（包括内置实现和自定义实现），然后创建所有 TypeHandler 实例并注册到 TypeHandlerRegistry 中，<strong data-nodeid="102414">由 TypeHandlerRegistry 统一管理所有 TypeHandler 实例</strong>。</p>
<p data-nodeid="102303"><br>
TypeHandlerRegistry 管理 TypeHandler 的时候，用到了以下四个最核心的集合。</p>
<ul data-nodeid="102304">
<li data-nodeid="102305">
<p data-nodeid="102306">jdbcTypeHandlerMap（Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;类型）：该集合记录了 JdbcType 与 TypeHandler 之间的关联关系。JdbcType 是一个枚举类型，每个 JdbcType 枚举值对应一种 JDBC 类型，例如，JdbcType.VARCHAR 对应的就是 JDBC 中的 varchar 类型。在从 ResultSet 中读取数据的时候，就会从 JDBC_TYPE_HANDLER_MAP 集合中根据 JDBC 类型查找对应的 TypeHandler，将数据转换成 Java 类型。</p>
</li>
<li data-nodeid="102307">
<p data-nodeid="102308">typeHandlerMap（Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;类型）：该集合第一层 Key 是需要转换的 Java 类型，第二层 Key 是转换的目标 JdbcType，最终的 Value 是完成此次转换时所需要使用的 TypeHandler 对象。那为什么要有两层 Map 的设计呢？这里我们举个例子：Java 类型中的 String 可能转换成数据库中的 varchar、char、text 等多种类型，存在一对多关系，所以就可能有不同的 TypeHandler 实现。</p>
</li>
<li data-nodeid="102309">
<p data-nodeid="102310">allTypeHandlersMap（Map&lt;Class, TypeHandler&gt;类型）：该集合记录了全部 TypeHandler 的类型以及对应的 TypeHandler 实例对象。</p>
</li>
<li data-nodeid="102311">
<p data-nodeid="102312">NULL_TYPE_HANDLER_MAP（Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;类型）：空 TypeHandler 集合的标识，默认值为 Collections.emptyMap()。</p>
</li>
</ul>
<p data-nodeid="102313">在 MyBatis 初始化的时候，实例化全部 TypeHandler 对象之后，会立即调用 TypeHandlerRegistry 的 register() 方法完成这些 TypeHandler 对象的注册，这个注册过程的核心逻辑就是向上述四个核心集合中添加 TypeHandler 实例以及与 Java 类型、JDBC 类型之间的映射。</p>
<p data-nodeid="102314">TypeHandlerRegistry.register() 方法有多个重载实现，这些重载中最基础的实现是三个参数的重载实现，具体实现如下：</p>
<pre class="lang-java" data-nodeid="102315"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (javaType != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 检测是否明确指定了TypeHandler能够处理的Java类型</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 根据指定的Java类型，从typeHandlerMap集合中获取相应的TypeHandler集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (map == <span class="hljs-keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 将TypeHandler实例记录到typeHandlerMap集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; map.put(jdbcType, handler);
&nbsp; &nbsp; &nbsp; &nbsp; typeHandlerMap.put(javaType, map);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 向allTypeHandlersMap集合注册TypeHandler类型和对应的TypeHandler对象</span>
&nbsp; &nbsp; allTypeHandlersMap.put(handler.getClass(), handler);
}
</code></pre>
<p data-nodeid="102316">除了上面的 register() 重载，在有的 register() 重载中会尝试从 TypeHandler 类中的@MappedTypes 注解和 @MappedJdbcTypes 注解中读取信息。其中，<strong data-nodeid="102457">@MappedTypes 注解中可以配置 TypeHandler 实现类能够处理的 Java 类型的集合，@MappedJdbcTypes 注解中可以配置该 TypeHandler 实现类能够处理的 JDBC 类型集合</strong>。</p>
<p data-nodeid="102317">如下就是读取 @MappedJdbcTypes 注解的 register() 重载方法：</p>
<pre class="lang-java" data-nodeid="102318"><code data-language="java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 尝试从TypeHandler类中获取@MappedJdbcTypes注解</span>
&nbsp; &nbsp; MappedJdbcTypes mappedJdbcTypes = typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mappedJdbcTypes != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; // 根据<span class="hljs-meta">@MappedJdbcTypes</span>注解指定的JDBC类型进行注册
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 交给前面的三参数重载处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register(javaType, handledJdbcType, typeHandler);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果支持jdbcType为null，也是交给前面的三参数重载处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register(javaType, <span class="hljs-keyword">null</span>, typeHandler);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果没有配置MappedJdbcTypes注解，也是交给前面的三参数重载处理</span>
&nbsp; &nbsp; &nbsp; &nbsp; register(javaType, <span class="hljs-keyword">null</span>, typeHandler);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="102319">下面是读取 @MappedTypes 注解的 register() 方法重载：</p>
<pre class="lang-java" data-nodeid="102320"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(TypeHandler&lt;T&gt; typeHandler)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">boolean</span> mappedTypeFound = <span class="hljs-keyword">false</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 读取TypeHandler类中定义的@MappedTypes注解</span>
&nbsp; &nbsp; MappedTypes mappedTypes = typeHandler.getClass().getAnnotation(MappedTypes.class);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (mappedTypes != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; // 根据<span class="hljs-meta">@MappedTypes</span>注解中指定的Java类型进行注册
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 交给前面介绍的register()重载读取@MappedJdbcTypes注解并完成注册</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register(handledType, typeHandler);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mappedTypeFound = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 从3.1.0版本开始，如果TypeHandler实现类同时继承了TypeReference这个抽象类，</span>
&nbsp; &nbsp; <span class="hljs-comment">// 这里会尝试自动查找对应的Java类型</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="hljs-keyword">instanceof</span> TypeReference) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">try</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 交给前面介绍的register()重载读取@MappedJdbcTypes注解并完成注册</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register(typeReference.getRawType(), typeHandler);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mappedTypeFound = <span class="hljs-keyword">true</span>;
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">catch</span> (Throwable t) {
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (!mappedTypeFound) {
&nbsp; &nbsp; &nbsp; &nbsp; register((Class&lt;T&gt;) <span class="hljs-keyword">null</span>, typeHandler);
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="102321">我们接下来看最后一个 register() 重载。<strong data-nodeid="102469">TypeHandlerRegistry 提供了扫描一个包下的全部 TypeHandler 接口实现类的 register() 重载</strong>。在该重载中，会首先读取指定包下面的全部的 TypeHandler 实现类，然后再交给 register() 重载读取 @MappedTypes 注解和 @MappedJdbcTypes 注解，并最终完成注册。这个 register() 重载的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis" data-nodeid="102467">源码</a>进行学习。</p>
<p data-nodeid="102322">最后，我们再来看看 TypeHandlerRegistry 的构造方法，其中会通过 register() 方法注册多个 TypeHandler 对象，下面就展示了为 String 类型注册 TypeHandler 的核心实现：</p>
<pre class="lang-java" data-nodeid="102323"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TypeHandlerRegistry</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// StringTypeHandler可以实现String类型与char、varchar、longvarchar类型之间的转换</span>
&nbsp; &nbsp; register(String.class, JdbcType.CHAR, <span class="hljs-keyword">new</span> StringTypeHandler());
&nbsp; &nbsp; register(String.class, JdbcType.VARCHAR, <span class="hljs-keyword">new</span> StringTypeHandler());
&nbsp; &nbsp; register(String.class, JdbcType.LONGVARCHAR, <span class="hljs-keyword">new</span> StringTypeHandler());
&nbsp; &nbsp; <span class="hljs-comment">// ClobTypeHandler可以完成String类型与clob类型之间的转换</span>
&nbsp; &nbsp; register(String.class, JdbcType.CLOB, <span class="hljs-keyword">new</span> ClobTypeHandler());
&nbsp; &nbsp; <span class="hljs-comment">// NStringTypeHandler可以完成String类型与NVARCHAR、NCHAR类型之间的转换</span>
&nbsp; &nbsp; register(String.class, JdbcType.NVARCHAR, <span class="hljs-keyword">new</span> NStringTypeHandler());
&nbsp; &nbsp; register(String.class, JdbcType.NCHAR, <span class="hljs-keyword">new</span> NStringTypeHandler());
&nbsp; &nbsp; <span class="hljs-comment">// NClobTypeHandler可以完成String类型与NCLOB类型之间的转换</span>
&nbsp; &nbsp; register(String.class, JdbcType.NCLOB, <span class="hljs-keyword">new</span> NClobTypeHandler());
&nbsp; &nbsp; <span class="hljs-comment">// 省略其他TypeHandler实现的注册逻辑</span>
}
</code></pre>
<h3 data-nodeid="102324">TypeHandler 查询</h3>
<p data-nodeid="102325">分析完注册 TypeHandler 实例的具体实现之后，我们接下来就来看看 MyBatis 是如何从 TypeHandlerRegistry 底层的这几个集合中查找正确的 TypeHandler 实例，<strong data-nodeid="102477">该功能的具体实现是在 TypeHandlerRegistry 的 getTypeHandler() 方法中</strong>。</p>
<p data-nodeid="102326">这里的 getTypeHandler() 方法也有多个重载，最核心的重载是 getTypeHandler(Type,JdbcType) 这个重载方法，其中会根据传入的 Java 类型和 JDBC 类型，从底层的几个集合中查询相应的 TypeHandler 实例，具体实现如下：</p>
<pre class="lang-java" data-nodeid="102327"><code data-language="java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">TypeHandler&lt;T&gt; <span class="hljs-title">getTypeHandler</span><span class="hljs-params">(Type type, JdbcType jdbcType)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (ParamMap.class.equals(type)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 过滤掉ParamMap类型</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 根据Java类型查找对应的TypeHandler集合</span>
&nbsp; &nbsp; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = getJdbcHandlerMap(type);
&nbsp; &nbsp; TypeHandler&lt;?&gt; handler = <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (jdbcHandlerMap != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 根据JdbcType类型查找对应的TypeHandler实例</span>
&nbsp; &nbsp; &nbsp; &nbsp; handler = jdbcHandlerMap.get(jdbcType);
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 没有对应的TypeHandler实例，则使用null对应的TypeHandler</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handler = jdbcHandlerMap.get(<span class="hljs-keyword">null</span>);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果jdbcHandlerMap只注册了一个TypeHandler，则使用此TypeHandler对象</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; handler = pickSoleHandler(jdbcHandlerMap);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> (TypeHandler&lt;T&gt;) handler;
}
</code></pre>
<p data-nodeid="102328">在 getTypeHandler() 方法中会调用 getJdbcHandlerMap() 方法检测 typeHandlerMap 集合中相应的 TypeHandler 集合是否已经初始化。</p>
<ul data-nodeid="102329">
<li data-nodeid="102330">
<p data-nodeid="102331">如果已初始化，则直接使用该集合进行查询；</p>
</li>
<li data-nodeid="102332">
<p data-nodeid="102333">如果未初始化，则尝试以传入的 Java 类型的、已初始化的父类对应的 TypeHandler 集合作为初始集合；</p>
</li>
<li data-nodeid="102334">
<p data-nodeid="102335">如果该 Java 类型的父类没有关联任何已初始化的 TypeHandler 集合，则将该 Java 类型对应的 TypeHandler 集合初始化为 NULL_TYPE_HANDLER_MAP 标识。</p>
</li>
</ul>
<p data-nodeid="102336">getJdbcHandlerMap() 方法具体实现如下：</p>
<pre class="lang-java" data-nodeid="102337"><code data-language="java"><span class="hljs-keyword">private</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; getJdbcHandlerMap(Type type) {
&nbsp; &nbsp; <span class="hljs-comment">// 首先查找指定Java类型对应的TypeHandler集合</span>
&nbsp; &nbsp; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = typeHandlerMap.get(type);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (NULL_TYPE_HANDLER_MAP.equals(jdbcHandlerMap)) { <span class="hljs-comment">// 检测是否为空集合标识</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 初始化指定Java类型的TypeHandler集合</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (jdbcHandlerMap == <span class="hljs-keyword">null</span> &amp;&amp; type <span class="hljs-keyword">instanceof</span> Class) {
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (Enum.class.isAssignableFrom(clazz)) { // 针对枚举类型的处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; enumClass = clazz.isAnonymousClass() ? clazz.getSuperclass() : clazz;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jdbcHandlerMap = getJdbcHandlerMapForEnumInterfaces(enumClass, enumClass);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (jdbcHandlerMap == <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; register(enumClass, getInstance(enumClass, defaultEnumTypeHandler));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> typeHandlerMap.get(enumClass);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 查找父类关联的TypeHandler集合，并将其作为clazz对应的TypeHandler集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jdbcHandlerMap = getJdbcHandlerMapForSuperclass(clazz);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 如果上述查找皆失败，则以NULL_TYPE_HANDLER_MAP作为clazz对应的TypeHandler集合</span>
&nbsp; &nbsp; typeHandlerMap.put(type, jdbcHandlerMap == <span class="hljs-keyword">null</span> ?&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NULL_TYPE_HANDLER_MAP : jdbcHandlerMap);
&nbsp; &nbsp; <span class="hljs-keyword">return</span> jdbcHandlerMap;
}
</code></pre>
<p data-nodeid="102338">这里调用的 getJdbcHandlerMapForSuperclass() 方法会判断传入的 clazz 的父类是否为空或 Object。如果是，则方法直接返回 null；如果不是，则尝试从 typeHandlerMap 集合中获取父类对应的 TypeHandler 集合，但如果父类没有关联 TypeHandler 集合，则递归调用 getJdbcHandlerMapForSuperclass() 方法顺着继承树继续向上查找父类，直到查找到父类的 TypeHandler 集合，然后直接返回。</p>
<p data-nodeid="102339">下面是 getJdbcHandlerMapForSuperclass() 方法的具体实现：</p>
<pre class="lang-java" data-nodeid="102340"><code data-language="java"><span class="hljs-keyword">private</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; getJdbcHandlerMapForSuperclass(Class&lt;?&gt; clazz) {
&nbsp; &nbsp; Class&lt;?&gt; superclass = clazz.getSuperclass();
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (superclass == <span class="hljs-keyword">null</span> || Object.class.equals(superclass)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 父类为Object或null则查找结束</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; jdbcHandlerMap = typeHandlerMap.get(superclass);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (jdbcHandlerMap != <span class="hljs-keyword">null</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> jdbcHandlerMap;
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 顺着继承树，递归查找父类对应的TypeHandler集合</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> getJdbcHandlerMapForSuperclass(superclass);
&nbsp; &nbsp; }
}
</code></pre>
<h3 data-nodeid="102341">别名管理</h3>
<p data-nodeid="102342">在《02 | 订单系统持久层示例分析，20 分钟带你快速上手 MyBatis》分析的 MyBatis 示例中，我们在 mybatis-config.xml 配置文件中使用 <code data-backticks="1" data-nodeid="102500">&lt;typeAlias&gt;</code> 标签为 Customer 等 Java 类的完整名称定义了相应的别名，后续编写 SQL 语句、定义 <code data-backticks="1" data-nodeid="102502">&lt;resultMap&gt;</code> 的时候，<strong data-nodeid="102508">直接使用这些别名即可完全替代相应的完整 Java 类名，这样就非常易于代码的编写和维护</strong>。</p>
<p data-nodeid="102343"><strong data-nodeid="102517">TypeAliasRegistry 是维护别名配置的核心实现所在</strong>，其中提供了别名注册、别名查询的基本功能。在 TypeAliasRegistry 的 typeAliases 字段（Map&lt;String, Class&lt;?&gt;&gt;类型）中记录了别名与 Java 类型之间的对应关系，我们可以通过 registerAlias() 方法完成别名的注册，具体实现如下：</p>
<pre class="lang-java" data-nodeid="102344"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(String alias, Class&lt;?&gt; value)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (alias == <span class="hljs-keyword">null</span>) { <span class="hljs-comment">// 传入的别名为null，直接抛出异常</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">"The parameter alias cannot be null"</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 将别名全部转换为小写</span>
&nbsp; &nbsp; String key = alias.toLowerCase(Locale.ENGLISH);
&nbsp; &nbsp; <span class="hljs-comment">// 检测别名是否存在冲突，如果存在冲突，则直接抛出异常</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (typeAliases.containsKey(key) &amp;&amp; typeAliases.get(key) != <span class="hljs-keyword">null</span> &amp;&amp; !typeAliases.get(key).equals(value)) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TypeException(<span class="hljs-string">"..."</span>);
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 在typeAliases集合中记录别名与类之间的映射关系</span>
&nbsp; &nbsp; typeAliases.put(key, value);
}
</code></pre>
<p data-nodeid="102345">在 TypeAliasRegistry 的构造方法中，会通过上述 registerAlias() 方法将 Java 的基本类型、基本类型的数组类型、基本类型的封装类、封装类型的数组类型、Date、BigDecimal、BigInteger、Map、HashMap、List、ArrayList、Collection、Iterator、ResultSet 等常用类型添加了别名，具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis" data-nodeid="102521">源码</a>进行学习。</p>
<p data-nodeid="102346">除了明确传入别名与相应的 Java 类型之外，TypeAliasRegistry 还提供了扫描指定包名下所有的类中的 @Alias 注解获取别名配置，并完成注册的功能，这个功能涉及两个 registerAliases() 方法的重载，相关实现如下：</p>
<pre class="lang-java" data-nodeid="102347"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAliases</span><span class="hljs-params">(String packageName, Class&lt;?&gt; superType)</span> </span>{
&nbsp; &nbsp; ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="hljs-keyword">new</span> ResolverUtil&lt;&gt;();
&nbsp; &nbsp; <span class="hljs-comment">// 查找指定包下所有的superType类型</span>
&nbsp; &nbsp; resolverUtil.find(<span class="hljs-keyword">new</span> ResolverUtil.IsA(superType), packageName);
&nbsp; &nbsp; Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (Class&lt;?&gt; type : typeSet) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 过滤掉内部类、接口以及抽象类</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 扫描类中的@Alias注解</span>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; registerAlias(type);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerAlias</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 获取类的简单名称，其中不会包含包名</span>
&nbsp; &nbsp; String alias = type.getSimpleName();
&nbsp; &nbsp; <span class="hljs-comment">// 获取类中的@Alias注解</span>
&nbsp; &nbsp; Alias aliasAnnotation = type.getAnnotation(Alias.class);
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (aliasAnnotation != <span class="hljs-keyword">null</span>) { // 获取特定别名
&nbsp; &nbsp; &nbsp; &nbsp; alias = aliasAnnotation.value();
&nbsp; &nbsp; }
&nbsp; &nbsp; // 这里的<span class="hljs-meta">@Alias</span>注解指定的别名与type类型绑定
&nbsp; &nbsp; registerAlias(alias, type);
}
</code></pre>
<h3 data-nodeid="102348">总结</h3>
<p data-nodeid="102349">在这一讲我们重点介绍了 MyBatis 中 JdbcType 与 Java 类型之间转换的相关实现。</p>
<ul data-nodeid="102350">
<li data-nodeid="102351">
<p data-nodeid="102352">首先，介绍了 JdbcType 与 Java 类型之间的常见映射关系，以及两种类型之间转换的基础知识；</p>
</li>
<li data-nodeid="102353">
<p data-nodeid="102354">然后，深入分析了 TypeHandler 接口及其核心实现，了解了两种类型转换的原理；</p>
</li>
<li data-nodeid="102355">
<p data-nodeid="102356">接下来，又讲解了 TypeHandler 的注册和查询机制，明确了 MyBatis 是如何管理和使用众多的 TypeHandler 实现；</p>
</li>
<li data-nodeid="102357">
<p data-nodeid="102358">最后，分析了 MyBatis 中的别名实现。</p>
</li>
</ul>
<p data-nodeid="102359">关于这部分的内容，如果你有什么问题，欢迎你在留言区与我分享和交流。在下一讲，我将接着介绍 MyBatis 中日志模块的相关内容，记得按时来听课。</p>
<hr data-nodeid="102534">
<p data-nodeid="102535"><a href="https://shenceyun.lagou.com/t/Mka" data-nodeid="102542"><img src="https://s0.lgstatic.com/i/image/M00/6D/3E/CgqCHl-s60-AC0B_AAhXSgFweBY762.png" alt="1.png" data-nodeid="102541"></a></p>
<p data-nodeid="102536"><strong data-nodeid="102546">《Java 工程师高薪训练营》</strong></p>
<p data-nodeid="102537" class="te-preview-highlight">实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，<a href="https://shenceyun.lagou.com/t/Mka" data-nodeid="102550">点击链接，提升自己</a>！</p>

---

### 精选评论

##### Lee：
> 思路清晰，受教良多

##### **红：
> 老师，后面会出spring源码分析吗

##### **恒：
> 老师，请教一下为什么在 TypeHandlerRegistry#getTypeHandler(Type, JdbcType) 方法中，首先就要过滤掉 ParamMap 类型

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; ParamMap是MyBatis中的内部类，不应被外部使用。

##### **滨：
> 讲得太好了，一周两次等不及呀

