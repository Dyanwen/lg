<p data-nodeid="59121" class="">到目前为止，你已经知道怎么基于 FaaS 开发 Serverless 应用了。不过你应该可以发现，04讲中的应用很简单（只有一个函数）。而实际情况中，绝大部分应用都是由多个函数组成的，应用部署时需要将所有函数一同部署，并且函数运行依赖 FaaS 环境，这就导致函数代码不能直接在本地运行。这些限制就给我们的应用开发、调试和部署流程带来了挑战，比如：</p>
<ul data-nodeid="59122">
<li data-nodeid="59123">
<p data-nodeid="59124">函数太多如何管理？</p>
</li>
<li data-nodeid="59125">
<p data-nodeid="59126">本地开发时如何进行调试？</p>
</li>
<li data-nodeid="59127">
<p data-nodeid="59128">代码开发完成后如何部署？</p>
</li>
<li data-nodeid="59129">
<p data-nodeid="59130">……</p>
</li>
</ul>
<p data-nodeid="59131">要解决这些问题，你就需要一套完整的开发、调试和部署 Serverless 的解决方案，这个解决方案最终可以抽象为一个开发框架。那么什么是 Serverless 开发框架呢？我认为<strong data-nodeid="59277">Serverless 的开发框架不是传统的 Express.js、Spring Boot 等代码框架，而是集成 Serverless 思想、贯穿 Serverless 应用从开发到上线全流程的工具。</strong> 基于 Serverless 开发框架，你很容易开发一个 Serverless 架构的应用，企业也能轻松把现有业务演化为 Serverless 架构。对 Serverless 来说，除了底层的 FaaS、BaaS 等基础设施， 上层的开发框架也是一个非常重要的部分，这直接决定了开发者使用 Serverless 的成本。</p>
<p data-nodeid="59132">这一讲，我以框架开发者的视角，带你思考如何设计并实现一个 Serverless 开发框架，以此让你深入理解开发框架底层设计思路和实现原理，进而明白为什么开发框架能提高 Serverless 应用开发效率。这样一来，当你学完这一讲内容之后，再面对任何开发框架，都能快速上手了，甚至你也能成为一个框架开发者，为广大 Serverless 用户提供更好用的开发工具。</p>
<h3 data-nodeid="59133">如何设计 Serverless 的开发框架</h3>
<p data-nodeid="59134">前面我已经提到，Serverless 开发框架是贯穿 Serverless 应用从开发到上线全流程的工具。基于这个定义，<strong data-nodeid="59285">一个开发框架至少要满足应用管理、应用开发、应用调试和应用部署这几个基本功能。</strong> 从形态上来看，Serverless 开发框架可以抽象为一个平台或服务，最终以终端工具（命令行工具）或控制台的方式提供给开发者使用。接下来我就从这几个方面进行讲解。</p>
<h4 data-nodeid="59135">应用管理</h4>
<p data-nodeid="59136">Serverless 应用是由函数组成的，所以应用的管理主要就是函数的管理。各个 FaaS 平台其实也考虑到了这一点，比如函数计算的 “服务”功能或 Lambda 的 “应用” 功能。你可以把一个应用的函数都创建在同一个 “服务” 下，一个 “服务” 即代表一个应用。</p>
<p data-nodeid="59137"><img src="https://s0.lgstatic.com/i/image2/M01/03/D4/Cip5yF_jCDqAd4mXAAFF8YqIxq8216.png" alt="Drawing 0.png" data-nodeid="59290"></p>
<p data-nodeid="59138">那么如何去描述 “服务” 和 “函数” 的关系呢？因为二者是静态的，不会在代码运行时改变，所以你可以用 YAML 或 JSON 配置文件来表示（我推荐 YAML，因为它可以编写注释，可读性更好）。在创建函数时，你还要指定函数的入口、编程语言、触发器等信息。<strong data-nodeid="59295">所以 YAML 文件的内容可能是这样的：</strong></p>
<pre class="lang-yaml" data-nodeid="59139"><code data-language="yaml"><span class="hljs-comment"># serverless.yaml</span>
<span class="hljs-comment"># 应用名称</span>
<span class="hljs-attr">service:</span> <span class="hljs-string">myservice</span>
<span class="hljs-comment"># 函数列表</span>
<span class="hljs-attr">functions:</span>
    <span class="hljs-comment"># 函数1</span>
  <span class="hljs-attr">hello:</span>
    <span class="hljs-attr">handler:</span> <span class="hljs-string">hello.main</span> <span class="hljs-comment"># 函数入口</span>
    <span class="hljs-attr">runtime:</span> <span class="hljs-string">nodejs12</span>
    <span class="hljs-attr">events:</span> <span class="hljs-comment"># 函数触发器，一个函数可能有多个触发器</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">http</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">timer</span>
  <span class="hljs-comment"># 函数2</span>
  <span class="hljs-attr">goodbye:</span>
    <span class="hljs-attr">handler:</span> <span class="hljs-string">goodbye.main</span>
    <span class="hljs-attr">runtime:</span> <span class="hljs-string">nodejs12</span>
    <span class="hljs-attr">events:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">http</span>
</code></pre>
<p data-nodeid="59140">我来简单讲一下其中的关键属性。</p>
<ul data-nodeid="59141">
<li data-nodeid="59142">
<p data-nodeid="59143">service：应用名称 。</p>
</li>
<li data-nodeid="59144">
<p data-nodeid="59145">functions：它的属性就是组成应用的函数，一个应用可以有多个函数，并且函数名不能重复，例如 hello 和 goodbye 就是 myservice 应用的两个函数。</p>
</li>
<li data-nodeid="59146">
<p data-nodeid="59147">handler ：函数的入口。</p>
</li>
<li data-nodeid="59148">
<p data-nodeid="59149">runtime ：函数运行环境（在 Serverless 中函数的运行环境是预先定义好的）。</p>
</li>
<li data-nodeid="59150">
<p data-nodeid="59151">events：一个函数可能有多个触发器，所以使用 events 数组来表示触发器，例如 hello 函数有 http 和 timer两个触发器。</p>
</li>
</ul>
<p data-nodeid="59152"><strong data-nodeid="59306">这里你要注意，</strong> 当用户不了解你的 YAML 结构时，让用户去编写这个配置文件就很困难了，所以你要为用户提供一个初始化的功能。假设你的终端工具是一个可执行脚本，命令为 serverless，那么你就可以提供 serverless init 命令自动为用户创建一个管理 Serverless 应用的 YAML 配置文件。</p>
<h4 data-nodeid="59153">应用开发</h4>
<p data-nodeid="59154">有了应用配置文件之后，开发者就可以开始开发代码了。为了进一步简化用户操作，你甚至可以提供一些代码模板，然后提供 init 命令让开发者基于模板一键生成一个 Serverless 应用。例如：</p>
<pre class="lang-shell" data-nodeid="59155"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> serverless init --template hello-world</span>
|-- hello.js
|-- serverless.yaml
</code></pre>
<pre class="lang-yaml" data-nodeid="59156"><code data-language="yaml"><span class="hljs-comment"># serverless.yaml</span>
<span class="hljs-attr">service:</span> <span class="hljs-string">myservice</span>
<span class="hljs-attr">functions:</span>
  <span class="hljs-attr">hello:</span>
    <span class="hljs-attr">handler:</span> <span class="hljs-string">hello.main</span>
    <span class="hljs-attr">events:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">http</span>
</code></pre>
<p data-nodeid="59157">这样开发者就能直接在本地用自己喜欢的编辑器编写代码了。</p>
<p data-nodeid="59158">此外你也可以提供一个 Web IDE，在 Web IDE 中为开发者初始化运行环境，这样开发者不用在本地安装编辑器就能开发，也不用关心运行环境的差异。目前各个 FaaS 平台也有提供了自己的 Web IDE，比如 AWS 的 Cloud9、函数计算 Web IDE。</p>
<p data-nodeid="59159"><strong data-nodeid="59318">这里我多说几句，丰富一下你的知识面。</strong> Cloud9 原本是一家创业公司，提供云上应用开发、部署能力，其 Web IDE 功能很强大，不过它在 2016 年 7 月就被 AWS 收购了。另一个比较有趣的事情是，腾讯在 2018 年投资了 Coding，Coding 的重点产品就是 Cloud Studio 这款 Web IDE，之后 Cloud Studio 就集成到了腾讯云中，腾讯云函数的 Web IDE 就是 Cloud Studio。2019 年腾讯则收购了 Coding。函数计算 Web IDE 则是基于 VS Code 开发的。微软在 2019 年 5 月发布了 Visual Studio Online，让开发者可以轻松实现一个 Web IDE。<strong data-nodeid="59319">所以你也能感受到 Serverless 时代 Web IDE 的重要性。</strong></p>
<p data-nodeid="59160">现在你基于 Visual Studio Online 也可以开发一个 Web IDE，当然要做一个完善的 Web IDE 还是很难的，我觉得目前体验最好的 Web IDE 还是 Cloud9，但相比本地开发还是有一定差距，不过我也相信，未来 Web IDE 的体验会越来越好。</p>
<h4 data-nodeid="59161">应用调试</h4>
<p data-nodeid="59162">接着说回来，应用开发结束后，就要进入调试阶段了，<strong data-nodeid="59326">毫不夸张地说，在 Serverless 应用开发中，应用调试十分麻烦。</strong></p>
<p data-nodeid="59163">以《03 | 基础入门：开发你的第一个 Serverless 应用》中的函数为例，函数代码如下：</p>
<pre class="lang-javascript" data-nodeid="59164"><code data-language="javascript">exports.handler = <span class="hljs-function">(<span class="hljs-params">event, context, callback</span>) =&gt;</span> {
    <span class="hljs-comment">// 从 event 中获取 URL query 参数</span>
    <span class="hljs-keyword">const</span> { name } = event.queryStringParameters;
    <span class="hljs-comment">// 定义 HTTP Response</span>
    <span class="hljs-keyword">const</span> response = {
        <span class="hljs-attr">statusCode</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">headers</span>: {
            <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
            },
        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({ <span class="hljs-attr">message</span>: <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>!`</span>} ),
    };
    callback(<span class="hljs-literal">null</span>, response);
};
</code></pre>
<p data-nodeid="59165">要想调试这个函数，就需要手动构造 event、context 和 callback 三个对象，然后以它们为参数来调用函数，测试函数运行情况。<strong data-nodeid="59340">麻烦点就在于：</strong> 这些参数运行依赖于 FaaS 环境，不同运行环境、不同触发器函数的入参都有差异，手动模拟这些对象很麻烦，且容易出错。<br>
<strong data-nodeid="59341">那如何让开发者方便调试呢？</strong> 有两种方式。</p>
<ul data-nodeid="59166">
<li data-nodeid="59167">
<p data-nodeid="59168">远程调试：将代码部署到 FaaS 平台，然后直接调用 FaaS 平台的接口执行函数，再得到函数运行日志及返回结果。</p>
</li>
<li data-nodeid="59169">
<p data-nodeid="59170">本地调试：由开发框架模拟函数运行时环境，构造函数参数来执行函数。</p>
</li>
</ul>
<p data-nodeid="59171"><strong data-nodeid="59348">我认为对一个 Serverless 开发框架来说，这两种调试方式都需要，</strong> 也就是需要实现 serverless invoke 和 serverless local invoke 两个命令。虽然远程调试最接近代码真实运行情况，但需要进行网络调用，大部分情况还是本地调试效率更高。</p>
<h4 data-nodeid="59172">应用部署</h4>
<p data-nodeid="59173">当代码开发完成后，就要部署应用了，过程是：根据 YAML 的配置，解析出应用的服务名称和函数列表，然后调用 FaaS 平台的接口来创建或更新服务和函数。</p>
<p data-nodeid="59174">需要注意的是，在创建函数时，FaaS 平台中的函数代码通常以压缩包的方式存储在文件存储服务中，所以部署函数前需要先在本地把代码压缩成 .zip 文件。<strong data-nodeid="59356">而在部署应用时，大部分同学会有这样一个担忧：</strong> 代码调试可以把函数部署到 FaaS 中进行调试，可能每次代码改动都会影响到线上服务，如果有版本控制就可以避免了。FaaS 平台当然考虑了这个问题，提供了函数版本功能（默认是 LATEST 版本）。通过版本控制，你在开发时可以使用 LATEST 版本进行开发，测试稳定了再发布稳定的新版本，用稳定版本提供线上服务。</p>
<p data-nodeid="59175">所以在远程调试时，就不能更新函数版本，一直用 LATEST，而当应用部署时，就需要更新函数版本。</p>
<p data-nodeid="59176"><img src="https://s0.lgstatic.com/i/image/M00/8B/FD/CgqCHl_jCFuACP1uAAGWw6OtS60066.png" alt="Drawing 1.png" data-nodeid="59360"></p>
<h4 data-nodeid="59177">账号设置与多平台支持</h4>
<p data-nodeid="59178"><strong data-nodeid="59366">讲到这儿，我们已经完成了应用部署功能设计，</strong> 但还有个问题没有解决，就是应用要部署到哪个云账号上？这时就需要账号功能了。</p>
<p data-nodeid="59179">在账号方面，对于接口编程访问，云厂商都是通过 AccessKeyId 和 AccessKeySecret 来授权的。你可以提供一个命令，让用户输入自己的云账号 AccessKeyId 和 AccessKeySecret，然后把账号信息保存到用户自己的磁盘上。这样应用部署的时候，你就可以从磁盘上读取账号信息，以用户的账号去调用 FaaS 平台的接口。这样就可以把应用部署到用户云账号下了，并且账号信息是存储在用户自己的磁盘上，也没有安全问题。</p>
<p data-nodeid="60807">除此之外，我认为一个优秀的 Serverless 开发框架，还应该具备多种不同 Serverless 平台或云厂商的支持，因为你不能限制用户只使用某一种云服务。Serverless 开发框架最好还要抹平不同 Serverless 平台的差异，让应用能够在不同 Serverless 平台中进行平滑迁移，甚至让开发者使用一个开发框架、一套开发流程就能实现多云部署。<strong data-nodeid="60813">而这，正是一个 Serverless 开发框架的核心竞争力之一。</strong></p>
<p data-nodeid="60808" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/8C/B3/CgqCHl_y8F-AKiNdAAGE8ajjCCA752.png" alt="Lark20210104-183828.png" data-nodeid="60816"></p>

<p data-nodeid="60380">当然，要支持多种 Serverless 平台，就需要在框架层去适配各个不同的平台。但现在各个 Serverless 平台都没有遵循统一的标准，<strong data-nodeid="60391">这也是实现一个多平台支持的难点所在。</strong> 所以你在实现一个开发框架时，需要先抽象出各个平台公共部分，然后制订一套你的开发标准，再以适配器的方式去适配不同的 Serverless 平台。</p>




<p data-nodeid="59182"><img src="https://s0.lgstatic.com/i/image/M00/8B/FD/CgqCHl_jCG6AHdZPAAOd4PqLzmk757.png" alt="Drawing 2.png" data-nodeid="59381"></p>
<div data-nodeid="59183"><p style="text-align:center">Serverless 框架架构</p></div>
<p data-nodeid="59184">至此，你就完成了一个完整的 Serverless 开发框架的设计。在 Serverless 框架架构中，你通过一个 serverless 命令对开发者提供所有服务，贯穿 Serverless 应用开发到上线的全流程。</p>
<p data-nodeid="59185"><strong data-nodeid="59387">这其实也是现在主流 Serverless 开发框架的实现原理</strong>。接下来，就让我带你看一下主流 Serverless 开发框架的实现细节、功能特性和使用方法，从而让你对 Serverless 开发框架的原理和实现有更多了解。</p>
<h3 data-nodeid="59186">主流 Serverless 开发框架的实现</h3>
<p data-nodeid="59187">整体而言，国外 Serverless 生态要比国内领先一到两年，因此国外有很多优秀的开发框架，但国内这方面还不够成熟，所以我就讲解一下国内外最具代表性的两个开发框架，<a href="https://github.com/serverless/serverless" data-nodeid="59392">Serverless Framework</a>和<a href="https://github.com/alibaba/funcraft" data-nodeid="59396">函数计算 Fun</a>。</p>
<p data-nodeid="59188">我会按照以下顺序讲解这部分内容：</p>
<p data-nodeid="59189"><img src="https://s0.lgstatic.com/i/image/M00/8B/F2/Ciqc1F_jCHeASYj3AAGl95hTVl4092.png" alt="Drawing 3.png" data-nodeid="59401"></p>
<h3 data-nodeid="59190">Serverless Framework</h3>
<p data-nodeid="59191">说到 Serverless，就不得不说 Serverless Framework ，我认为这是目前最完善的 Serverless 开发框架之一。它不仅实现了前面提到的应用开发、调试、部署等基础功能，还实现了多个 Serverless 平台的支持（因为它不仅支持 AWS、Azure、Google、阿里云、腾讯云等公有云 Serverless 平台，还支持 CloudFlare、Kubeless、OpenWhisk 等私有 Serverless 平台）。</p>
<ul data-nodeid="59192">
<li data-nodeid="59193">
<p data-nodeid="59194"><strong data-nodeid="59407">安装</strong></p>
</li>
</ul>
<p data-nodeid="59195">Serverless Framework 是使用 Node.js 开发的，所以你可以使用 npm 直接来安装它，安装后你就可以直接使用 serverless 这个命令了（好巧，跟我们前面设计的开发框架的命令一样）。</p>
<pre class="lang-shell" data-nodeid="59196"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> npm install -g serverless</span>
<span class="hljs-meta">$</span><span class="bash"> serverless --version</span>
Framework Core: 2.15.0
Plugin: 4.2.0
SDK: 2.3.2
Components: 3.4.3
</code></pre>
<ul data-nodeid="59197">
<li data-nodeid="59198">
<p data-nodeid="59199"><strong data-nodeid="59412">账号设置</strong></p>
</li>
</ul>
<p data-nodeid="59200">你在使用 Serverless 时，第一件事就进行账号设置，假设你使用 AWS 则命令如下：</p>
<pre class="lang-shell" data-nodeid="59201"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> serverless config credentials --provider aws --key key --secret secret</span>
</code></pre>
<ul data-nodeid="59202">
<li data-nodeid="59203">
<p data-nodeid="59204">--provider&nbsp;具体的 Serverless 平台</p>
</li>
<li data-nodeid="59205">
<p data-nodeid="59206">--key&nbsp;AWS 账号的 aws_access_key_id</p>
</li>
<li data-nodeid="59207">
<p data-nodeid="59208">--secret&nbsp;AWS 账号的 aws_secret_access_key</p>
</li>
</ul>
<p data-nodeid="59209">Serverless Framework 会把 AWS 的 aws_access_key_id 和 aws_secret_access_key 保存在 ~/.aws/credentials文件中。</p>
<p data-nodeid="59210">在 Serverless Framework 中，通过 provider 来实现不同平台的支持。在不同 provider 中， Serverless Framework 的命令大部分相同，但不同 provider 的功能完整性还是有一定差异，比如它虽然支持阿里云 provider，但目前只支持 HTTP 触发器和 OSS 触发器。</p>
<ul data-nodeid="59211">
<li data-nodeid="59212">
<p data-nodeid="59213"><strong data-nodeid="59448">应用配置</strong></p>
</li>
</ul>
<p data-nodeid="59214">接下来你就可以使用 serverless 初始化一个应用了：</p>
<pre class="lang-shell" data-nodeid="59215"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> serverless create --template aws-nodejs</span>
Serverless: Generating boilerplate...
 _______                             __
|   _   .-----.----.--.--.-----.----|  .-----.-----.-----.
|   |___|  -__|   _|  |  |  -__|   _|  |  -__|__ --|__ --|
|____   |_____|__|  \___/|_____|__| |__|_____|_____|_____|
|   |   |             The Serverless Application Framework
|       |                           serverless.com, v2.15.0
 -------'
Serverless: Successfully generated boilerplate for template: "aws-nodejs"
Serverless: NOTE: Please update the "service" property in serverless.yml with your service name
<span class="hljs-meta">$</span><span class="bash"> ls</span>
handler.js    serverless.yml
</code></pre>
<p data-nodeid="59216">Serverless Framework 也是通过 YAML 配置文件来定义应用和函数的，其 YAML 格式如下：</p>
<pre class="lang-yaml" data-nodeid="59217"><code data-language="yaml"><span class="hljs-attr">service:</span> <span class="hljs-string">myservice</span>
<span class="hljs-attr">frameworkVersion:</span> <span class="hljs-string">'2'</span>
<span class="hljs-attr">provider:</span>
  <span class="hljs-attr">name:</span> <span class="hljs-string">aws</span>
  <span class="hljs-attr">runtime:</span> <span class="hljs-string">nodejs12.x</span>
<span class="hljs-attr">functions:</span>
  <span class="hljs-attr">hello:</span>
    <span class="hljs-attr">handler:</span> <span class="hljs-string">handler.hello</span>
    <span class="hljs-attr">events:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span>
          <span class="hljs-attr">path:</span> <span class="hljs-string">users/create</span>
          <span class="hljs-attr">method:</span> <span class="hljs-string">get</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">websocket:</span> <span class="hljs-string">$connect</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">s3:</span> <span class="hljs-string">${env:BUCKET}</span>
<span class="hljs-attr">resources:</span>
  <span class="hljs-attr">Resources:</span>
    <span class="hljs-attr">NewResource:</span>
      <span class="hljs-attr">Type:</span> <span class="hljs-string">AWS::S3::Bucket</span>
      <span class="hljs-attr">Properties:</span>
        <span class="hljs-attr">BucketName:</span> <span class="hljs-string">my-new-bucket</span>
  <span class="hljs-attr">Outputs:</span>
     <span class="hljs-attr">NewOutput:</span>
       <span class="hljs-attr">Description:</span> <span class="hljs-string">"Description for the output"</span>
       <span class="hljs-attr">Value:</span> <span class="hljs-string">"Some output value"</span>
</code></pre>
<p data-nodeid="59218"><strong data-nodeid="59455">在这份 YAML 中，有一个前面没有提到过的属性 resources</strong>，resources 的作用就是帮你创建或更新资源（如果资源不存在则创建，如果资源已存在则更新）。比如示例中，就是为你创建一个 AWS 的 S3 存储桶。之所以会有 resources 属性，是因为通常一个应用都需要依赖其他云服务，比如存储、数据库等，之前你可能都是手动在云厂商的控制台去购买这些资源，一旦应用需要扩容的时候，手动创建资源就非常复杂且容易出错。Serverless Framework 则给你一种新的方式去管理云上资源，即通过代码来描述基础基础设施。</p>
<ul data-nodeid="59219">
<li data-nodeid="59220">
<p data-nodeid="59221"><strong data-nodeid="59459">应用调试</strong></p>
</li>
</ul>
<p data-nodeid="59222">在 Serverless Framework 中，调试函数也很简单，直接通过 invoke 命令即可：</p>
<pre class="lang-shell" data-nodeid="59223"><code data-language="shell"><span class="hljs-meta">#</span><span class="bash"> 远程调试</span>
<span class="hljs-meta">$</span><span class="bash"> serverless invoke --<span class="hljs-keyword">function</span> hello</span>
{
    "statusCode": 200,
    "body": "{\n  \"message\": \"Go Serverless v1.0! Your function executed successfully!\",\n  \"input\": \"\"\n}"
}
<span class="hljs-meta">#</span><span class="bash"> 本地调试</span>
<span class="hljs-meta">$</span><span class="bash"> serverless invoke <span class="hljs-built_in">local</span> --<span class="hljs-keyword">function</span> hello</span>
{
    "statusCode": 200,
    "body": "{\n  \"message\": \"Go Serverless v1.0! Your function executed successfully!\",\n  \"input\": \"\"\n}"
}
</code></pre>
<p data-nodeid="59224">当然了，你也可以通过 serverless invoke local 来实现本地调试。</p>
<ul data-nodeid="59225">
<li data-nodeid="59226">
<p data-nodeid="59227"><strong data-nodeid="59465">应用部署</strong></p>
</li>
</ul>
<p data-nodeid="59228">应用开发完成后，你就可以使用 deploy 命令来部署应用，如下所示：</p>
<pre class="lang-shell" data-nodeid="59229"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> serverless deploy</span>
Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Service files not changed. Skipping deployment...
Service Information
service: myservice
stage: dev
region: us-east-1
stack: myservice-dev
resources: 6
functions:
  hello: myservice-dev-hello
layers:
  None
<span class="hljs-meta">
$</span><span class="bash"> tree</span>
|-- .serverless
     |-- myservice.zip
|-- handler.js
|-- serverless.yaml
</code></pre>
<p data-nodeid="59230">在将函数部署到 Lambda 之前，serverless 会先在本地将代码打包，最终代码是一个压缩包，路径为 .serverles/[serviceName].zip 。你也可以通过 serverless deploy function -f functionName 来单独部署某个函数。</p>
<p data-nodeid="59231">除此之外，Serverless Framework 还提供了日志查询功能，当然，Serverless Framework 的功能不止于此（但因为不是这一讲的重点，所以我想留给你去探索），接下来我们再来了解一下，函数计算 Fun 的基本功能和使用，<strong data-nodeid="59476">看看它和 Serverless Framework 有什么差异。</strong></p>
<h3 data-nodeid="59232">函数计算 Fun</h3>
<p data-nodeid="59233">Fun 是阿里云函数计算团队开发维护的一个 Serverles 开发框架，因此只支持函数计算。因为它是用 Node.js 编写的，所以也可以使用 npm 安装：</p>
<pre class="lang-java" data-nodeid="59234"><code data-language="java">$ npm install <span class="hljs-meta">@alicloud</span>/fun -g
$ fun --version
<span class="hljs-number">3.6</span><span class="hljs-number">.20</span>
</code></pre>
<p data-nodeid="59235"><strong data-nodeid="59482">安装后第一步同样是设置账号：</strong></p>
<pre class="lang-java" data-nodeid="59236"><code data-language="java">$ fun config
? Aliyun Account ID *******
? Aliyun Access Key ID ******
? Aliyun Access Key Secret ******
? Default region name cn-hangzhou
$ cat ~/.fcli/config.yaml
endpoint: <span class="hljs-string">'https://******.cn-hangzhou.fc.aliyuncs.com'</span>
api_version: <span class="hljs-string">'2016-08-15'</span>
access_key_id: ******
access_key_secret: ******
security_token: <span class="hljs-string">''</span>
debug: <span class="hljs-keyword">false</span>
timeout: <span class="hljs-number">10</span>
retries: <span class="hljs-number">3</span>
sls_endpoint: cn-hangzhou.log.aliyuncs.com
report: <span class="hljs-keyword">true</span>
enable_custom_endpoint: <span class="hljs-keyword">false</span>
</code></pre>
<p data-nodeid="59237">配置完成后，fun 会将账号信息存储在.fcli/config.yaml 文件中。除此之外，你也可以在项目根目录中使用 .env文件来配置账号信息，其优先级更高。</p>
<pre class="lang-java" data-nodeid="59238"><code data-language="java"># 项目根目录 .env
ACCOUNT_ID=*****
REGION=cn-hangzhou
ACCESS_KEY_ID=******
ACCESS_KEY_SECRET=******
TIMEOUT=10
RETRIES=3
FC_ENDPOINT=******
ENABLE_CUSTOM_ENDPOINT=false
</code></pre>
<p data-nodeid="59239"><strong data-nodeid="59490">在应用配置上，</strong> 你可以通过 fun init <code data-backticks="1" data-nodeid="59488">&lt;templateName&gt;</code>命令来初始化一个项目：</p>
<pre class="lang-java" data-nodeid="59240"><code data-language="java">$ fun init event-nodejs12
$ ls -l
index.js    template.yaml
</code></pre>
<p data-nodeid="59241">其中 &nbsp;template.yaml 功能与 serverless.yaml 一致，但内容定义有较大差异。template.yaml 的定义如下：</p>
<pre class="lang-java" data-nodeid="59242"><code data-language="java">ROSTemplateFormatVersion: <span class="hljs-string">'2015-09-01'</span>
Transform: <span class="hljs-string">'Aliyun::Serverless-2018-04-03'</span>
Resources:
  myservice:
    Type: <span class="hljs-string">'Aliyun::Serverless::Service'</span>
    Properties:
      Description: <span class="hljs-string">'helloworld'</span>
    hello:
      Type: <span class="hljs-string">'Aliyun::Serverless::Function'</span>
      Properties:
        Handler: index.handler
        Runtime: nodejs12
        CodeUri: <span class="hljs-string">'./'</span>
</code></pre>
<p data-nodeid="59243">其中 Resources 是表示资源的对象，对象的属性就是具体资源，对象属性中的Type 用来表示资源的类型。比如 Aliyun::Serverless::Service就表示是“服务”，Aliyun::Serverless::Function 表示函数。因此 template.yaml 中你可以定义多个服务，一个服务中也可以定义多个函数。</p>
<p data-nodeid="59244"><strong data-nodeid="59496">接下来，你可以通过 fun invoke functionName 命令对函数进行远程调试：</strong></p>
<pre class="lang-java" data-nodeid="59245"><code data-language="java">$ fun invoke hello
using template: template.yml
========= FC invoke Logs begin =========
FC Invoke Start RequestId: c6abf471-<span class="hljs-number">949</span>a-<span class="hljs-number">4</span>bbc-<span class="hljs-number">9</span>edf-<span class="hljs-number">35e4</span>c312a974
load code <span class="hljs-keyword">for</span> handler:index.handler
<span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">06</span>T14:<span class="hljs-number">19</span>:<span class="hljs-number">11.353</span>Z c6abf471-<span class="hljs-number">949</span>a-<span class="hljs-number">4</span>bbc-<span class="hljs-number">9</span>edf-<span class="hljs-number">35e4</span>c312a974 [verbose] hello world
FC Invoke End RequestId: c6abf471-<span class="hljs-number">949</span>a-<span class="hljs-number">4</span>bbc-<span class="hljs-number">9</span>edf-<span class="hljs-number">35e4</span>c312a974
Duration: <span class="hljs-number">13.99</span> ms, Billed Duration: <span class="hljs-number">100</span> ms, Memory Size: <span class="hljs-number">128</span> MB, Max Memory Used: <span class="hljs-number">17.30</span> MB
========= FC invoke Logs end =========
FC Invoke Result:
hello world
</code></pre>
<p data-nodeid="59246">当然，你也可以通过fun local invoke function 在本地调试。但本地调试前，你必须先安装 Docker，因为 fun 的本地调试原理是通过 Docker 在本地启动一个代码运行环境来执行代码，而不是直接模拟函数参数。这样的好处是，更接近 FaaS 平台的运行环境。</p>
<p data-nodeid="59247"><strong data-nodeid="59501">应用开发完毕后，你可以通过 fun deploy 进行应用部署。</strong></p>
<pre class="lang-java" data-nodeid="59248"><code data-language="java">$ fun fun deploy
using template: template.yml
using region: cn-hangzhou
using accountId: ***********<span class="hljs-number">4698</span>
using accessKeyId: ***********QliF
using timeout: <span class="hljs-number">10</span>
Waiting <span class="hljs-keyword">for</span> service myservice to be deployed...
    Waiting <span class="hljs-keyword">for</span> function hello to be deployed...
        Waiting <span class="hljs-keyword">for</span> packaging function hello code...
        The function hello has been packaged. A total of <span class="hljs-number">1</span> file were compressed and the <span class="hljs-keyword">final</span> size was <span class="hljs-number">318</span> B
    function hello deploy success
service myservice deploy success
</code></pre>
<h3 data-nodeid="59249">总结</h3>
<p data-nodeid="59250">在我看来，开发框架的意义就在于帮助开发者提升 Serverless 应用的开发效率， 因此一个 Serverless 开发框架最主要的就是要实现应用管理、应用调试、应用部署等功能。而在Serverless Framework 和 Fun 这两个开发框架中：</p>
<ul data-nodeid="59251">
<li data-nodeid="59252">
<p data-nodeid="59253">Serverless Framework 特点是功能完善、支持平台丰富。但由于 Serverless 平台尚且没有统一标准，所以支持多平台难度极大，也导致其对国内产品支持不够友好；</p>
</li>
<li data-nodeid="59254">
<p data-nodeid="59255">Fun 的特点是只为函数计算服务，因此有很多针对函数计算的特定功能。</p>
</li>
</ul>
<p data-nodeid="59256">除了 Serverless Framework 外，国外还有 <a href="https://vercel.com/" data-nodeid="59509">Vercel</a>、<a href="https://apex.sh/up/" data-nodeid="59513">Apex Up</a> 等非常优秀的 Serverless 开发框架，Vercel 的前生就是 now.sh ，Apex Up 则是 Node.js 领域的 TJ 大神 2016 年就开始开发的产品。而国内除了 Fun，现在也有 <a href="https://github.com/midwayjs/midway-faas" data-nodeid="59517">Midway FaaS</a>、<a href="https://github.com/cellbang/malagu" data-nodeid="59521">Malagu</a> 等新兴产品出现，这些产品虽然没有国外产品功能完善，但相信随着时间的推移，国内的 Serverless 开发体验也一定会越来越好。也是由于国内 Serverless 生态还不够完善，<strong data-nodeid="59526">所以我们才有更多的机会，也希望你也能一起参与进来，为国内 Serverless 开发生态做出贡献。</strong></p>
<p data-nodeid="59257">另一方面，现在绝大部分 Serverless 开发框架都是基于 Node.js 实现，并且大部分都是对 Node.js 编写语言支持最友好，甚至只支持 Node.js，这也能看出 Node.js 在 Serverless 领域的重要性。</p>
<p data-nodeid="59258"><strong data-nodeid="59531">关于这节课，我想强调这几个点：</strong></p>
<ul data-nodeid="59259">
<li data-nodeid="59260">
<p data-nodeid="59261">与 FaaS、BaaS 等基础技术一样，Serverless 开发框架也是 Serverless 领域中的非常重要的一部分；</p>
</li>
<li data-nodeid="59262">
<p data-nodeid="59263">一个优秀的 Serverless 开发框架，可以让开发者很容易开发一个 Serverless 架构的应用，也能让企业轻易将现有业务演化到 Serverless 架构；</p>
</li>
<li data-nodeid="59264">
<p data-nodeid="59265">Serverless 开发框架需要具备的基本能力是应用管理、应用调试和应用部署。</p>
</li>
</ul>
<p data-nodeid="59266" class="">最后，这节课我留给你的作业时，亲自体验一下本文中提到的各个开发框架，进而对 Serverless 的开发体系有更深的了解。</p>

---

### 精选评论


