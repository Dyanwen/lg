<p data-nodeid="6257" class="">在介绍完 Eureka 服务器端组件之后，今天我们详细地展开讲解 Eureka 的客户端组件。我们的思路同样是先介绍使用 Eureka 注册和发现服务的使用方法，然后基于源码，剖析 Eureka 客户端的实现原理。</p>
<h3 data-nodeid="6258">使用 Eureka 注册和发现服务</h3>
<p data-nodeid="6259">现在我们的 SpringHealth 案例中已经有了第一个独立的微服务，即<strong data-nodeid="6338">上一课时构建的 eureka-server 服务</strong>。对于 Eureka 服务器而言，user-service、device-service 和 intervention-service 都是它的客户端，今天我们将先以 user-service 为例来演示如何完成服务的注册和发现。</p>
<h4 data-nodeid="6260">实现服务注册</h4>
<p data-nodeid="6261">使用 Eureka 注册基于 Spring Boot 构建的 user-service，它非常简单，其主要工作也是通过配置来完成的。在介绍配置内容之前，我们首先需要确保在 Maven 工程中添加对 Eureka 客户端组件 spring-cloud-starter-netflix-eureka-client 的依赖，如下所示。</p>
<pre class="lang-xml" data-nodeid="6262"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p data-nodeid="6263">然后，我们来看 user-service 的 Bootstrap 类，如下所示：</p>
<pre class="lang-java" data-nodeid="6264"><code data-language="java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableEurekaClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserApplication</span> </span>{
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
	&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SpringApplication.run(UserApplication.class, args);
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="6265">这里引入了一个新的注解 @EnableEurekaClient，该注解用于表明当前服务就是一个 Eureka 客户端，这样该服务就可以自动注册到 Eureka 服务器。当然，随着我们后续内容的演进，你会发现可以使用统一的 @SpringCloudApplication 注解，来实现 @SpringBootApplication 和 @EnableEurekaClient 这两个注解整合在一起的效果。</p>
<p data-nodeid="6266">这里使用独立的 @EnableEurekaClient 注解是为了帮助你更好地理解该注解的作用，而关于 @SpringCloudApplication 注解我们会在介绍到服务熔断时再进行专门引入。</p>
<p data-nodeid="6267">接下来就是最重要的配置工作，user-service 中的配置内容如下所示：</p>
<pre class="lang-java" data-nodeid="6268"><code data-language="java">spring:
&nbsp; application:
	name: userservice 
server:
&nbsp; port: <span class="hljs-number">8081</span>
	&nbsp;
eureka:
&nbsp; client:
&nbsp;&nbsp;&nbsp; serviceUrl:
	&nbsp; defaultZone: http:<span class="hljs-comment">//localhost:8761/eureka/</span>
</code></pre>
<p data-nodeid="6269">显然，这里包含两段配置内容。第一段配置指定了服务的名称和运行时端口。在上面的示例中，user-service 的名称通过“spring.application.name=userservice”进行指定，也就是说 user-service 在注册中心中的名称为 userservice。在后续的示例中，我们会使用这一名称获取 user-service 在 Eureka 中的各种注册信息。</p>
<p data-nodeid="6270">在 eureka.client 段中，我们设置 Eureka 客户端行为。这里的 serviceUrl 配置项在上一课时中已经介绍过，serviceUrl.defaultZone 指定的就是 Eureka 服务器的地址。</p>
<p data-nodeid="6271">当然，如果我们同样基于上一课时中介绍的 Peer Awareness 模式构建了 Eureka 服务器集群，那么 eureka.client.serviceUrl.defaultZone 配置项的内容就应该是“http://eureka1:8761/eureka/,<a href="http://eureka2" data-nodeid="6350">http://eureka2</a>:8762/eureka/”，用于指向当前的集群环境。</p>
<h4 data-nodeid="6272">实现服务发现</h4>
<p data-nodeid="6273">当我们成功创建并启动了 user-service 之后，Eureka 服务器的当前状态如下图所示：</p>
<p data-nodeid="6274"><img src="https://s0.lgstatic.com/i/image/M00/58/DB/Ciqc1F9wT66APdccAAB8da4b_EM993.png" alt="Drawing 0.png" data-nodeid="6356"></p>
<div data-nodeid="6275"><p style="text-align:center">包含 user-service 服务注册信息的 Eureka 服务监控页面</p></div>
<p data-nodeid="6276">可以看到，现在的 Eureka 中注册了两个 user-service 的服务实例，运行端口分别是 8082 和 8083。这时候，你可能会好奇，user-service 在 Eureka 服务器中的注册信息是如何进行表示的呢？为了获取注册到 Eureka 服务器上具体某一个服务实例的详细信息，我们可以访问如下地址：</p>
<pre class="lang-xml" data-nodeid="6277"><code data-language="xml">http://<span class="hljs-tag">&lt;<span class="hljs-name">eureka-ip-port</span>&gt;</span>:8761/eureka/apps/<span class="hljs-tag">&lt;<span class="hljs-name">APPID</span>&gt;</span>
</code></pre>
<p data-nodeid="6278">该地址代表的就是一个普通的 HTTP 请求，URL 中的 APPID 就是服务名称。以 user-service 为例，我们发送 HTTP 请求到 <a href="http://localhost:8761/eureka/apps/userservice" data-nodeid="6361">http://localhost:8761/eureka/apps/userservice</a> 可以得到如下信息：</p>
<pre class="lang-xml" data-nodeid="6279"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>USERSERVICE<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span> 
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">instanceId</span>&gt;</span>localhost:userservice:8082<span class="hljs-tag">&lt;/<span class="hljs-name">instanceId</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">hostName</span>&gt;</span>localhost<span class="hljs-tag">&lt;/<span class="hljs-name">hostName</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">app</span>&gt;</span>USERSERVICE<span class="hljs-tag">&lt;/<span class="hljs-name">app</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">ipAddr</span>&gt;</span>192.168.247.1<span class="hljs-tag">&lt;/<span class="hljs-name">ipAddr</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">status</span>&gt;</span>UP<span class="hljs-tag">&lt;/<span class="hljs-name">status</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">overriddenstatus</span>&gt;</span>UNKNOWN<span class="hljs-tag">&lt;/<span class="hljs-name">overriddenstatus</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">port</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span>&gt;</span>8082<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">securePort</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"false"</span>&gt;</span>443<span class="hljs-tag">&lt;/<span class="hljs-name">securePort</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">countryId</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">countryId</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">dataCenterInfo</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo"</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>MyOwn<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> 
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">dataCenterInfo</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">leaseInfo</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">renewalIntervalInSecs</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">renewalIntervalInSecs</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">durationInSecs</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">durationInSecs</span>&gt;</span>
&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">registrationTimestamp</span>&gt;</span>1599277974858<span class="hljs-tag">&lt;/<span class="hljs-name">registrationTimestamp</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">lastRenewalTimestamp</span>&gt;</span>1599278364582<span class="hljs-tag">&lt;/<span class="hljs-name">lastRenewalTimestamp</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">evictionTimestamp</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">evictionTimestamp</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">serviceUpTimestamp</span>&gt;</span>1599277974859<span class="hljs-tag">&lt;/<span class="hljs-name">serviceUpTimestamp</span>&gt;</span> 
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">leaseInfo</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">metadata</span>&gt;</span> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">management.port</span>&gt;</span>8082<span class="hljs-tag">&lt;/<span class="hljs-name">management.port</span>&gt;</span> 
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">metadata</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">homePageUrl</span>&gt;</span>http://localhost:8082/<span class="hljs-tag">&lt;/<span class="hljs-name">homePageUrl</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">statusPageUrl</span>&gt;</span>http://localhost:8082/actuator/info<span class="hljs-tag">&lt;/<span class="hljs-name">statusPageUrl</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">healthCheckUrl</span>&gt;</span>http://localhost:8082/actuator/health<span class="hljs-tag">&lt;/<span class="hljs-name">healthCheckUrl</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">vipAddress</span>&gt;</span>userservice<span class="hljs-tag">&lt;/<span class="hljs-name">vipAddress</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">secureVipAddress</span>&gt;</span>userservice<span class="hljs-tag">&lt;/<span class="hljs-name">secureVipAddress</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">isCoordinatingDiscoveryServer</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">isCoordinatingDiscoveryServer</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">lastUpdatedTimestamp</span>&gt;</span>1599277974860<span class="hljs-tag">&lt;/<span class="hljs-name">lastUpdatedTimestamp</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">lastDirtyTimestamp</span>&gt;</span>1599277974520<span class="hljs-tag">&lt;/<span class="hljs-name">lastDirtyTimestamp</span>&gt;</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">actionType</span>&gt;</span>ADDED<span class="hljs-tag">&lt;/<span class="hljs-name">actionType</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span>
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">instance</span>&gt;</span>
	…
	<span class="hljs-tag">&lt;/<span class="hljs-name">instance</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span>
</code></pre>
<p data-nodeid="6280">这里出现了两个标签代表存在两个 user-service 服务实例。根据如上所示的服务实例详细信息，我们可以获取该服务的服务名称、IP 地址、端口、是否可用等基本信息，也可以访问 statusPageUrl、healthCheckUrl 等地址查看当前服务的运行状态，更为重要的是得到了 leaseInfo 等与服务注册过程直接相关的基础数据，这些基础数据有助于我们理解 Eureka 作为注册中心的工作原理。</p>
<h3 data-nodeid="6281">理解 Eureka 客户端基本原理</h3>
<p data-nodeid="6282">对于 Eureka 而言，微服务的提供者和消费者都是它的客户端，其中服务提供者关注<strong data-nodeid="6374">服务注册、服务续约</strong>和<strong data-nodeid="6375">服务下线</strong>等功能，而服务消费者关注于服务信息的获取。同时，对于服务消费者而言，为了提高服务获取的性能以及在注册中心不可用的情况下继续使用服务，一般都还会具有缓存机制。</p>
<p data-nodeid="6283">在 Netflix Eureka 中，专门提供了一个客户端包，并抽象了一个客户端接口 EurekaClient。EurekaClient 接口继承自 LookupService 接口，这个 LookupService 接口实际上也是我们上一课时中所介绍的 InstanceRegistry 接口的父接口。EurekaClient 在 LookupService 接口的基础上提供了一系列扩展方法，<strong data-nodeid="6381">这些扩展方法并不是重点，我们还是更应该关注于它的类层机构</strong>，如下所示：</p>
<p data-nodeid="6284"><img src="https://s0.lgstatic.com/i/image/M00/58/E7/CgqCHl9wUAmATPQxAAAqMtQEPGk029.png" alt="Drawing 1.png" data-nodeid="6384"></p>
<div data-nodeid="6285"><p style="text-align:center">接口 EurekaClient 的类层结构</p></div>
<p data-nodeid="6286">可以看到 EurekaClient 接口有个实现类 DiscoveryClient（位于 com.netflix.discovery 包中），该类包含了服务提供者和服务消费者的核心处理逻辑，同时提供了我们在介绍 Eureka 服务器端基本原理时所介绍的 register、renew 等方法。DiscoveryClient 类的实现非常复杂，我们重点关注它构造方法中的这行代码：</p>
<pre class="lang-java" data-nodeid="6287"><code data-language="java">initScheduledTasks();
</code></pre>
<p data-nodeid="6288">通过分析该方法中的代码，我们看到系统在这里初始化了一批调度任务，具体包含缓存刷新 cacheRefresh、心跳 heartbeat、服务实例复制 InstanceInfoReplicator 等，其中缓存刷新面向服务消费者，而心跳和服务实例复制面向服务提供者。接下来我们将分别从这两个 Eureka 客户端组件出发讨论服务注册和发现的客户端操作。</p>
<h4 data-nodeid="6289">服务提供者操作源码解析</h4>
<p data-nodeid="6290">服务提供者关注<strong data-nodeid="6393">服务注册、服务续约和服务下线</strong>等功能，它可以使用 Eureka 服务器提供的 RESTful API 完成上述操作。因为篇幅关系，这里同样以服务注册为例给出服务提供者的操作流程。</p>
<p data-nodeid="6291">在 DiscoveryClient 类中，服务注册操作由register 方法完成，如下所示。为了简单起见，我们对代码进行了裁剪，省略了日志相关等非核心代码：</p>
<pre class="lang-java" data-nodeid="6292"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">register</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EurekaHttpResponse&lt;Void&gt; httpResponse;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">try</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; httpResponse = eurekaTransport.registrationClient.register(instanceInfo);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">catch</span> (Exception e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">throw</span> e;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> httpResponse.getStatusCode() == <span class="hljs-number">204</span>;
}
</code></pre>
<p data-nodeid="6293">上述 register 方法会在 InstanceInfoReplicator 类的 run 方法中进行执行。从操作流程上讲，上述代码的逻辑非常简单，即服务提供者先将自己注册到 Eureka 服务器中，然后根据返回的结果确定操作是否成功。显然，这里的重点代码是eurekaTransport.registrationClient.register()，DiscoveryClient 通过这行代码发起了远程请求。</p>
<p data-nodeid="6294">首先我们来看 EurekaTransport 类，这是 DiscoveryClient 类中的一个内部类，定义了 registrationClient 变量用于实现服务注册。registrationClient 的类型是 EurekaHttpClient 接口，该接口的定义如下：</p>
<pre class="lang-java" data-nodeid="6295"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EurekaHttpClient</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">register</span><span class="hljs-params">(InstanceInfo info)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">cancel</span><span class="hljs-params">(String appName, String id)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;InstanceInfo&gt; <span class="hljs-title">sendHeartBeat</span><span class="hljs-params">(String appName, String id, InstanceInfo info, InstanceStatus overriddenStatus)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">statusUpdate</span><span class="hljs-params">(String appName, String id, InstanceStatus newStatus, InstanceInfo info)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">deleteStatusOverride</span><span class="hljs-params">(String appName, String id, InstanceInfo info)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Applications&gt; <span class="hljs-title">getApplications</span><span class="hljs-params">(String... regions)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Applications&gt; <span class="hljs-title">getDelta</span><span class="hljs-params">(String... regions)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Applications&gt; <span class="hljs-title">getVip</span><span class="hljs-params">(String vipAddress, String... regions)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Applications&gt; <span class="hljs-title">getSecureVip</span><span class="hljs-params">(String secureVipAddress, String... regions)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;Application&gt; <span class="hljs-title">getApplication</span><span class="hljs-params">(String appName)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;InstanceInfo&gt; <span class="hljs-title">getInstance</span><span class="hljs-params">(String appName, String id)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;InstanceInfo&gt; <span class="hljs-title">getInstance</span><span class="hljs-params">(String id)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="6296">可以看到这个 EurekaHttpClient 接口定义了 Eureka 服务器的一些底层 REST API，包括 register、cancel、sendHeartBeat、statusUpdate、getApplications 等。在 Eureka 中，关于如何实现客户端与服务器端的远程通信，从工作原理上讲只是一个 RESTful 风格的 HTTP 请求，但在具体设计和实现上可以说是非常考究，因此类层结构上也比较复杂。我们先来看 EurekaHttpClient 接口的一个实现类 EurekaHttpClientDecorator，从命名上看它是一个装饰器（Decorator），如下所示：</p>
<pre class="lang-java" data-nodeid="6297"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaHttpClientDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EurekaHttpClient</span> </span>{
&nbsp;
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RequestType</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Register,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cancel,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SendHeartBeat,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StatusUpdate,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DeleteStatusOverride,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetApplications,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestExecutor</span>&lt;<span class="hljs-title">R</span>&gt; </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpResponse&lt;R&gt; <span class="hljs-title">execute</span><span class="hljs-params">(EurekaHttpClient delegate)</span></span>;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function">RequestType <span class="hljs-title">getRequestType</span><span class="hljs-params">()</span></span>;
&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> &lt;R&gt; <span class="hljs-function">EurekaHttpResponse&lt;R&gt; <span class="hljs-title">execute</span><span class="hljs-params">(RequestExecutor&lt;R&gt; requestExecutor)</span></span>;
&nbsp;
&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> InstanceInfo info)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> execute(<span class="hljs-keyword">new</span> RequestExecutor&lt;Void&gt;() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> EurekaHttpResponse&lt;Void&gt; <span class="hljs-title">execute</span><span class="hljs-params">(EurekaHttpClient delegate)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> delegate.register(info);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> RequestType <span class="hljs-title">getRequestType</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> RequestType.Register;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });
	&nbsp;&nbsp;&nbsp; }
	&nbsp;
	<span class="hljs-comment">//省略其他方法实现</span>
}
</code></pre>
<p data-nodeid="6298">可以看到 EurekaHttpClientDecorator 通过定义一个抽象方法 execute(RequestExecutor requestExecutor) 来包装 EurekaHttpClient，这种包装是代理机制的一种表现形式。</p>
<p data-nodeid="6299"><br>
然后我们再来看如何构建一个 EurekaHttpClient，Eureka 也专门提供了 EurekaHttpClientFactory 类来负责构建具体的 EurekaHttpClient。显然，这是工厂模式的一种典型应用。EurekaHttpClientFactory 接口定义如下：</p>
<pre class="lang-java" data-nodeid="6300"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EurekaHttpClientFactory</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpClient <span class="hljs-title">newClient</span><span class="hljs-params">()</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="6301">Eureka 中存在一批 EurekaHttpClientFactory 的实现类，包括 RetryableEurekaHttpClient 和 MetricsCollectingEurekaHttpClient 等，这些类都位于 com.netflix.discovery.shared.transport.decorator 包下。同时，在 com.netflix.discovery.shared.transport 包下，还存在一个 EurekaHttpClients 工具类，能够创建通过 RedirectingEurekaHttpClient、RetryableEurekaHttpClient、SessionedEurekaHttpClient 包装之后的 EurekaHttpClient。如下所示：</p>
<pre class="lang-java" data-nodeid="6302"><code data-language="java"><span class="hljs-keyword">new</span> EurekaHttpClientFactory() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> EurekaHttpClient <span class="hljs-title">newClient</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SessionedEurekaHttpClient(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RetryableEurekaHttpClient.createFactory(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transportConfig,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clusterResolver,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RedirectingEurekaHttpClient.createFactory(transportClientFactory),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServerStatusEvaluators.legacyEvaluator()),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; transportConfig.getSessionedClientReconnectIntervalSeconds() * <span class="hljs-number">1000</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
};
</code></pre>
<p data-nodeid="6303">这是 EurekaHttpClient 创建过程中的一条分支，即通过包装器对请求过程进行层层封装和代理。而在执行远程请求时，Eureka 同样提供了另一套体系来完成真正的远程调用，原始的 EurekaHttpClient 通过 TransportClientFactory 进行创建。TransportClientFactory 接口定义如下：</p>
<pre class="lang-java" data-nodeid="6304"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransportClientFactory</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-function">EurekaHttpClient <span class="hljs-title">newClient</span><span class="hljs-params">(EurekaEndpoint serviceUrl)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<p data-nodeid="6305">TransportClientFactory 同样存在一批实现类，其中有些是实名类，有些是匿名类。以实名的实现类 JerseyEurekaHttpClientFactory 为例，它位于 com.netflix.discovery.shared.transport.jersey 包下，通过 EurekaJerseyClient 获取 Jersey 客户端，而 EurekaJerseyClient 又会使用 ApacheHttpClient4 对象，从而完成 REST 调用。</p>
<p data-nodeid="6306">作为总结，这里也给你分享一个 Eureka 在设计和实现上的技巧，也就是所谓的高阶（High Level）API和低阶（Low Level）API，如下图所示：</p>
<p data-nodeid="8055"><img src="https://s0.lgstatic.com/i/image/M00/5B/A4/CgqCHl9_zgeAKVhNAAHaQoJ_1kI602.png" alt="Lark20201009-104135.png" data-nodeid="8058"></p>

<div data-nodeid="7689"><p style="text-align:center">高阶 API 和低阶 API 关系示意图</p></div>




<p data-nodeid="6309">针对高阶 API，主要是通过装饰器模式进行一系列包装，从而创建目标 EurekaHttpClient。而关于低阶 API 的话，主要是 HTTP 远程调用的实现，Netflix 提供的是基于 Jersey 的版本，而 Spring Cloud 则提供了基于 RestTemplate 的版本，这点我们后面会再讲到。</p>
<h4 data-nodeid="6310">服务消费者操作源码解析</h4>
<p data-nodeid="6311">我们在介绍注册中心模型时，服务消费者可以配备缓存机制以加速服务路由。对于 Eureka 而言，作为客户端组件的 DiscoveryClient 同样具备这种缓存功能。</p>
<p data-nodeid="6312">Eureka 客户端通过定时任务完成缓存刷新操作，我们已经在前面的内容中提到 DiscoveryClient 中的 initScheduledTasks 方法用于初始化各种调度任务，对于缓存刷选而言，调度器的初始化过程如下所示：</p>
<pre class="lang-java" data-nodeid="6313"><code data-language="java"><span class="hljs-keyword">if</span> (clientConfig.shouldFetchRegistry()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">int</span> registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">int</span> expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scheduler.schedule(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">new</span> TimedSupervisorTask(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-string">"cacheRefresh"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scheduler,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cacheRefreshExecutor,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; registryFetchIntervalSeconds,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TimeUnit.SECONDS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expBackOffBound,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">new</span> CacheRefreshThread()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; registryFetchIntervalSeconds, TimeUnit.SECONDS);
}
</code></pre>
<p data-nodeid="6314">显然，这里启动了一个调度任务并通过 CacheRefreshThread 线程完成具体操作。CacheRefreshThread 线程定义如下：</p>
<pre class="lang-java" data-nodeid="6315"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheRefreshThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; refreshRegistry();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="6316">对于服务消费者而言，最重要的操作就是<strong data-nodeid="6419">获取服务注册信息</strong>。在这里的 refreshRegistry 方法中，我们发现在进行一系列的校验之后，最终调用了 fetchRegistry 方法以完成注册信息的更新，该方法代码如下。为了简单起见，我们对代码进行了部分裁剪，只保留主流程：</p>
<pre class="lang-java" data-nodeid="6317"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">fetchRegistry</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> forceFullRegistryFetch)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">try</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// 获取应用</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Applications applications = getApplications();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (…) <span class="hljs-comment">//如果满足全量拉取条件</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<span class="hljs-comment">// 全量拉取服务实例数据</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getAndStoreFullRegistry();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <span class="hljs-comment">// 增量拉取服务实例数据</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getAndUpdateDelta(applications);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span class="hljs-comment">// 重新计算和设置一致性hashcode</span>
	applications.setAppsHashCode(applications.getReconcileHashCode());

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } 
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// 刷新本地缓存</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; onCacheRefreshed();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">// 更新远程服务实例运行状态</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; updateInstanceRemoteStatus();
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre>
<p data-nodeid="6318">这里的几个带注释的方法都非常有用，因为 getAndStoreFullRegistry 的逻辑相对比较简单，我们将重点介绍 getAndUpdateDelta 方法，以便学习在 Eureka 中如何实现增量数据更新的设计技巧。裁剪之后的 getAndUpdateDelta 方法代码如下所示：</p>
<pre class="lang-java" data-nodeid="6319"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getAndUpdateDelta</span><span class="hljs-params">(Applications applications)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">long</span> currentUpdateGeneration = fetchRegistryGeneration.get();
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;Applications delta = <span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//通过 eurekaTransport.queryClient 获取增量信息</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EurekaHttpResponse&lt;Applications&gt; httpResponse = eurekaTransport.queryClient.getDelta(remoteRegionsRef.get());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (httpResponse.getStatusCode() == Status.OK.getStatusCode()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta = httpResponse.getEntity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (delta == <span class="hljs-keyword">null</span>) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; <span class="hljs-comment">//如果增量信息为空，就直接发起一次全量更新</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getAndStoreFullRegistry();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fetchRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + <span class="hljs-number">1</span>)) {<span class="hljs-comment">//通过CAS来确保请求的线程安全性</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String reconcileHashCode = <span class="hljs-string">""</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (fetchRegistryUpdateLock.tryLock()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">try</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span class="hljs-comment">//比对从服务器端返回的增量数据和本地数据，合并两者的差异数据</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; updateDelta(delta);
&nbsp;
	<span class="hljs-comment">//用合并了增量数据之后的本地数据来生成一致性 hashcode</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reconcileHashCode = getReconcileHashCode(applications);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">finally</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fetchRegistryUpdateLock.unlock();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;
	<span class="hljs-comment">//比较本地数据中的 hashcode 和来自服务器端的 hashcode</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (!reconcileHashCode.equals(delta.getAppsHashCode()) || clientConfig.shouldLogDeltaDiff()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;<span class="hljs-comment">//如果 hashcode 不一致，就触发远程调用进行全量更新</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reconcileAndLogDifference(delta, reconcileHashCode);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <span class="hljs-keyword">else</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="6320">回顾 Eureka 服务器端基本原理，我们知道 Eureka 服务器端会保存一个服务注册列表的缓存。Eureka 官方文档中提到这个数据保留时间是三分钟，而 Eureka 客户端的定时调度机制会每隔 30 秒刷选本地缓存。原则上，只要 Eureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。但如果客户端在 3 分钟之内没有获取更新数据，就会导致自身与服务器端的数据不一致，这是这种更新机制所必须要考虑的问题，也是我们自己在设计类似场景时的一个注意点。</p>
<p data-nodeid="6321">针对上述问题，Eureka 采用了一致性 HashCode 方法来进行解决。Eureka 服务器端每次返回的增量数据中都会带有一个一致性 HashCode，这个 HashCode 会与 Eureka 客户端用本地服务列表数据算出的一致性 HashCode 进行比对，如果两者不一致就证明增量更新出了问题，这时候就需要执行一次全量更新。</p>
<p data-nodeid="6322">在 Eureka 中，计算一致性 HashCode 的方法如下所示，可以看到这一方法基于服务注册实例信息完成编码计算过程，最终返回一个 String 类型的计算结果：</p>
<pre class="lang-java" data-nodeid="6323"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getReconcileHashCode</span><span class="hljs-params">(Map&lt;String, AtomicInteger&gt; instanceCountMap)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuilder reconcileHashCode = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-number">75</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">for</span> (Map.Entry&lt;String, AtomicInteger&gt; mapEntry : instanceCountMap.entrySet()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reconcileHashCode.append(mapEntry.getKey()).append(STATUS_DELIMITER).append(mapEntry.getValue().get())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .append(STATUS_DELIMITER);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> reconcileHashCode.toString();
}
</code></pre>
<p data-nodeid="6324">作为总结，Eureka 客户端缓存定时更新的流程如下图所示，可以看到它与服务注册的流程基本一致，也就是说在 Eureka 中，服务提供者和服务消费者作为 Eureka 服务器的客户端采用了同一套体系完成与服务器端的交互。</p>
<p data-nodeid="7154"><img src="https://s0.lgstatic.com/i/image/M00/5B/99/Ciqc1F9_zfGAOViSAAGXRnBlAdc236.png" alt="Lark20201009-104138.png" data-nodeid="7157"></p>

<div data-nodeid="6788"><p style="text-align:center">Eureka 缓存刷选流程时序图</p></div>




<h3 data-nodeid="6327">小结与预告</h3>
<p data-nodeid="6328">延续上一课时内容，今天我们讨论了 Eureka 客户端组件的使用方法和实现原理。在使用方法上，我们同样只需要在 Spring Boot 的启动类中添加一个注解，就可以将服务自身注册到 Eureka 服务器中。而在实现原理上，服务的提供者和服务的消费者都是 Eureka 客户端，但却有不同的操作流程，需要我们分别进行分析。</p>
<p data-nodeid="6329">这里给你留一道思考题：针对位于 Eureka 服务器上的服务列表信息，Eureka 客户端如何实现注册信息的同步和增量更新？</p>
<p data-nodeid="6330" class="">负载均衡与服务治理关系密切。下一课时，我们就将基于Eureka 的已知内容，讨论 Spring Cloud 中的客户端负载均衡组件 Ribbon 与 Eureka 之间的交互关系以及使用方法。</p>

---

### 精选评论

##### **江：
> 对于说的源码这些比较难以理解，请问这些源码可以通过调试去验证吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 可以的，都是开源的源码，直接引用到项目中打断点逐步调试就行了

##### **浩：
> “这个 HashCode 会与 Eureka 客户端用本地服务列表数据算出的一致性 HashCode 进行比对”这句话有歧义，应该是服务器端返回的增量数据和客户端本地的数据合并后，算出的一致性HashCode，与服务器端返回的HashCode进行比较

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 对的

##### **明：
> "也就是说在 Eureka 中，服务提供者和服务消费者作为 Eureka 服务器的客户端采用了同一套体系完成与服务器端的交互。" 关于短链接的情况 能再详细点吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 短链接是什么？这段的意思是说，对于Eureka而言，服务提供者和消费者都是它的客户端，交互流程是一样的

##### *峰：
> 老师，eureka增量的hashcode跟本地的hashcode不一致，就要去全量更新，这个地方不太理解。不应该是获取到的增量数据的hashcide就应该本地的不一样吗？（当有新的实例注册进来了）

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个是这样的：如果正常的流程之下两边的hashcode就应该是一致的，但如果某个服务中间出现了异常情况，比方说宕机了一段时间，超过了正常的30秒心跳，这个hashcode就会不一致，就需要做一次全量更新。你说的新的实例进来时也相当于是这种异常情况

##### **旭：
> 服务注册实现了那服务消费者没有提供案例代码实现哦?

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 案例代码中有的，对于user-service而言，intervention-service就是它的消费者

##### **勤：
> 文章中uaerservice 是在8081端口，为什么注册到eureka 集群之后是8082和8083端口呢，老师可以解释一下吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 后面作为两个服务实例，分别修改了端口而已

