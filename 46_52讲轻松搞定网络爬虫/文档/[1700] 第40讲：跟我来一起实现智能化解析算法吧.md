<p data-nodeid="3062">在上一节课我们介绍了智能解析算法的实现原理，接下来我们就一起动手用代码来实现一下智能解析算法吧。</p>



<h3 data-nodeid="4016" class="">学习目标</h3>

<p data-nodeid="1626">这里使用的案例还是凤凰网的一篇资讯文章，链接为：<a href="http://news.ifeng.com/c/7kQcQG2peWU" data-nodeid="1757">http://news.ifeng.com/c/7kQcQG2peWU</a>，本节我们主要实现的提取字段为标题、时间、正文内容。</p>
<p data-nodeid="1627">我们会用 Python 来对上一节讲解的智能解析算法进行实现，实现新闻内容的提取。</p>
<h3 data-nodeid="4970" class="">准备工作</h3>

<p data-nodeid="6868">首先让我们将上述 URL 打开，然后在浏览器里面打开开发者工具，并打开 Elements 选项卡，最后把 HTML 代码复制下来，如图所示：</p>
<p data-nodeid="6869" class=""><img src="https://s0.lgstatic.com/i/image/M00/28/39/CgqCHl74UmGAJc3ZAAMZ_A3o4rs583.png" alt="image.png" data-nodeid="6873"></p>


<p data-nodeid="1631">复制下来之后我们把源代码保存成一个 html 文件，名字叫作 sample.html。</p>
<p data-nodeid="1632">然后我们定义如下代码，将 html 里面的字符转化成 lxml 里面的 HtmlElement 对象，代码如下：</p>
<pre class="lang-java" data-nodeid="8303"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, fromstring
​
html = open(<span class="hljs-string">'sample.html'</span>, encoding=<span class="hljs-string">'utf-8'</span>).read()
element = fromstring(html=html)
</code></pre>


<p data-nodeid="1634">这里 element 对象其实就是整个网页对应的 HtmlElement 对象，其根节点就是 html，下面我们会用到它来进行页面解析，从这个 HtmlElement 对象里面提取出我们想要的时间、标题、正文内容。</p>
<h3 data-nodeid="9256" class="">时间</h3>

<p data-nodeid="1636">对于时间来说，我们这里就根据两个方面来进行提取，一个就是 meta 标签，如果里面包含了发布时间的相关信息，一般提取出来就是对的，可信度非常高，如果提取不到，那就用正则表达式来匹配一些时间规则进行提取。</p>
<p data-nodeid="1637">首先我们就来进行 meta 标签的提取，这里我们列出来了一些用来匹配发布时间的 XPath 规则，内容如下：</p>
<pre class="lang-java" data-nodeid="10687"><code data-language="java">METAS = [
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "rnews:datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "article:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:published_time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@property, "og:release_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "datePublished")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@itemprop, "dateUpdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "OriginalPublicationDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "article_date_original")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "og:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "apub:time")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publication_date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "sailthru.date")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PublishDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "publishdate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "PubDate")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "_pubtime")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@name, "weibo: article:create_at")]/@content'</span>,
 &nbsp; &nbsp;<span class="hljs-string">'//meta[starts-with(@pubdate, "pubdate")]/@content'</span>,
]
</code></pre>


<p data-nodeid="1639">在这里我们就定义一个 extract_by_meta 的方法，它接受一个 HtmlElement 对象，定义如下：</p>
<pre class="lang-java" data-nodeid="11640"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> xpath in METAS:
 &nbsp; &nbsp; &nbsp; &nbsp;datetime </span>= element.xpath(xpath)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> datetime:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(datetime)
</code></pre>

<p data-nodeid="1641">这里我们其实就是对 METAS 进行逐个遍历，然后查找整个 HtmlElement 里面是不是有匹配的内容，比如说：</p>
<pre class="lang-java" data-nodeid="12593"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@property, "og:published_time")]/@content</span>
</code></pre>

<p data-nodeid="1643">这个就是查找 meta 节点中是不是存在以 og:published_time 开头的 property 属性，如果存在，那就提取出其中的 content 属性内容。<br>
比如说我们的案例中刚好有一个 meta 节点，内容为：</p>
<pre class="lang-java" data-nodeid="13546"><code data-language="java">&lt;meta name=<span class="hljs-string">"og:time "</span> content=<span class="hljs-string">"2019-02-20 02:26:00"</span>&gt;
</code></pre>

<p data-nodeid="1645">经过处理，它会匹配到这个 XPath 表达式：</p>
<pre class="lang-java" data-nodeid="14499"><code data-language="java"><span class="hljs-comment">//meta[starts-with(@name, "og:time")]/@content</span>
</code></pre>

<p data-nodeid="15452">这样其实 extract_by_meta 方法就成功匹配到时间信息，然后提取出 2019-02-20 02:26:00 这个值了。</p>
<p data-nodeid="15453">这就相当于时间提取的第一步成功了，而且一般来说匹配到的结果可信度都是非常高的，我们可以直接将这个内容返回作为最终的提取结果即可。</p>

<p data-nodeid="1648">可是并不是所有的页面都会包含这个 meta 标签，如果不包含的话，我们还需要进行第二步的提取。</p>
<p data-nodeid="1649">下面我们再来实现第二步，也就是根据一些时间正则表达式来进行提取的方法。这里我们其实就是定义一些时间的正则表达式写法，内容如下：</p>
<pre class="lang-java" data-nodeid="16412"><code data-language="java">REGEXES = [
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[0-1]?[0-9]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[2][0-3]:[0-5]?[0-9])"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2}\s*?[1-24]\d时[0-60]\d分)([1-24]\d时)"</span>,
 &nbsp;  ...
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}[-|/|.]\d{1,2}[-|/|.]\d{1,2})"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{4}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{2}年\d{1,2}月\d{1,2}日)"</span>,
 &nbsp; &nbsp;<span class="hljs-string">"(\d{1,2}月\d{1,2}日)"</span>
]
</code></pre>

<p data-nodeid="1651">由于内容比较多，这里省略了部分内容。其实这里就是一些日期的常见写法格式，由于日期的写法是有限的，所以我们通过一些有限的正则表达就能进行匹配。<br>
接下来我们就定义一个正则搜索的方法，实现如下：</p>
<pre class="lang-java" data-nodeid="17365"><code data-language="java"><span class="hljs-keyword">import</span> re
​
<span class="hljs-function">def <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
 &nbsp; &nbsp;text </span>= <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
 &nbsp; &nbsp;<span class="hljs-keyword">for</span> regex in REGEXES:
 &nbsp; &nbsp; &nbsp; &nbsp;result = re.search(regex, text)
 &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">if</span> result:
 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-keyword">return</span> result.group(<span class="hljs-number">1</span>)
</code></pre>

<p data-nodeid="1653">这里我们先查找了 element 的文本内容，然后对文本内容进行正则表达式搜索，符合条件的就直接返回。<br>
最后，时间提取的方法我们直接定义为：</p>
<pre class="lang-java" data-nodeid="18318"><code data-language="java">extract_by_meta(element) <span class="hljs-function">or <span class="hljs-title">extract_by_regex</span><span class="hljs-params">(element)</span>
</span></code></pre>

<p data-nodeid="1655">即可，这样就会优先提取 meta，其次根据正则表达式提取。</p>
<h3 data-nodeid="19271" class="">标题</h3>

<p data-nodeid="1657">接下来我们来实现标题的提取，根据上节内容，标题的提取我们在这里实现三个来源的提取：</p>
<ul data-nodeid="1658">
<li data-nodeid="1659">
<p data-nodeid="1660">查找 meta 节点里面的标题信息。</p>
</li>
<li data-nodeid="1661">
<p data-nodeid="1662">查找 title 节点的标题信息。</p>
</li>
<li data-nodeid="1663">
<p data-nodeid="1664">查找 h 节点的信息。</p>
</li>
</ul>
<p data-nodeid="1665">首先就是从 meta 节点提取，其实过程还是类似的，我们定义如下的 meta 节点的 XPath 提取规则，内容如下：</p>
<pre class="lang-java" data-nodeid="20225"><code data-language="java">METAS = [
    <span class="hljs-string">'//meta[starts-with(@property, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "og:title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@name, "title")]/@content'</span>,
    <span class="hljs-string">'//meta[starts-with(@property, "page:title")]/@content'</span>,
]
</code></pre>

<p data-nodeid="1667">实现的提取方法也是完全一样的：</p>
<pre class="lang-java" data-nodeid="21178"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_meta</span><span class="hljs-params">(element: HtmlElement)</span> -&gt; str:
    <span class="hljs-keyword">for</span> xpath in METAS:
        title </span>= element.xpath(xpath)
        <span class="hljs-keyword">if</span> title:
            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(title)
</code></pre>

<p data-nodeid="23084">关于这一部分就不再展开说明了。</p>
<p data-nodeid="23085">接下来我们还可以提取 title 和 h 节点的信息，通过基本的 XPath 表达式就可以实现，代码如下：</p>

<pre class="lang-java" data-nodeid="22131"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_by_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(element.xpath(<span class="hljs-string">'//title//text()'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
def <span class="hljs-title">extract_by_h</span><span class="hljs-params">(element: HtmlElement)</span>:
    return ''.<span class="hljs-title">join</span><span class="hljs-params">(
        element.xpath(<span class="hljs-string">'(//h1//text() | //h2//text() | //h3//text())'</span>)</span>).<span class="hljs-title">strip</span><span class="hljs-params">()</span>
</span></code></pre>

<p data-nodeid="24040">这里我们提取了 title、h1~h3 节点的信息，然后返回了它们的纯文本内容。</p>
<p data-nodeid="24041">紧接着，我们分别调用以下这三个方法，看看针对这个案例，其结果是怎样的，调用如下：</p>

<pre class="lang-yaml" data-nodeid="44535"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_meta(element)</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_h(element)</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">=</span> <span class="hljs-string">extract_by_title(element)</span>
</code></pre>


<p data-nodeid="1673">运行结果如下：</p>
<pre class="lang-yaml" data-nodeid="43582"><code data-language="yaml"><span class="hljs-string">title_extracted_by_meta</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调</span>
<span class="hljs-string">title_extracted_by_h</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调为您推荐精品有声好书精选</span>
<span class="hljs-string">title_extracted_by_title</span> <span class="hljs-string">故宫，你低调点！故宫：不，实力已不允许我继续低调_凤凰网资讯_凤凰网</span>
</code></pre>




















<p data-nodeid="45488">这里我们观察到，三个方法都返回了差不多的结果，但是后缀还是不太一样。</p>
<p data-nodeid="45489">title_extracted_by_meta 实际上是完全正确的内容，可以直接返回，一般来说，它的可信度也非常高，如果匹配到，那就直接返回就好了。</p>

<p data-nodeid="1676">但是如果不存在 title_extracted_by_meta 的结果呢？那只能靠 title_extracted_by_title 和 title_extracted_by_h 了。</p>
<p data-nodeid="1677">这里我们观察到 title_extracted_by_title 和 title_extracted_by_h 包含一些冗余信息，仔细想想确实是这样的，因为 title 一般来说会再加上网站的名称，而 h 节点众多，通常会包含很多噪音。</p>
<p data-nodeid="1678">这里我们可以提取它们的公共连续内容其实就好了，这里用到一个算法，就是最长连续公共子串，即 Longest Common String，这里我们直接借助于 Python 的 difflib 库来实现即可，如果你感兴趣的话也可以手动实现一下。</p>
<p data-nodeid="1679">这里我们的实现如下：</p>
<pre class="lang-java" data-nodeid="51215"><code data-language="java"><span class="hljs-function">from difflib <span class="hljs-keyword">import</span> SequenceMatcher
def <span class="hljs-title">lcs</span><span class="hljs-params">(a, b)</span>:
    match </span>= SequenceMatcher(None, a, b).find_longest_match(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">0</span>, len(b))
    <span class="hljs-keyword">return</span> a[match[<span class="hljs-number">0</span>]: match[<span class="hljs-number">0</span>] + match[<span class="hljs-number">2</span>]]
</code></pre>






<p data-nodeid="52168">这里定义了一个 lcs 方法，它接收两个字符串类型的参数，比如 <code data-backticks="1" data-nodeid="52171">abcd</code> 和 <code data-backticks="1" data-nodeid="52173">bcde</code>，那么它的返回结果就是它们的公共部分，即 <code data-backticks="1" data-nodeid="52175">bcd</code>。</p>
<p data-nodeid="52169">好，那么对于 title_extracted_by_title 和 title_extracted_by_h，我们调用下 lcs 方法就好了，实现如下：</p>

<pre class="lang-java" data-nodeid="53142"><code data-language="java">lcs(title_extracted_by_title, title_extracted_by_h)
</code></pre>

<p data-nodeid="1683">最终我们可以把标题的提取定义成一个方法，实现如下：</p>
<pre class="lang-java" data-nodeid="54095"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract_title</span><span class="hljs-params">(element: HtmlElement)</span>:
    title_extracted_by_meta </span>= extract_by_meta(element)
    title_extracted_by_h = extract_by_h(element)
    title_extracted_by_title = extract_by_title(element)
    <span class="hljs-keyword">if</span> title_extracted_by_meta:
        <span class="hljs-keyword">return</span> title_extracted_by_meta
    <span class="hljs-keyword">if</span> title_extracted_by_title and title_extracted_by_h:
        <span class="hljs-keyword">return</span> lcs(title_extracted_by_title, title_extracted_by_h)
    <span class="hljs-keyword">if</span> title_extracted_by_title:
        <span class="hljs-keyword">return</span> title_extracted_by_title
    <span class="hljs-keyword">return</span> title_extracted_by_h
</code></pre>

<p data-nodeid="1685">这里我们就定义了一些优先级判定逻辑，如：</p>
<ul data-nodeid="1686">
<li data-nodeid="1687">
<p data-nodeid="1688">如果存在 title_extracted_by_meta，由于其可信度非常高，直接返回即可。</p>
</li>
<li data-nodeid="1689">
<p data-nodeid="1690">如果不存在 title_extracted_by_meta，而 title_extracted_by_title 和 title_extracted_by_h 同时存在，取二者的最长公共子串返回即可。</p>
</li>
<li data-nodeid="1691">
<p data-nodeid="1692">如果上述条件不成立， title_extracted_by_title 存在，返回 title_extracted_by_title 即可。</p>
</li>
<li data-nodeid="1693">
<p data-nodeid="1694">如果上述条件不成立，只能返回 title_extracted_by_h 了。</p>
</li>
</ul>
<p data-nodeid="1695">以上就是我们的标题提取逻辑。</p>
<h3 data-nodeid="55048" class="">正文</h3>

<p data-nodeid="1697">接下来终于轮到重头戏，正文提取了。在上一节课我们介绍了利用文本密度和符号密度进行提取的方法，下面我们就来实现一下吧。</p>
<p data-nodeid="1698">正文的提取需要我们做一些预处理工作，比如一个 html 标签内有很多噪音，非常影响正文的提取，比如说 script、style 这些内容，一定不会包含正文，但是它们会严重影响文本密度的计算，所以这里我们先定义一个预处理操作。</p>
<pre class="lang-java" data-nodeid="56002"><code data-language="java">from lxml.html <span class="hljs-keyword">import</span> HtmlElement, etree
CONTENT_USELESS_TAGS = [<span class="hljs-string">'meta'</span>, <span class="hljs-string">'style'</span>, <span class="hljs-string">'script'</span>, <span class="hljs-string">'link'</span>, <span class="hljs-string">'video'</span>, <span class="hljs-string">'audio'</span>, <span class="hljs-string">'iframe'</span>, <span class="hljs-string">'source'</span>, <span class="hljs-string">'svg'</span>, <span class="hljs-string">'path'</span>,
                        <span class="hljs-string">'symbol'</span>, <span class="hljs-string">'img'</span>]
CONTENT_STRIP_TAGS = [<span class="hljs-string">'span'</span>, <span class="hljs-string">'blockquote'</span>]
CONTENT_NOISE_XPATHS = [
    <span class="hljs-string">'//div[contains(@class, "comment")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advertisement")]'</span>,
    <span class="hljs-string">'//div[contains(@class, "advert")]'</span>,
    <span class="hljs-string">'//div[contains(@style, "display: none")]'</span>,
]

<span class="hljs-function">def <span class="hljs-title">preprocess4content</span><span class="hljs-params">(element: HtmlElement)</span>:
    # remove tag and its content
    etree.<span class="hljs-title">strip_elements</span><span class="hljs-params">(element, *CONTENT_USELESS_TAGS)</span>
    # only move tag pair
    etree.<span class="hljs-title">strip_tags</span><span class="hljs-params">(element, *CONTENT_STRIP_TAGS)</span>
    # remove noise tags
    <span class="hljs-title">remove_children</span><span class="hljs-params">(element, CONTENT_NOISE_XPATHS)</span>
    
    <span class="hljs-keyword">for</span> child in <span class="hljs-title">children</span><span class="hljs-params">(element)</span>:
        
        # merge text in span or strong to parent p tag
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'p'</span>:
            etree.strip_tags(child, <span class="hljs-string">'span'</span>)
            etree.strip_tags(child, <span class="hljs-string">'strong'</span>)
            
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">not</span> <span class="hljs-params">(child.text and child.text.strip()</span>):
                <span class="hljs-title">remove_element</span><span class="hljs-params">(child)</span>
        
        # <span class="hljs-keyword">if</span> a div tag does not contain any sub node, it could be converted to p node.
        <span class="hljs-keyword">if</span> child.tag.<span class="hljs-title">lower</span><span class="hljs-params">()</span> </span>== <span class="hljs-string">'div'</span> and not child.getchildren():
            child.tag = <span class="hljs-string">'p'</span>
</code></pre>

<p data-nodeid="1700">这里我们定义了一些规则，比如 CONTENT_USELESS_TAGS 代表一些噪音节点，可以直接调用 strip_elements 把整个节点和它的内容删除。<br>
另外定义了 CONTENT_STRIP_TAGS ，这些节点文本内容需要保留，但是它的标签是可以删掉的。</p>
<p data-nodeid="1701">另外我们还定义了 CONTENT_NOISE_XPATHS，这是一些很明显不是正文的节点，如评论、广告等，直接移除就好。</p>
<p data-nodeid="1702">这里还依赖于几个工具方法，定义如下：</p>
<pre class="lang-java" data-nodeid="56955"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">remove_element</span><span class="hljs-params">(element: HtmlElement)</span>:
    parent </span>= element.getparent()
    <span class="hljs-keyword">if</span> parent is not None:
        parent.remove(element)
<span class="hljs-function">def <span class="hljs-title">remove_children</span><span class="hljs-params">(element: HtmlElement, xpaths=None)</span>:
    <span class="hljs-keyword">if</span> not xpaths:
        return
    <span class="hljs-keyword">for</span> xpath in xpaths:
        nodes </span>= element.xpath(xpath)
        <span class="hljs-keyword">for</span> node in nodes:
            remove_element(node)
    <span class="hljs-keyword">return</span> <span class="hljs-function">element
def <span class="hljs-title">children</span><span class="hljs-params">(element: HtmlElement)</span>:
    yield element
    <span class="hljs-keyword">for</span> child_element in element:
        <span class="hljs-keyword">if</span> <span class="hljs-title">isinstance</span><span class="hljs-params">(child_element, HtmlElement)</span>:
            yield from <span class="hljs-title">children</span><span class="hljs-params">(child_element)</span>
</span></code></pre>

<p data-nodeid="57908">另外对于一些节点我们还做了特殊处理，如 p 节点内部的 span、strong 节点去掉标签，只留内容。如果是 div 节点，而且没有子节点了，那么可以换成 p 节点。</p>
<p data-nodeid="57909">当然还有一些细节的处理，你如果想到了可以继续优化。预处理完毕之后，整个 element 就比较规整了，去除了很多噪声和干扰数据。</p>

<p data-nodeid="1705">接下来我们就来实现文本密度和符号密度的计算吧。为了方便处理，这里我把节点定义成了一个 Python Object，名字叫作 ElementInfo，它里面有很多字段，代表了某一个节点的信息，比如文本密度、符号密度等，定义如下：</p>
<pre class="lang-dart" data-nodeid="63629"><code data-language="dart">from lxml.html <span class="hljs-keyword">import</span> HtmlElement
from pydantic <span class="hljs-keyword">import</span> BaseModel
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElementInfo</span>(<span class="hljs-title">BaseModel</span>):
    <span class="hljs-title">id</span>: <span class="hljs-title">int</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">tag_name</span>: <span class="hljs-title">str</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">element</span>: <span class="hljs-title">HtmlElement</span> = <span class="hljs-title">None</span>
    <span class="hljs-title">number_of_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_char</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_linked_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_p_tag</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">number_of_punctuation</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_of_punctuation</span>: <span class="hljs-title">int</span> = 1
    <span class="hljs-title">density_of_text</span>: <span class="hljs-title">int</span> = 0
    <span class="hljs-title">density_score</span>: <span class="hljs-title">int</span> = 0
    
    <span class="hljs-title">class</span> <span class="hljs-title">Config</span>:
        <span class="hljs-title">arbitrary_types_allowed</span> = <span class="hljs-title">True</span>
</span></code></pre>






<p data-nodeid="1707">这里我们定义了几个字段。</p>
<ul data-nodeid="1708">
<li data-nodeid="1709">
<p data-nodeid="1710">id：节点的唯一 id。</p>
</li>
<li data-nodeid="1711">
<p data-nodeid="1712">tag_name：节点的标签值，如 p、div、img 等。</p>
</li>
<li data-nodeid="1713">
<p data-nodeid="1714">element：节点对应的 HtmlElement 对象。</p>
</li>
<li data-nodeid="1715">
<p data-nodeid="1716">number_of_char：节点的总字符数。</p>
</li>
<li data-nodeid="1717">
<p data-nodeid="1718">number_of_linked_char：节点带超链接的字符数。</p>
</li>
<li data-nodeid="1719">
<p data-nodeid="1720">number_of_tag：节点的标签数。</p>
</li>
<li data-nodeid="1721">
<p data-nodeid="1722">number_of_linked_tag：节点的带链接的标签数，即 a 的标签数。</p>
</li>
<li data-nodeid="1723">
<p data-nodeid="1724">number_of_p_tag：节点的 p 标签数。</p>
</li>
<li data-nodeid="1725">
<p data-nodeid="1726">number_of_punctuation：节点包含的标点符号数。</p>
</li>
<li data-nodeid="1727">
<p data-nodeid="1728">density_of_punctuation：节点的符号密度。</p>
</li>
<li data-nodeid="1729">
<p data-nodeid="1730">density_of_text：节点的文本密度。</p>
</li>
<li data-nodeid="1731">
<p data-nodeid="1732">density_score：最终评分。</p>
</li>
</ul>
<p data-nodeid="1733">好，下面我们要做的就是对整个 HTML 的所有节点进行处理，然后得到每个节点的信息，实现如下：</p>
<pre class="lang-dart" data-nodeid="71253"><code data-language="dart"># start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
</code></pre>








<p data-nodeid="72206">这里我们先调用了 children_of_body 获取了最初 element 节点的所有子节点，然后对节点进行处理。</p>
<p data-nodeid="72207">其中这里依赖 children_of_body 和 fill_element_info 方法，分别是获取所有 body 内的子节点（包括 body）以及计算节点信息，实现如下：</p>

<pre class="lang-dart" data-nodeid="82704"><code data-language="dart">def children_of_body(element: HtmlElement):
    body_xpath = <span class="hljs-string">'//body'</span>
    elements = element.xpath(body_xpath)
    <span class="hljs-keyword">if</span> elements:
        <span class="hljs-keyword">return</span> children(elements[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> []

def fill_element_info(element_info: ElementInfo):
    element = element_info.element
    
    # fill id
    element_info.id = hash(element)
    element_info.tag_name = element.tag
    
    # fill number_of_char
    element_info.number_of_char = number_of_char(element)
    element_info.number_of_linked_char = number_of_linked_char(element)
    element_info.number_of_tag = number_of_tag(element)
    element_info.number_of_linked_tag = number_of_linked_tag(element)
    element_info.number_of_p_tag = number_of_p_tag(element)
    element_info.number_of_punctuation = number_of_punctuation(element)
    
    # fill density
    element_info.density_of_text = density_of_text(element_info)
    element_info.density_of_punctuation = density_of_punctuation(element_info)
    <span class="hljs-keyword">return</span> element_info
</code></pre>











<p data-nodeid="1737">这里 fill_element_info 方法非常重要，其实就是填充了 element_info 的几乎所有指标信息，这里又依赖了 number_of_char、number_of_linked_char、number_of_tag、number_of_linked_tag、number_of_p_tag、number_of_punctuation、density_of_text、density_of_punctuation 方法，实现如下：</p>
<pre class="lang-dart" data-nodeid="93187"><code data-language="dart">def number_of_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_linked_char(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//a//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    <span class="hljs-keyword">return</span> len(text)

def number_of_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//*'</span>))

def number_of_p_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//p'</span>))

def number_of_linked_tag(element: HtmlElement):
    <span class="hljs-keyword">return</span> len(element.xpath(<span class="hljs-string">'.//a'</span>))

def density_of_text(element_info: ElementInfo):
    # <span class="hljs-keyword">if</span> denominator <span class="hljs-keyword">is</span> <span class="hljs-number">0</span>, just <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> element_info.number_of_tag - element_info.number_of_linked_tag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
    <span class="hljs-keyword">return</span> (element_info.number_of_char - element_info.number_of_linked_char) / \
           (element_info.number_of_tag - element_info.number_of_linked_tag)

def density_of_punctuation(element_info: ElementInfo):
    result = (element_info.number_of_char - element_info.number_of_linked_char) / \
             (element_info.number_of_punctuation + <span class="hljs-number">1</span>)
    # result should not be zero
    <span class="hljs-keyword">return</span> result or <span class="hljs-number">1</span>

def number_of_punctuation(element: HtmlElement):
    text = <span class="hljs-string">''</span>.join(element.xpath(<span class="hljs-string">'.//text()'</span>))
    text = re.sub(<span class="hljs-string">r'\s*'</span>, <span class="hljs-string">''</span>, text, flags=re.S)
    punctuations = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> PUNCTUATION]
    <span class="hljs-keyword">return</span> len(punctuations)
</code></pre>











<p data-nodeid="94140">这里比较重要的就是 density_of_text 和 density_of_punctuation 两个方法了，分别代表文本密度和符号密度，其算法原理在上一节已经提到了，可以参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的内容。</p>
<p data-nodeid="94141">好，这样我们运行完毕之后，就可以得到每个节点的各个指标啦。最后，我们继续参考论文《洪鸿辉，等 基于文本富豪密度的网页正文提取方法》的公式，根据各个指标计算每个节点的得分情况，最后提取内容即可：</p>

<pre class="lang-dart" data-nodeid="107493"><code data-language="dart"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
# start to evaluate every child element
element_infos = []
child_elements = children_of_body(element)
<span class="hljs-keyword">for</span> child_element <span class="hljs-keyword">in</span> child_elements:
    # <span class="hljs-keyword">new</span> element info
    element_info = ElementInfo()
    element_info.element = child_element
    element_info = fill_element_info(element_info)
    element_infos.append(element_info)
    # <span class="hljs-keyword">get</span> std of density_of_text among all elements
    density_of_text = [element_info.density_of_text <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos]
    density_of_text_std = np.std(density_of_text, ddof=<span class="hljs-number">1</span>)
    # <span class="hljs-keyword">get</span> density_score of every element
    <span class="hljs-keyword">for</span> element_info <span class="hljs-keyword">in</span> element_infos:
        score = np.log(density_of_text_std) * \
                element_info.density_of_text * \
                np.log10(element_info.number_of_p_tag + <span class="hljs-number">2</span>) * \
                np.log(element_info.density_of_punctuation)
        element_info.density_score = score
    # sort element info by density_score
    element_infos = sorted(element_infos, key=lambda x: x.density_score, reverse=True)
    element_info_first = element_infos[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> element_infos <span class="hljs-keyword">else</span> None
    text = <span class="hljs-string">'\n'</span>.join(element_info_first.element.xpath(<span class="hljs-string">'.//p//text()'</span>))
</code></pre>














<p data-nodeid="108446">这里我们首先计算了 density_of_text 的标准差，然后对各个节点计算了最终的密度得分，最后排序得到最高的节点，获取文本值即可。</p>
<p data-nodeid="108447">运行结果如下：</p>

<pre class="lang-java" data-nodeid="109406"><code data-language="java"><span class="hljs-string">"“我的名字叫紫禁城，快要600岁了，这上元的夜啊，总是让我沉醉，这么久了却从未停止。”\n“重檐之上的月光，曾照进古人的宫殿；城墙上绵延的灯彩，映出了角楼的瑰丽。今夜，一群博物馆人将我点一段话。\n半小时后，“紫禁城上元之夜”的灯光点亮了北京夜空。\n午门城楼及东西雁翅楼用白、黄、红三种颜色光源装扮！\n太和门广场变成了超大的夜景灯光秀场！\n图片来源：东方IC 版权作品 请勿转载\n午门城宫博物院供图\n故宫的角楼被灯光装点出满满的节日气氛！\n故宫博物院供图\n令人惊叹的是，故宫的“网红”藏品《清明上河图》《千里江山图卷》在“灯会”中展开画卷。\n灯光版《清明上河图》\n以灯为笔，以屋顶为，故宫博物院最北端神武门也被灯光点亮！\n故宫博物院供图\n上元之夜，故宫邀请了劳动模范、北京榜样、快递小哥、环卫工人、解放军和武警官兵、消防指战员、公安干警等各界代表以及预约成功的观众，共3000人故宫博物院供图\n时间退回到两天前，故宫博物院发布了2月19日(正月十五)、20日(正月十六)即将举办“紫禁城上元之夜”文化活动的消息。\n图片来源：视觉中国\n18日凌晨，一众网友前往故宫博物院官网抢票，网站甚节就有诸多讲究。\n有灯无月不娱人，有月无灯不算春。\n春到人间人似玉，灯烧月下月如怠。\n满街珠翠游村女，沸地笙歌赛社神。\n不展芳尊开口笑，如何消得此良辰。\n——唐伯虎《元宵》\n明代宫中过上元节，皇宵节晚会”。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄\n其中，灯戏颇为有趣。由多人舞灯拼出吉祥文字及图案，每人手执彩灯、身着不同颜色的服装，翩翩起舞，类似于现代的大型团体操表演。\n但这紫禁城，恭亲王奕 与英法联军交换了《天津条约》批准书，并订立《中英北京条约》《中法北京条约》作为补充。\n战争结束了，侵略者摇身一变成了游客。一位外国“摄影师”拍下了当年的紫禁城，并在日记里写到，百年。\n直到上世纪40年代时，故宫的环境仍然并不是想象中的博物馆的状态。\n曾有故宫博物院工作人员撰文回忆，当时的故宫内杂草丛生，房倒屋漏，有屋顶竟长出了树木。光是清理当时宫中存留的垃圾、杂草就用单霁翔到任故宫院长。那时，他拿到的故宫博物院介绍，写了这座博物馆诸多的“世界之最”。\n可他觉得，当自己真正走到观众中间，这些“世界之最”都没有了。\n2月18日，北京故宫午门调试灯光。中新社记者 杜洋 摄外环境进行了大整治。\n游客没有地方休息，那就拆除了宫中的临时建筑、新增供游客休息的椅子；\n游客排队上厕所，那就将一个职工食堂都改成了洗手间；\n游客买票难，那就全面采用电子购票，新增多个售票点；馆。\n今年，持续整个正月的“过大年”展览和“紫禁城上元之夜”，让本该是淡季的故宫变得一票难求。\n在不少普通人眼中，近600岁的故宫正变得越来越年轻。\n资料图：故宫博物院院长单霁翔。中新社记者 刘关关 摄元宵节活动进行评估后，或结合二十四节气等重要时间节点推出夜场活动。\n你期待吗？\n作者：上官云 宋宇晟"</span>
</code></pre>

<p data-nodeid="1743">可以看到，正文就被成功提取出来了。</p>
<h3 data-nodeid="110359" class="">整理</h3>

<p data-nodeid="1745">最后整理一下，三者结果合并，输出为 JSON 格式，实现如下：</p>
<pre class="lang-java" data-nodeid="111313"><code data-language="java"><span class="hljs-function">def <span class="hljs-title">extract</span><span class="hljs-params">(html)</span>:
    return </span>{
        <span class="hljs-string">'title'</span>: extract_title(html),
        <span class="hljs-string">'datetime'</span>: extract_datetime(html),
        <span class="hljs-string">'content'</span>: extract_content(html)
    }
</code></pre>

<p data-nodeid="113212">最后，我们可以看到类似的输出效果，内容如下：</p>
<p data-nodeid="113213" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/28/3D/CgqCHl74VdaATYm8AAKNT19ZZkg888.png" alt="image (1).png" data-nodeid="113221"></p>


<p data-nodeid="1748">到此为止，我们就成功提取出来了标题、时间和正文内容并输出为 JSON 格式了。其他的一些字段相对没有那么重要，你可以根据类似的方法来进行提取和实验。</p>
<p data-nodeid="1749">本节代码：<a href="https://github.com/Gerapy/GerapyAutoExtractor" data-nodeid="2100">https://github.com/Gerapy/GerapyAutoExtractor</a>。</p>

---

### 精选评论

##### **之路：
> 正是我需要的，大神就是大神

##### **波：
> 崔大神总能给我带来惊喜😛

