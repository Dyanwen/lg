<p data-nodeid="4145" class="">在上个课时中，我们学会了如何用 Requests 来获取网页的源代码，得到 HTML 代码。但我们如何从 HTML 代码中获取真正想要的数据呢？</p>
<p data-nodeid="4146">正则表达式就是一个有效的方法。</p>
<p data-nodeid="4147">本课时中，我们将学习正则表达式的相关用法。正则表达式是处理字符串的强大工具，它有自己特定的语法结构。有了它，我们就能实现字符串的检索、替换、匹配验证。</p>
<p data-nodeid="4148">当然，对于爬虫来说，有了它，要从 HTML 里提取想要的信息就非常方便了。</p>
<h3 data-nodeid="4149">实例引入</h3>
<p data-nodeid="4150">说了这么多，可能我们对正则表达式的概念还是比较模糊，下面就用几个实例来看一下正则表达式的用法。</p>
<p data-nodeid="4151">打开开源中国提供的正则表达式测试工具&nbsp;<a href="http://tool.oschina.net/regex/" data-nodeid="4445">http://tool.oschina.net/regex/</a>，输入待匹配的文本，然后选择常用的正则表达式，就可以得出相应的匹配结果了。</p>
<p data-nodeid="4152">例如，输入下面这段待匹配的文本：</p>
<pre class="lang-python" data-nodeid="4153"><code data-language="python">Hello, my phone number <span class="hljs-keyword">is</span> <span class="hljs-number">010</span><span class="hljs-number">-86432100</span> <span class="hljs-keyword">and</span> email <span class="hljs-keyword">is</span> cqc@cuiqingcai.com, <span class="hljs-keyword">and</span> my website <span class="hljs-keyword">is</span> https://cuiqingcai.com.
</code></pre>
<p data-nodeid="4154">这段字符串中包含了一个电话号码和一个电子邮件，接下来就尝试用正则表达式提取出来，如图所示。</p>
<p data-nodeid="4155"><img src="https://s0.lgstatic.com/i/image3/M01/74/26/Cgq2xl5rZiKAcRoMAAKSM5SSmyk124.png" alt="" data-nodeid="4450"></p>
<p data-nodeid="4156">在网页右侧选择 “匹配 Email 地址”，就可以看到下方出现了文本中的 E-mail。如果选择 “匹配网址 URL”，就可以看到下方出现了文本中的 URL。是不是非常神奇？</p>
<p data-nodeid="4157">其实，这里使用了正则表达式的匹配功能，也就是用一定规则将特定的文本提取出来。</p>
<p data-nodeid="4158">比方说，电子邮件是有其特定的组成格式的：一段字符串 + @ 符号 + 某个域名。而 URL的组成格式则是协议类型 + 冒号加双斜线 + 域名和路径。</p>
<p data-nodeid="4159">可以用下面的正则表达式匹配 URL：</p>
<pre data-nodeid="4160"><code>[a-zA-z]+://[^\s]*
</code></pre>
<p data-nodeid="4161">用这个正则表达式去匹配一个字符串，如果这个字符串中包含类似 URL 的文本，那就会被提取出来。</p>
<p data-nodeid="4162">这个看上去乱糟糟的正则表达式其实有特定的语法规则。比如，a-z 匹配任意的小写字母，\s 匹配任意的空白字符，* 匹配前面任意多个字符。这一长串的正则表达式就是这么多匹配规则的组合。</p>
<p data-nodeid="4163">写好正则表达式后，就可以拿它去一个长字符串里匹配查找了。不论这个字符串里面有什么，只要符合我们写的规则，统统可以找出来。对于网页来说，如果想找出网页源代码里有多少 URL，用 URL 的正则表达式去匹配即可。</p>
<p data-nodeid="4164">下表中列出了常用的匹配规则：<br>
<br></p>
<table data-nodeid="4165">
<thead data-nodeid="4166">
<tr data-nodeid="4167">
<th data-nodeid="4169"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">模　　式</span></span></span></th>
<th data-nodeid="4170"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">描　　述</span></span></span></th>
</tr>
</thead>
<tbody data-nodeid="4173">
<tr data-nodeid="4174">
<td data-nodeid="4175"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\w</span></span></span></td>
<td data-nodeid="4176"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配字母、数字及下划线</span></span></span></td>
</tr>
<tr data-nodeid="4177">
<td data-nodeid="4178"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\W</span></span></span></td>
<td data-nodeid="4179"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配不是字母、数字及下划线的字符</span></span></span></td>
</tr>
<tr data-nodeid="4180">
<td data-nodeid="4181"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\s</span></span></span></td>
<td data-nodeid="4182"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配任意空白字符，等价于 [\t\n\r\f]</span></span></span></td>
</tr>
<tr data-nodeid="4183">
<td data-nodeid="4184"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\S</span></span></span></td>
<td data-nodeid="4185"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配任意非空字符</span></span></span></td>
</tr>
<tr data-nodeid="4186">
<td data-nodeid="4187"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\d</span></span></span></td>
<td data-nodeid="4188"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配任意数字，等价于 [0~9]</span></span></span></td>
</tr>
<tr data-nodeid="4189">
<td data-nodeid="4190"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\D</span></span></span></td>
<td data-nodeid="4191"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配任意非数字的字符</span></span></span></td>
</tr>
<tr data-nodeid="4192">
<td data-nodeid="4193"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\A</span></span></span></td>
<td data-nodeid="4194"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配字符串开头</span></span></span></td>
</tr>
<tr data-nodeid="4195">
<td data-nodeid="4196"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\Z</span></span></span></td>
<td data-nodeid="4197"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串</span></span></span></td>
</tr>
<tr data-nodeid="4198">
<td data-nodeid="4199"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\z</span></span></span></td>
<td data-nodeid="4200"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配字符串结尾，如果存在换行，同时还会匹配换行符</span></span></span></td>
</tr>
<tr data-nodeid="4201">
<td data-nodeid="4202"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\G</span></span></span></td>
<td data-nodeid="4203"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配最后匹配完成的位置</span></span></span></td>
</tr>
<tr data-nodeid="4204">
<td data-nodeid="4205"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\n</span></span></span></td>
<td data-nodeid="4206"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配一个换行符</span></span></span></td>
</tr>
<tr data-nodeid="4207">
<td data-nodeid="4208"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">\t</span></span></span></td>
<td data-nodeid="4209"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配一个制表符</span></span></span></td>
</tr>
<tr data-nodeid="4210">
<td data-nodeid="4211"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">^</span></span></span></td>
<td data-nodeid="4212"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配一行字符串的开头</span></span></span></td>
</tr>
<tr data-nodeid="4213">
<td data-nodeid="4214"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">$</span></span></span></td>
<td data-nodeid="4215"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配一行字符串的结尾</span></span></span></td>
</tr>
<tr data-nodeid="4216">
<td data-nodeid="4217"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">.</span></span></span></td>
<td data-nodeid="4218"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符</span></span></span></td>
</tr>
<tr data-nodeid="4219">
<td data-nodeid="4220"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">[...]</span></span></span></td>
<td data-nodeid="4221"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k</span></span></span></td>
</tr>
<tr data-nodeid="4222">
<td data-nodeid="4223"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">[^...]</span></span></span></td>
<td data-nodeid="4224"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">不在 [] 中的字符，比如 &nbsp;匹配除了 a、b、c 之外的字符</span></span></span></td>
</tr>
<tr data-nodeid="4225">
<td data-nodeid="4226"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">*</span></span></span></td>
<td data-nodeid="4227"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配 0 个或多个表达式</span></span></span></td>
</tr>
<tr data-nodeid="4228">
<td data-nodeid="4229"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">+</span></span></span></td>
<td data-nodeid="4230"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配 1 个或多个表达式</span></span></span></td>
</tr>
<tr data-nodeid="4231">
<td data-nodeid="4232"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">?</span></span></span></td>
<td data-nodeid="4233"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式</span></span></span></td>
</tr>
<tr data-nodeid="4234">
<td data-nodeid="4235"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">{n}</span></span></span></td>
<td data-nodeid="4236"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">精确匹配 n 个前面的表达式</span></span></span></td>
</tr>
<tr data-nodeid="4237">
<td data-nodeid="4238"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">{n, m}</span></span></span></td>
<td data-nodeid="4239"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式</span></span></span></td>
</tr>
<tr data-nodeid="4240">
<td data-nodeid="4241"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">a|b</span></span></span></td>
<td data-nodeid="4242"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配 a 或 b</span></span></span></td>
</tr>
<tr data-nodeid="4243">
<td data-nodeid="4244"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">()</span></span></span></td>
<td data-nodeid="4245"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">匹配括号内的表达式，也表示一个组</span></span></span></td>
</tr>
</tbody>
</table>
<p data-nodeid="4246">看完之后，你可能有点晕晕的吧，不用担心，后面我们会详细讲解一些常见规则的用法。</p>
<p data-nodeid="4247">其实正则表达式不是 Python 独有的，它也可以用在其他编程语言中。但是 Python 的 re 库提供了整个正则表达式的实现，利用这个库，可以在 Python 中使用正则表达式。</p>
<p data-nodeid="4248">在 Python 中写正则表达式几乎都用这个库，下面就来了解它的一些常用方法。</p>
<h3 data-nodeid="4249">match</h3>
<p data-nodeid="4250">首先介绍一个常用的匹配方法 —— match，向它传入要匹配的字符串，以及正则表达式，就可以检测这个正则表达式是否匹配字符串。</p>
<p data-nodeid="4251">match 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回 None。</p>
<p data-nodeid="4252">示例如下：</p>
<pre class="lang-python" data-nodeid="4253"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>
print(len(content))
result = re.match(<span class="hljs-string">'^Hello\s\d\d\d\s\d{4}\s\w{10}'</span>, content)
print(result)
print(result.group())
print(result.span())
</code></pre>
<p data-nodeid="4254">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4255"><code data-language="html">41
<span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">25</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 123 4567 World_This'</span>&gt;</span>
Hello 123 4567 World_This
(0, 25)
</code></pre>
<p data-nodeid="4256">这里首先声明了一个字符串，其中包含英文字母、空白字符、数字等。接下来，我们写一个正则表达式：</p>
<pre class="lang-python" data-nodeid="4257"><code data-language="python">^Hello\s\d\d\d\s\d{<span class="hljs-number">4</span>}\s\w{<span class="hljs-number">10</span>}
</code></pre>
<p data-nodeid="4258">用它来匹配这个长字符串。开头的 ^ 匹配字符串的开头，也就是以 Hello 开头； \s 匹配空白字符，用来匹配目标字符串的空格；\d 匹配数字，3 个 \d 匹配 123；再写 1 个 \s 匹配空格；后面的 4567，其实依然能用 4 个 \d 来匹配，但是这么写比较烦琐，所以后面可以跟 {4} 代表匹配前面的规则 4 次，也就是匹配 4 个数字；后面再紧接 1 个空白字符，最后\w{10} 匹配 10 个字母及下划线。</p>
<p data-nodeid="4259">我们注意到，这里并没有把目标字符串匹配完，不过依然可以进行匹配，只不过匹配结果短一点而已。</p>
<p data-nodeid="4260">而在 match 方法中，第一个参数传入正则表达式，第二个参数传入要匹配的字符串。</p>
<p data-nodeid="4261">打印输出结果，可以看到结果是 SRE_Match 对象，这证明成功匹配。该对象有两个方法：group 方法可以输出匹配的内容，结果是 Hello 123 4567 World_This，这恰好是正则表达式规则所匹配的内容；span 方法可以输出匹配的范围，结果是 (0, 25)，这就是匹配到的结果字符串在原字符串中的位置范围。</p>
<p data-nodeid="4262">通过上面的例子，我们基本了解了如何在 Python 中使用正则表达式来匹配一段文字。</p>
<h4 data-nodeid="4263">匹配目标</h4>
<p data-nodeid="4264">刚才我们用 match 方法得到了匹配到的字符串内容，但当我们想从字符串中提取一部分内容，该怎么办呢？</p>
<p data-nodeid="4265">就像最前面的实例一样，要从一段文本中提取出邮件或电话号码等内容。我们可以使用 () 括号将想提取的子字符串括起来。() 实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，调用 group 方法传入分组的索引即可获取提取的结果。</p>
<p data-nodeid="4266">示例如下：</p>
<pre class="lang-python" data-nodeid="4267"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>
result = re.match(<span class="hljs-string">'^Hello\s(\d+)\sWorld'</span>, content)
print(result)
print(result.group())
print(result.group(<span class="hljs-number">1</span>))
print(result.span())
</code></pre>
<p data-nodeid="4268">这里我们想把字符串中的 1234567 提取出来，此时可以将数字部分的正则表达式用 () 括起来，然后调用了 group(1) 获取匹配结果。</p>
<p data-nodeid="4269">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4270"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">19</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 1234567 World'</span>&gt;</span>
Hello 1234567 World
1234567
(0, 19)
</code></pre>
<p data-nodeid="4271">可以看到，我们成功得到了 1234567。这里用的是 group(1)，它与 group() 有所不同，后者会输出完整的匹配结果，而前者会输出第一个被 () 包围的匹配结果。假如正则表达式后面还有 () 包括的内容，那么可以依次用 group(2)、group(3) 等来获取。</p>
<h4 data-nodeid="4272">通用匹配</h4>
<p data-nodeid="4273">刚才我们写的正则表达比较复杂，出现空白字符我们就写 \s 匹配，出现数字我们就用 \d 匹配，这样的工作量非常大。</p>
<p data-nodeid="4274">我们还可以用一个万能匹配来减少这些工作，那就是 .*。其中 . 可以匹配任意字符（除换行符），* 代表匹配前面的字符无限次，它们组合在一起就可以匹配任意字符了。有了它，我们就不用挨个字符的匹配了。</p>
<p data-nodeid="4275">接着上面的例子，我们可以改写一下正则表达式：</p>
<pre class="lang-python" data-nodeid="4276"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>
result = re.match(<span class="hljs-string">'^Hello.*Demo$'</span>, content)
print(result)
print(result.group())
print(result.span())
</code></pre>
<p data-nodeid="4277">这里我们将中间部分直接省略，全部用 .* 来代替，最后加一个结尾字符就好了。</p>
<p data-nodeid="4278">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4279"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">41</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;</span>
Hello 123 4567 World_This is a Regex Demo
(0, 41)
</code></pre>
<p data-nodeid="4280">可以看到，group 方法输出了匹配的全部字符串，也就是说我们写的正则表达式匹配到了目标字符串的全部内容；span 方法输出 (0, 41)，这是整个字符串的长度。</p>
<p data-nodeid="4281">因此，我们可以使用 .* 简化正则表达式的书写。</p>
<h4 data-nodeid="4282">贪婪与非贪婪</h4>
<p data-nodeid="4283">使用上面的通用匹配 .* 时，有时候匹配到的并不是我们想要的结果。</p>
<p data-nodeid="4284">看下面的例子：</p>
<pre class="lang-python" data-nodeid="4285"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>
result = re.match(<span class="hljs-string">'^He.*(\d+).*Demo$'</span>, content)
print(result)
print(result.group(<span class="hljs-number">1</span>))
</code></pre>
<p data-nodeid="4286">这里我们依然想获取中间的数字，所以中间依然写的是 (\d+)。由于数字两侧的内容比较杂乱，所以略写成 .*。最后，组成 ^He.*(\d+).*Demo$，看样子并没有什么问题。</p>
<p data-nodeid="4287">我们看下运行结果：</p>
<pre class="lang-html" data-nodeid="4288"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">40</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span>
7
</code></pre>
<p data-nodeid="4289">奇怪的事情发生了，我们只得到了 7 这个数字，这是怎么回事呢？</p>
<p data-nodeid="4290">这里就涉及一个贪婪匹配与非贪婪匹配的问题了。在贪婪匹配下，.* 会匹配尽可能多的字符。正则表达式中 .* 后面是 \d+，也就是至少一个数字，并没有指定具体多少个数字，因此，.* 就尽可能匹配多的字符，这里就把 123456 匹配了，给 \d+ 留下一个可满足条件的数字 7，最后得到的内容就只有数字 7 了。</p>
<p data-nodeid="4291">这显然会给我们带来很大的不便。有时候，匹配结果会莫名其妙少了一部分内容。其实，这里只需要使用非贪婪匹配就好了。非贪婪匹配的写法是 .*?，多了一个 ？，那么它可以达到怎样的效果？</p>
<p data-nodeid="4292">我们再用实例看一下：</p>
<pre class="lang-python" data-nodeid="4293"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>
result = re.match(<span class="hljs-string">'^He.*?(\d+).*Demo$'</span>, content)
print(result)
print(result.group(<span class="hljs-number">1</span>))
</code></pre>
<p data-nodeid="4294">这里我们只是将第一个.* 改成了 .*?，转变为非贪婪匹配。</p>
<p data-nodeid="4295">结果如下：</p>
<pre class="lang-html" data-nodeid="4296"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">40</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span>
1234567
</code></pre>
<p data-nodeid="4297">此时就可以成功获取 1234567 了。原因可想而知，贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符。当 .*? 匹配到 Hello 后面的空白字符时，再往后的字符就是数字了，而 \d+ 恰好可以匹配，那么 .*? 就不再进行匹配，交给 \d+ 去匹配后面的数字。这样 .*? 匹配了尽可能少的字符，\d+ 的结果就是 1234567 了。</p>
<p data-nodeid="4298">所以，在做匹配的时候，字符串中间尽量使用非贪婪匹配，也就是用 .*? 来代替 .*，以免出现匹配结果缺失的情况。</p>
<p data-nodeid="4299">但需要注意的是，如果匹配的结果在字符串结尾，.*? 就有可能匹配不到任何内容了，因为它会匹配尽可能少的字符。例如：</p>
<pre class="lang-python" data-nodeid="4300"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'http://weibo.com/comment/kEraCN'</span>
result1 = re.match(<span class="hljs-string">'http.*?comment/(.*?)'</span>, content)
result2 = re.match(<span class="hljs-string">'http.*?comment/(.*)'</span>, content)
print(<span class="hljs-string">'result1'</span>, result1.group(<span class="hljs-number">1</span>))
print(<span class="hljs-string">'result2'</span>, result2.group(<span class="hljs-number">1</span>))
</code></pre>
<p data-nodeid="4301">运行结果如下：</p>
<pre data-nodeid="9327" class="te-preview-highlight"><code>result1 
result2 kEraCN
</code></pre>



<p data-nodeid="4303" class="">可以观察到，.*? 没有匹配到任何结果，而 .* 则尽量匹配多的内容，成功得到了匹配结果。</p>
<h4 data-nodeid="4304">修饰符</h4>
<p data-nodeid="4305">正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。</p>
<p data-nodeid="4306">我们用实例来看一下：</p>
<pre class="lang-python" data-nodeid="4307"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'''Hello 1234567 World_This
is a Regex Demo
'''</span>
result = re.match(<span class="hljs-string">'^He.*?(\d+).*?Demo$'</span>, content)
print(result.group(<span class="hljs-number">1</span>))
</code></pre>
<p data-nodeid="4308">和上面的例子相仿，我们在字符串中加了换行符，正则表达式还是一样的，用来匹配其中的数字。看一下运行结果：</p>
<pre class="lang-html" data-nodeid="4309"><code data-language="html">AttributeError Traceback (most recent call last)
<span class="hljs-tag">&lt;<span class="hljs-name">ipython-input-18-c7d232b39645</span>&gt;</span> in <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>()
      5 '''
      6 result = re.match('^He.*?(\d+).*?Demo$', content)
----&gt; 7 print(result.group(1))

AttributeError: 'NoneType' object has no attribute 'group'
</code></pre>
<p data-nodeid="4310">运行直接报错，也就是说正则表达式没有匹配到这个字符串，返回结果为 None，而我们又调用了 group 方法导致 AttributeError。</p>
<p data-nodeid="4311">为什么加了一个换行符，就匹配不到了呢？</p>
<p data-nodeid="4312">这是因为我们匹配的是除换行符之外的任意字符，当遇到换行符时，.*? 就不能匹配了，导致匹配失败。</p>
<p data-nodeid="4313">这里只需加一个修饰符 re.S，即可修正这个错误：</p>
<pre class="lang-python" data-nodeid="4314"><code data-language="python">result = re.match(<span class="hljs-string">'^He.*?(\d+).*?Demo$'</span>, content, re.S)
</code></pre>
<p data-nodeid="4315">这个修饰符的作用是匹配包括换行符在内的所有字符。</p>
<p data-nodeid="4316">此时运行结果如下：</p>
<pre data-nodeid="4317"><code>1234567
</code></pre>
<p data-nodeid="4318">这个 re.S 在网页匹配中经常用到。因为 HTML 节点经常会有换行，加上它，就可以匹配节点与节点之间的换行了。</p>
<p data-nodeid="4319">另外，还有一些修饰符，在必要的情况下也可以使用，如表所示：</p>
<table data-nodeid="4321">
<thead data-nodeid="4322">
<tr data-nodeid="4323">
<th data-nodeid="4325"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">修饰符</span></span></span></th>
<th data-nodeid="4326"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">描　　述</span></span></span></th>
</tr>
</thead>
<tbody data-nodeid="4329">
<tr data-nodeid="4330">
<td data-nodeid="4331"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.I</span></span></span></td>
<td data-nodeid="4332"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">使匹配对大小写不敏感</span></span></span></td>
</tr>
<tr data-nodeid="4333">
<td data-nodeid="4334"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.L</span></span></span></td>
<td data-nodeid="4335"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">做本地化识别（locale-aware）匹配</span></span></span></td>
</tr>
<tr data-nodeid="4336">
<td data-nodeid="4337"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.M</span></span></span></td>
<td data-nodeid="4338"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">多行匹配，影响 ^ 和 $</span></span></span></td>
</tr>
<tr data-nodeid="4339">
<td data-nodeid="4340"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.S</span></span></span></td>
<td data-nodeid="4341"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">使匹配包括换行在内的所有字符</span></span></span></td>
</tr>
<tr data-nodeid="4342">
<td data-nodeid="4343"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.U</span></span></span></td>
<td data-nodeid="4344"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">根据 Unicode 字符集解析字符。这个标志影响 \w、\W、\b 和 \B</span></span></span></td>
</tr>
<tr data-nodeid="4345">
<td data-nodeid="4346"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">re.X</span></span></span></td>
<td data-nodeid="4347"><span style="color:#3f3f3f"><span class="font" style="font-family:微软雅黑, &quot;Microsoft YaHei&quot;"><span class="size" style="font-size:16px">该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</span></span></span></td>
</tr>
</tbody>
</table>
<p data-nodeid="4348">在网页匹配中，较为常用的修饰符有 re.S 和 re.I。</p>
<h4 data-nodeid="4349">转义匹配</h4>
<p data-nodeid="4350">我们知道正则表达式定义了许多匹配模式，如匹配除换行符以外的任意字符，但如果目标字符串里面就包含 .，那该怎么办呢？</p>
<p data-nodeid="4351">这里就需要用到转义匹配了，示例如下：</p>
<pre class="lang-python" data-nodeid="4352"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'(百度) www.baidu.com'</span>
result = re.match(<span class="hljs-string">'\(百度 \) www\.baidu\.com'</span>, content)
print(result)
</code></pre>
<p data-nodeid="4353">当遇到用于正则匹配模式的特殊字符时，在前面加反斜线转义一下即可。例 . 就可以用 \. 来匹配。</p>
<p data-nodeid="4354">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4355"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(0,</span> <span class="hljs-attr">17</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'(百度) www.baidu.com'</span>&gt;</span>
</code></pre>
<p data-nodeid="4356">可以看到，这里成功匹配到了原字符串。</p>
<p data-nodeid="4357">这些是写正则表达式常用的几个知识点，熟练掌握它们对后面写正则表达式匹配非常有帮助。</p>
<h3 data-nodeid="4358">search</h3>
<p data-nodeid="4359">前面提到过，match 方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了。</p>
<p data-nodeid="4360">我们看下面的例子：</p>
<pre class="lang-python" data-nodeid="4361"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'Extra stings Hello 1234567 World_This is a Regex Demo Extra stings'</span>
result = re.match(<span class="hljs-string">'Hello.*?(\d+).*?Demo'</span>, content)
print(result)
</code></pre>
<p data-nodeid="4362">这里的字符串以 Extra 开头，但是正则表达式以 Hello 开头，整个正则表达式是字符串的一部分，但是这样匹配是失败的。</p>
<p data-nodeid="4363">运行结果如下：</p>
<pre data-nodeid="4364"><code>None
</code></pre>
<p data-nodeid="4365">因为 match 方法在使用时需要考虑到开头的内容，这在做匹配时并不方便。它更适合用来检测某个字符串是否符合某个正则表达式的规则。</p>
<p data-nodeid="4366">这里有另外一个方法 search，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果。也就是说，正则表达式可以是字符串的一部分，在匹配时，search 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，就返回 None。</p>
<p data-nodeid="4367">我们把上面代码中的 match 方法修改成 search，再看下运行结果：</p>
<pre class="lang-html" data-nodeid="4368"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">_sre.SRE_Match</span> <span class="hljs-attr">object</span>; <span class="hljs-attr">span</span>=<span class="hljs-string">(13,</span> <span class="hljs-attr">53</span>), <span class="hljs-attr">match</span>=<span class="hljs-string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span>
1234567
</code></pre>
<p data-nodeid="4369">这时就得到了匹配结果。</p>
<p data-nodeid="4370">因此，为了匹配方便，我们可以尽量使用 search 方法。</p>
<p data-nodeid="4371">下面再用几个实例来看看 search 方法的用法。</p>
<p data-nodeid="4372">这里有一段待匹配的 HTML 文本，接下来我们写几个正则表达式实例来实现相应信息的提取：</p>
<pre class="lang-html" data-nodeid="4373"><code data-language="html">html = '''<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"songs-list"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>经典老歌<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"introduction"</span>&gt;</span>
经典老歌列表
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"2"</span>&gt;</span>一路上有你<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"7"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/2.mp3"</span> <span class="hljs-attr">singer</span>=<span class="hljs-string">"任贤齐"</span>&gt;</span>沧海一声笑<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"4"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/3.mp3"</span> <span class="hljs-attr">singer</span>=<span class="hljs-string">"齐秦"</span>&gt;</span>往事随风<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"6"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/4.mp3"</span> <span class="hljs-attr">singer</span>=<span class="hljs-string">"beyond"</span>&gt;</span>光辉岁月<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"5"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/5.mp3"</span> <span class="hljs-attr">singer</span>=<span class="hljs-string">"陈慧琳"</span>&gt;</span>记事本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"5"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/6.mp3"</span> <span class="hljs-attr">singer</span>=<span class="hljs-string">"邓丽君"</span>&gt;</span>但愿人长久<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>'''
</code></pre>
<p data-nodeid="4374">可以观察到，ul 节点里有许多 li 节点，其中 li 节点中有的包含 a 节点，有的不包含 a 节点，a 节点还有一些相应的属性 —— 超链接和歌手名。</p>
<p data-nodeid="4375">首先，我们尝试提取 class为 active 的 li 节点内部超链接包含的歌手名和歌名，此时需要提取第三个 li 节点下 a 节点的 singer 属性和文本。</p>
<p data-nodeid="4376">此时，正则表达式可以用 li 开头，然后寻找一个标志符 active，中间的部分可以用 .*? 来匹配。</p>
<p data-nodeid="4377">接下来，要提取 singer 这个属性值，所以还需要写入 singer="(.*?)"，这里需要提取的部分用小括号括起来，以便用 group 方法提取出来，它的两侧边界是双引号。</p>
<p data-nodeid="4378">然后还需要匹配 a 节点的文本，其中它的左边界是 &gt;，右边界是 &lt;/a&gt;。目标内容依然用 (.*?) 来匹配，所以最后的正则表达式就变成了：</p>
<pre class="lang-html" data-nodeid="4379"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">li.*?active.*?singer="(.*?)"</span>&gt;</span>(.*?)<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<p data-nodeid="4380">然后再调用 search 方法，它会搜索整个 HTML 文本，找到符合正则表达式的第一个内容返回。</p>
<p data-nodeid="4381">另外，由于代码有换行，所以这里第三个参数需要传入 re.S。整个匹配代码如下：</p>
<pre class="lang-python" data-nodeid="4382"><code data-language="python">result = re.search(<span class="hljs-string">'&lt;li.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S) 
<span class="hljs-keyword">if</span> result:
    print(result.group(<span class="hljs-number">1</span>), result.group(<span class="hljs-number">2</span>))
</code></pre>
<p data-nodeid="4383">由于需要获取的歌手和歌名都已经用小括号包围，所以可以用 group 方法获取。</p>
<p data-nodeid="4384">运行结果如下：</p>
<pre data-nodeid="4385"><code>齐秦 往事随风
</code></pre>
<p data-nodeid="4386">可以看到，这正是 class 为 active 的 li 节点内部的超链接包含的歌手名和歌名。</p>
<p data-nodeid="4387">如果正则表达式不加 active（也就是匹配不带 class 为 active 的节点内容），那会怎样呢？我们将正则表达式中的 active 去掉。</p>
<p data-nodeid="4388">代码改写如下：</p>
<pre class="lang-python" data-nodeid="4389"><code data-language="python">result = re.search(<span class="hljs-string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)
<span class="hljs-keyword">if</span> result:
    print(result.group(<span class="hljs-number">1</span>), result.group(<span class="hljs-number">2</span>))
</code></pre>
<p data-nodeid="4390">由于 search 方法会返回第一个符合条件的匹配目标，这里结果就变了：</p>
<pre data-nodeid="4391"><code>任贤齐 沧海一声笑
</code></pre>
<p data-nodeid="4392">把 active 标签去掉后，从字符串开头开始搜索，此时符合条件的节点就变成了第二个 li 节点，后面的不再匹配，所以运行结果变成第二个 li 节点中的内容。</p>
<p data-nodeid="4393">注意，在上面的两次匹配中，search 方法的第三个参数都加了 re.S，这使得 .*? 可以匹配换行，所以含有换行的 li 节点被匹配到了。如果我们将其去掉，结果会是什么？</p>
<p data-nodeid="4394">代码如下：</p>
<pre class="lang-python" data-nodeid="4395"><code data-language="python">result = re.search(<span class="hljs-string">'&lt;li.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html)
<span class="hljs-keyword">if</span> result:
    print(result.group(<span class="hljs-number">1</span>), result.group(<span class="hljs-number">2</span>))
</code></pre>
<p data-nodeid="4396">运行结果如下：</p>
<pre data-nodeid="4397"><code>beyond 光辉岁月
</code></pre>
<p data-nodeid="4398">可以看到，结果变成了第四个 li 节点的内容。这是因为第二个和第三个 li 节点都包含了换行符，去掉 re.S 之后，.*? 已经不能匹配换行符，所以正则表达式不会匹配到第二个和第三个 li 节点，而第四个 li 节点中不包含换行符，所以成功匹配。</p>
<p data-nodeid="4399">由于绝大部分的 HTML 文本都包含了换行符，所以尽量都需要加上 re.S 修饰符，以免出现匹配不到的问题。</p>
<h3 data-nodeid="4400">findall</h3>
<p data-nodeid="4401">前面我们介绍了 search 方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果想要获取匹配正则表达式的所有内容，那该怎么办呢？这时就要借助 findall 方法了。</p>
<p data-nodeid="4402">该方法会搜索整个字符串，然后返回匹配正则表达式的所有内容。</p>
<p data-nodeid="4403">还是上面的 HTML 文本，如果想获取所有 a 节点的超链接、歌手和歌名，就可以将 search 方法换成 findall 方法。如果有返回结果的话，就是列表类型，所以需要遍历一下来依次获取每组内容。</p>
<p data-nodeid="4404">代码如下：</p>
<pre class="lang-python" data-nodeid="4405"><code data-language="python">results = re.findall(<span class="hljs-string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>, html, re.S)
print(results)
print(type(results))
<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
    print(result)
    print(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>], result[<span class="hljs-number">2</span>])
</code></pre>
<p data-nodeid="4406">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4407"><code data-language="html">[('/2.mp3', ' 任贤齐 ', ' 沧海一声笑 '), ('/3.mp3', ' 齐秦 ', ' 往事随风 '), ('/4.mp3', 'beyond', ' 光辉岁月 '), ('/5.mp3', ' 陈慧琳 ', ' 记事本 '), ('/6.mp3', ' 邓丽君 ', ' 但愿人长久 ')]
<span class="hljs-tag">&lt;<span class="hljs-name">class</span> '<span class="hljs-attr">list</span>'&gt;</span>
('/2.mp3', ' 任贤齐 ', ' 沧海一声笑 ')
/2.mp3 任贤齐 沧海一声笑
('/3.mp3', ' 齐秦 ', ' 往事随风 ')
/3.mp3 齐秦 往事随风
('/4.mp3', 'beyond', ' 光辉岁月 ')
/4.mp3 beyond 光辉岁月
('/5.mp3', ' 陈慧琳 ', ' 记事本 ')
/5.mp3 陈慧琳 记事本
('/6.mp3', ' 邓丽君 ', ' 但愿人长久 ')
/6.mp3 邓丽君 但愿人长久
</code></pre>
<p data-nodeid="4408">可以看到，返回的列表中的每个元素都是元组类型，我们用对应的索引依次取出即可。</p>
<p data-nodeid="4409">如果只是获取第一个内容，可以用 search 方法。当需要提取多个内容时，可以用 findall 方法。</p>
<h3 data-nodeid="4410">sub</h3>
<p data-nodeid="4411">除了使用正则表达式提取信息外，有时候还需要借助它来修改文本。比如，想要把一串文本中的所有数字都去掉，如果只用字符串的 replace 方法，那就太烦琐了，这时可以借助 sub 方法。</p>
<p data-nodeid="4412">示例如下：</p>
<pre class="lang-python" data-nodeid="4413"><code data-language="python"><span class="hljs-keyword">import</span> re

content = <span class="hljs-string">'54aK54yr5oiR54ix5L2g'</span>
content = re.sub(<span class="hljs-string">'\d+'</span>, <span class="hljs-string">''</span>, content)
print(content)
</code></pre>
<p data-nodeid="4414">运行结果如下：</p>
<pre data-nodeid="4415"><code>aKyroiRixLg
</code></pre>
<p data-nodeid="4416">这里只需要给第一个参数传入 \d+ 来匹配所有的数字，第二个参数替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串。</p>
<p data-nodeid="4417">在上面的 HTML 文本中，如果想获取所有 li 节点的歌名，直接用正则表达式来提取可能比较烦琐。比如，可以写成这样子：</p>
<pre class="lang-python" data-nodeid="4418"><code data-language="python">results = re.findall(<span class="hljs-string">'&lt;li.*?&gt;\s*?(&lt;a.*?&gt;)?(\w+)(&lt;/a&gt;)?\s*?&lt;/li&gt;'</span>, html, re.S)
<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
    print(result[<span class="hljs-number">1</span>])
</code></pre>
<p data-nodeid="4419">运行结果如下：</p>
<pre data-nodeid="4420"><code>一路上有你
沧海一声笑
往事随风
光辉岁月
记事本
但愿人长久
</code></pre>
<p data-nodeid="4421">此时借助 sub 方法就比较简单了。可以先用 sub 方法将 a 节点去掉，只留下文本，然后再利用 findall 提取就好了：</p>
<pre class="lang-html" data-nodeid="4422"><code data-language="html">html = re.sub('<span class="hljs-tag">&lt;<span class="hljs-name">a.*?</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>', '', html)
print(html)
results = re.findall('<span class="hljs-tag">&lt;<span class="hljs-name">li.*?</span>&gt;</span>(.*?)<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>', html, re.S)
for result in results:
    print(result.strip())
</code></pre>
<p data-nodeid="4423">运行结果如下：</p>
<pre class="lang-html" data-nodeid="4424"><code data-language="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"songs-list"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span> 经典老歌 <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"introduction"</span>&gt;</span>
        经典老歌列表
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"2"</span>&gt;</span> 一路上有你 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"7"</span>&gt;</span>
            沧海一声笑
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"4"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span>
            往事随风
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"6"</span>&gt;</span> 光辉岁月 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"5"</span>&gt;</span> 记事本 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-view</span>=<span class="hljs-string">"5"</span>&gt;</span>
            但愿人长久
        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
一路上有你
沧海一声笑
往事随风
光辉岁月
记事本
但愿人长久
</code></pre>
<p data-nodeid="4425">可以看到，a 节点经过 sub 方法处理后就没有了，随后我们通过 findall 方法直接提取即可。</p>
<p data-nodeid="4426">通过以上例子，你会发现，在适当的时候，借助 sub 方法可以起到事半功倍的效果。</p>
<h3 data-nodeid="4427">compile</h3>
<p data-nodeid="4428">前面所讲的方法都是用来处理字符串的方法，最后再介绍一下 compile 方法，这个方法可以将正则字符串编译成正则表达式对象，以便在后面的匹配中复用。</p>
<p data-nodeid="4429">示例代码如下：</p>
<pre class="lang-python" data-nodeid="4430"><code data-language="python"><span class="hljs-keyword">import</span> re

content1 = <span class="hljs-string">'2019-12-15 12:00'</span>
content2 = <span class="hljs-string">'2019-12-17 12:55'</span>
content3 = <span class="hljs-string">'2019-12-22 13:21'</span>
pattern = re.compile(<span class="hljs-string">'\d{2}:\d{2}'</span>)
result1 = re.sub(pattern, <span class="hljs-string">''</span>, content1)
result2 = re.sub(pattern, <span class="hljs-string">''</span>, content2)
result3 = re.sub(pattern, <span class="hljs-string">''</span>, content3)
print(result1, result2, result3)
</code></pre>
<p data-nodeid="4431">这里有 3 个日期，我们想分别将 3 个日期中的时间去掉，这时可以借助 sub 方法。该方法的第一个参数是正则表达式，但是我们没有必要重复写 3 个同样的正则表达式。此时可以借助 compile 方法将正则表达式编译成一个正则表达式对象，以便复用。</p>
<p data-nodeid="4432">运行结果如下：</p>
<pre data-nodeid="4433"><code>2019-12-15  2019-12-17  2019-12-22
</code></pre>
<p data-nodeid="4434">另外，compile 还可以传入修饰符，例如 re.S 等修饰符，这样在 search、findall 等方法中就不需要额外传了。所以，compile 方法可以说是给正则表达式做了一层封装，以便我们更好的复用。</p>
<p data-nodeid="4435" class="">到此，正则表达式的基本用法就介绍完了。后面我会通过具体的实例来讲解正则表达式的用法。</p>

---

### 精选评论

##### **斌：
> 很棒

##### **林：
> 讲得真好！！以前看过正则这块，一段时间不用就忘了……还是得多加练习啊😂

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 温故而知新嘛，学过的知识不能丢～

##### **林：
> 非常棒~

##### *正：
> 温故而知新

##### **飞：
> 深入浅出

##### **麒：
> 很喜欢

##### **盛：
> 很好

##### **7129：
> 每课都要很多遍才可以加深理解和印象，还没有上手敲，跟完一遍课程再重头来敲

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 反复琢磨才能吃透知识点，理解之后再上手敲加以实践，相信你会有更多的收获。加油！

##### bing wu：
> 以后实战项目会有么

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 会有！

##### **5151：
> 老师的博客中猫眼实战内容过期了，请问有没有猫眼的新实战了？<div><br></div>

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 后面换新的爬取案例了，都是自建案例了，不用猫眼了。猫眼的实战内容可以到 GitHub 看下 Issue，有最新更新。

##### *兴：
> 通俗易懂，博客中代码可以直接复制+运行，beautiful

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 你要继续加油呀，记得按时来听课～

##### **佳：
> bs4不讲吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; bs4、pyquery 也是一个很好的选择，由于内容量限制，这里我选取了一种来讲，bs4 也建议了解下。

##### **0926：
> 老师讲得挺好，视频也很高清

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 谢谢你的认可，我们会继续加油的

##### **泳：
> 太棒了。

