<p data-nodeid="1353" class="">Redux 相信大家或多或少都接触过，关于 Redux 的基础知识，第 05 讲已经有过铺垫。从本讲开始，我们将在此基础上，针对 Redux 进行更加系统和深入的学习。</p>
<blockquote data-nodeid="1354">
<p data-nodeid="1355">注：如果你没有接触过 Redux，点击<a href="https://www.redux.org.cn/" data-nodeid="1474">这里</a>可以快速上手。</p>
</blockquote>
<p data-nodeid="1356"><strong data-nodeid="1484">何谓“系统”的学习</strong>？系统的一个前提就是<strong data-nodeid="1485">建立必要的学习上下文</strong>，尝试理解事情的来龙去脉。</p>
<p data-nodeid="1357">这些年不管是面试、还是帮读者答疑，我有一个很强烈的感受：很多人对 Redux 的基本操作很熟悉，甚至对它的运作机制也有所了解，但就是不明白为什么要用 Redux，更不清楚 Redux 到底解决了什么问题。因此在讲源码和原理之前，我们首先需要说清楚的是 Redux 的问题背景和架构思想。</p>
<h3 data-nodeid="1358">Redux 背后的架构思想——认识 Flux 架构</h3>
<p data-nodeid="1359">Redux 的设计在很大程度上受益于 Flux 架构，我们可以认为 Redux 是 Flux 的一种实现形式（虽然它并不严格遵循 Flux 的设定），理解 Flux 将帮助你更好地从抽象层面把握 Redux。</p>
<p data-nodeid="1360">Flux 并不是一个具体的框架，它是一套由 Facebook 技术团队提出的应用架构，这套架构约束的是<strong data-nodeid="1494">应用处理数据的模式</strong>。在 Flux 架构中，一个应用将被拆分为以下 4 个部分。</p>
<ul data-nodeid="1361">
<li data-nodeid="1362">
<p data-nodeid="1363"><strong data-nodeid="1507">View</strong>（<strong data-nodeid="1508">视图层</strong>）：用户界面。该用户界面可以是以任何形式实现出来的，React 组件是一种形式，Vue、Angular 也完全 OK。<strong data-nodeid="1509">Flux 架构与 React 之间并不存在耦合关系</strong>。</p>
</li>
<li data-nodeid="1364">
<p data-nodeid="1365"><strong data-nodeid="1518">Action</strong>（<strong data-nodeid="1519">动作</strong>）：也可以理解为视图层发出的“消息”，它会触发应用状态的改变。</p>
</li>
<li data-nodeid="1366">
<p data-nodeid="1367"><strong data-nodeid="1524">Dispatcher</strong>（派发器）：它负责对 action 进行分发。</p>
</li>
<li data-nodeid="1368">
<p data-nodeid="1369"><strong data-nodeid="1529">Store</strong>（数据层）：它是存储应用状态的“仓库”，此外还会定义修改状态的逻辑。store 的变化最终会映射到 view 层上去。</p>
</li>
</ul>
<p data-nodeid="1370">这 4 个部分之间的协作将通过下图所示的工作流规则来完成配合：</p>
<p data-nodeid="1691" class=""><img src="https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX4iAVQDeAABqpNRcHXQ065.png" alt="图片1.png" data-nodeid="1694"></p>

<p data-nodeid="1372">一个典型的 Flux 工作流是这样的：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面。</p>
<blockquote data-nodeid="1373">
<p data-nodeid="1374">值得注意的是，图中所有的箭头都是单向的，这也正是 Flux 架构最核心的一个特点——<strong data-nodeid="1540">单向数据流</strong>。</p>
</blockquote>
<p data-nodeid="1375">那么 Flux 架构的出现到底是为了解决什么问题呢？</p>
<h3 data-nodeid="1376">Flux 架构到底解决了什么问题</h3>
<p data-nodeid="1377">Flux 的核心特征是单向数据流，要想完全了解单向数据流的好处，我们需要先了解双向数据流带来了什么问题。</p>
<h4 data-nodeid="1378">MVC 模式在前端场景下的局限性</h4>
<p data-nodeid="1379">双向数据流最为典型的代表就是<strong data-nodeid="1550">前端场景下的 MVC 架构</strong>，该架构的示意图如下图所示：</p>
<p data-nodeid="1380"><img src="https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVeKAMZaHAACLXZ2Co3Q900.png" alt="Drawing 3.png" data-nodeid="1553"></p>
<p data-nodeid="1381">除了允许用户通过 View 层交互来触发流程以外，MVC 架构还有另外一种形式，即允许用户通过直接触发 Controller 逻辑来触发流程，这种模式下的架构关系如下图所示：</p>
<p data-nodeid="1382"><img src="https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVe2AaJt5AACCt5hpXUM704.png" alt="Drawing 5.png" data-nodeid="1557"></p>
<p data-nodeid="1383">在 MVC 应用中，会涉及这 3 个部分：</p>
<ul data-nodeid="1384">
<li data-nodeid="1385">
<p data-nodeid="1386">Model（模型），程序需要操作的数据或信息；</p>
</li>
<li data-nodeid="1387">
<p data-nodeid="1388">View（视图），用户界面；</p>
</li>
<li data-nodeid="1389">
<p data-nodeid="1390">Controller（控制器），用于连接 View 和 Model，管理 Model 与 View 之间的逻辑。</p>
</li>
</ul>
<p data-nodeid="1391">原则上来说，三者的关系应该像上图一样，用户操作 View 后，由 Controller 来处理逻辑（或者直接触发 Controller 的逻辑），经过 Controller 将改变应用到 Model 中，最终再反馈到 View 上。在这个过程中，数据流应该是单向的。</p>
<p data-nodeid="1392"><strong data-nodeid="1567">事实上，在许多服务端的 MVC 应用中，数据流确实能够保持单向。但是在前端场景下，实际的 MVC 应用要复杂不少，前端应用/框架往往出于交互的需要，允许 View 和 Model 直接通信</strong>。此时的架构关系就会变成下图这样：</p>
<p data-nodeid="1393"><img src="https://s0.lgstatic.com/i/image/M00/7E/BA/Ciqc1F_PVfWAMialAACIyVXJabE467.png" alt="Drawing 7.png" data-nodeid="1570"></p>
<p data-nodeid="1394">这就允许了双向数据流的存在。当业务复杂度较高时，数据流会变得非常混乱，出现类似下图这种情况：</p>
<p data-nodeid="1395"><img src="https://s0.lgstatic.com/i/image/M00/7E/C5/CgqCHl_PVgWAcAkZAAFInClVHRM354.png" alt="Drawing 11.png" data-nodeid="1574"></p>
<p data-nodeid="1396">图中我们的示例只有一个 Controller，但考虑到一个应用中还可能存在多个 Controller，实际的情况应该比上图还要复杂得多（尽管图示本身已经够复杂了）。</p>
<p data-nodeid="1397">在如此复杂的依赖关系下，再小的项目变更也将伴随着不容小觑的风险——或许一个小小的改动，就会对整个项目造成“蝴蝶效应”般的巨大影响。如此混乱的修改来源，将会使得我们连 Bug 排查都无从下手，因为你很难区分出一个数据的变化到底是由哪个 Controller 或者哪个 View 引发的。</p>
<p data-nodeid="1398">此时再回头看下 Flux 的架构模式，你应该多少能感受到其中的妙处。这里我们再来回顾一下 Flux 中的数据流模式，请看下图：</p>
<p data-nodeid="2371" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/7E/D2/CgqCHl_PX5mAYUWaAABqpNRcHXQ626.png" alt="图片1.png" data-nodeid="2374"></p>

<p data-nodeid="1400">Flux 最核心的地方在于<strong data-nodeid="1590">严格的单向数据流</strong>，在单向数据流下，<strong data-nodeid="1591">状态的变化是可预测的</strong>。如果 store 中的数据发生了变化，那么有且仅有一个原因，那就是由 Dispatcher 派发 Action 来触发的。这样一来，就从根本上避免了混乱的数据关系，使整个流程变得清晰简单。</p>
<p data-nodeid="1401">不过这并不意味着 Flux 是完美的。事实上，Flux 对数据流的约束背后是不可忽视的成本：除了开发者的学习成本会提升外，Flux 架构还意味着项目中代码量的增加。</p>
<p data-nodeid="1402">Flux 架构往往在复杂的项目中才会体现出它的优势和必要性。如果项目中的数据关系并不复杂，其实完全轮不到 Flux 登场，这一点对于 Redux 来说也是一样的。</p>
<p data-nodeid="1403">现在你不妨结合 Flux 架构的特性，再去品味一遍 Redux 官方给出的这个定义：</p>
<blockquote data-nodeid="1404">
<p data-nodeid="1405">Redux 是 JavaScript 状态容器，它提供可预测的状态管理。</p>
</blockquote>
<p data-nodeid="1406">此时的你，想必更加能够体会“<strong data-nodeid="1601">可预测</strong>”这三个字背后的深意。</p>
<h3 data-nodeid="1407">Redux 关键要素与工作流回顾</h3>
<p data-nodeid="1408">Redux 库和 Flux 架构之间可以说是“你侬我侬”，虽然 Redux 在实现层面并没有按照 Flux 那一套来（比如 Flux 中允许多个 Store 存在，而 Redux 中只有一个 Store 等），但 Redux 在设计思想上确实和 Flux 一脉相承。</p>
<p data-nodeid="1409">前面我们介绍的 Flux 架构的特征、解决问题的思路，包括使用场景方面的注意事项，完全可以迁移到 Redux 上来用。基于 Flux 的思想背景去理解 Redux 这个落地产物，你的学习曲线将会更加平滑一些。</p>
<p data-nodeid="1410">接下来我们在介绍 Redux 的实现原理之前，先简单回顾一下它的关键要素与工作流。Redux 主要由 3 部分组成：Store、Reducer 和 Action。</p>
<ul data-nodeid="1411">
<li data-nodeid="1412">
<p data-nodeid="1413">Store：它是一个单一的数据源，而且是只读的。</p>
</li>
<li data-nodeid="1414">
<p data-nodeid="1415">Action 人如其名，是“动作”的意思，它是对变化的描述。</p>
</li>
<li data-nodeid="1416">
<p data-nodeid="1417">Reducer 是一个函数，它负责<strong data-nodeid="1613">对变化进行分发和处理</strong>，最终将新的数据返回给 Store。</p>
</li>
</ul>
<p data-nodeid="1418">Store、Action 和 Reducer 三者紧密配合，便形成了 Redux 独树一帜的工作流，如下图所示：</p>
<p data-nodeid="1419"><img src="https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVh-ATfOGAAB089LdYcY341.png" alt="Drawing 13.png" data-nodeid="1617"></p>
<p data-nodeid="1420">在 Redux 的整个工作过程中，<strong data-nodeid="1627">数据流是严格单向的</strong>。如果你想对数据进行修改，只有一种途径：<strong data-nodeid="1628">派发 Action</strong>。Action 会被 Reducer 读取，Reducer 将根据 Action 内容的不同执行不同的计算逻辑，最终生成新的 state（状态），这个新的 state 会更新到 Store 对象里，进而驱动视图层面作出对应的改变。</p>
<p data-nodeid="1421">对于组件来说，任何组件都可以以约定的方式从 Store 读取到全局的状态，任何组件也都可以通过合理地派发 Action 来修改全局的状态。<strong data-nodeid="1634">Redux 通过提供一个统一的状态容器</strong>，使得数据能够自由而有序地在任意组件之间穿梭。</p>
<p data-nodeid="1422">复习完 Redux 的工作流，下面我们来结合源码看看这套工作流到底是如何实现的。</p>
<h3 data-nodeid="1423">Redux 是如何工作的</h3>
<p data-nodeid="1424">我们先来看一下 Redux 的源码文件夹结构，如下图所示：<br>
<img src="https://s0.lgstatic.com/i/image/M00/7E/C6/CgqCHl_PVieAeMfAAABARscWp8o305.png" alt="Drawing 14.png" data-nodeid="1641"></p>
<p data-nodeid="1425">其中，utils 是工具方法库；index.js 作为入口文件，用于对功能模块进行收敛和导出。真正“干活”的是功能模块本身，也就是下面这几个文件：</p>
<ul data-nodeid="1426">
<li data-nodeid="1427">
<p data-nodeid="1428">applyMiddleware.js</p>
</li>
<li data-nodeid="1429">
<p data-nodeid="1430">bindActionCreators.js</p>
</li>
<li data-nodeid="1431">
<p data-nodeid="1432">combineReducers.js</p>
</li>
<li data-nodeid="1433">
<p data-nodeid="1434">compose.js</p>
</li>
<li data-nodeid="1435">
<p data-nodeid="1436">createStore.js</p>
</li>
</ul>
<p data-nodeid="1437">applyMiddleware 是中间件模块，它的独立性较强，我们将在第 20 讲中单独讲解。</p>
<p data-nodeid="1438">而 bindActionCreators（用于将传入的 actionCreator 与 dispatch 方法相结合，揉成一个新的方法，感兴趣的同学可以点击<a href="https://cn.redux.js.org/docs/api/bindActionCreators.html" data-nodeid="1652">这里</a>了解它的使用场景）、combineReducers（用于将多个 &nbsp;reducer 合并起来）、compose（用于把接收到的函数从右向左进行组合）这三个方法均为工具性质的方法。</p>
<p data-nodeid="1439">如果你对这三个工具方法感到陌生，也不用急着去搜索，因为它们均独立于 Redux 主流程之外，属于“非必须使用”的<strong data-nodeid="1663">辅助 API</strong>，不熟悉这些 API 并不影响你理解 Redux 本身。理解 Redux 实现原理，真正需要我们关注的模块其实只有一个——<strong data-nodeid="1664">createStore</strong>。</p>
<p data-nodeid="1440"><strong data-nodeid="1669">createStore 方法是我们在使用 Redux 时最先调用的方法，它是整个流程的入口，也是 Redux 中最核心的 API</strong>。接下来我们就从 createStore 入手，顺藤摸瓜揪出 Redux 源码的主流程。</p>
<h4 data-nodeid="1441">故事的开始：createStore</h4>
<p data-nodeid="1442">使用 Redux 的第一步，我们就需要调用 createStore 方法。单纯从使用感上来说，这个方法做的事情似乎就是创建一个 store 对象出来，像这样：</p>
<pre class="lang-plain" data-nodeid="1443"><code data-language="plain">// 引入 redux
import { createStore } from 'redux'
// 创建 store
const store = createStore(
    reducer,
    initial_state,
    applyMiddleware(middleware1, middleware2, ...)
);
</code></pre>
<p data-nodeid="1444">createStore 方法可以接收以下 3 个入参：</p>
<ul data-nodeid="1445">
<li data-nodeid="1446">
<p data-nodeid="1447">reducer</p>
</li>
<li data-nodeid="1448">
<p data-nodeid="1449">初始状态内容</p>
</li>
<li data-nodeid="1450">
<p data-nodeid="1451">指定中间件</p>
</li>
</ul>
<p data-nodeid="1452">从拿到入参到返回出 store 的过程中，到底都发生了什么呢？这里我为你提取了 createStore 中主体逻辑的源码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="1453"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createStore</span><span class="hljs-params">(reducer, preloadedState, enhancer)</span> </span>{
    <span class="hljs-comment">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span>
    <span class="hljs-keyword">if</span> (typeof preloadedState === <span class="hljs-string">'function'</span> &amp;&amp; typeof enhancer === <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-comment">// 此时第二个参数会被认为是 enhancer（中间件）</span>
        enhancer = preloadedState;
        preloadedState = undefined;
    }
    <span class="hljs-comment">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span>
    <span class="hljs-keyword">if</span> (typeof enhancer !== <span class="hljs-string">'undefined'</span>) {
        <span class="hljs-keyword">return</span> enhancer(createStore)(reducer, preloadedState);
    }
    <span class="hljs-comment">// 记录当前的 reducer，因为 replaceReducer 会修改 reducer 的内容</span>
    let currentReducer = reducer;
    <span class="hljs-comment">// 记录当前的 state</span>
    let currentState = preloadedState;
    <span class="hljs-comment">// 声明 listeners 数组，这个数组用于记录在 subscribe 中订阅的事件</span>
    let currentListeners = [];
    <span class="hljs-comment">// nextListeners 是 currentListeners 的快照</span>
    let nextListeners = currentListeners;
    <span class="hljs-comment">// 该变量用于记录当前是否正在进行 dispatch</span>
    let isDispatching = <span class="hljs-keyword">false</span>

    <span class="hljs-comment">// 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身</span>
    <span class="hljs-function">function <span class="hljs-title">ensureCanMutateNextListeners</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
        }
    }

    <span class="hljs-comment">// 我们通过调用 getState 来获取当前的状态</span>
    <span class="hljs-function">function <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> currentState;
    }

    <span class="hljs-comment">// subscribe 订阅方法，它将会定义 dispatch 最后执行的 listeners 数组的内容</span>
    <span class="hljs-function">function <span class="hljs-title">subscribe</span><span class="hljs-params">(listener)</span> </span>{
        <span class="hljs-comment">// 校验 listener 的类型</span>
        <span class="hljs-keyword">if</span> (typeof listener !== <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Expected the listener to be a function.'</span>)
        }
        <span class="hljs-comment">// 禁止在 reducer 中调用 subscribe</span>
        <span class="hljs-keyword">if</span> (isDispatching) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(
            <span class="hljs-string">'You may not call store.subscribe() while the reducer is executing. '</span> +
              <span class="hljs-string">'If you would like to be notified after the store has been updated, subscribe from a '</span> +
              <span class="hljs-string">'component and invoke store.getState() in the callback to access the latest state. '</span> +
              <span class="hljs-string">'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.'</span>
          )
        }
        <span class="hljs-comment">// 该变量用于防止调用多次 unsubscribe 函数</span>
        let isSubscribed = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">// 确保 nextListeners 与 currentListeners 不指向同一个引用</span>
        ensureCanMutateNextListeners(); 
        <span class="hljs-comment">// 注册监听函数</span>
        nextListeners.push(listener); 

        <span class="hljs-comment">// 返回取消订阅当前 listener 的方法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-function">function <span class="hljs-title">unsubscribe</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (!isSubscribed) {
                <span class="hljs-keyword">return</span>;
            }
            isSubscribed = <span class="hljs-keyword">false</span>;
            ensureCanMutateNextListeners();
            <span class="hljs-keyword">const</span> index = nextListeners.indexOf(listener);
            <span class="hljs-comment">// 将当前的 listener 从 nextListeners 数组中删除 </span>
            nextListeners.splice(index, <span class="hljs-number">1</span>);
        };
    }

    <span class="hljs-comment">// 定义 dispatch 方法，用于派发 action </span>
    <span class="hljs-function">function <span class="hljs-title">dispatch</span><span class="hljs-params">(action)</span> </span>{
        <span class="hljs-comment">// 校验 action 的数据格式是否合法</span>
        <span class="hljs-keyword">if</span> (!isPlainObject(action)) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(
            <span class="hljs-string">'Actions must be plain objects. '</span> +
              <span class="hljs-string">'Use custom middleware for async actions.'</span>
          )
        }

        <span class="hljs-comment">// 约束 action 中必须有 type 属性作为 action 的唯一标识 </span>
        <span class="hljs-keyword">if</span> (typeof action.type === <span class="hljs-string">'undefined'</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(
            <span class="hljs-string">'Actions may not have an undefined "type" property. '</span> +
              <span class="hljs-string">'Have you misspelled a constant?'</span>
          )
        }

        <span class="hljs-comment">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span>
        <span class="hljs-keyword">if</span> (isDispatching) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">'Reducers may not dispatch actions.'</span>)
        }
        <span class="hljs-keyword">try</span> {
          <span class="hljs-comment">// 执行 reducer 前，先"上锁"，标记当前已经存在 dispatch 执行流程</span>
          isDispatching = <span class="hljs-keyword">true</span>
          <span class="hljs-comment">// 调用 reducer，计算新的 state </span>
          currentState = currentReducer(currentState, action)
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-comment">// 执行结束后，把"锁"打开，允许再次进行 dispatch </span>
          isDispatching = <span class="hljs-keyword">false</span>
        }

        <span class="hljs-comment">// 触发订阅</span>
        <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);
        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; listeners.length; i++) {
            <span class="hljs-keyword">const</span> listener = listeners[i];
            listener();
        }
        <span class="hljs-keyword">return</span> action;
    }

    <span class="hljs-comment">// replaceReducer 可以更改当前的 reducer</span>
    <span class="hljs-function">function <span class="hljs-title">replaceReducer</span><span class="hljs-params">(nextReducer)</span> </span>{
        currentReducer = nextReducer;
        dispatch({ type: ActionTypes.REPLACE });
        <span class="hljs-keyword">return</span> store;
    }

    <span class="hljs-comment">// 初始化 state，当派发一个 type 为 ActionTypes.INIT 的 action，每个 reducer 都会返回</span>
    <span class="hljs-comment">// 它的初始值</span>
    dispatch({ type: ActionTypes.INIT });

    <span class="hljs-comment">// observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触</span>
    <span class="hljs-function">function <span class="hljs-title">observable</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">// observable 方法的实现</span>
    }

    <span class="hljs-comment">// 将定义的方法包裹在 store 对象里返回</span>
    <span class="hljs-keyword">return</span> {
      dispatch,
      subscribe,
      getState,
      replaceReducer,
      [$$observable]: observable
    }
}
</code></pre>
<p data-nodeid="1454">通过阅读源码会发现，createStore 从外面看只是一个简单的创建动作，但在内部却别有洞天，涵盖了所有 Redux 主流程中核心方法的定义。</p>
<p data-nodeid="1455">接下来我将 createStore 内部逻辑总结进一张大图中，这张图涵盖了每个核心方法的工作内容，它将帮助你快速把握 createStore 的逻辑框架。</p>
<p data-nodeid="1456"><img src="https://s0.lgstatic.com/i/image/M00/7E/BB/Ciqc1F_PVkCAST4AAAJfMvoaI4Q803.png" alt="Drawing 15.png" data-nodeid="1681"></p>
<p data-nodeid="1457">在 createStore 导出的方法中，与 Redux 主流程强相关的，同时也是我们平时使用中最常打交道的几个方法，分别是：</p>
<ul data-nodeid="1458">
<li data-nodeid="1459">
<p data-nodeid="1460">getState</p>
</li>
<li data-nodeid="1461">
<p data-nodeid="1462">subscribe</p>
</li>
<li data-nodeid="1463">
<p data-nodeid="1464">dispatch</p>
</li>
</ul>
<p data-nodeid="1465">其中 getState 的源码内容比较简单，我们在逐行分析的过程中已经对它有了充分的认识。而 subscribe 和 dispatch 则分别代表了 Redux 独有的“发布-订阅”模式以及主流程中最为关键的分发动作，在下一讲，我们会重点讲解。</p>
<h3 data-nodeid="1466">总结</h3>
<p data-nodeid="1467">在本讲，我们首先学习了 Redux 的架构思想，梳理了“单向数据流”这一核心特征的来龙去脉，真正理解了 Redux 定义中“可预测”这 3 个字背后的深意。</p>
<p data-nodeid="1468">随后，在复习 Redux 关键要素与工作流程的基础上，我们尝试对其源码进行拆解，认识了 Redux 源码的基本构成与主要模块，并选取了 createStore 这个核心模块作为发力点，提取出了 Redux 源码中值得我们格外深入的两个方法——subscribe 和 dispatch。</p>
<p data-nodeid="1469" class="">那么 subscribe 和 dispatch 中到底藏着什么样的玄机，值得我们继续深入学习呢？我们下一讲见分晓！</p>

---

### 精选评论

##### **威：
> 老师，讲得真好😊

##### console_man：
> 修言老板 么么哒

##### *琴：
> 老师真牛！！

##### **你辣条就跑：
> 一个典型的 Flux 工作流是这样的：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面。意思是用到了该状态的页面都会直接刷新吗？不需要再次手动触发setState或useState、render?

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 不是的。只是“通知”view，要不要更新、如何更新是由view自己决定的。

