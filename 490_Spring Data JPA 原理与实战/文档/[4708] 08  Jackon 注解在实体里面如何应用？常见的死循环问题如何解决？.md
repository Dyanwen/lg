<p data-nodeid="29640" class="">经过前面课时的讲解，相信你已经对实体里面的 JPA 注解有了一定的了解，但是实际工作中你会发现实体里面不仅有 JPA 的注解，也会用到很多 JSON 相关的注解。</p>
<p data-nodeid="29641">我们用 Spring Boot 里面默认集成的 fasterxml.jackson 加以说明，这看似和 JPA 没什么关系，但是一旦我们和 @Entity 一起使用的时候，就会遇到一些问题，特别是新手同学，我们这一课时详细介绍一下用法。先来跟着我了解一下 Jackson 的基本语法。</p>
<h3 data-nodeid="29642">Jackson 基本语法</h3>
<p data-nodeid="29643">我们先看一下我们项目里面的依赖。</p>
<p data-nodeid="29644"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6KeAArLTAAGETKtGSS0950.png" alt="Drawing 0.png" data-nodeid="29829"></p>
<p data-nodeid="29645">从中可以看到，当我们用 spring boot starter 的时候就会默认加载 fasterxml 相关的 jar 包模块，包括核心模块以及 jackson 提供的一些扩展 jar 包，下面详细介绍。</p>
<h4 data-nodeid="29646">核心模块有三个</h4>
<ol data-nodeid="29647">
<li data-nodeid="29648">
<p data-nodeid="29649"><strong data-nodeid="29836">jackson-core：核心包</strong>，提供基于“流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</p>
</li>
<li data-nodeid="29650">
<p data-nodeid="29651"><strong data-nodeid="29841">jackson-annotations：注解包</strong>，提供标准注解功能，这是我们必须要掌握的基础语法。</p>
</li>
<li data-nodeid="29652">
<p data-nodeid="29653"><strong data-nodeid="29846">jackson-databind：数据绑定包</strong>，提供基于“对象绑定”解析的相关 API（ ObjectMapper ） 和“树模型”解析的相关 API（JsonNode）；基于“对象绑定”解析的 API 和“树模型”解析的 API 依赖基于“流模式”解析的 API。如下图中一些标准的类型转换：</p>
</li>
</ol>
<p data-nodeid="29654"><img src="https://s0.lgstatic.com/i/image/M00/59/F4/CgqCHl9y6LCAZOFqAAGiK2TqQR8365.png" alt="Drawing 1.png" data-nodeid="29849"></p>
<h4 data-nodeid="29655">jackson 提供了一些扩展 jar</h4>
<ol data-nodeid="29656">
<li data-nodeid="29657">
<p data-nodeid="29658"><strong data-nodeid="29855">jackson-module-parameter-names</strong>：对原来的 jackson 进行了扩展，支持了构造方法和方法基本的参数支持。</p>
</li>
<li data-nodeid="29659">
<p data-nodeid="29660"><strong data-nodeid="29860">jackson-datatype</strong>：是对字段类型的支持做的一些扩展，包括下述几个部分。</p>
</li>
</ol>
<p data-nodeid="29661">a. <strong data-nodeid="29866">jackson-datatype-jdk8</strong>：是对 jdk8 语法里面的一些 Optional、Stream 等一些新的类型做的一些支持，如下图展示的一些类：</p>
<p data-nodeid="29662"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6OaAQJiiAACgvjgT_sE264.png" alt="Drawing 2.png" data-nodeid="29869"></p>
<p data-nodeid="29663">b.<strong data-nodeid="29875">jackson-datatype-jsr310</strong>：是对 jdk8 中的 JSR310 时间协议做了支持，如 Duration、Instant、LocalDate、Clock 等时间类型的序列化、反序列化，如下图展示的一些类：</p>
<p data-nodeid="29664"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6O2AGMdBAAHAi0GnpZI902.png" alt="Drawing 3.png" data-nodeid="29878"></p>
<p data-nodeid="29665">c.<strong data-nodeid="29884">jackson-datatype-hibernate5</strong>：是对Hibernate的里面的一些数据类型的序列化、反序列化，如HibernateProxy 等。</p>
<p data-nodeid="29666">剩下不常见的咱们就不说了，jackson-datatype 其实就是对一些常见的数据类型做序列化、反序列化，省去了我们自己写序列化、反序列化的过程。所以在我们工作中，如果需要自定义序列化的时候，可以参考这些源码。</p>
<p data-nodeid="29667">知道了这些脉络之后，剩下的就是我们要掌握的注解有哪些了，下面我来介绍一下。</p>
<h4 data-nodeid="29668">常用的一些注解</h4>
<p data-nodeid="29669">正如上面所说，我们打开 jackson-annotations，就可以看到有哪些注解了，一目了然，闲着没事的时候就可以到这里面看看，这样你会越来越熟悉。下面我们挑选一些常用的介绍一下。</p>
<p data-nodeid="29670"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6TiAIApWAAGnwAKoAuQ411.png" alt="Drawing 4.png" data-nodeid="29891"></p>
<p data-nodeid="30870">Jackson 里面常用的注解如下表格所示：</p>
<p data-nodeid="32859"><img src="https://s0.lgstatic.com/i/image/M00/5B/A6/CgqCHl9_0CiAWB2rAAL0pfxIviE487.png" alt="Lark20201009-105051.png" data-nodeid="32904"></p>







<h4 data-nodeid="29715">我们看个实例感受一下</h4>
<p data-nodeid="29716">接下来我们写个测试用例看一下。</p>
<p data-nodeid="29717">首先，新建一个 UserJson 实体对象，将它转成 Json 对象，如下所示：</p>
<pre class="lang-java" data-nodeid="29718"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.*;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.util.*;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@JsonPropertyOrder({"createDate","email"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserJson</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-meta">@JsonProperty("my_name")</span>
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> Instant createDate;
   <span class="hljs-meta">@JsonFormat(timezone ="GMT+8", pattern = "yyyy-MM-dd HH:mm")</span>
   <span class="hljs-keyword">private</span> Date updateDate;
   <span class="hljs-keyword">private</span> String email;
   <span class="hljs-meta">@JsonIgnore</span>
   <span class="hljs-keyword">private</span> String sex;
   <span class="hljs-meta">@JsonCreator</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserJson</span><span class="hljs-params">(<span class="hljs-meta">@JsonProperty("email")</span> String email)</span> </span>{
      System.out.println(<span class="hljs-string">"其他业务逻辑"</span>);
      <span class="hljs-keyword">this</span>.email = email;
   }
   <span class="hljs-meta">@Transient</span>
   <span class="hljs-meta">@JsonAnySetter</span>
   <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; other = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
   <span class="hljs-meta">@JsonAnyGetter</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getOther</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> other;
   }
}
</code></pre>
<p data-nodeid="29719">然后，我们写一个测试用例，看一下运行结果。</p>
<pre class="lang-java" data-nodeid="29720"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;
<span class="hljs-keyword">import</span> org.assertj.core.util.Maps;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeAll;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.TestInstance;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
<span class="hljs-keyword">import</span> org.springframework.test.annotation.Rollback;
<span class="hljs-keyword">import</span> javax.transaction.Transactional;
<span class="hljs-keyword">import</span> java.time.Instant;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-meta">@DataJpaTest</span>
<span class="hljs-meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserJsonRepositoryTest</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserJsonRepository userJsonRepository;
    <span class="hljs-meta">@BeforeAll</span>
    <span class="hljs-meta">@Rollback(false)</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        UserJson user = UserJson.builder()
                .name(<span class="hljs-string">"jackxx"</span>).createDate(Instant.now()).updateDate(<span class="hljs-keyword">new</span> Date()).sex(<span class="hljs-string">"men"</span>).email(<span class="hljs-string">"123456@126.com"</span>).build();
        userJsonRepository.saveAndFlush(user);
    }
    <span class="hljs-comment">/**
     * 测试用User关联关系操作
     *
     */</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-meta">@Rollback(false)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
        UserJson userJson = userJsonRepository.findById(<span class="hljs-number">1L</span>).get();
        userJson.setOther(Maps.newHashMap(<span class="hljs-string">"address"</span>,<span class="hljs-string">"shanghai"</span>));
        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
System.out.println(objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(userJson));
    }
}
</code></pre>
<p data-nodeid="29721">最后，运行一下可以看到如下结果。</p>
<pre class="lang-java" data-nodeid="29722"><code data-language="java">{
        <span class="hljs-string">"createDate"</span> : {
        <span class="hljs-string">"epochSecond"</span> : <span class="hljs-number">1600530086</span>,
        <span class="hljs-string">"nano"</span> : <span class="hljs-number">588000000</span>
        },
        <span class="hljs-string">"email"</span> : <span class="hljs-string">"123456@126.com"</span>,
        <span class="hljs-string">"id"</span> : <span class="hljs-number">1</span>,
        <span class="hljs-string">"updateDate"</span> : <span class="hljs-string">"2020-09-19 23:41"</span>,
        <span class="hljs-string">"my_name"</span> : <span class="hljs-string">"jackxx"</span>,
        <span class="hljs-string">"address"</span> : <span class="hljs-string">"shanghai"</span>
}
</code></pre>
<p data-nodeid="29723">这里可以和上面的注解列表对比一下，其中我们看到了 HashMap 被平铺开了。我们通过例子可以很容易想到使用场景是 SpringMvc 的情况下，在 get 请求的时候我们要用到序列化；在 post 请求的时候我们要用到反序列化，将 json 字符串反向转化成实体对象。</p>
<p data-nodeid="29724">那么在 Spring 里面 Jackson 都有哪些应用场景呢？我们来看一下。</p>
<h3 data-nodeid="29725">Jackson 和 Spring 的关系</h3>
<p data-nodeid="29726">我们先看一下 Jackson 在 Spring 中常见的四个应用场景，来了解一下 Spring 在这些情况下的应用，带你详细掌握 Jackson 并知道它的重要性。</p>
<h4 data-nodeid="29727">应用场景一</h4>
<p data-nodeid="29728">在Spring MVC中，我们需要知道Mvc的JSON视图的加载原理。我们看一下源码，mvc 对象的转化类：HttpMessageConvertersAutoConfiguration，里面要利用JacksonHttpMessageConvertersConfiguration，如下所示：</p>
<p data-nodeid="29729"><img src="https://s0.lgstatic.com/i/image/M00/59/F4/CgqCHl9y6WSAGuZoAAFNeYDzpto473.png" alt="Drawing 5.png" data-nodeid="30025"></p>
<p data-nodeid="29730">而里面的MappingJackson2HttpMessageConverter 正是采用 fasterxml.jackson 进行转化的，看下面的图片。</p>
<p data-nodeid="29731"><img src="https://s0.lgstatic.com/i/image/M00/59/F4/CgqCHl9y6WqAER67AAIDaup89yg019.png" alt="Drawing 6.png" data-nodeid="30029"></p>
<h4 data-nodeid="29732">应用场景二</h4>
<p data-nodeid="29733">我们在微服务之间相互调用的时候，都会用到 HttpMessageConverter 里面的 JacksonHttpMessageConverter 进行转化。特别是在用 open-feign 里面的 Encode 和 Decode 的时候，我们就可以看到如下应用场景：</p>
<p data-nodeid="29734"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6XaAD3msAAKEmKvGup4502.png" alt="Drawing 7.png" data-nodeid="30034"></p>
<h4 data-nodeid="29735">应用场景三</h4>
<p data-nodeid="29736">redis、cacheable 都会用到 value 的序列化，都离不开 JSON 的序列化，看下面的 redis 里面的关键配置文件。</p>
<p data-nodeid="29737"><img src="https://s0.lgstatic.com/i/image/M00/59/F4/CgqCHl9y6X2AFrzKAAF2qLKQjhg118.png" alt="Drawing 8.png" data-nodeid="30039"></p>
<h4 data-nodeid="29738">应用场景四</h4>
<p data-nodeid="29739">当我们项目之间解耦用到消息队列的时候，可能会基于 JMS消息协议发送消息，其也是基于 JSON 的序列化机制来继续converter的，它在用JmsTemplate 的时候也会遇到同样情况，我们看一下 JMS 里面相关代码。</p>
<p data-nodeid="29740"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6YKAB5RYAACd0TRs-9E100.png" alt="Drawing 9.png" data-nodeid="30044"></p>
<p data-nodeid="29741">综上四个场景所述，我们是经常和 Entity 打交道的，而 @Entity 又要在各种场景转化成 JSONString，所以 Jackson 的原理我们还是要掌握一些的，下面来分析几个比较重要的。</p>
<h3 data-nodeid="29742">Jackson 原理分析</h3>
<h4 data-nodeid="29743">Jackson 的可见性原理分析</h4>
<p data-nodeid="29744">前面我们看到了注解@JsonAutoDetect JsonAutoDetect.Visibility 类包含与 Java 中的可见性级别匹配的常量，表示 ANY、DEFAULT、NON_PRIVATE、NONE、PROTECTED_AND_PRIVATE和PUBLIC_ONLY。</p>
<p data-nodeid="29745">那么我们打开这个类，看一下源码：</p>
<p data-nodeid="29746"><img src="https://s0.lgstatic.com/i/image/M00/59/F4/CgqCHl9y6YmAEhRpAADjSxOL7wI046.png" alt="Drawing 10.png" data-nodeid="30060"></p>
<p data-nodeid="29747">这里面的代码并不复杂，通过JsonAutoDetect 我们可以看到，Jackson 默认不是所有的属性都可以被序列化和反序列化。默认的属性可视化的规则如下：</p>
<ul data-nodeid="29748">
<li data-nodeid="29749">
<p data-nodeid="29750">若该属性修饰符是 public，该属性可序列化和反序列化。</p>
</li>
<li data-nodeid="29751">
<p data-nodeid="29752">若属性的修饰符不是 public，但是它的 getter 方法和 setter 方法是 public，该属性可序列化和反序列化。因为 getter 方法用于序列化，而 setter 方法用于反序列化。</p>
</li>
<li data-nodeid="29753">
<p data-nodeid="29754">若属性只有 public 的 setter 方法，而无 public 的 getter 方法，该属性只能用于反序列化。</p>
</li>
</ul>
<p data-nodeid="29755">所以我们可以通过私有字段的 public get 和 public set 方法控制是否可以序列化。这里可以和我们前面讲到的“JPA 实体里面的注解生效方式”做一下对比，也可以通过直接更改 ObjectMapper 设置可视化策略，如下所示：</p>
<pre class="lang-java" data-nodeid="29756"><code data-language="java">ObjectMapper&nbsp;mapper&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ObjectMapper();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;PropertyAccessor&nbsp;支持的类型有&nbsp;ALL,CREATOR,FIELD,GETTER,IS_GETTER,NONE,SETTER</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;Visibility&nbsp;支持的类型有&nbsp;ANY,DEFAULT,NON_PRIVATE,NONE,PROTECTED_AND_PUBLIC,PUBLIC_ONLY</span>
&nbsp;&nbsp;&nbsp;&nbsp;mapper.setVisibility(PropertyAccessor.FIELD,&nbsp;JsonAutoDetect.Visibility.ANY);
</code></pre>
<p data-nodeid="29757">这样，就可以直接看到所有字段了，包括私有字段。接着我们说一下反序列化相关方法。</p>
<h4 data-nodeid="29758">反序列化最重要的方法</h4>
<p data-nodeid="29759">我们在做反序列化的时候要用到的三个重要方法如下所示。</p>
<p data-nodeid="29760"><img src="https://s0.lgstatic.com/i/image/M00/59/E9/Ciqc1F9y6ceAEC13AAIfyfec2VQ426.png" alt="Drawing 11.png" data-nodeid="30071"></p>
<pre class="lang-java" data-nodeid="29761"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">readValue</span><span class="hljs-params">(String content, Class&lt;T&gt; valueType)</span>
<span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title">readValue</span><span class="hljs-params">(String content, TypeReference&lt;T&gt; valueTypeRef)</span>
<span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title">readValue</span><span class="hljs-params">(String content, JavaType valueType)</span>
</span></code></pre>
<p data-nodeid="29762">可以看出，反序列化的时候要知道 java 的 Type 是很重要的，如下：</p>
<pre class="lang-java" data-nodeid="29763"><code data-language="java">String json = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(userJson);
<span class="hljs-comment">//单个对象的写法：</span>
UserJson user = objectMapper.readValue(json,UserJson.class);
<span class="hljs-comment">//返回List的返回结果的写法：</span>
&nbsp;&nbsp;&nbsp;&nbsp;List&lt;User&gt;&nbsp;personList2&nbsp;=&nbsp;mapper.readValue(jsonListString,&nbsp;<span class="hljs-keyword">new</span>&nbsp;TypeReference&lt;List&lt;User&gt;&gt;(){});
</code></pre>
<p data-nodeid="29764">我们也可以根据 java 的反射，即万能的 JavaType 进行反序列化和转化，如下：</p>
<p data-nodeid="29765"><img src="https://s0.lgstatic.com/i/image/M00/59/F5/CgqCHl9y6deAf6crAACm1nnSdgY500.png" alt="Drawing 12.png" data-nodeid="30076"></p>
<p data-nodeid="29766">你也可以看一下 Jackson2HttpMessageConverter 里面的用法。</p>
<p data-nodeid="29767"><img src="https://s0.lgstatic.com/i/image/M00/59/EA/Ciqc1F9y6eCAFva6AAMGNGEyorM459.png" alt="Drawing 13.png" data-nodeid="30080"></p>
<p data-nodeid="29768">这个时候你应该很好奇，readValue 里面是如何判断 java 类型的呢？我们看下 ObjectMapper 的源码里面做了如下操作：</p>
<pre class="lang-java" data-nodeid="29769"><code data-language="java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">readValue</span><span class="hljs-params">(DataInput src, Class&lt;T&gt; valueType)</span> <span class="hljs-keyword">throws</span> IOException
</span>{
    _assertNotNull(<span class="hljs-string">"src"</span>, src);
    <span class="hljs-keyword">return</span> (T) _readMapAndClose(_jsonFactory.createParser(src),
            _typeFactory.constructType(valueType));
}
</code></pre>
<p data-nodeid="29770">到这里，我们看到 typeFactory 里面的 constructType 可以取到各种 type，那么点击进去看看。</p>
<p data-nodeid="29771"><img src="https://s0.lgstatic.com/i/image/M00/59/EA/Ciqc1F9y6euAKmewAAPSLO28R0s115.png" alt="Drawing 14.png" data-nodeid="30085"></p>
<p data-nodeid="29772">可以看到里面处理各种 java 类型和泛型的情况，当我们自己写反射代码的时候可以参考这一段，或者直接调用。此外，ObjectMapper 里面还一个重要的概念就是 Moduel，我们来看下。</p>
<h4 data-nodeid="29773">Moduel 的加载机制</h4>
<p data-nodeid="29774">ObejctMapper 里面可以扩展很多 datatype，而不同的 datatype 封装到了不通的 modules 里面，我们可以 register 注册进去不同的 module，从而处理不同的数据类型。</p>
<p data-nodeid="29775">目前 Modules 官方网站提供了很多内容，具体你可以查看这个网址：<a href="https://github.com/FasterXML/jackson#third-party-datatype-modules" data-nodeid="30092">https://github.com/FasterXML/jackson#third-party-datatype-modules</a>。这里我们重点说一下常用的加载机制。</p>
<p data-nodeid="29776"><img src="https://s0.lgstatic.com/i/image/M00/59/F5/CgqCHl9y6fWAOmAQAAJetYinNl4753.png" alt="Drawing 15.png" data-nodeid="30096"></p>
<p data-nodeid="29777">我们通过在代码里面设置一个断点，就可以很清楚地知道常用的 ModuleType 都有哪些，如 Jdk8、jsr310、Hibernate5 等。在MVC 里面默认的 Module 也是图上那些，Hibernate5 是我们自己引入的，具体解决什么问题和如何自定义的呢？我们接着往下看。</p>
<h3 data-nodeid="29778">Jackson 与 JPA 常见的问题</h3>
<p data-nodeid="29779">我们用 JPA 的时候，特别是关联关系的时候，最常见的就是死循环了，你在使用时一定要注意。</p>
<h4 data-nodeid="29780">死循环问题如何解决</h4>
<p data-nodeid="29781">第一种情况：我们在写 ToString 方法，特别是 JPA 的实体的时候，很容易陷入死循环，因为实体之间的关联关系配置是双向的，我们就需要 ToString 的时候把一方排除掉，如下所示：</p>
<p data-nodeid="29782"><img src="https://s0.lgstatic.com/i/image/M00/59/F5/CgqCHl9y6f2Abh0_AABqSNxYu3A670.png" alt="Drawing 16.png" data-nodeid="30104"></p>
<p data-nodeid="29783">第二种情况：在转化JSON的时候，双向关联也会死循环。按照我们上面讲的方法，这是时候我们要想到通过&nbsp;@JsonIgnoreProperties(value={"address"})或者字段上面配置@JsonIgnore，如下：</p>
<pre class="lang-java" data-nodeid="29784"><code data-language="java"><span class="hljs-meta">@JsonIgnore</span>
<span class="hljs-keyword">private</span> List&lt;UserAddress&gt; address;
</code></pre>
<p data-nodeid="29785">此外，通过 @JsonBackReference 和 @JsonManagedReference 注解也可以解决死循环。</p>
<pre class="lang-java" data-nodeid="29786"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span> </span>{
   <span class="hljs-meta">@JsonManagedReference</span>
   <span class="hljs-keyword">private</span> User user;
....}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
   <span class="hljs-meta">@OneToMany(mappedBy = "user",fetch = FetchType.LAZY)</span>
   <span class="hljs-meta">@JsonBackReference</span>
   <span class="hljs-keyword">private</span> List&lt;UserAddress&gt; address;
...}
</code></pre>
<p data-nodeid="29787">如上述代码，也可以达到 @JsonIgnore 的效果，具体你可以自己操作一下试试，原理都是一样的，都是利用排除方法。那么接下来我们看下 HibernateModel5 是怎么使用的。</p>
<h4 data-nodeid="29788">JPA 实体 JSON 序列化的常见报错</h4>
<p data-nodeid="29789">我们在实际跑之前讲过的 user 对象，或者是类似带有 lazy 对象关系的时候，经常会遇到下面的错误：</p>
<pre class="lang-dart" data-nodeid="29790"><code data-language="dart">No serializer found <span class="hljs-keyword">for</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">org</span>.<span class="hljs-title">hibernate</span>.<span class="hljs-title">proxy</span>.<span class="hljs-title">pojo</span>.<span class="hljs-title">bytebuddy</span>.<span class="hljs-title">ByteBuddyInterceptor</span> <span class="hljs-title">and</span> <span class="hljs-title">no</span> <span class="hljs-title">properties</span> <span class="hljs-title">discovered</span> <span class="hljs-title">to</span> <span class="hljs-title">create</span> <span class="hljs-title">BeanSerializer</span> (<span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">exception</span>, <span class="hljs-title">disable</span> <span class="hljs-title">SerializationFeature</span>.<span class="hljs-title">FAIL_ON_EMPTY_BEANS</span>) (<span class="hljs-title">through</span> <span class="hljs-title">reference</span> <span class="hljs-title">chain</span>: <span class="hljs-title">com</span>.<span class="hljs-title">example</span>.<span class="hljs-title">jpa</span>.<span class="hljs-title">example1</span>.<span class="hljs-title">User</span>$<span class="hljs-title">HibernateProxy</span>$<span class="hljs-title">MdjeSaTz</span>["<span class="hljs-title">hibernateLazyInitializer</span>"])
<span class="hljs-title">com</span>.<span class="hljs-title">fasterxml</span>.<span class="hljs-title">jackson</span>.<span class="hljs-title">databind</span>.<span class="hljs-title">exc</span>.<span class="hljs-title">InvalidDefinitionException</span>: <span class="hljs-title">No</span> <span class="hljs-title">serializer</span> <span class="hljs-title">found</span> <span class="hljs-title">for</span> <span class="hljs-title">class</span> <span class="hljs-title">org</span>.<span class="hljs-title">hibernate</span>.<span class="hljs-title">proxy</span>.<span class="hljs-title">pojo</span>.<span class="hljs-title">bytebuddy</span>.<span class="hljs-title">ByteBuddyInterceptor</span> <span class="hljs-title">and</span> <span class="hljs-title">no</span> <span class="hljs-title">properties</span> <span class="hljs-title">discovered</span> <span class="hljs-title">to</span> <span class="hljs-title">create</span> <span class="hljs-title">BeanSerializer</span> (<span class="hljs-title">to</span> <span class="hljs-title">avoid</span> <span class="hljs-title">exception</span>, <span class="hljs-title">disable</span> <span class="hljs-title">SerializationFeature</span>.<span class="hljs-title">FAIL_ON_EMPTY_BEANS</span>) (<span class="hljs-title">through</span> <span class="hljs-title">reference</span> <span class="hljs-title">chain</span>: <span class="hljs-title">com</span>.<span class="hljs-title">example</span>.<span class="hljs-title">jpa</span>.<span class="hljs-title">example1</span>.<span class="hljs-title">User</span>$<span class="hljs-title">HibernateProxy</span>$<span class="hljs-title">MdjeSaTz</span>["<span class="hljs-title">hibernateLazyInitializer</span>"])
</span></code></pre>
<p data-nodeid="29791">这个时候该怎么办呢？下面介绍几个解决办法，第一个可以引入Hibernate5Module。</p>
<h4 data-nodeid="29792">常见报错解决方法</h4>
<p data-nodeid="29793"><strong data-nodeid="30119">解决方法一：引入 Hibernate5Module</strong></p>
<p data-nodeid="29794">代码如下：</p>
<pre class="lang-java" data-nodeid="29795"><code data-language="java">ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
objectMapper.registerModule(<span class="hljs-keyword">new</span> Hibernate5Module());
String json = objectMapper.writeValueAsString(user);
System.out.println(json);
</code></pre>
<p data-nodeid="29796">这样子就不会报错了。</p>
<p data-nodeid="29797">Hibernate5Module 里面还有很多 Feature 配置，例如FORCE_LAZY_LOADING，强制 lazy 里面加载就不会有上面的问题了。但是这个会有性能问题，我不建议使用。</p>
<p data-nodeid="29798">还有 USE_TRANSIENT_ANNOTATION，利用 JPA 的 @Transient 注解配置，这个默认是开启的。所以基本上 feature 默认配置都是 ok 的，不需要我们动手，只要知道这回事就行了。</p>
<p data-nodeid="29799"><img src="https://s0.lgstatic.com/i/image/M00/59/EA/Ciqc1F9y6iKAE-gMAAEKYfENrs8207.png" alt="Drawing 17.png" data-nodeid="30134"></p>
<p data-nodeid="29800"><strong data-nodeid="30144">解决方法二：关闭 SerializationFeature.FAIL_ON_EMPTY_BEANS 的 feature</strong></p>
<p data-nodeid="29801">代码如下：</p>
<pre class="lang-java" data-nodeid="29802"><code data-language="java">        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
<span class="hljs-comment">//直接关闭SerializationFeature.FAIL_ON_EMPTY_BEANS       objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS,false);</span>
        String json = objectMapper.writeValueAsString(user);
        System.out.println(json);
</code></pre>
<p data-nodeid="29803">因为是 lazy，所以 empty 的 bean 的时候不报错也可以。<br>
<strong data-nodeid="30151">解决方法三：对象上面排除“hibernateLazyInitializer”“handler”“fieldHandler”等</strong></p>
<p data-nodeid="29804">代码如下：</p>
<pre class="lang-java" data-nodeid="29805"><code data-language="java"><span class="hljs-meta">@JsonIgnoreProperties(value={"address","hibernateLazyInitializer","handler","fieldHandler"})</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
</code></pre>
<p data-nodeid="29806">那有没有其他 ObjectMapper 的推荐配置了呢？</p>
<h4 data-nodeid="29807">ObjectMapper 实战经验推荐配置项</h4>
<p data-nodeid="29808">下面是我根据自己实战经验为你推荐的配置项。</p>
<pre class="lang-java" data-nodeid="29809"><code data-language="java">ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
<span class="hljs-comment">//empty beans不需要报错，没有就是没有了</span>
objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS,<span class="hljs-keyword">false</span>);
<span class="hljs-comment">//遇到不可识别字段的时候不要报错，因为前端传进来的字段不可信，可以不要影响正常业务逻辑</span>
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,<span class="hljs-keyword">false</span>);
<span class="hljs-comment">//遇到不可以识别的枚举的时候，为了保证服务的强壮性，建议也不要关心未知的，甚至给个默认的，特别是微服务大家的枚举值随时在变，但是老的服务是不需要跟着一起变的</span>
objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL,<span class="hljs-keyword">true</span>);
objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_USING_DEFAULT_VALUE,<span class="hljs-keyword">true</span>);
</code></pre>
<p data-nodeid="29810"><strong data-nodeid="30159">时间类型的最佳实践，如何返回 ISO 格式的标准时间</strong></p>
<p data-nodeid="29811">有的时候我们会发现，默认的 ObjectMapper 里面的 module 提供的时间转化格式可能不能满足我们的要求，可能要进行扩展，老师提供一个自定义 module 返回 ISO 标准时间格式的一个案例，如下：</p>
<pre class="lang-java" data-nodeid="29812"><code data-language="java"><span class="hljs-meta">@Test</span>
<span class="hljs-meta">@Rollback(false)</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
    UserJson userJson = userJsonRepository.findById(<span class="hljs-number">1L</span>).get();
    userJson.setOther(Maps.newHashMap(<span class="hljs-string">"address"</span>,<span class="hljs-string">"shanghai"</span>));
    <span class="hljs-comment">//自定义 myInstant解析序列化和反序列化DateTimeFormatter.ISO_ZONED_DATE_TIME这种格式</span>
   SimpleModule myInstant = <span class="hljs-keyword">new</span> SimpleModule(<span class="hljs-string">"instant"</span>, Version.unknownVersion())
            .addSerializer(java.time.Instant.class, <span class="hljs-keyword">new</span> JsonSerializer&lt;Instant&gt;() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(java.time.Instant instant,
                                      JsonGenerator jsonGenerator,
                                      SerializerProvider serializerProvider)</span>
                        <span class="hljs-keyword">throws</span> IOException </span>{
                    <span class="hljs-keyword">if</span> (instant == <span class="hljs-keyword">null</span>) {
                        jsonGenerator.writeNull();
                    } <span class="hljs-keyword">else</span> {
                        jsonGenerator.writeObject(instant.toString());
                    }
                }
            })
            .addDeserializer(Instant.class, <span class="hljs-keyword">new</span> JsonDeserializer&lt;Instant&gt;() {
                <span class="hljs-meta">@Override</span>
                <span class="hljs-function"><span class="hljs-keyword">public</span> Instant <span class="hljs-title">deserialize</span><span class="hljs-params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span> <span class="hljs-keyword">throws</span> IOException </span>{
                    Instant result = <span class="hljs-keyword">null</span>;
                    String text = jsonParser.getText();
                    <span class="hljs-keyword">if</span> (!StringUtils.isEmpty(text)) {
                        result = ZonedDateTime.parse(text, DateTimeFormatter.ISO_ZONED_DATE_TIME).toInstant();
                    }
                    <span class="hljs-keyword">return</span> result;
                }
            });
    ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();
    <span class="hljs-comment">//注册自定义的module</span>
    objectMapper.registerModule(myInstant);
    String json = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(userJson);
    System.out.println(json);
}
</code></pre>
<p data-nodeid="29813">我们利用上面的UserJson案例，在测试用例里面自定义了myInstant来进行序列化和反序列化Instant这种类型，然后我们通过objectMapper.registerModule(myInstant); 注册进去。那么我们看一下运行结果：</p>
<pre class="lang-java" data-nodeid="29814"><code data-language="java">{
        <span class="hljs-string">"createDate"</span> : <span class="hljs-string">"2020-09-20T02:36:33.308Z"</span>,
        <span class="hljs-string">"email"</span> : <span class="hljs-string">"123456@126.com"</span>,
        <span class="hljs-string">"id"</span> : <span class="hljs-number">1</span>,
        <span class="hljs-string">"updateDate"</span> : <span class="hljs-string">"2020-09-20 10:36"</span>,
        <span class="hljs-string">"my_name"</span> : <span class="hljs-string">"jackxx"</span>,
        <span class="hljs-string">"address"</span> : <span class="hljs-string">"shanghai"</span>
}
</code></pre>
<p data-nodeid="29815">这时你会发现 createDate 的格式发生了变化，这样子的话，任何人看到我们这样的 JSON 结构就不必问我们到底是哪个时区的问题了。</p>
<h3 data-nodeid="29816">总结</h3>
<p data-nodeid="29817">到这里，本课时的讲解就结束了，关于 Spring Data JPA 的基础知识也告一段落，不知道你是否已经掌握了。</p>
<p data-nodeid="29818">我在这一课时详细讲解了 Jackson 的原理，分析了一下 JPA 里面经常会遇到的问题，并为你推荐了一些常见配置。有个需要注意的点就是双向关联关系，如果你暂时不得要领的话，我建议不要为了用而用，我们就按照 DB 的真实映射写法就可以，类似 MyBatis 一样，只不过不需要我们去关心和配置映射关系。</p>
<p data-nodeid="29819">这里我还想说一个解题思路，就是当我们遇到问题的时候，要学着挖一挖问题的根源，这样解决问题才能够游刃有余。</p>
<p data-nodeid="29820">好了，Jackson 的强大之处肯定远不止这些，欢迎你留言讨论和分享。</p>
<blockquote data-nodeid="29821">
<p data-nodeid="29822" class="">点击下方链接查看源码（不定时更新）<br>
<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="30172">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>
</blockquote>

---

### 精选评论

##### **磊：
> Jackson可以忽略对象中某个属性序列化， 比如多对多。 user role 。 user 中忽略 roles 里面的 users 属性。 这样就可以避免循环依赖。

##### **强：
> 打卡

##### **雷：
> 条分缕析，透彻

