<p data-nodeid="245456" class="">实际工作中，我们经常会在一些注解中使用 SpEL 表达式，当然在 JPA 里也不例外，如果想知道它在 JPA 中的使用详情，必须要先从了解开始。那么这一讲，我们就来聊聊 SpEL 表达式相关知识。</p>


<h3 data-nodeid="244141">SpEL 基础语法</h3>
<h4 data-nodeid="244142">SpEL 大纲</h4>
<p data-nodeid="244143">SpEL 的全称为 Spring Expression Language，即 Spring 表达式语言，是 Spring framework 里面的核心项目。我们先来看一下 spring-expression 的 jar 包的引用关系，如下图所示。</p>
<p data-nodeid="246332" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/88/Ciqc1F_TZgOAeZinAAWQDYZICUE395.png" alt="Drawing 0.png" data-nodeid="246335"></p>

<p data-nodeid="249811" class="">从核心引用来看，SpEL 贯穿所有 Spring 的核心功能。当然了，SpEL 可以脱离 Spring 工程独立使用，其项目里有三个重要的接口：ExpressionParser、Expression、EvaluationContext，我从官方文档中找了一张图来说明它们之间的关系。<br>
<img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZg6AAkIJAADdShpwElA350.png" alt="Drawing 1.png" data-nodeid="249816"></p>


<div data-nodeid="248944" class=""><p style="text-align:center">注：图片来自网络</p></div>



<p data-nodeid="244148"><strong data-nodeid="244349">ExpressionParser</strong></p>
<p data-nodeid="244149">它是 SpEL 的处理接口，默认实现类是 SpelExpressionParser，对外提供的只有两个方法，如下述代码所示。</p>
<pre class="lang-java" data-nodeid="244150"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExpressionParser</span> </span>{
   <span class="hljs-comment">// 根据传入的表达式生成Expression</span>
   <span class="hljs-function">Expression <span class="hljs-title">parseExpression</span><span class="hljs-params">(String expressionString)</span> <span class="hljs-keyword">throws</span> ParseException</span>;
   <span class="hljs-comment">// 根据传入的表达式和ParserContext生成Expression对象</span>
   <span class="hljs-function">Expression <span class="hljs-title">parseExpression</span><span class="hljs-params">(String expressionString, ParserContext context)</span> <span class="hljs-keyword">throws</span> ParseException</span>;
}
</code></pre>
<p data-nodeid="244151">我们可以看到，这两个方法的目的都是生成 Expression。</p>
<p data-nodeid="244152"><strong data-nodeid="244355">Expression</strong></p>
<p data-nodeid="244153">它默认的实现是 SpELExpression，主要对外提供的接口就是根据表达式获得表达式响应的结果，如下图所示。</p>
<p data-nodeid="250683" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/88/Ciqc1F_TZhaAXrP7AAH3T5PfIR8675.png" alt="Drawing 2.png" data-nodeid="250686"></p>

<p data-nodeid="244155">而它的这些方法中，最重的一个参数就是 EvaluationContext。</p>
<p data-nodeid="244156"><strong data-nodeid="244364">EvaluationContext</strong></p>
<p data-nodeid="244157">表示解析 String 表达式所需要的上下文，例如寻找 ROOT 是谁，反射解析的 Method、Field、Constructor 的解析器和取值所需要的上下文。我们看一下其接口提供的方法，如下图所示。</p>
<p data-nodeid="251553" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZhyAfk9oAADDsWDvRJM660.png" alt="Drawing 3.png" data-nodeid="251556"></p>

<p data-nodeid="244159">现在对这三个接口有了初步认识之后，我们通过实例来看一下基本用法。</p>
<h4 data-nodeid="244160">SpEL 的基本用法</h4>
<p data-nodeid="244161">下面是一个 SpEL 基本用法的例子，你可以结合注释来理解。</p>
<pre class="lang-java" data-nodeid="244162"><code data-language="java"><span class="hljs-comment">//ExpressionParser是操作SpEL的总入口，创建一个接口ExpressionParser对应的实例SpelExpressionParser</span>
ExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser();
<span class="hljs-comment">//通过上面我们讲的parser.parseExpression方法获得一个Expression的实例，里面实现的就是new一个SpelExpression对象；而parseExpression的参数就是SpEL的使用重点，各种表达式的字符串</span>
<span class="hljs-comment">//1.简单的string类型用'' 引用</span>
Expression exp = parser.parseExpression(<span class="hljs-string">"'Hello World'"</span>);
<span class="hljs-comment">//2.SpEL支持很多功能特性，如调用方法、访问属性、调用构造函数，我们可以直接调用String对象里面的concat方法进行字符串拼接</span>
Expression exp = parser.parseExpression(<span class="hljs-string">"'Hello World'.concat('!')"</span>);
<span class="hljs-comment">//通过getValue方法可以得到经过Expresion计算parseExpression方法的字符串参数(符合SpEL语法的表达式)的结果</span>
String message = (String) exp.getValue();
</code></pre>
<p data-nodeid="244163">而访问属性值如下所示。</p>
<pre class="lang-java" data-nodeid="244164"><code data-language="java"><span class="hljs-comment">//3.invokes getBytes()方法</span>
Expression exp = parser.parseExpression(<span class="hljs-string">"'Hello World'.bytes"</span>);
<span class="hljs-keyword">byte</span>[] bytes = (<span class="hljs-keyword">byte</span>[]) exp.getValue(); <span class="hljs-comment">//得到 byte[]类型的结果</span>
</code></pre>
<p data-nodeid="244165">SpEL 字符串表达式还支持使用“.”进行嵌套属性 prop1.prop2.prop3 访问，代码如下。</p>
<pre class="lang-java" data-nodeid="244166"><code data-language="java"><span class="hljs-comment">// invokes getBytes().length</span>
Expression exp = parser.parseExpression(<span class="hljs-string">"'Hello World'.bytes.length"</span>);
<span class="hljs-keyword">int</span> length = (Integer) exp.getValue();
</code></pre>
<p data-nodeid="244167">访问构造方法，例如字符串的构造方法，如下所示。</p>
<pre class="lang-java" data-nodeid="244168"><code data-language="java">Expression exp = parser.parseExpression(<span class="hljs-string">"new String('hello world').toUpperCase()"</span>);
String message = exp.getValue(String.class);
</code></pre>
<p data-nodeid="244169">我们也可以通过 EvaluationContext 来配置一些根元素，代码如下。</p>
<pre class="lang-java" data-nodeid="244170"><code data-language="java"><span class="hljs-comment">//我们通过一个Expression表达式想取name属性对应的值</span>
ExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser();
Expression exp = parser.parseExpression(<span class="hljs-string">"name"</span>);
<span class="hljs-comment">//我们通过EvaluationContext设置rootObject等于我们new的UserInfo对象</span>
UserInfo rootUserInfo = UserInfo.builder().name(<span class="hljs-string">"jack"</span>).build();
EvaluationContext context = <span class="hljs-keyword">new</span> StandardEvaluationContext(rootUserInfo);
<span class="hljs-comment">//getValue根据我们设置context取值，可以得到jack字符串</span>
String name = (String) exp.getValue(context);
<span class="hljs-comment">//我们也可以利用SpEL的表达式进行运算，判断名字是否等于字符串Nikola</span>
Expression exp2 = parser.parseExpression(<span class="hljs-string">"name == 'Nikola'"</span>);
<span class="hljs-keyword">boolean</span> result2 = exp2.getValue(context, Boolean.class); // 根据我们UserInfo的rootObject得到<span class="hljs-keyword">false</span>
</code></pre>
<p data-nodeid="244171">我们在看 SpelExpressionParser 的构造方法时，会发现其还支持一些配置，例如我们经常遇到空指针异常和下标越界的问题，就可以通过 SpelParserConfiguration 配置：当 Null 的时候自动初始化，当 Collection 越界的时候自动扩容增加。我们看一下例子，如下所示。</p>
<pre class="lang-java" data-nodeid="244172"><code data-language="java"><span class="hljs-comment">//构造一个Class，方便测试</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUser</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;String&gt; address;
}
<span class="hljs-comment">//开启自动初始化null和自动扩容collection</span>
SpelParserConfiguration config = <span class="hljs-keyword">new</span> SpelParserConfiguration(<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>);
<span class="hljs-comment">//利用config生成ExpressionParser的实例</span>
ExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser(config);
<span class="hljs-comment">//我们通过表达式取这个用户的第三个地址</span>
Expression expression = parser.parseExpression(<span class="hljs-string">"address[3]"</span>);
MyUser demo = <span class="hljs-keyword">new</span> MyUser(); 
<span class="hljs-comment">//new一个对象，但是没有初始化MyUser里面的address，由于我们配置了自动初始化和扩容，所以通过下面的计算，没有得到异常，o可以得到一个空的字符串</span>
Object o = expression.getValue(demo);<span class="hljs-comment">// 空字符串</span>
</code></pre>
<p data-nodeid="244173">通过上面的介绍，你大概就知道 SpEL 是什么意思了，也知道了该怎么单独使用它，其实不难理解。不过 SpEL 的功能远不止这么简单，我们通过在 Spring 中常见的应用场景，看一下它还有哪些功能。</p>
<h3 data-nodeid="244174">SpEL 在 Spring 中常见的使用场景</h3>
<p data-nodeid="244175">SpEL 在 @Value 里面的用法最常见，我们通过 @Value 来了解一下。</p>
<h4 data-nodeid="244176">@Value 的应用场景</h4>
<p data-nodeid="244177">新建一个 DemoProperties 对象，用 Spring 装载，测试一下两个语法点：运算符和 Map、List。</p>
<p data-nodeid="244178">**第一个语法：通过 @Value 展示 SpEL 里面支持的各种运算符的写法。**如下面的表格所示。</p>
<table data-nodeid="244180">
<thead data-nodeid="244181">
<tr data-nodeid="244182">
<th data-nodeid="244184"><strong data-nodeid="244389">类型</strong></th>
<th data-nodeid="244185"><strong data-nodeid="244393">操作符</strong></th>
</tr>
</thead>
<tbody data-nodeid="244188">
<tr data-nodeid="244189">
<td data-nodeid="244190">逻辑运算</td>
<td data-nodeid="244191">+, -, *, /, %, ^, div, mod</td>
</tr>
<tr data-nodeid="244192">
<td data-nodeid="244193">逻辑比较符号</td>
<td data-nodeid="244194">&lt;, &gt;, ==, !=, &lt;=, &gt;=, lt, gt, eq, ne, le, ge</td>
</tr>
<tr data-nodeid="244195">
<td data-nodeid="244196">逻辑关系</td>
<td data-nodeid="244197">and, or, not, &amp;&amp;, ||, !</td>
</tr>
<tr data-nodeid="244198">
<td data-nodeid="244199">三元表达式</td>
<td data-nodeid="244200">?:</td>
</tr>
<tr data-nodeid="244201">
<td data-nodeid="244202">正则表达式</td>
<td data-nodeid="244203">matches</td>
</tr>
</tbody>
</table>
<p data-nodeid="244204">我们通过四部分代码展示一下 SpEL 里面支持的各种运算符，用法如下所示。</p>
<pre class="lang-java" data-nodeid="244205"><code data-language="java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@ToString</span>
<span class="hljs-meta">@Component</span> <span class="hljs-comment">//通过@Value使用SpEL的地方，一定要将此对象交由Spring进行管理</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoProperties</span> </span>{
<span class="hljs-comment">//第一部分：逻辑运算操作</span>
    <span class="hljs-meta">@Value("#{19 + 1}")</span> <span class="hljs-comment">// 20</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> add;
    <span class="hljs-meta">@Value("#{'String1 ' + 'string2'}")</span> <span class="hljs-comment">// "String1 string2"</span>
    <span class="hljs-keyword">private</span> String addString;
    <span class="hljs-meta">@Value("#{20 - 1}")</span> <span class="hljs-comment">// 19</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> subtract;
    <span class="hljs-meta">@Value("#{10 * 2}")</span> <span class="hljs-comment">// 20</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> multiply;
    <span class="hljs-meta">@Value("#{36 / 2}")</span> <span class="hljs-comment">// 19</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> divide;
    <span class="hljs-meta">@Value("#{36 div 2}")</span> <span class="hljs-comment">// 18, the same as for / operator</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> divideAlphabetic;
    <span class="hljs-meta">@Value("#{37 % 10}")</span> <span class="hljs-comment">// 7</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> modulo;
    <span class="hljs-meta">@Value("#{37 mod 10}")</span> <span class="hljs-comment">// 7, the same as for % operator</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> moduloAlphabetic;
<span class="hljs-comment">// 第二部分：逻辑比较符号</span>
    <span class="hljs-meta">@Value("#{1 == 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> equal;
    <span class="hljs-meta">@Value("#{1 eq 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> equalAlphabetic;
    <span class="hljs-meta">@Value("#{1 != 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> notEqual;
    <span class="hljs-meta">@Value("#{1 ne 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> notEqualAlphabetic;
    <span class="hljs-meta">@Value("#{1 &lt; 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lessThan;
    <span class="hljs-meta">@Value("#{1 lt 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lessThanAlphabetic;
    <span class="hljs-meta">@Value("#{1 &lt;= 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lessThanOrEqual;
    <span class="hljs-meta">@Value("#{1 le 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> lessThanOrEqualAlphabetic;
    <span class="hljs-meta">@Value("#{1 &gt; 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> greaterThan;
    <span class="hljs-meta">@Value("#{1 gt 1}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> greaterThanAlphabetic;
    <span class="hljs-meta">@Value("#{1 &gt;= 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> greaterThanOrEqual;
    <span class="hljs-meta">@Value("#{1 ge 1}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> greaterThanOrEqualAlphabetic;
<span class="hljs-comment">//第三部分：逻辑关系运算符    </span>
    <span class="hljs-meta">@Value("#{250 &gt; 200 &amp;&amp; 200 &lt; 4000}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> and;
    <span class="hljs-meta">@Value("#{250 &gt; 200 and 200 &lt; 4000}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> andAlphabetic;
    <span class="hljs-meta">@Value("#{400 &gt; 300 || 150 &lt; 100}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> or;
    <span class="hljs-meta">@Value("#{400 &gt; 300 or 150 &lt; 100}")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> orAlphabetic;
    <span class="hljs-meta">@Value("#{!true}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> not;
    <span class="hljs-meta">@Value("#{not true}")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> notAlphabetic;    
    
<span class="hljs-comment">//第四部分：三元表达式 &amp; Elvis运算符</span>
    <span class="hljs-meta">@Value("#{2 &gt; 1 ? 'a' : 'b'}")</span> <span class="hljs-comment">// "b"</span>
    <span class="hljs-keyword">private</span> String ternary;
    <span class="hljs-comment">//demoProperties就是我们通过spring加载的当前对象，</span>
    <span class="hljs-comment">//我们取spring容器里面的某个bean的属性，</span>
    <span class="hljs-comment">//这里我们取的是demoProperties对象里面的someProperty属性，</span>
    <span class="hljs-comment">//如果不为null就直接用，如果为null返回'default'字符串</span>
   <span class="hljs-meta">@Value("#{demoProperties.someProperty != null ? demoProperties.someProperty : 'default'}")</span>
    <span class="hljs-keyword">private</span> String ternaryProperty;
    <span class="hljs-comment">/**
     * Elvis运算符是三元表达式简写的方式，和上面一样的结果。如果someProperty为null则返回default值。
     */</span>
    <span class="hljs-meta">@Value("#{demoProperties.someProperty ?: 'default'}")</span>
    <span class="hljs-keyword">private</span> String elvis;
    <span class="hljs-comment">/**
     * 取系统环境的属性，如果系统属性pop3.port已定义会直接注入，如果未定义，则返回默认值25。systemProperties是spring容器里面的systemProperties实体；
     */</span>
    <span class="hljs-meta">@Value("#{systemProperties['pop3.port'] ?: 25}")</span>
    <span class="hljs-keyword">private</span> Integer port;
    <span class="hljs-comment">/**
     * 还可以用于安全引用运算符主要为了避免空指针，源于Groovy语言。
     * 很多时候你引用一个对象的方法或者属性时都需要做非空校验。
     * 为了避免此类问题，使用安全引用运算符只会返回null而不是抛出一个异常。
     */</span>
    <span class="hljs-comment">//@Value("#{demoPropertiesx?:someProperty}") </span>
    <span class="hljs-comment">// 如果demoPropertiesx不为null，则返回someProperty值</span>
    <span class="hljs-keyword">private</span> String someProperty;
    
<span class="hljs-comment">//第五部分：正则表达式的支持</span>
    <span class="hljs-meta">@Value("#{'100' matches '\\d+' }")</span> <span class="hljs-comment">// true</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> validNumericStringResult;
    <span class="hljs-meta">@Value("#{'100fghdjf' matches '\\d+' }")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> invalidNumericStringResult;
    <span class="hljs-comment">// 利用matches匹配正则表达式，返回true</span>
    <span class="hljs-meta">@Value("#{'valid alphabetic string' matches '[a-zA-Z\\s]+' }")</span> 
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> validAlphabeticStringResult;
    <span class="hljs-meta">@Value("#{'invalid alphabetic string #$1' matches '[a-zA-Z\\s]+' }")</span> <span class="hljs-comment">// false</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> invalidAlphabeticStringResult;
    <span class="hljs-comment">//如果someValue只有数字</span>
    <span class="hljs-meta">@Value("#{demoProperties.someValue matches '\\d+'}")</span> <span class="hljs-comment">// true </span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> validNumericValue;
    <span class="hljs-comment">//新增一个空的someValue属性方便测试</span>
    <span class="hljs-keyword">private</span> String someValue=<span class="hljs-string">""</span>;
}
</code></pre>
<p data-nodeid="244206">我们可以通过 @Value 测试各种 SpEL 的表达式，这和放在 parser.parseExpression("SpEL 的表达式字符串"); 里面的效果是一样的。我们可以写一个测试用例来看一下，如下所示。</p>
<pre class="lang-java" data-nodeid="244207"><code data-language="java"><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span>
<span class="hljs-meta">@Import(TestConfiguration.class)</span>
<span class="hljs-meta">@ComponentScan(value = "com.example.jpa.demo.config.DemoProperties")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoPropertiesTest</span> </span>{
    <span class="hljs-meta">@Autowired(required = false)</span>
    <span class="hljs-keyword">private</span> DemoProperties demoProperties;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSpel</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//通过测试用例就可以测试@Value里面不同表达式的值了</span>
        System.out.println(demoProperties.toString());
    }
    <span class="hljs-meta">@TestConfiguration</span>
    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestConfig</span> </span>{
        <span class="hljs-meta">@Bean</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> DemoProperties <span class="hljs-title">demoProperties</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DemoProperties();
        }
    }
}
</code></pre>
<p data-nodeid="244208">或者你可以启动一下项目，也能看到结果。</p>
<p data-nodeid="244209">下面我们通过源码来分析一下 @Value 的解析原理。Spring 项目启动的时候会根据 @Value 的注解，去加载 SpelExpressionResolver 及算出来需要的 StandardEvaluationContext，然后再调用 Expression 方法进行 getValue 操作，其中计算 StandardEvaluationContext 的关键源码如下面两张图所示。</p>
<p data-nodeid="254151"><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZjOAeGv_AATHsCZz1as768.png" alt="Drawing 4.png" data-nodeid="254155"></p>
<p data-nodeid="254152" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZjmAW5suAARIid5TtLA365.png" alt="Drawing 5.png" data-nodeid="254158"></p>





<p data-nodeid="244212"><strong data-nodeid="244433">第二个语法：@Value 展示了 SpEL 可以直接读取 Map 和 List 里面的值</strong>，代码如下所示。</p>
<pre class="lang-java" data-nodeid="244213"><code data-language="java"><span class="hljs-comment">//我们通过@Component加载一个类，并且给其中的List和Map附上值</span>
<span class="hljs-meta">@Component("workersHolder")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkersHolder</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private</span> List&lt;String&gt; workers = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; salaryByWorkers = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkersHolder</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workers.add(<span class="hljs-string">"John"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workers.add(<span class="hljs-string">"Susie"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workers.add(<span class="hljs-string">"Alex"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;workers.add(<span class="hljs-string">"George"</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salaryByWorkers.put(<span class="hljs-string">"John"</span>, <span class="hljs-number">35000</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salaryByWorkers.put(<span class="hljs-string">"Susie"</span>, <span class="hljs-number">47000</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salaryByWorkers.put(<span class="hljs-string">"Alex"</span>, <span class="hljs-number">12000</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;salaryByWorkers.put(<span class="hljs-string">"George"</span>, <span class="hljs-number">14000</span>);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//Getters and setters ...</span>
}
<span class="hljs-comment">//SpEL直接读取Map和List里面的值</span>
<span class="hljs-meta">@Value("#{workersHolder.salaryByWorkers['John']}")</span> <span class="hljs-comment">// 35000</span>
<span class="hljs-keyword">private</span> Integer johnSalary;
<span class="hljs-meta">@Value("#{workersHolder.salaryByWorkers['George']}")</span> <span class="hljs-comment">// 14000</span>
<span class="hljs-keyword">private</span> Integer georgeSalary;
<span class="hljs-meta">@Value("#{workersHolder.salaryByWorkers['Susie']}")</span> <span class="hljs-comment">// 47000</span>
<span class="hljs-keyword">private</span> Integer susieSalary;
<span class="hljs-meta">@Value("#{workersHolder.workers[0]}")</span> <span class="hljs-comment">// John</span>
<span class="hljs-keyword">private</span> String firstWorker;
<span class="hljs-meta">@Value("#{workersHolder.workers[3]}")</span> <span class="hljs-comment">// George</span>
<span class="hljs-keyword">private</span> String lastWorker;
<span class="hljs-meta">@Value("#{workersHolder.workers.size()}")</span> <span class="hljs-comment">// 4</span>
<span class="hljs-keyword">private</span> Integer numberOfWorkers;
</code></pre>
<p data-nodeid="244214">以上就是 SpEL 的运算符和对 Map、List、SpringBeanFactory 里面的 Bean 的调用情况，不知道你是否掌握了？那么使用 @Value 都有哪些需要注意的呢？</p>
<p data-nodeid="244215"><strong data-nodeid="244438">@Value 使用的注意事项 # 与 $ 的区别</strong></p>
<p data-nodeid="244216">SpEL 表达式默认以&nbsp;#&nbsp;开始，以大括号进行包住，如 #{expression}。默认规则在 ParserContext 里面设置，我们也可以自定义，但是一般建议不要动。</p>
<p data-nodeid="255025" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZkSAcGUfAAIDnxtLZsQ409.png" alt="Drawing 6.png" data-nodeid="255028"></p>

<p data-nodeid="244218">这里注意要与 Spring 中的 Properties 进行区别，Properties 相关的表达式是以&nbsp;$&nbsp;开始的大括号进行包住的，如&nbsp;${property.name}。</p>
<p data-nodeid="244219">也就是说 @Value 的值有两类：</p>
<ul data-nodeid="244220">
<li data-nodeid="244221">
<p data-nodeid="244222">${ property**:**default_value }</p>
</li>
<li data-nodeid="244223">
<p data-nodeid="244224">#{ obj.property**? :**default_value }</p>
</li>
</ul>
<p data-nodeid="244225">第一个注入的是外部参数对应的 Property，第二个则是 SpEL 表达式对应的内容。</p>
<p data-nodeid="244226">而 Property placeholders 不能包含&nbsp;SpEL 表达式，但是 SpEL 表达式可以包含 Property 的引用。如 #{${someProperty} + 2}，如果 someProperty=1，那么效果将是 #{ 1 + 2}，最终的结果将是 3。</p>
<p data-nodeid="244227">上面我们通过 @Value 的应用场景讲解了一部分 SpEL 的语法，此外它同样适用于 @Query 注解，那么我们通过 @Query 再学习一些 SpEL 的其他语法。</p>
<h4 data-nodeid="244228">JPA 中 @Query 的应用场景</h4>
<p data-nodeid="244229">SpEL 除了能在 @Value 里面使用外，也能在 @Query 里使用，而在 @Query 里还有一个特殊的地方，就是它可以用来取方法的参数。</p>
<p data-nodeid="244230"><strong data-nodeid="244467">通过 SpEL 取被 @Query 注解的方法参数</strong></p>
<p data-nodeid="244231">在 @Query 注解中使用 SpEL 的主要目的是取方法的参数，主要有三种用法，如下所示。</p>
<pre class="lang-java" data-nodeid="244232"><code data-language="java"><span class="hljs-comment">//用法一：根据下标取方法里面的参数</span>
<span class="hljs-meta">@Query("select u from User u where u.age = ?#{[0]}")</span> 
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUsersByAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span></span>;
<span class="hljs-comment">//用法二：#customer取@Param("customer")里面的参数</span>
<span class="hljs-meta">@Query("select u from User u where u.firstname = :#{#customer.firstname}")</span>
<span class="hljs-function">List&lt;User&gt; <span class="hljs-title">findUsersByCustomersFirstname</span><span class="hljs-params">(<span class="hljs-meta">@Param("customer")</span> Customer customer)</span></span>;
<span class="hljs-comment">//用法三：用JPA约定的变量entityName取得当前实体的实体名字</span>
<span class="hljs-meta">@Query("from #{#entityName}")</span>
<span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findAllByEntityName</span><span class="hljs-params">()</span></span>;
</code></pre>
<p data-nodeid="244233">其中，</p>
<ul data-nodeid="244234">
<li data-nodeid="244235">
<p data-nodeid="244236">方法一可以通过 [0] 的方式，根据下标取到方法的参数；</p>
</li>
<li data-nodeid="244237">
<p data-nodeid="244238">方法二通过 #customer 可以根据 @Param 注解的参数的名字取到参数，必须通过 ?#{} 和 :#{} 来触发 SpEL 的表达式语法；</p>
</li>
<li data-nodeid="244239">
<p data-nodeid="244240">方法三通过 #{#entityName} 取约定的实体的名字。</p>
</li>
</ul>
<p data-nodeid="244241">你要注意区别我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=490#/detail/pc?id=4705" data-nodeid="244480">05 | @Query 解决了什么问题？什么时候应该选择它？</a>”中介绍的取 @Param 的用法<code data-backticks="1" data-nodeid="244482">:lastname</code>这种方式。</p>
<p data-nodeid="244242">下面我们再来看一个更复杂一点的例子，代码如下。</p>
<pre class="lang-java" data-nodeid="244243"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInfoRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">UserInfo</span>, <span class="hljs-title">Long</span>&gt; </span>{
   <span class="hljs-comment">// JPA约定的变量entityName取得当前实体的实体名字</span>
   <span class="hljs-meta">@Query("from #{#entityName}")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findAllByEntityName</span><span class="hljs-params">()</span></span>;
   
   <span class="hljs-comment">//一个查询中既可以支持SpEL也可以支持普通的:ParamName的方式</span>
   <span class="hljs-meta">@Modifying</span>
   <span class="hljs-meta">@Query("update #{#entityName} u set u.name = :name where u.id =:id")</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateUserActiveState</span><span class="hljs-params">(<span class="hljs-meta">@Param("name")</span> String name, <span class="hljs-meta">@Param("id")</span> Long id)</span></span>;
   
   <span class="hljs-comment">//演示SpEL根据数组下标取参数，和根据普通的Parma的名字:name取参数</span>
   <span class="hljs-meta">@Query("select u from UserInfo u where u.lastName like %:#{[0]} and u.name like %:name%")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findContainingEscaped</span><span class="hljs-params">(<span class="hljs-meta">@Param("name")</span> String name)</span></span>;
   
   <span class="hljs-comment">//SpEL取Parma的名字customer里面的属性</span>
   <span class="hljs-meta">@Query("select u from UserInfo u where u.name = :#{#customer.name}")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findUsersByCustomersFirstname</span><span class="hljs-params">(<span class="hljs-meta">@Param("customer")</span> UserInfo customer)</span></span>;
   
   <span class="hljs-comment">//利用SpEL根据一个写死的'jack'字符串作为参数</span>
   <span class="hljs-meta">@Query("select u from UserInfo u where u.name = ?#{'jack'}")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findOliverBySpELExpressionWithoutArgumentsWithQuestionmark</span><span class="hljs-params">()</span></span>;
   
   <span class="hljs-comment">//同时SpEL支持特殊函数escape和escapeCharacter</span>
   <span class="hljs-meta">@Query("select u from UserInfo u where u.lastName like %?#{escape([0])}% escape ?#{escapeCharacter()}")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findByNameWithSpelExpression</span><span class="hljs-params">(String name)</span></span>;
   
   <span class="hljs-comment">// #entityName和#[]同时使用</span>
   <span class="hljs-meta">@Query("select u from #{#entityName} u where u.name = ?#{[0]} and u.lastName = ?#{[1]}")</span>
   <span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findUsersByFirstnameForSpELExpressionWithParameterIndexOnlyWithEntityExpression</span><span class="hljs-params">(String name, String lastName)</span></span>;
   <span class="hljs-comment">//对于 native SQL同样适用，并且同样支持取pageable分页里面的属性值</span>
   <span class="hljs-meta">@Query(value = "select * from (" //
         + "select u.*, rownum() as RN from (" //
         + "select * from user_info ORDER BY ucase(firstname)" //
         + ") u" //
         + ") where RN between ?#{ #pageable.offset +1 } and ?#{#pageable.offset + #pageable.pageSize}", //
         countQuery = "select count(u.id) from user_info u", //
         nativeQuery = true)</span>
   <span class="hljs-function">Page&lt;UserInfo&gt; <span class="hljs-title">findUsersInNativeQueryWithPagination</span><span class="hljs-params">(Pageable pageable)</span></span>;
}
</code></pre>
<p data-nodeid="244244">我个人比较推荐使用 @Param 的方式，这样语义清晰，参数换位置了也不影响执行结果。</p>
<p data-nodeid="244245">关于源码的实现，你可以到 ExpressionBasedStringQuery.class 里面继续研究，关键代码如下图所示。</p>
<p data-nodeid="255895" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/88/Ciqc1F_TZlOAIupqAALzhPEi9nM327.png" alt="Drawing 7.png" data-nodeid="255898"></p>

<p data-nodeid="244247">好了，以上就是 @Query 支持的 SpEL 的基本语法，其他场景我就不多列举了。那么其实 JPA 还支持自定义 rootObject，我们看一下。</p>
<p data-nodeid="244248"><strong data-nodeid="244494">spring-security-data 在 @Query 中的用法</strong></p>
<p data-nodeid="244249">在实际工作中，我发现有些同事会用 spring-security 做鉴权，详细的 Spring Secrity 如何集成不是我们的重点，我就不多介绍了，具体怎么集成你可以查看官方文档：<a href="https://spring.io/projects/spring-security#learn" data-nodeid="244498">https://spring.io/projects/spring-security#learn</a>。</p>
<p data-nodeid="244250">我想说的是，当我们用 Spring Secrity 的时候，其实可以额外引入 jai 包&nbsp;spring-security-data。如果我们使用了 JPA 和 Spring Secrity 的话，build.gradle 最终会变成如下形式，请看代码。</p>
<pre class="lang-java" data-nodeid="244251"><code data-language="java"><span class="hljs-comment">//引入spring data jpa</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>
<span class="hljs-comment">//集成spring security</span>
implementation <span class="hljs-string">'org.springframework.boot:spring-boot-starter-security'</span>
<span class="hljs-comment">// 集成spring security data对JPA的支持</span>
implementation <span class="hljs-string">'org.springframework.security:spring-security-data'</span>
</code></pre>
<p data-nodeid="244252">我们假设继承 Spring Security 之后，SecurityContextHolder 里面放置的 Authentication 是 UserInfo，代码如下。</p>
<pre class="lang-java" data-nodeid="244253"><code data-language="java"><span class="hljs-comment">//应用上下文中设置登录用户信息，此时Authentication类型为UserInfo</span>
SecurityContextHolder.getContext().setAuthentication(authentication);
</code></pre>
<p data-nodeid="244254">这样 JPA 里面的 @Query 就可以取到当前的 SecurityContext 信息，其用法如下所示。</p>
<pre class="lang-java" data-nodeid="244255"><code data-language="java"><span class="hljs-comment">// 根据当前用户email取当前用户的信息</span>
<span class="hljs-meta">@Query("select u from UserInfo u where u.emailAddress = ?#{principal.email}")</span>
<span class="hljs-function">List&lt;UserInfo&gt; <span class="hljs-title">findCurrentUserWithCustomQuery</span><span class="hljs-params">()</span></span>;
<span class="hljs-comment">//如果当前用户是admin，我们就返回某业务的所有对象；如果不是admin角色，就只给当前用户的某业务数据</span>
<span class="hljs-meta">@Query("select o from BusinessObject o where o.owner.emailAddress like "+
      "?#{hasRole('ROLE_ADMIN') ? '%' : principal.emailAddress}")</span>
<span class="hljs-function">List&lt;BusinessObject&gt; <span class="hljs-title">findBusinessObjectsForCurrentUser</span><span class="hljs-params">()</span></span>;
</code></pre>
<p data-nodeid="244256">我们通过看源码会发现，spring-security-data 就帮我们做了一件事情：实现 EvaluationContextExtension，设置了 SpEL 所需要的 rootObject 为 SecurityExpressionRoot。关键代码如下图所示。</p>
<p data-nodeid="256765" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZl2AIjYgAAYG1kqP1Zw860.png" alt="Drawing 8.png" data-nodeid="256768"></p>

<p data-nodeid="244258">由于 SecurityExpressionRoot 是 rootObject，根据我们上面介绍的 SpEL 的基本用法，SecurityExpressionRoot 里面的各种属性和方法都可以在 SpEL 中使用，如下图所示。</p>
<p data-nodeid="257635" class=""><img src="https://s0.lgstatic.com/i/image/M00/84/88/Ciqc1F_TZmKAbFerAAHOBNbwd44831.png" alt="Drawing 9.png" data-nodeid="257638"></p>

<p data-nodeid="244260">这其实也给了我们一些启发：当需要自动 rootObject 给 @Query 使用的时候，也可以采用这种方式，这样 @Query 的灵活性会增强很多。</p>
<p data-nodeid="244261">最后我们再看看 SpEL 在 @Cacheable 里面做了哪些支持。</p>
<h4 data-nodeid="244262">SpEL 在 @Cacheable 中的应用场景</h4>
<p data-nodeid="244263">我们在实际工作中还有一个经常用到 SpEL 的场景，就是在 Cache 的时候，也就是 Spring Cache 的相关注解里面，如 @Cacheable、@CachePut、@CacheEvict 等。我们还是通过例子来体会一下，代码如下所示。</p>
<pre class="lang-java" data-nodeid="244264"><code data-language="java"><span class="hljs-comment">//缓存key取当前方法名，判断一下只有返回结果不为null或者非empty才进行缓存</span>
<span class="hljs-meta">@Cacheable(value = "APP", key = "#root.methodName", cacheManager = "redis.cache", unless = "#result == null || #result.isEmpty()")</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> Map&lt;String, Map&lt;String, String&gt;&gt; getAppGlobalSettings() {}
<span class="hljs-comment">//evict策略的key是当前参数customer里面的name属性</span>
<span class="hljs-meta">@Caching(evict = {
@CacheEvict(value="directory", key="#customer.name") })</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">(Customer customer)</span> </span>{...}
<span class="hljs-comment">//在condition里面使用，当参数里面customer的name属性的值等于字符串Tom才放到缓存里面</span>
<span class="hljs-meta">@CachePut(value="addresses", condition="#customer.name=='Tom'")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">(Customer customer)</span> </span>{...}
<span class="hljs-comment">//用在unless里面，利用SpEL的条件表达式判断，排除返回的结果地址长度小于64的请求</span>
<span class="hljs-meta">@CachePut(value="addresses", unless="#result.length()&lt;64")</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">(Customer customer)</span> </span>{...}
</code></pre>
<p data-nodeid="244265"><strong data-nodeid="244518">Spring Cache 中 SpEL 支持的上下文语法</strong></p>
<p data-nodeid="244266">Spring Cache 提供了一些供我们使用的 SpEL 上下文数据，如下表所示（摘自 Spring 官方文档）。</p>
<table data-nodeid="244268">
<thead data-nodeid="244269">
<tr data-nodeid="244270">
<th data-nodeid="244272">支持的属性</th>
<th data-nodeid="244273">作用域</th>
<th data-nodeid="244274">功能描述</th>
<th data-nodeid="244275">使用方法</th>
</tr>
</thead>
<tbody data-nodeid="244280">
<tr data-nodeid="244281">
<td data-nodeid="244282">methodName</td>
<td data-nodeid="244283">root 对象</td>
<td data-nodeid="244284">当前被调用的方法名</td>
<td data-nodeid="244285">#root.methodName</td>
</tr>
<tr data-nodeid="244286">
<td data-nodeid="244287">method</td>
<td data-nodeid="244288">root 对象</td>
<td data-nodeid="244289">当前被调用的方法</td>
<td data-nodeid="244290">#root.method.name</td>
</tr>
<tr data-nodeid="244291">
<td data-nodeid="244292">target</td>
<td data-nodeid="244293">root 对象</td>
<td data-nodeid="244294">当前被调用的目标对象</td>
<td data-nodeid="244295">#root.target</td>
</tr>
<tr data-nodeid="244296">
<td data-nodeid="244297">targetClass</td>
<td data-nodeid="244298">root 对象</td>
<td data-nodeid="244299">当前被调用的目标对象类</td>
<td data-nodeid="244300">#root.targetClass</td>
</tr>
<tr data-nodeid="244301">
<td data-nodeid="244302">args</td>
<td data-nodeid="244303">root 对象</td>
<td data-nodeid="244304">当前被调用的方法的参数列表</td>
<td data-nodeid="244305">#root.args[0]</td>
</tr>
<tr data-nodeid="244306">
<td data-nodeid="244307">caches</td>
<td data-nodeid="244308">root 对象</td>
<td data-nodeid="244309">当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})），则有两个 cache</td>
<td data-nodeid="244310">#root.caches[0].name</td>
</tr>
<tr data-nodeid="244311">
<td data-nodeid="244312">argument name</td>
<td data-nodeid="244313">执行上下文</td>
<td data-nodeid="244314">当前被调用的方法的参数，如 findById(Long id)，我们可以通过 #id 拿到参数</td>
<td data-nodeid="244315">#user.id<br>表示参数 user 里面的 id</td>
</tr>
<tr data-nodeid="244316">
<td data-nodeid="244317">result</td>
<td data-nodeid="244318">执行上下文</td>
<td data-nodeid="244319">方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache evict’的 beforeInvocation=false）</td>
<td data-nodeid="244320">#result</td>
</tr>
</tbody>
</table>
<p data-nodeid="244321">有兴趣的话，你可以看一下 Spring Cache 中 SpEL 的 EvaluationContext 加载方式，关键源码如下图所示。</p>
<p data-nodeid="258505" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image/M00/84/93/CgqCHl_TZm6AaOt5AAFe2hVbtrM473.png" alt="Drawing 10.png" data-nodeid="258509"></p>
<h3 data-nodeid="258506">总结</h3>



<p data-nodeid="244325">本讲内容到这里就结束了。这一讲我们通过 SpEL 的基本语法介绍，分别介绍了其在 @Value、@Query、@Cache 注解里面的使用场景和方法，其中 # 和 $ 是容易在 @Value 里面犯错的地方；@Param 的用法 : 和 # 也是 @Query 里面容易犯错的地方，你要注意一下。</p>
<p data-nodeid="244326">其实任何形式的 SpEL 的变化都离不开它基本的三个接口：ExpressionParser、Expression、EvaluationContext，只不过框架提供了不同形式的封装，你也可以根据实际场景自由扩展。</p>
<p data-nodeid="244327">关于这一讲内容，希望你能认真去思考，有问题可以在下方留言，我们一起讨论。下一讲我们来聊聊 Hibernate 中一级缓存的概念，到时见。</p>
<blockquote data-nodeid="244328">
<p data-nodeid="244329">点击下方链接查看源码（不定时更新）<br>
<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="244577">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>
</blockquote>

---

### 精选评论


