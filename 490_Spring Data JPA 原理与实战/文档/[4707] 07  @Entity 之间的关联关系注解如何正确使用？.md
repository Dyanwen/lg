<p data-nodeid="2031">你好，欢迎来到第 07 课时的学习，这一课时我们讲一下实体与实体之间的关联关系，这和数据的表与表之间的外键关系类似，我们为之为映射。</p>

<p data-nodeid="1626">实体与实体之间的关联关系一共分为四种，分别为 OneToOne、OneToMany、ManyToOne 和 ManyToMany；而实体之间的关联关系又分为双向的和单向的。实体之间的关联关系是在 JPA 使用中最容易发生问题的地方，接下来我将一一揭晓并解释。我们先看一下 OneToOne，即一对一的关联关系。</p>
<h3 data-nodeid="1627">@OneToOne 关联关系</h3>
<p data-nodeid="1628">@OneToOne 一般表示对象之间一对一的关联关系，它可以放在 field 上面，也可以放在 get/set 方法上面。其中 JPA 协议有规定，如果是配置双向关联，维护关联关系的是拥有外键的一方，而另一方必须配置 mappedBy；如果是单项关联，直接配置在拥有外键的一方即可。</p>
<p data-nodeid="1629">举个例子：user 表是用户的主信息，user_info 是用户的扩展信息，两者之间是一对一的关系。user_info 表里面有一个 user_id 作为关联关系的外键，如果是单项关联，我们的写法如下：</p>
<pre class="lang-Java" data-nodeid="1630"><code data-language="Java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;
<span class="hljs-keyword">import</span> lombok.Builder;
<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String email;
   <span class="hljs-keyword">private</span> String sex;
   <span class="hljs-keyword">private</span> String address;
}
</code></pre>
<p data-nodeid="1631">User 实体里面什么都没变化，不需要添加 @OneToOne 注解。我们只需要在拥有外键的一方配置就可以，所以 UserInfo 的代码如下：</p>
<pre class="lang-java" data-nodeid="1632"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "user")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> Integer ages;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@OneToOne</span> <span class="hljs-comment">//维护user的外键关联关系，配置一对一</span>
   <span class="hljs-keyword">private</span> User user;
}
</code></pre>
<p data-nodeid="1633">我们看到，UserInfo 实体对象里面添加了 @OneToOne 注解，这时我们写一个测试用例跑一下看看有什么效果：</p>
<pre class="lang-java" data-nodeid="1634"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, address varchar(<span class="hljs-number">255</span>)</span>, email <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user_info</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, ages integer, telephone varchar(<span class="hljs-number">255</span>)</span>, user_id bigint, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: alter table user_info add constraint FKn8pl63y4abe7n0ls6topbqjh2 foreign <span class="hljs-title">key</span> <span class="hljs-params">(user_id)</span> references user
</span></code></pre>
<p data-nodeid="1635">因为我们新建了两个实体，跑任何一个 @SpringDataTest 就会看到上面有三个 sql 在执行，分别创建了两张表，而在 user_info 表上面还创建了一个外键索引。</p>
<p data-nodeid="1636">上面我们说了单项关联关系，那么双向关联应该怎么配置呢？我们保持 UserInfo 不变，在 User 实体对象里面添加这一段代码即可。</p>
<pre class="lang-java" data-nodeid="1637"><code data-language="java"><span class="hljs-meta">@OneToOne(mappedBy = "user")</span>
<span class="hljs-keyword">private</span> UserInfo userInfo;
</code></pre>
<p data-nodeid="1638">完整的 User 实体对象就会变成如下模样。</p>
<pre class="lang-java" data-nodeid="1639"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String email;
   <span class="hljs-meta">@OneToOne(mappedBy = "user")</span>
   <span class="hljs-keyword">private</span> UserInfo userInfo;<span class="hljs-comment">//变化之处</span>
   <span class="hljs-keyword">private</span> String sex;
   <span class="hljs-keyword">private</span> String address;
}
</code></pre>
<p data-nodeid="1640">我们跑任何一个测试用例，就会看到运行结果是一样的，还是上面三条 sql。那么我们再查看一下 @OneToOne 源码，看看其支持的配置都有哪些。</p>
<h4 data-nodeid="1641">@interface OneToOne 源码解读</h4>
<p data-nodeid="1642">下面我列举了@OneToOne 的源码，并加以解读。通过这些你可以了解 @OneToOne 的用法。</p>
<pre class="lang-java" data-nodeid="1643"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OneToOne {
    <span class="hljs-comment">//表示关系目标实体，默认该注解标识的返回值的类型的类。</span>
    <span class="hljs-function">Class <span class="hljs-title">targetEntity</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class</span>;
    <span class="hljs-comment">//cascade 级联操作策略，就是我们常说的级联操作</span>
    CascadeType[] cascade() <span class="hljs-keyword">default</span> {};
    <span class="hljs-comment">//数据获取方式EAGER(立即加载)/LAZY(延迟加载)</span>
    <span class="hljs-function">FetchType <span class="hljs-title">fetch</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> EAGER</span>;
    <span class="hljs-comment">//是否允许为空，默认是可选的，也就表示可以为空；</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">optional</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;
    <span class="hljs-comment">//关联关系被谁维护的一方对象里面的属性名字。 双向关联的时候必填</span>
    <span class="hljs-function">String <span class="hljs-title">mappedBy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//当被标识的字段发生删除或者置空操作之后，是否同步到关联关系的一方，即进行通过删除操作，默认flase，注意与CascadeType.REMOVE 级联删除的区别</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">orphanRemoval</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;
}
</code></pre>
<h4 data-nodeid="1644">mappedBy 注意事项</h4>
<p data-nodeid="1645">只有关联关系的维护方才能操作两个实体之间外键的关系。被维护方即使设置了维护方属性进行存储也不会更新外键关联。</p>
<p data-nodeid="1646">mappedBy 不能与 @JoinColumn 或者 @JoinTable 同时使用，因为没有意义，关联关系不在这里面维护。</p>
<p data-nodeid="1647">此外，mappedBy 的值是指另一方的实体里面属性的字段，而不是数据库字段，也不是实体的对象的名字。也就是维护关联关系的一方属性字段名称，或者加了 @JoinColumn / @JoinTable 注解的属性字段名称。如上面的 User 例子 user 里面 mappedBy 的值，就是 UserInfo 里面的 user 字段的名字。</p>
<h4 data-nodeid="1648">CascadeType用法</h4>
<p data-nodeid="1649">在 CascadeType 的用法中，CascadeType 的枚举值只有五个，分别如下：</p>
<ol data-nodeid="1650">
<li data-nodeid="1651">
<p data-nodeid="1652">CascadeType.PERSIST 级联新建</p>
</li>
<li data-nodeid="1653">
<p data-nodeid="1654">CascadeType.REMOVE 级联删除</p>
</li>
<li data-nodeid="1655">
<p data-nodeid="1656">CascadeType.REFRESH 级联刷新</p>
</li>
<li data-nodeid="1657">
<p data-nodeid="1658">CascadeType.MERGE 级联更新</p>
</li>
<li data-nodeid="1659">
<p data-nodeid="1660">CascadeType.ALL 四项全选</p>
</li>
</ol>
<p data-nodeid="1661">其中，默认是没有级联操作的，关系表不会产生任何影响。此外，JPA 2.0 还新增了 CascadeType.DETACH，即级联实体到 Detach 状态。</p>
<p data-nodeid="1662">了解了枚举值，下面我们来测试一下级联新建和级联删除。</p>
<p data-nodeid="1663">首先，修改 UserInfo 里面的关键代码如下，并在 @OneToOne 上面添加<br>
<code data-nodeid="1845" data-backticks="1">cascade ={CascadeType.PERSIST,CascadeType.REMOVE}</code>，如下：<br>
<img alt="1.png" src="https://s0.lgstatic.com/i/image/M00/59/95/Ciqc1F9xtZeAOQV4AACTEuTNOao100.png" data-nodeid="1850"></p>
<p data-nodeid="1664">其次，我们新增一个测试方法。</p>
<pre class="lang-java" data-nodeid="1665"><code data-language="java">    <span class="hljs-meta">@Test</span>
    <span class="hljs-meta">@Rollback(false)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserRelationships</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
        User user = User.builder().name(<span class="hljs-string">"jackxx"</span>).email(<span class="hljs-string">"123456@126.com"</span>).build();
        UserInfo userInfo = UserInfo.builder().ages(<span class="hljs-number">12</span>).user(user).telephone(<span class="hljs-string">"12345678"</span>).build();
        <span class="hljs-comment">//保存userInfo的同上也会保存User信息</span>
        userInfoRepository.saveAndFlush(userInfo);
        <span class="hljs-comment">//删除userInfo，同时也会级联的删除user记录</span>
        userInfoRepository.delete(userInfo);
}
</code></pre>
<p data-nodeid="1666">最后，运行一下看看效果。<br>
<img alt="1.png" src="https://s0.lgstatic.com/i/image/M00/59/A0/CgqCHl9xtbmAP4vcAAEKnyVM6Ig708.png" data-nodeid="1856"><br>
从上面的运行结果可以看到，上面的测试在执行了 insert 的时候，会执行两条 insert 的sql 和两条 delete 的 sql，这就体现出了 CascadeType.PERSIST 和 CascadeType.REMOVE 的作用。</p>
<p data-nodeid="1667">上面讲了级联删除的场景，下面我们再说一下关联关系的删除场景该怎么做。</p>
<h4 data-nodeid="1668">orphanRemoval 属性用法</h4>
<p data-nodeid="1669">orphanRemoval 表示当关联关系被删除的时候，是否应用级联删除，默认 false。什么意思呢？测试一下你就会明白。</p>
<p data-nodeid="1670">首先，还沿用上面的例子，当我们删除 userInfo 的时候，把 User 置空，作如下改动。</p>
<pre class="lang-java" data-nodeid="1671"><code data-language="java">userInfo.setUser(<span class="hljs-keyword">null</span>);
userInfoRepository.delete(userInfo);
</code></pre>
<p data-nodeid="1672">其次，我们再运行测试，看看效果。</p>
<pre class="lang-java" data-nodeid="1673"><code data-language="java">Hibernate: delete from user_info where id=?
</code></pre>
<p data-nodeid="1674">这时候你就会发现，少了一条删除 user 的 sql，说明没有进行级联删除。那我们再把 UserInfo 做一下调整。</p>
<pre class="lang-java" data-nodeid="1675"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> </span>{
   <span class="hljs-meta">@OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true)</span>
   <span class="hljs-keyword">private</span> User user;
   ....其他没变的代码省了
}
</code></pre>
<p data-nodeid="1676">然后，我们把 CascadeType.Remove 删除了，不让它进行级联删除，但是我们把 orphanRemoval 设置成 true，即当关联关系变化的时候级联更新。我们看下完整的测试用例。</p>
<pre class="lang-java" data-nodeid="1677"><code data-language="java">    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserRelationships</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
        User user = User.builder().name(<span class="hljs-string">"jackxx"</span>).email(<span class="hljs-string">"123456@126.com"</span>).build();
        UserInfo userInfo = UserInfo.builder().ages(<span class="hljs-number">12</span>).user(user).telephone(<span class="hljs-string">"12345678"</span>).build();
        userInfoRepository.saveAndFlush(userInfo);
        userInfo.setAges(<span class="hljs-number">13</span>);
        userInfo.setUser(<span class="hljs-keyword">null</span>);<span class="hljs-comment">//还是通过这个设置user数据为空</span>
        userInfoRepository.delete(userInfo);
}
</code></pre>
<p data-nodeid="1678">这个时候我们看一下运行结果。<br>
<img alt="1.png" src="https://s0.lgstatic.com/i/image/M00/59/A1/CgqCHl9xthOAHALuAAFaT_9YXuM848.png" data-nodeid="1870"></p>
<p data-nodeid="1679">从中我们可以看到，结果依然是两个 inser 和两个 delete，但是中间多了一个 update。我来解释一下，因为去掉了 CascadeType.REMOVE，这个时候不会进行级联删除了。当我们把 user 对象更新成空的时候，就会执行一条 update 语句把关联关系去掉了。</p>
<p data-nodeid="1680">而为什么又出现了级联删除 user 呢？因为我们修改了集合关联关系，orphanRemoval 设置为 true，所以又执行了级联删除的操作。这一点你可以仔细体会一下 orphanRemoval 和 CascadeType.REMOVE 的区别。</p>
<p data-nodeid="1681">到这里，@OneToOne 关联关系介绍完了，接下来我们看一下日常工作常见的场景，先看场景一：主键和外键都是同一个字段的情况。</p>
<h4 data-nodeid="1682">主键和外键都是同一个字段</h4>
<p data-nodeid="1683">我们假设 user 表是主表，user_info 的主键是 user_id，并且 user_id=user 是表里面的 id，那我们应该怎么写？</p>
<p data-nodeid="1684">继续沿用上面的例子，User 实体不变，我们看看 UserInfo 变成什么样了。</p>
<pre class="lang-java" data-nodeid="1685"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-keyword">private</span> Long userId;
   <span class="hljs-keyword">private</span> Integer ages;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@MapsId</span>
   <span class="hljs-meta">@OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true)</span>
   <span class="hljs-keyword">private</span> User user;
}
</code></pre>
<p data-nodeid="1686">这里的做法很简单，我们直接把 userId 设置为主键，在 @OneToOne 上面添加 @MapsId 注解即可。@MapsId 注解的作用是把关联关系实体里面的 ID（默认）值 copy 到 @MapsId 标注的字段上面（这里指的是 user_id 字段）。</p>
<p data-nodeid="1687">接着，上面的测试用例我们跑一下，看一下效果。</p>
<pre class="lang-java" data-nodeid="1688"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, address varchar(<span class="hljs-number">255</span>)</span>, email <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user_info</span> <span class="hljs-params">(ages integer, telephone varchar(<span class="hljs-number">255</span>)</span>, user_id bigint not <span class="hljs-keyword">null</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(user_id)</span>)
Hibernate: alter table user_info add constraint FKn8pl63y4abe7n0ls6topbqjh2 foreign <span class="hljs-title">key</span> <span class="hljs-params">(user_id)</span> references user
</span></code></pre>
<p data-nodeid="1689">在启动的时候，我们直接创建了 user 表和 user_info 表，其中 user_info 的主键是 user_id，并且通过外键关联到了 user 表的 ID 字段，那么我们同时看一下 inser 的 sql，也发生了变化。</p>
<pre class="lang-java" data-nodeid="1690"><code data-language="java">Hibernate: <span class="hljs-function">insert into <span class="hljs-title">user</span> <span class="hljs-params">(address, email, name, sex, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?, ?, ?)</span>
Hibernate: insert into <span class="hljs-title">user_info</span> <span class="hljs-params">(ages, telephone, user_id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?)</span>
</span></code></pre>
<p data-nodeid="1691">上面就是我们讲的实战场景一，主键和外键都是同一个字段。接下来我们再说一个场景，就是在查 user_info 的时候，我们只想知道 user_id 的值就行了，不需要查 user 的其他信息，具体我们应该怎么做呢？</p>
<h4 data-nodeid="1692">@OneToOne 延迟加载，我们只需要 ID 值</h4>
<p data-nodeid="1693">在 @OneToOne 延迟加载的情况下，我们假设只想查下 user_id，而不想查看 user 表其他的信息，因为当前用不到，可以有以下几种做法。</p>
<p data-nodeid="1694">第一种做法：还是 User 实体不变，我们改一下 UserInfo 对象，如下所示：</p>
<pre class="lang-java" data-nodeid="1695"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "user")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> Integer ages;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@MapsId</span>
   <span class="hljs-meta">@OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true,fetch = FetchType.LAZY)</span>
   <span class="hljs-keyword">private</span> User user;
}
</code></pre>
<p data-nodeid="1696">从上面这段代码中，可以看到做的更改如下：</p>
<ul data-nodeid="1697">
<li data-nodeid="1698">
<p data-nodeid="1699">id 字段我们先用原来的</p>
</li>
<li data-nodeid="1700">
<p data-nodeid="1701">@OneToOne 上面我们添加 @MapsId 注解</p>
</li>
<li data-nodeid="1702">
<p data-nodeid="1703">@OneToOne 里面的 fetch = FetchType.LAZY 设置延迟加载</p>
</li>
</ul>
<p data-nodeid="1704">接着，我们改造一下测试类，完整代码如下：</p>
<pre class="lang-java" data-nodeid="1705"><code data-language="java"><span class="hljs-meta">@DataJpaTest</span>
<span class="hljs-meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoRepositoryTest</span> </span>{
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserInfoRepository userInfoRepository;
    <span class="hljs-meta">@BeforeAll</span>
    <span class="hljs-meta">@Rollback(false)</span>
    <span class="hljs-meta">@Transactional</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
        User user = User.builder().name(<span class="hljs-string">"jackxx"</span>).email(<span class="hljs-string">"123456@126.com"</span>).build();
        UserInfo userInfo = UserInfo.builder().ages(<span class="hljs-number">12</span>).user(user).telephone(<span class="hljs-string">"12345678"</span>).build();
        userInfoRepository.saveAndFlush(userInfo);
    }
    <span class="hljs-comment">/**
     * 测试用User关联关系操作
     *
     * <span class="hljs-doctag">@throws</span> JsonProcessingException
     */</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-meta">@Rollback(false)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserRelationships</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
        UserInfo userInfo1 = userInfoRepository.getOne(<span class="hljs-number">1L</span>);
        System.out.println(userInfo1);
        System.out.println(userInfo1.getUser().getId());
}
</code></pre>
<p data-nodeid="1706">然后，我们跑一下测试用例，看看测试结果。</p>
<pre class="lang-java" data-nodeid="1707"><code data-language="java">Hibernate: <span class="hljs-function">insert into <span class="hljs-title">user</span> <span class="hljs-params">(address, email, name, sex, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?, ?, ?)</span>
Hibernate: insert into <span class="hljs-title">user</span> <span class="hljs-params">(address, email, name, sex, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?, ?, ?)</span>
两条inser照旧，而只有一个select
Hibernate: select userinfo0_.user_id as user_id3_6_0_, userinfo0_.ages as ages1_6_0_, userinfo0_.telephone as telephon2_6_0_ from user_info userinfo0_ where userinfo0_.user_id</span>=?
</code></pre>
<p data-nodeid="1708">最后你会发现，打印的结果符合预期。</p>
<pre class="lang-java" data-nodeid="1709"><code data-language="java">UserInfo(id=<span class="hljs-number">1</span>, ages=<span class="hljs-number">12</span>, telephone=<span class="hljs-number">12345678</span>)
<span class="hljs-number">1</span>
</code></pre>
<p data-nodeid="1710">接下来介绍第二种做法，这种做法很简单，只要在 UserInfo 对象里面直接去掉 @OneToOne 关联关系，新增下面的字段即可。</p>
<pre class="lang-java" data-nodeid="1711"><code data-language="java"><span class="hljs-meta">@Column(name = "user_id")</span>
<span class="hljs-keyword">private</span> Long userId;
</code></pre>
<p data-nodeid="1712">第三做法是利用 Hibernate，它给我们提供了一种字节码增强技术，通过编译器改变 class 解决了延迟加载问题。这种方式有点复杂，需要在编译器引入 hibernateEnhance 的相关 jar 包，以及编译器需要改变 class 文件并添加 lazy 代理来解决延迟加载。我不太推荐这种方式，因为太复杂，你知道有这回事就行了。</p>
<p data-nodeid="1713">以上我们掌握了这么多用法，那么最佳实践是什么？双向关联更好还是单向关联更好？根据最近几年的应用，我总结出了一些最佳实践，我们来看一下。</p>
<h4 data-nodeid="1714">@OneToOne 的最佳实践是什么？</h4>
<p data-nodeid="1715"><strong data-nodeid="1918">第一，我要说一种 Java 面向对象的设计原则：开闭原则。</strong></p>
<p data-nodeid="1716">即对扩展开放，对修改关闭。如果我们一直使用双向关联，两个实体的对象耦合太严重了。想象一下，随着业务的发展，User 对象可能是原始对象，围绕着 User 可能会扩展出各种关联对象。难道 User 里面每次都要修改，去添加双向关联关系吗？肯定不是，否则时间长了，对象与对象之间的关联关系就是一团乱麻。</p>
<p data-nodeid="1717">所以，我们尽量、甚至不要用双向关联，如果非要用关联关系的话，只用单向关联就够了。双向关联正是 JPA 的强大之处，但同时也是问题最多，最被人诟病之处。所以我们要用它的优点，而不是学会了就一定要使用。</p>
<p data-nodeid="1718"><strong data-nodeid="1924">第二，我想说 CascadeType 很强大，但是我也建议保持默认。</strong></p>
<p data-nodeid="1719">即没有级联更新动作，没有级联删除动作。还有 orphanRemoval 也要尽量保持默认 false，不做级联删除。因为这两个功能很强大，但是我个人觉得这违背了面向对象设计原则里面的“职责单一原则”，除非你非常非常熟悉，否则你在用的时候会时常感到惊讶——数据什么时间被更新了？数据被谁删除了？遇到这种问题查起来非常麻烦，因为是框架处理，有的时候并非预期的效果。</p>
<p data-nodeid="1720">一旦生产数据被莫名更新或者删除，那是一件非常糟糕的事情。因为这些级联操作会使你的方法名字没办法命名，而且它不是跟着业务逻辑变化的，而是跟着实体变化的，这就会使方法和对象的职责不单一。</p>
<p data-nodeid="1721"><strong data-nodeid="1930">第三，我想告诉你，所有用到关联关系的地方，能用 Lazy 的绝对不要用 EAGER，否则会有 SQL 性能问题，会出现不是预期的 SQL。</strong></p>
<p data-nodeid="1722">以上三点是我总结的避坑指南，有经验的同学这时候会有个疑问：外键约束不是不推荐使用的吗？如果我的外键字段名不是约定的怎么办？别着急，我们再看一下 @JoinColumn 注解和 @JoinColumns 注解。</p>
<h3 data-nodeid="1723">@JoinCloumns &amp; JoinColumn</h3>
<p data-nodeid="1724">这两个注解是集合关系，他们可以同时使用，@JoinColumn 表示单字段，@JoinCloumns 表示多个 @JoinColumn，我们来一一看一下。</p>
<p data-nodeid="1725">我们还是先直接看一下 @JoinColumn 源码，了解下这一注解都有哪些配置项。</p>
<pre class="lang-java" data-nodeid="1726"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> JoinColumn {
    <span class="hljs-comment">//关键的字段名,默认注解上的字段名，在@OneToOne代表本表的外键字段名字；</span>
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//与name相反关联对象的字段，默认主键字段</span>
    <span class="hljs-function">String <span class="hljs-title">referencedColumnName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//外键字段是否唯一</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;
    <span class="hljs-comment">//外键字段是否允许为空</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">nullable</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;
    <span class="hljs-comment">//是否跟随一起新增</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">insertable</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;
    <span class="hljs-comment">//是否跟随一起更新</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">updatable</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;
    <span class="hljs-comment">//JPA2.1新增，外键策略</span>
    <span class="hljs-function">ForeignKey <span class="hljs-title">foreignKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @<span class="hljs-title">ForeignKey</span><span class="hljs-params">(PROVIDER_DEFAULT)</span></span>;
}
</code></pre>
<p data-nodeid="1727">其次，我们看一下 @ForeignKey(PROVIDER_DEFAULT) 里面枚举值有几个。</p>
<pre class="lang-java" data-nodeid="1728"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ConstraintMode</span> </span>{
    <span class="hljs-comment">//创建外键约束</span>
   CONSTRAINT,
    <span class="hljs-comment">//不创建外键约束</span>
   NO_CONSTRAINT,
   <span class="hljs-comment">//采用默认行为</span>
   PROVIDER_DEFAULT
}
</code></pre>
<p data-nodeid="1729">然后，我们看看这个注解的语法，就可以解答我们上面的两个问题。修改一下 UserInfo，如下所示：</p>
<pre class="lang-java" data-nodeid="1730"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span></span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> Integer ages;
   <span class="hljs-keyword">private</span> String telephone;
   <span class="hljs-meta">@OneToOne(cascade = {CascadeType.PERSIST},orphanRemoval = true,fetch = FetchType.LAZY)</span>
   <span class="hljs-meta">@JoinColumn(foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT),name = "my_user_id")</span>
   <span class="hljs-keyword">private</span> User user;
...其他不变}
</code></pre>
<p data-nodeid="1731">可以看到，我们在其中指定了字段的名字：my_user_id，并且指定 NO_CONSTRAINT 不生成外键。而测试用例不变，我们看下运行结果。</p>
<pre class="lang-java" data-nodeid="1732"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, address varchar(<span class="hljs-number">255</span>)</span>, email <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user_info</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, ages integer, telephone varchar(<span class="hljs-number">255</span>)</span>, my_user_id bigint, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
</span></code></pre>
<p data-nodeid="1733">这时我们看到 user_info 表里面新增了一个字段 my_user_id，insert 的时候也能正确 inser my_user_id 的值等于 user.id。</p>
<pre class="lang-java" data-nodeid="1734"><code data-language="java">Hibernate: <span class="hljs-function">insert into <span class="hljs-title">user_info</span> <span class="hljs-params">(ages, telephone, my_user_id, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?, ?)</span>
</span></code></pre>
<p data-nodeid="1735">而 @JoinColumns 是 JoinColumns 的复数形式，就是通过两个字段进行的外键关联，这个不常用，我们看一个 demo 了解一下就好。</p>
<pre class="lang-java" data-nodeid="1736"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompanyOffice</span> </span>{
   <span class="hljs-meta">@ManyToOne(fetch = FetchType.LAZY)</span>
   <span class="hljs-meta">@JoinColumns({
         @JoinColumn(name="ADDR_ID", referencedColumnName="ID"),
         @JoinColumn(name="ADDR_ZIP", referencedColumnName="ZIP")
   })</span>
   <span class="hljs-keyword">private</span> Address address;
}
</code></pre>
<p data-nodeid="1737">上面的实例中，CompanyOffice 通过 ADDR_ID 和 ADDR_ZIP 两个字段对应一条 address 信息，解释了一下@JoinColumns的用法。</p>
<p data-nodeid="1738">如果你了解了 @OneToOne 的详细用法，后面要讲的几个注解就很好理解了，因为他们有点类似，那么我们接下来看看 @ManyToOne 和 @OneToMany 的用法。</p>
<h3 data-nodeid="1739">@ManyToOne&amp; @OneToMany</h3>
<p data-nodeid="1740">@ManyToOne 代表多对一的关联关系，而 @OneToMany 代表一对多，一般两个成对使用表示双向关联关系。而 JPA 协议中也是明确规定：维护关联关系的是拥有外键的一方，而另一方必须配置 mappedBy。看下面的代码。</p>
<pre class="lang-java" data-nodeid="1741"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ManyToOne {
    <span class="hljs-function">Class <span class="hljs-title">targetEntity</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class</span>;
    CascadeType[] cascade() <span class="hljs-keyword">default</span> {};
    <span class="hljs-function">FetchType <span class="hljs-title">fetch</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> EAGER</span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">optional</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;
}
 <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OneToMany {
    <span class="hljs-function">Class <span class="hljs-title">targetEntity</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class</span>;
 <span class="hljs-comment">//cascade 级联操作策略：(CascadeType.PERSIST、CascadeType.REMOVE、CascadeType.REFRESH、CascadeType.MERGE、CascadeType.ALL)</span>
如果不填，默认关系表不会产生任何影响。
    CascadeType[] cascade() <span class="hljs-keyword">default</span> {};
<span class="hljs-comment">//数据获取方式EAGER(立即加载)/LAZY(延迟加载)</span>
    <span class="hljs-function">FetchType <span class="hljs-title">fetch</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LAZY</span>;
    <span class="hljs-comment">//关系被谁维护，单项的。注意：只有关系维护方才能操作两者的关系。</span>
    <span class="hljs-function">String <span class="hljs-title">mappedBy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
<span class="hljs-comment">//是否级联删除。和CascadeType.REMOVE的效果一样。两种配置了一个就会自动级联删除</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">orphanRemoval</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;
}
</code></pre>
<p data-nodeid="1742">我们看到上面的字段和 @OneToOne 里面的基本一样，用法是一样的，不过需要注意以下几点：</p>
<ol data-nodeid="1743">
<li data-nodeid="1744">
<p data-nodeid="1745">@ManyToOne 一定是维护外键关系的一方，所以没有 mappedBy 字段；</p>
</li>
<li data-nodeid="1746">
<p data-nodeid="1747">@ManyToOne 删除的时候一定不能把 One 的一方删除了，所以也没有 orphanRemoval 的选项；</p>
</li>
<li data-nodeid="1748">
<p data-nodeid="1749">@ManyToOne 的 Lazy 效果和 @OneToOne 的一样，所以和上面的用法基本一致；</p>
</li>
<li data-nodeid="1750">
<p data-nodeid="1751">@OneToMany 的 Lazy 是有效果的。</p>
</li>
</ol>
<p data-nodeid="1752">我们看个例子，假设 User 有多个地址 Address，我们看看实体应该如何建立。</p>
<pre class="lang-java" data-nodeid="1753"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-keyword">private</span> String email;
   <span class="hljs-keyword">private</span> String sex;
   <span class="hljs-meta">@OneToMany(mappedBy = "user",fetch = FetchType.LAZY)</span>
   <span class="hljs-keyword">private</span> List&lt;UserAddress&gt; address;
}
</code></pre>
<p data-nodeid="1754">上述代码我们可以看到，@OneToMany 双向关联并且采用 LAZY 的机制；这时我们新建一个 UserAddress 实体维护关联关系如下：</p>
<pre class="lang-java" data-nodeid="1755"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "user")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddress</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String address;
   <span class="hljs-meta">@ManyToOne(cascade = CascadeType.ALL)</span>
   <span class="hljs-keyword">private</span> User user;
}
</code></pre>
<p data-nodeid="1756">再新建一个测试用例，完整代码如下：</p>
<pre class="lang-java" data-nodeid="1757"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;
<span class="hljs-keyword">import</span> org.assertj.core.util.Lists;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeAll;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.TestInstance;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
<span class="hljs-keyword">import</span> org.springframework.test.annotation.Rollback;
<span class="hljs-keyword">import</span> javax.transaction.Transactional;
<span class="hljs-meta">@DataJpaTest</span>
<span class="hljs-meta">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAddressRepositoryTest</span> </span>{
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> UserAddressRepository userAddressRepository;
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> UserRepository userRepository;
   <span class="hljs-comment">/**
    * 负责添加数据
    */</span>
   <span class="hljs-meta">@BeforeAll</span>
   <span class="hljs-meta">@Rollback(false)</span>
   <span class="hljs-meta">@Transactional</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
      User user = User.builder().name(<span class="hljs-string">"jackxx"</span>).email(<span class="hljs-string">"123456@126.com"</span>).build();
      UserAddress userAddress = UserAddress.builder().address(<span class="hljs-string">"shanghai1"</span>).user(user).build();
      UserAddress userAddress2 = UserAddress.builder().address(<span class="hljs-string">"shanghai2"</span>).user(user).build();
      userAddressRepository.saveAll(Lists.newArrayList(userAddress,userAddress2));
   }
   <span class="hljs-comment">/**
    * 测试用User关联关系操作
    * <span class="hljs-doctag">@throws</span> JsonProcessingException
    */</span>
   <span class="hljs-meta">@Test</span>
   <span class="hljs-meta">@Rollback(false)</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUserRelationships</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>{
      User user = userRepository.getOne(<span class="hljs-number">2L</span>);
      System.out.println(user.getName());
      System.out.println(user.getAddress());
   }
}
</code></pre>
<p data-nodeid="1758">然后，我们看一下运行结果。</p>
<pre class="lang-java" data-nodeid="1759"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, email varchar(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user_address</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, address varchar(<span class="hljs-number">255</span>)</span>, user_id bigint, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: alter table user_address add constraint FKk2ox3w9jm7yd6v1m5f68xibry foreign <span class="hljs-title">key</span> <span class="hljs-params">(user_id)</span> references user
</span></code></pre>
<p data-nodeid="1760">接着我们创建两张表，并且创建外键。</p>
<pre class="lang-java" data-nodeid="1761"><code data-language="java">Hibernate: <span class="hljs-function">insert into <span class="hljs-title">user</span> <span class="hljs-params">(email, name, sex, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?, ?)</span>
Hibernate: insert into <span class="hljs-title">user_address</span> <span class="hljs-params">(address, user_id, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?)</span>
Hibernate: insert into <span class="hljs-title">user_address</span> <span class="hljs-params">(address, user_id, id)</span> <span class="hljs-title">values</span> <span class="hljs-params">(?, ?, ?)</span>
</span></code></pre>
<p data-nodeid="1762">这时我们得到了符合预期的三条 inser 语句，可以看到 lazy 起作用了，说明了只有用到 address 的时候才会取重新加载 SQL。</p>
<p data-nodeid="1763"><img alt="1.png" src="https://s0.lgstatic.com/i/image/M00/59/96/Ciqc1F9xt6qADqg2AAHww7pd2q4555.png" data-nodeid="1983"></p>
<p data-nodeid="1764">综上，@ManyToOne 的 lazy 机制和用法，与 @OneToOne 的一样，我们就不过多介绍了。而 @ManyToOne 和 @OneToMany 的最佳实践，与 @OneToOne 的完全一样，也是尽量避免双向关联，一切级联更新和 orphanRemoval 都保持默认规则，并且 fetch 采用 lazy 延迟加载。</p>
<p data-nodeid="1765">以上就是关于 @ManyToOne 和 @OneToMan 的讲解，实际开发过程中可以详细体会一下上面老师讲的用法。接下来我们介绍一下 @ManyToMany 多对多关联关系的用法。</p>
<h3 data-nodeid="1766">@ManyToMany</h3>
<p data-nodeid="1767">@ManyToMany 代表多对多的关联关系，这种关联关系任何一方都可以维护关联关系。我们还是先看个例子感受一下。</p>
<p data-nodeid="1768">我们假设 user 表和 room 表是多对多的关系，看看两个实体怎么写。</p>
<pre class="lang-java" data-nodeid="1769"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.io.Serializable;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span></span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String name;
   <span class="hljs-meta">@ManyToMany(mappedBy = "users")</span>
   <span class="hljs-keyword">private</span> List&lt;Room&gt; rooms;
}
</code></pre>
<p data-nodeid="1770">接着，我们让 Room 维护关联关系。</p>
<pre class="lang-java" data-nodeid="1771"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "users")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String title;
   <span class="hljs-meta">@ManyToMany</span>
   <span class="hljs-keyword">private</span> List&lt;User&gt; users;
}
</code></pre>
<p data-nodeid="1772">然后，我们跑一下测试用例，可以看到如下结果：</p>
<pre class="lang-java" data-nodeid="1773"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">room</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, title varchar(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">room_users</span> <span class="hljs-params">(rooms_id bigint not <span class="hljs-keyword">null</span>, users_id bigint not <span class="hljs-keyword">null</span>)</span>
Hibernate: create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, email varchar(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: alter table room_users add constraint FKld9phr4qt71ve3gnen43qxxb8 foreign <span class="hljs-title">key</span> <span class="hljs-params">(users_id)</span> references user
Hibernate: alter table room_users add constraint FKtjvf84yquud59juxileusukvk foreign <span class="hljs-title">key</span> <span class="hljs-params">(rooms_id)</span> references room
</span></code></pre>
<p data-nodeid="1774">从结果上我们看到 JPA 帮我们创建的三张表中，room_users 表维护了 user 和 room 的多对多关联关系。其实这个情况还告诉我们一个道理：当用到 @ManyToMany 的时候一定是三张表，不要想着建两张表，两张表肯定是违背表的设计原则的。</p>
<p data-nodeid="1775">那么我们看下 @ManyToMany 的语法。</p>
<pre class="lang-java" data-nodeid="1776"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ManyToMany {
    <span class="hljs-function">Class <span class="hljs-title">targetEntity</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span>.class</span>;
    CascadeType[] cascade() <span class="hljs-keyword">default</span> {};
    <span class="hljs-function">FetchType <span class="hljs-title">fetch</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LAZY</span>;
    <span class="hljs-function">String <span class="hljs-title">mappedBy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
}
</code></pre>
<p data-nodeid="1777">源码里面字段就这么多，基本和上面雷同，我就不多介绍了。这个时候有的同学可能会问，我们怎么去掉外键索引？怎么改中间表的表名？怎么指定外键字段的名字呢？我们继续引入另外一个注解——@JoinTable。</p>
<p data-nodeid="1778">我先看一下例子，修改一下 Room 里面的内容。</p>
<pre class="lang-java" data-nodeid="1779"><code data-language="java"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@ToString(exclude = "users")</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> String title;
   <span class="hljs-meta">@ManyToMany</span>
   <span class="hljs-meta">@JoinTable(name = "user_room_ref",
         joinColumns = @JoinColumn(name = "room_id_x"),
         inverseJoinColumns = @JoinColumn(name = "user_id_x")
   )</span>
   <span class="hljs-keyword">private</span> List&lt;User&gt; users;
}
</code></pre>
<p data-nodeid="1780">接着，我们在 Room 里面添加了 @JoinTable 注解，看一下 junit 的运行结果。</p>
<pre class="lang-java" data-nodeid="1781"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">room</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, title varchar(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, email varchar(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user_room_ref</span> <span class="hljs-params">(room_id_x bigint not <span class="hljs-keyword">null</span>, user_id_x bigint not <span class="hljs-keyword">null</span>)</span>
Hibernate: alter table user_room_ref add constraint FKoxolr1eyfiu69o45jdb6xdule foreign <span class="hljs-title">key</span> <span class="hljs-params">(user_id_x)</span> references user
Hibernate: alter table user_room_ref add constraint FK2sl9rtuxo9w130d83e19f3dd9 foreign <span class="hljs-title">key</span> <span class="hljs-params">(room_id_x)</span> references room
</span></code></pre>
<p data-nodeid="1782">到这里可以看到，我们创建了一张中间表，并且添加了两个在预想之内的外键关系。</p>
<pre class="lang-java" data-nodeid="1783"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> JoinTable {
    <span class="hljs-comment">//中间关联关系表明</span>
    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//表的catalog</span>
    <span class="hljs-function">String <span class="hljs-title">catalog</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//表的schema</span>
    <span class="hljs-function">String <span class="hljs-title">schema</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
    <span class="hljs-comment">//维护关联关系一方的外键字段的名字</span>
    JoinColumn[] joinColumns() <span class="hljs-keyword">default</span> {};
    <span class="hljs-comment">//另一方的表外键字段</span>
    JoinColumn[] inverseJoinColumns() <span class="hljs-keyword">default</span> {};
    <span class="hljs-comment">//指定维护关联关系一方的外键创建规则</span>
    <span class="hljs-function">ForeignKey <span class="hljs-title">foreignKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @<span class="hljs-title">ForeignKey</span><span class="hljs-params">(PROVIDER_DEFAULT)</span></span>;
    <span class="hljs-comment">//指定另一方的外键创建规则</span>
    <span class="hljs-function">ForeignKey <span class="hljs-title">inverseForeignKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> @Forei <span class="hljs-title">gnKey</span><span class="hljs-params">(PROVIDER_DEFAULT)</span></span>;
}
</code></pre>
<p data-nodeid="1784">那么通过上面的介绍，你知道了 @ManyToMany 的用法，然而实际开发者对 @ManyToMany 用得比较少，一般我们会用成对的 @ManyToOne 和 @OneToMany 代替，因为我们的中间表可能还有一些约定的公共字段，如 ID、update_time、create_time等其他字段。</p>
<h4 data-nodeid="1785">利用 @ManyToOne 和 @OneToMany 表达多对多的关联关系</h4>
<p data-nodeid="1786">我们修改一下上面的 Demo，来看一下通过 @ManyToOne 和 @OneToMany 如何表达多对多的关联关系。</p>
<p data-nodeid="1787">我们新建一张表 user_room_relation 来存储双方的关联关系和额外字段，实体如下：</p>
<pre class="lang-java" data-nodeid="1788"><code data-language="java"><span class="hljs-keyword">package</span> com.example.jpa.example1;
<span class="hljs-keyword">import</span> lombok.*;
<span class="hljs-keyword">import</span> javax.persistence.*;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Builder</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRoomRelation</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-keyword">private</span> Date createTime,udpateTime;
   <span class="hljs-meta">@ManyToOne</span>
   <span class="hljs-keyword">private</span> Room room;
   <span class="hljs-meta">@ManyToOne</span>
   <span class="hljs-keyword">private</span> User user;
}
</code></pre>
<p data-nodeid="1789">而 User 变化如下：</p>
<pre class="lang-java" data-nodeid="1790"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy= GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-meta">@OneToMany(mappedBy = "user")</span>
   <span class="hljs-keyword">private</span> List&lt;UserRoomRelation&gt; userRoomRelations;
....}

Room 变化如下：
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Room</span> </span>{
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.AUTO)</span>
   <span class="hljs-keyword">private</span> Long id;
   <span class="hljs-meta">@OneToMany(mappedBy = "room")</span>
   <span class="hljs-keyword">private</span> List&lt;UserRoomRelation&gt; userRoomRelations;
...}
</code></pre>
<p data-nodeid="1791">到这里我们再看一下 JUnit 运行结果。</p>
<pre class="lang-java" data-nodeid="1792"><code data-language="java">Hibernate: <span class="hljs-function">create table <span class="hljs-title">user_room_relation</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, create_time timestamp, udpate_time timestamp, room_id bigint, user_id bigint, primary key (id)</span>)
Hibernate: create table <span class="hljs-title">room</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, title varchar(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
Hibernate: create table <span class="hljs-title">user</span> <span class="hljs-params">(id bigint not <span class="hljs-keyword">null</span>, email varchar(<span class="hljs-number">255</span>)</span>, name <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, sex <span class="hljs-title">varchar</span><span class="hljs-params">(<span class="hljs-number">255</span>)</span>, primary <span class="hljs-title">key</span> <span class="hljs-params">(id)</span>)
</span></code></pre>
<p data-nodeid="1793">可以看到，上面我们依然创建了三张表，唯一不同的是 user_room_relation 里面多了很多字段，而外键索引也是如约创建，如下所示：</p>
<pre class="lang-java" data-nodeid="1794"><code data-language="java">Hibernate: <span class="hljs-function">alter table user_room_relation add constraint FKaesy2rg60vtaxxv73urprbuwb foreign <span class="hljs-title">key</span> <span class="hljs-params">(room_id)</span> references room
Hibernate: alter table user_room_relation add constraint FK45gha85x63026r8q8hs03uhwm foreign <span class="hljs-title">key</span> <span class="hljs-params">(user_id)</span> references user
</span></code></pre>
<p data-nodeid="1795">好了，跑一下测试是不是就很容易理解了。下面我总结了关于 @ManyToMany 的最佳实践和你分享。</p>
<h4 data-nodeid="1796">@ManyToMany 的最佳实践</h4>
<ol data-nodeid="1797">
<li data-nodeid="1798">
<p data-nodeid="1799">上面我们介绍的 @OneToMany 的最佳实践同样适用，我为了说明方便，采用的是双向关联，而实际生产一般是在中间表对象里面做单向关联，这样会让实体之间的关联关系简单很多。</p>
</li>
<li data-nodeid="1800">
<p data-nodeid="1801">与 @OneToMany 一样的道理，不要用级联删除和 orphanRemoval=true。</p>
</li>
<li data-nodeid="1802">
<p data-nodeid="1803">FetchType 采用默认方式：fetch = FetchType.LAZY 的方式。</p>
</li>
</ol>
<h3 data-nodeid="1804">总结</h3>
<p data-nodeid="1805">通过本课时内容，我们基本上能理解 @OneToOne、@ManyToOne、@OneToMany、@ManyToMany 分别表示的是什么关联关系，各自解决的应用场景是什么，以及生产中我们推荐的最佳实践是什么。我们所说的“如何才算正确使用”，重点是要将原理和解决的场景理解透彻，参考最佳实践，做出符合自己业务场景的最好办法。</p>
<p data-nodeid="1806">其实细心的同学还会看出我分享的学习思路，即看协议规定、看源码，然后实际动手写个最小环境进行测试，一看就明白是怎么回事了。在这节课中还涉及了 N+1SQL 的问题，我们在第 25 课时将会详细介绍。</p>
<p data-nodeid="1807">此处给你留一道作业题：仔细去查一下 @OrderColumn 和 @OrderBy 这两个注解是干什么用的，他们的最佳实践是什么？</p>
<p data-nodeid="1808">点击下方链接查看源码（不定时更新）<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="2030">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>

---

### 精选评论

##### **龙：
> 老师你好，我在用ManyToMany的时候貌似`ConstraintMode.NO_CONSTRAINT没有起作用

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 打印一下SQL看一下执行的sql对不对

##### **酱：
> 对于井蛙提到的会出现循环应用的问题，也可以通过不使用lombok来避免

##### **军：
> 看源码还是挺管用的，但是不太会看

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 多跟着老师学就好啦

##### **龙：
> 老师，在manyTomany的情况下不可以去掉外键吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 可以呀，所有的关联关系外键都可以去掉

##### **龙：
> 老师为什么`ConstraintMode.NO_CONSTRAINT`参数不生效呀，指定了还是会生成外键

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; debug一下，仔细检查代码

##### *雨：
> 在User中设置：@OneToOne(mappedBy = "user")private UserInfo userInfo;在UserInfo中设置@OneToOne(cascade = {CascadeType.PERSIST}, orphanRemoval = true, fetch = FetchType.LAZY)private User user;当查找 User 或者 UserInfo 的时候，会出现循环引用的情况，导致栈溢出可以在UserInfo中这样配置@OneToOne(cascade = {CascadeType.PERSIST}, orphanRemoval = true, fetch = FetchType.LAZY)@JsonBackReferenceprivate User user;可以避免循环引用

##### *谨：
> 你好老师,我在测试ManyToMany时无法去掉外键,能请教下如何避免么,版本2.4.2

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; workspace清理一下，应该是没问题的，还有就是看一下默认规则是什么样的？覆盖默认规则

##### **学：
> 自己弄明白了，谢谢老师的课程

