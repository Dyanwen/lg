<p data-nodeid="1669" class="">你好，欢迎继续学习 Spring Data JPA 原理与实战。上一课时，我们讲解了数据源的基本原理和工作方式，你知道了数据源是创建数据连接的入口，数据源里面获得连接的时候也采用了连接池。那么这一讲我们来看下事务在 JPA 和 Spring 里面的详细配置和原理。</p>
<h3 data-nodeid="1670">事务的基本原理</h3>
<p data-nodeid="1671">在学习 Spring 的事务之前，你首先要了解数据库的事务原理，我们以 MySQL 5.7 为例，讲解一下数据库事务的基础知识。</p>
<p data-nodeid="2225" class="">我们都知道 当 MySQL 使用 InnoDB 数据库引擎的时候，数据库是对事务有支持的。而事务最主要的作用是保证数据 ACID 的特性，即原子性（<strong data-nodeid="2243">A</strong>tomicity）、一致性（<strong data-nodeid="2244">C</strong>onsistency）、隔离性（<strong data-nodeid="2245">I</strong>solation）、持久性（<strong data-nodeid="2246">D</strong>urability），下面来一一解释。</p>

<p data-nodeid="3359" class=""><strong data-nodeid="3371">原子性：</strong> 是指一个事务（Transaction）中的所有操作，要么全部完成，要么全部回滚，而不会有中间某个数据单独更新的操作。事务在执行过程中一旦发生错误，会被回滚（Rollback）到此次事务开始之前的状态，就像这个事务从来没有执行过一样。</p>
<p data-nodeid="8983" class=""><strong data-nodeid="8988">一致性：</strong> 是指事务操作开始之前，和操作异常回滚以后，数据库的完整性没有被破坏。数据库事务 Commit 之后，数据也是按照我们预期正确执行的。即要通过事务保证数据的正确性。</p>

<p data-nodeid="6755" class=""><strong data-nodeid="6763">持久性：</strong> 是指事务处理结束后，对数据的修改进行了持久化的永久保存，即便系统故障也不会丢失，其实就是保存到硬盘。</p>
<p data-nodeid="14523" class=""><strong data-nodeid="14528">隔离性：</strong> 是指数据库允许多个连接，同时并发多个事务，又对同一个数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时，由于交叉执行而导致数据不一致的现象。而 MySQL 里面就是我们经常说的事务的四种隔离级别，即读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。</p>











<p data-nodeid="1682">由于隔离级别是事务知识点中最基础的部分，我们就简单介绍一下四种隔离级别。但是它特别重要，你要好好掌握。</p>
<h4 data-nodeid="1683">四种 MySQL 事务的隔离级别</h4>
<p data-nodeid="1684"><strong data-nodeid="1926">Read Uncommitted（读取未提交内容）</strong>：此隔离级别，表示所有正在进行的事务都可以看到其他未提交事务的执行结果。不同的事务之间读取到其他事务中未提交的数据，通常这种情况也被称之为脏读（Dirty Read），会造成数据的逻辑处理错误，也就是我们在多线程里面经常说的数据不安全了。在业务开发中，几乎很少见到使用的，因为它的性能也不比其他级别要好多少。</p>
<p data-nodeid="1685"><strong data-nodeid="1931">Read Committed（读取提交内容）：</strong> 此隔离级别是指，在一个事务相同的两次查询可能产生的结果会不一样，也就是第二次查询能读取到其他事务已经提交的最新数据。也就是我们常说的不可重复读（Nonrepeatable Read）的事务隔离级别。因为同一事务的其他实例在该实例处理期间，可能会对其他事务进行新的 commit，所以在同一个事务中的同一 select 上，多次执行可能返回不同结果。这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的隔离级别）。</p>
<p data-nodeid="1686"><strong data-nodeid="1940">Repeatable Read（可重读）：</strong> 这是 MySQL 的默认事务隔离级别，它确保同一个事务多次查询相同的数据，能读到相同的数据。即使多个事务的修改已经 commit，本事务如果没有结束，永远读到的是相同数据，要注意它与<strong data-nodeid="1941">Read Committed 的隔离级别的区别，是正好相反的</strong>。这会导致另一个棘手的问题：幻读 （Phantom Read），即读到的数据可能不是最新的。这个是最常见的，我们举个例子来说明。</p>
<p data-nodeid="1687"><strong data-nodeid="1945">第一步：用工具打开一个数据库的 DB 连接，如图所示。</strong></p>
<p data-nodeid="1688"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNb6AaokCAABai7wNSic586.png" alt="Drawing 0.png" data-nodeid="1948"></p>
<p data-nodeid="1689">查看一下数据库的事务隔离级别。</p>
<p data-nodeid="1690"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNcWACz55AAAXUwrH98M528.png" alt="Drawing 1.png" data-nodeid="1952"></p>
<p data-nodeid="15631" class="">然后开启一个事务，查看一下 user_info 的数据，我们在 user_info 表里面插入了三条数据，如下图所示。</p>

<p data-nodeid="1692"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNc2AScnZAACUKRe0XVg992.png" alt="Drawing 2.png" data-nodeid="1960"></p>
<p data-nodeid="22280" class=""><strong data-nodeid="22284">第二步：我们打开另外一个相同数据库的 DB 连接，删除一条数据，SQL 如下所示。</strong></p>






<p data-nodeid="1694"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNdOAK6XEAABWb-OgKmE001.png" alt="Drawing 3.png" data-nodeid="1967"></p>
<p data-nodeid="1695">当删除执行成功之后，我们可以开启第三个连接，看一下数据库里面确实少了一条 ID=1 的数据。那么这个时候我们再返回第一个连接，第二次执行 select * from user_info，如下图所示，查到的还是三条数据。这就是我们经常说的可重复读。</p>
<p data-nodeid="1696"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNdyAPJhDAACyY8j4U8k591.png" alt="Drawing 4.png" data-nodeid="1975"></p>
<p data-nodeid="1697"><strong data-nodeid="1980">Serializable（可串行化）</strong>：这是最高的隔离级别，它保证了每个事务是串行执行的，即强制事务排序，所有事务之间不可能产生冲突，从而解决幻读问题。如果配置在这个级别的事务，处理时间比较长，并发比较大的时候，就会导致大量的 db 连接超时现象和锁竞争，从而降低了数据处理的吞吐量。也就是这个性能比较低，所以除了某些财务系统之外，用的人不是特别多。</p>
<p data-nodeid="1698">数据库的隔离级别我们了解完了，并不复杂，这四种类型中，你能清楚地知道<strong data-nodeid="1986">Read Uncommitted 和 Read Committed</strong>就可以了，一般这两个用得是最多的。</p>
<p data-nodeid="1699">下面看一下数据的事务和连接是什么关系呢？</p>
<h4 data-nodeid="1700">MySQL 事务与连接的关系</h4>
<p data-nodeid="1701">我们要搞清楚事务和连接池的关系，必须要先知道二者存在的前提条件。</p>
<ol data-nodeid="1702">
<li data-nodeid="1703">
<p data-nodeid="1704">事务必须在同一个连接里面的，离开连接没有事务可言；</p>
</li>
<li data-nodeid="1705">
<p data-nodeid="1706">MySQL 数据库默认 autocommit=1，即每一条 SQL 执行完自动提交事务；</p>
</li>
<li data-nodeid="1707">
<p data-nodeid="1708">数据库里面的每一条 SQL 执行的时候必须有事务环境；</p>
</li>
<li data-nodeid="1709">
<p data-nodeid="1710">MySQL 创建连接的时候默认开启事务，关闭连接的时候如果存在事务没有 commit 的情况，则自动执行 rollback 操作；</p>
</li>
<li data-nodeid="1711">
<p data-nodeid="1712">不同的 connect 之间的事务是相互隔离的。</p>
</li>
</ol>
<p data-nodeid="1713">知道了这些条件，我们就可以继续探索二者的关系了。在 connection 当中，操作事务的方式只有两种。</p>
<p data-nodeid="1714"><strong data-nodeid="1999">MySQL 事务的两种操作方式</strong></p>
<p data-nodeid="1715">第一种：用 BEGIN、ROLLBACK、COMMIT 来实现。</p>
<ul data-nodeid="1716">
<li data-nodeid="1717">
<p data-nodeid="1718"><strong data-nodeid="2005">BEGIN</strong>开始一个事务</p>
</li>
<li data-nodeid="1719">
<p data-nodeid="1720"><strong data-nodeid="2010">ROLLBACK</strong>事务回滚</p>
</li>
<li data-nodeid="1721">
<p data-nodeid="1722"><strong data-nodeid="2015">COMMIT</strong>事务确认</p>
</li>
</ul>
<p data-nodeid="1723">第二种：直接用 SET 来改变 MySQL 的自动提交模式。</p>
<ul data-nodeid="1724">
<li data-nodeid="1725">
<p data-nodeid="1726"><strong data-nodeid="2021">SET AUTOCOMMIT=0</strong>禁止自动提交</p>
</li>
<li data-nodeid="1727">
<p data-nodeid="1728"><strong data-nodeid="2026">SET AUTOCOMMIT=1</strong>开启自动提交</p>
</li>
</ul>
<p data-nodeid="1729"><strong data-nodeid="2030">MySQL 数据库的最大连接数是什么？</strong></p>
<p data-nodeid="1730">而任何数据库的连接数都是有限的，受内存和 CPU 限制，你可以通过</p>
<p data-nodeid="1731">show variables like 'max_connections' 查看此数据库的最大连接数、通过 show global status like 'Max_used_connections' 查看正在使用的连接数，还可以通过 set global max_connections=1500 来设置数据库的最大连接数。</p>
<p data-nodeid="1732">除此之外，你可以在观察数据库的连接数的同时，通过观察 CPU 和内存的使用，来判断你自己的数据库中 server 的连接数最佳大小是多少。而既然是连接，那么肯定会有超时时间，默认是 8 小时。</p>
<p data-nodeid="1733">这里我只是列举了 MySQL 数据库的事务处理原理，你可以用相同的思考方式看一下你在用的数据源的事务是什么机制的。</p>
<p data-nodeid="1734">那么学习完了数据库事务的基础知识，我们再看一下 Spring 中事务的用法和配置是什么样的。</p>
<h3 data-nodeid="1735">Spring 里面事务的配置方法</h3>
<p data-nodeid="23387" class="">由于我们使用的是 Spring Boot，所以会通过 TransactionAutoConfiguration.java 加载 @EnableTransactionManagement 注解帮我们默认开启事务，关键代码如下图所示。</p>

<p data-nodeid="1737"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNeiAbqu7AAKkFEn3-98148.png" alt="Drawing 5.png" data-nodeid="2056"></p>
<p data-nodeid="25595" class="">Spring 里面的事务有两种使用方式，常见的是直接通过 @Transaction 的方式进行配置，而我们打开 SimpleJpaRepository 源码类的话，会看到如下代码。</p>


<pre class="lang-java" data-nodeid="1739"><code data-language="java"><span class="hljs-meta">@Repository</span>
<span class="hljs-meta">@Transactional(readOnly = true)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleJpaRepository</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">JpaRepositoryImplementation</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">ID</span>&gt; </span>{
...
<span class="hljs-meta">@Transactional</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">(Iterable&lt;? extends T&gt; entities)</span> </span>{
.....
</code></pre>
<p data-nodeid="1740">我们仔细看源码的时候就会发现，默认情况下，所有 SimpleJpaRepository 里面的方法都是只读事务，而一些更新的方法都是读写事务。</p>
<p data-nodeid="1741">所以每个 Respository 的方法是都是有事务的，即使我们没有使用任何加 @Transactional 注解的方法，按照上面所讲的 MySQL 的 Transactional 开启原理，也会有数据库的事务。那么我们就来看下 @Transactional 的具体用法。</p>
<h4 data-nodeid="1742">默认 @Transactional 注解式事务</h4>
<p data-nodeid="1743">注解式事务又称显式事务，需要手动显式注解声明，那么我们看看如何使用。</p>
<p data-nodeid="26699" class="">按照惯例，我们打开 @Transactional 的源码，如下所示。</p>

<pre class="lang-java" data-nodeid="1745"><code data-language="java"><span class="hljs-meta">@Target({ElementType.METHOD, ElementType.TYPE})</span>
<span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Inherited</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional {
   <span class="hljs-meta">@AliasFor("transactionManager")</span>
   <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
   <span class="hljs-meta">@AliasFor("value")</span>
   <span class="hljs-function">String <span class="hljs-title">transactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;
   <span class="hljs-function">Propagation <span class="hljs-title">propagation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation.REQUIRED</span>;
   <span class="hljs-function">Isolation <span class="hljs-title">isolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation.DEFAULT</span>;
   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;
   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">readOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;
   Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="hljs-keyword">default</span> {};
   String[] rollbackForClassName() <span class="hljs-keyword">default</span> {};
   Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="hljs-keyword">default</span> {};
   String[] noRollbackForClassName() <span class="hljs-keyword">default</span> {};
}
</code></pre>
<p data-nodeid="1746">针对 @Transactional 注解中常用的参数，我列了一个表格方便你查看。</p>
<p data-nodeid="1747"><img src="https://s0.lgstatic.com/i/image/M00/6E/36/Ciqc1F-yC3-AP_fhAArdN5coRWQ007.png" alt="图片1.png" data-nodeid="2066"></p>
<p data-nodeid="1748">其他属性你基本上都可以知道是什么意思，下面重点说一下隔离级别和事务的传播机制。</p>
<p data-nodeid="27803" class=""><strong data-nodeid="27808">隔离级别&nbsp;Isolation isolation() default Isolation.DEFAULT</strong>：默认采用数据库的事务隔离级别。其中，Isolation 是个枚举值，基本和我们上面讲解的数据库隔离级别是一样的，如下图所示。</p>

<p data-nodeid="1750"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNiKAcZFcAABWnGlal1Q227.png" alt="Drawing 6.png" data-nodeid="2075"></p>
<p data-nodeid="34457" class=""><strong data-nodeid="34462">propagation</strong>：代表的是事务的传播机制，这个是 Spring 事务的核心业务逻辑，是 Spring 框架独有的，它和 MySQL 数据库没有一点关系。所谓事务的传播行为是指在同一线程中，在开始当前事务之前，需要判断一下当前线程中是否有另外一个事务存在，如果存在，提供了七个选项来指定当前事务的发生行为。我们可以看 org.springframework.transaction.annotation.Propagation 这类的枚举值来确定有哪些传播行为。7 个表示传播行为的枚举值如下所示。</p>






<pre class="lang-java" data-nodeid="1752"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Propagation {
	REQUIRED(<span class="hljs-number">0</span>),
	SUPPORTS(<span class="hljs-number">1</span>),
	MANDATORY(<span class="hljs-number">2</span>),
	REQUIRES_NEW(<span class="hljs-number">3</span>),
	NOT_SUPPORTED(<span class="hljs-number">4</span>),
	NEVER(<span class="hljs-number">5</span>),
	NESTED(<span class="hljs-number">6</span>);
}
</code></pre>
<ol data-nodeid="1753">
<li data-nodeid="1754">
<p data-nodeid="1755">REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这个值是默认的。</p>
</li>
<li data-nodeid="1756">
<p data-nodeid="1757">SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li data-nodeid="1758">
<p data-nodeid="1759">MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p>
</li>
<li data-nodeid="1760">
<p data-nodeid="1761">REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li data-nodeid="1762">
<p data-nodeid="1763">NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li data-nodeid="1764">
<p data-nodeid="1765">NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
<li data-nodeid="1766">
<p data-nodeid="1767">NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 REQUIRED。</p>
</li>
</ol>
<p data-nodeid="1768">设置方法：通过使用 propagation 属性设置，例如下面这行代码。</p>
<pre class="lang-java" data-nodeid="1769"><code data-language="java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span>
</code></pre>
<p data-nodeid="1770">虽然用法很简单，但是也有使用 @Transactional 不生效的时候，那么在哪些场景中是不可用的呢？</p>
<h4 data-nodeid="1771">@Transactional 的局限性</h4>
<p data-nodeid="1772">这里列举的是一个当前对象调用对象自己里面的方法不起作用的场景。</p>
<p data-nodeid="35565" class="">我们在 UserInfoServiceImpl 的 save 方法中调用了带事务的 calculate 方法，代码如下。</p>

<pre class="lang-java" data-nodeid="1774"><code data-language="java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfoServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInfoService</span> </span>{
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> UserInfoRepository userInfoRepository;
   <span class="hljs-comment">/**
    * 根据UserId产生的一些业务计算逻辑
    */</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-meta">@Transactional(transactionManager = "db2TransactionManager")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">calculate</span><span class="hljs-params">(Long userId)</span> </span>{
      UserInfo userInfo = userInfoRepository.findById(userId).get();
      userInfo.setAges(userInfo.getAges()+<span class="hljs-number">1</span>);
      <span class="hljs-comment">//.....等等一些复杂事务内的操作</span>
      userInfo.setTelephone(Instant.now().toString());
      <span class="hljs-keyword">return</span> userInfoRepository.saveAndFlush(userInfo);
   }
   <span class="hljs-comment">/**
    * 此方法调用自身对象的方法，就会发现calculate方法上面的事务是失效的
    */</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">save</span><span class="hljs-params">(Long userId)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calculate(userId);
   }
}
</code></pre>
<p data-nodeid="1775">当在 UserInfoServiceImpl 类的外部调用 save 方法的时候，此时 save 方法里面调用了自身的 calculate 方法，你就会发现 calculate 方法上面的事务是没有效果的，这个是 Spring 的代理机制的问题。那么我们应该如何解决这个问题呢？可以引入一个类 TransactionTemplate，我们看下它的用法。</p>
<h4 data-nodeid="1776">TransactionTemplate 的用法</h4>
<p data-nodeid="36669" class="">此类是通过 TransactionAutoConfiguration 加载配置进去的，如下图所示。</p>

<p data-nodeid="1778"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNjSAdRhTAAD7wR2FY0Y574.png" alt="Drawing 7.png" data-nodeid="2102"></p>
<p data-nodeid="1779">我们通过源码可以看到此类提供了一个关键 execute 方法，如下图所示。</p>
<p data-nodeid="1780"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNjqAQwCiAAFp_zAyVg4557.png" alt="Drawing 8.png" data-nodeid="2106"></p>
<p data-nodeid="37773" class="">这里面会帮我们处理事务开始、rollback、commit 的逻辑，所以我们用的时候就非常简单，把上面的方法做如下改动。</p>

<pre class="lang-java" data-nodeid="1782"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">save</span><span class="hljs-params">(Long userId)</span> </span>{
   <span class="hljs-keyword">return</span> transactionTemplate.execute(status -&gt; <span class="hljs-keyword">this</span>.calculate(userId));
}
</code></pre>
<p data-nodeid="1783">此时外部再调用我们的 save 方法的时候，calculate 就会进入事务管理里面去了。当然了，我这里举的例子很简单，你也可以通过下面代码中的方法设置隔离级别和传播机制，以及超时时间和是否只读。</p>
<pre class="lang-java" data-nodeid="1784"><code data-language="java">transactionTemplate = <span class="hljs-keyword">new</span> TransactionTemplate(transactionManager);
<span class="hljs-comment">//设置隔离级别</span>
transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);
<span class="hljs-comment">//设置传播机制</span>
transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);
<span class="hljs-comment">//设置超时时间</span>
transactionTemplate.setTimeout(<span class="hljs-number">1000</span>);
<span class="hljs-comment">//设置是否只读</span>
transactionTemplate.setReadOnly(<span class="hljs-keyword">true</span>);
</code></pre>
<p data-nodeid="1785">我们也可以根据 transactionTemplate 的实现原理，自己实现一个 TransactionHelper，一起来看一下。</p>
<h4 data-nodeid="1786">自定义 TransactionHelper</h4>
<p data-nodeid="38877" class="">第一步：新建一个 TransactionHelper 类，进行事务管理，代码如下。</p>

<pre class="lang-java" data-nodeid="1788"><code data-language="java"><span class="hljs-comment">/**
 * 利用spring进行管理
 */</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionHelper</span> </span>{
    <span class="hljs-comment">/**
     * 利用spring 的机制和jdk8的function机制实现事务
     */</span>
    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span> <span class="hljs-comment">//可以根据实际业务情况，指定明确的回滚异常</span>
    <span class="hljs-keyword">public</span> &lt;T, R&gt; <span class="hljs-function">R <span class="hljs-title">transactional</span><span class="hljs-params">(Function&lt;T, R&gt; function, T t)</span> </span>{
        <span class="hljs-keyword">return</span> function.apply(t);
    }
}
</code></pre>
<p data-nodeid="39981" class="">第二步：直接在 service 中就可以使用了，代码如下。</p>

<pre class="lang-java" data-nodeid="1790"><code data-language="java">    <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> TransactionHelper transactionHelper;==
   <span class="hljs-comment">/**
    * 调用外部的transactionHelper类，利用transactionHelper方法上面的<span class="hljs-doctag">@Transaction</span>注解使事务生效
    */</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">save</span><span class="hljs-params">(Long userId)</span> </span>{
      <span class="hljs-keyword">return</span> transactionHelper.transactional((uid)-&gt;<span class="hljs-keyword">this</span>.calculate(uid),userId);
   }
</code></pre>
<p data-nodeid="1791">上面我介绍了显式事务，都是围绕 @Transactional 的显式指定的事务，我们也可以利用 AspectJ 进行隐式的事务配置。</p>
<h4 data-nodeid="1792">隐式事务 / AspectJ 事务配置</h4>
<p data-nodeid="41085" class="">只需要在我们的项目中新增一个类 AspectjTransactionConfig 即可，代码如下。</p>

<pre class="lang-java" data-nodeid="1794"><code data-language="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AspectjTransactionConfig</span> </span>{
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String transactionExecution = <span class="hljs-string">"execution (* com.example..service.*.*(..))"</span>;<span class="hljs-comment">//指定拦截器作用的包路径</span>
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> PlatformTransactionManager transactionManager;
   <span class="hljs-meta">@Bean</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultPointcutAdvisor <span class="hljs-title">defaultPointcutAdvisor</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-comment">//指定一般要拦截哪些类</span>
      AspectJExpressionPointcut pointcut = <span class="hljs-keyword">new</span> AspectJExpressionPointcut();
      pointcut.setExpression(transactionExecution);
      <span class="hljs-comment">//配置advisor</span>
      DefaultPointcutAdvisor advisor = <span class="hljs-keyword">new</span> DefaultPointcutAdvisor();
      advisor.setPointcut(pointcut);
      <span class="hljs-comment">//根据正则表达式，指定上面的包路径里面的方法的事务策略</span>
      Properties attributes = <span class="hljs-keyword">new</span> Properties();
      attributes.setProperty(<span class="hljs-string">"get*"</span>, <span class="hljs-string">"PROPAGATION_REQUIRED,-Exception"</span>);
      attributes.setProperty(<span class="hljs-string">"add*"</span>, <span class="hljs-string">"PROPAGATION_REQUIRED,-Exception"</span>);
      attributes.setProperty(<span class="hljs-string">"save*"</span>, <span class="hljs-string">"PROPAGATION_REQUIRED,-Exception"</span>);
      attributes.setProperty(<span class="hljs-string">"update*"</span>, <span class="hljs-string">"PROPAGATION_REQUIRED,-Exception"</span>);
      attributes.setProperty(<span class="hljs-string">"delete*"</span>, <span class="hljs-string">"PROPAGATION_REQUIRED,-Exception"</span>);
      <span class="hljs-comment">//创建Interceptor</span>
      TransactionInterceptor txAdvice = <span class="hljs-keyword">new</span> TransactionInterceptor(transactionManager, attributes);
      advisor.setAdvice(txAdvice);
      <span class="hljs-keyword">return</span> advisor;
   }
}
</code></pre>
<p data-nodeid="1795">这种方式，只要符合我们上面的正则表达规则的 service 方法，就会自动添加事务了；如果我们在方法上添加 @Transactional，也可以覆盖上面的默认规则。</p>
<p data-nodeid="1796">不过这种方法近两年使用的团队越来越少了，因为注解的方式其实很方便，并且注解 @Transactional 的方式更容易让人理解，代码也更简单，你了解一下就好了。</p>
<p data-nodeid="1797">上面的方法介绍完了，那么一个方法经历的 SQL 和过程都有哪些呢？我们通过日志分析一下。</p>
<h4 data-nodeid="1798">通过日志分析配置方法的过程</h4>
<p data-nodeid="1799">大致可以分为以下几个步骤。</p>
<p data-nodeid="42189" class="">第一步，我们在数据连接中加上 logger=Slf4JLogger&amp;profileSQL=true，用来显示 MySQL 执行的 SQL 日志，如图所示。</p>

<p data-nodeid="1801"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNm2ATrnOAABc0E8c02I350.png" alt="Drawing 9.png" data-nodeid="2126"></p>
<p data-nodeid="43295" class="">第二步，打开 Spring 的事务处理日志，用来观察事务的执行过程，代码如下。</p>

<pre class="lang-java" data-nodeid="1803"><code data-language="java"># Log Transactions Details
logging.level.org.springframework.orm.jpa=DEBUG
logging.level.org.springframework.transaction=TRACE
logging.level.org.hibernate.engine.transaction.internal.TransactionImpl=DEBUG
# 监控连接的情况
logging.level.org.hibernate.resource.jdbc=trace
logging.level.com.zaxxer.hikari=DEBUG
</code></pre>
<p data-nodeid="44399" class="">第三步，我们执行一个 saveOrUpdate 的操作，详细的执行日志如下所示。</p>

<p data-nodeid="1805"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNluAfXmfAAaGouAFSxo546.png" alt="Drawing 10.png" data-nodeid="2131"></p>
<p data-nodeid="45503" class="">通过日志可以发现，我们执行一个 saveUserInfo 的动作，由于在其中配置了一个事务，所以可以看到 JpaTransactionManager 获得事务的过程，图上黄色的部分是同一个连接里面执行的 SQL 语句，其执行的整体过程如下所示。</p>

<ol data-nodeid="1807">
<li data-nodeid="1808">
<p data-nodeid="1809">get connection：从事务管理里面，获得连接就 begin 开始事务了。我们没有看到显示的 begin 的 SQL，基本上可以断定它利用了 MySQL 的 connection 初始化事务的特性。</p>
</li>
<li data-nodeid="1810">
<p data-nodeid="1811">set autocommit=0：关闭自动提交模式，这个时候必须要在程序里面 commit 或者 rollback。</p>
</li>
<li data-nodeid="1812">
<p data-nodeid="1813">select user_info：看看 user_info 数据库里面是否存在我们要保存的数据。</p>
</li>
<li data-nodeid="1814">
<p data-nodeid="1815">update user_info：发现数据库里面存在，执行更新操作。</p>
</li>
<li data-nodeid="1816">
<p data-nodeid="1817">commit：执行提交事务。</p>
</li>
<li data-nodeid="1818">
<p data-nodeid="1819">set autocommit=1：事务执行完，改回 autocommit 的默认值，每条 SQL 是独立的事务。</p>
</li>
</ol>
<p data-nodeid="1820">我们这里采用的是数据库默认的隔离级别，如果我们通过下面这行代码，改变默认隔离级别的话，再观察我们的日志。</p>
<pre class="lang-java" data-nodeid="1821"><code data-language="java"><span class="hljs-meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span>
</code></pre>
<p data-nodeid="1822">你会发现在开始事务之前，它会先改变默认的事务隔离级别，如图所示。</p>
<p data-nodeid="1823"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNn-APx9CAADQdW_irSE093.png" alt="Drawing 11.png" data-nodeid="2149"></p>
<p data-nodeid="1824">而在事务结束之后，它还会还原此链接的事务隔离级别，又如下图所示。</p>
<p data-nodeid="1825"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNoWAEDj7AAFt5sGd5LM165.png" alt="Drawing 12.png" data-nodeid="2153"></p>
<p data-nodeid="1826">如果你明白了 MySQL 的事务原理的话，再通过日志分析可以很容易地理解 Spring 的事务原理。我们在日志里面能看到 MySQL 的事务执行过程，同样也能看到 Spring 的 TransactionImpl 的事务执行过程。这是什么原理呢？我们来详细分析一下。</p>
<h3 data-nodeid="1827">Spring 事务的实现原理</h3>
<p data-nodeid="46607" class="">这里我重点介绍一下 @Transactional 的工作机制，这个主要是利用 Spring 的 AOP 原理，在加载所有类的时候，容器就会知道某些类需要对应地进行哪些 Interceptor 的处理。</p>

<p data-nodeid="1829">例如我们所讲的 TransactionInterceptor，在启动的时候是怎么设置事务的、是什么样的处理机制，默认的代理机制又是什么样的呢？</p>
<h4 data-nodeid="1830">Spring 事务源码分析</h4>
<p data-nodeid="47711" class="">我们在 TransactionManagementConfigurationSelector 里面设置一个断点，就会知道代理的加载类 ProxyTransactionManagementConfiguration 对事务的处理机制。关键源码如下图所示。</p>

<p data-nodeid="1832"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNo2AInI6AAD3vfniJv8550.png" alt="Drawing 13.png" data-nodeid="2162"></p>
<p data-nodeid="54341" class="">而我们打开 ProxyTransactionManagementConfiguration 的话，就会加载 TransactionInterceptor 的处理类，关键源码如下图所示。</p>






<p data-nodeid="1834"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNpOAAxwDAAGlgl20cFA682.png" alt="Drawing 14.png" data-nodeid="2166"></p>
<p data-nodeid="55445" class="">如果继续加载的话，里面就会加载带有 @Transactional 注解的类或者方法。关键源码如下图所示。</p>

<p data-nodeid="1836"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNpuAC0_7AAIneVB94HQ302.png" alt="Drawing 15.png" data-nodeid="2170"></p>
<p data-nodeid="1837">加载期间，通过 @Trnsactional 注解来确定哪些方法需要进行事务处理。</p>
<pre class="lang-java" data-nodeid="1838"><code data-language="java">o.s.orm.jpa.JpaTransactionManager : Creating <span class="hljs-keyword">new</span> transaction with name
</code></pre>
<p data-nodeid="56549" class="">而运行期间通过上面这条日志，就可以找到 JpaTransactionManager 里面通过 getTransaction 方法创建的事务，然后再通过 debuger 模式的 IDEA 线程栈进行分析，就能知道创建事务的整个过程。你可以一步一步地去断点进行查看，如下图所示。</p>

<p data-nodeid="1840" class=""><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNqKAB-R6AAGkheoE3KM863.png" alt="Drawing 16.png" data-nodeid="2175"></p>
<p data-nodeid="57653" class="">如上图，我们可以知道 createTransactionIfNecessary 是用来判断是否需要创建事务的，有兴趣的话你可以点击进去看看，如下图所示。</p>

<p data-nodeid="1842"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNqmAKf_kAAGFZTc6ZAY735.png" alt="Drawing 17.png" data-nodeid="2179"></p>
<p data-nodeid="59861" class="">我们继续往下面 debug 的话，就会找到创建事务的关键代码，它会通过调用 AbstractPlatformTransactionManager 里面的 startTransaction 方法开启事务，如下图所示。</p>


<p data-nodeid="1844"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNq-AeshIAAI2vVdh7OM636.png" alt="Drawing 18.png" data-nodeid="2183"></p>
<p data-nodeid="1845">然后我们就可以继续往下断点进行分析了。断点走到最后的时候，你就可以看到开启事务的时候，必须要从我们的数据源里面获得连接。看一下断点的栈信息，这里有几个关键的 debug 点。如下图所示。</p>
<p data-nodeid="1846"><img src="https://s0.lgstatic.com/i/image/M00/6D/98/CgqCHl-uNraAaX3wAAH1QpBB_a8699.png" alt="Drawing 19.png" data-nodeid="2187"></p>
<p data-nodeid="1847">其中，</p>
<p data-nodeid="1848">第一处：是处理带 @Transactional 的注解的方法，利用 CGLIB 进行事务拦截处理；</p>
<p data-nodeid="1849">第二处：是根据 Spring 的事务传播机制，来判断是用现有的事务，还是创建新的事务；</p>
<p data-nodeid="60965" class="">第七处：是用来判断是否现有连接，如果有直接用，如果没有就从第八处的数据源里面的连接池中获取连接，第七处的关键代码如下。</p>

<p data-nodeid="1851"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNr6Ab1CwAADUuVBSiKY292.png" alt="Drawing 20.png" data-nodeid="2194"></p>
<p data-nodeid="1852">到这里，我们介绍完了事务获得连接的关键时机，那么还需要知道它是在什么时间释放连接到连接池里面的。我们在 LogicalConnectionManagedImpl 的 releaseConnection 方法中设置一个断点，如下图所示。</p>
<p data-nodeid="1853"><img src="https://s0.lgstatic.com/i/image/M00/6D/8D/Ciqc1F-uNsqAFKXjAACeh8P3Fcg501.png" alt="Drawing 21.png" data-nodeid="2198"></p>
<p data-nodeid="1854">然后观察断点线性的执行方法，你会发现，在事务执行之后，它会将连接释放到连接池里面。</p>
<p data-nodeid="1855">我们通过上面的 saveOrUpdate 的详细执行日志，可以观察出来，事务是在什么时机开启的、数据库连接是什么时机开启的、事务是在什么时机关闭的，以及数据库连接是在什么时机释放的，如果你没看出来，可以再仔细看一遍日志。</p>
<p data-nodeid="1856">所以，Spring 中的事务和连接的关系是，开启事务的同时获取 DB 连接；事务完成的时候释放 DB 连接。通过 MySQL 的基础知识可以知道数据库连接是有限的，那么当我们给某些方法加事务的时候，都需要注意哪些内容呢？</p>
<h4 data-nodeid="1857">事务和连接池在 JPA 中的注意事项</h4>
<p data-nodeid="1858">我们在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=490#/detail/pc?id=4717" data-nodeid="2208">“17 | DataSource 为何物？加载过程是怎样的？”</a>中对数据源的介绍时，说过数据源的连接池不能配置过大，否则连接之前切换就会非常耗费应用内部的 CPU 和内存，从而降低应用对外提供 API 的吞吐量。</p>
<p data-nodeid="1859">所以当我们使用事务的时候，需要注意如下 几个事项：</p>
<ol data-nodeid="1860">
<li data-nodeid="1861">
<p data-nodeid="1862">事务内的逻辑不能执行时间太长，否则就会导致占用 db 连接的时间过长，会造成数据库连接不够用的情况；</p>
</li>
<li data-nodeid="1863">
<p data-nodeid="1864">跨应用的操作，如 API 调用等，尽量不要在有事务的方法里面进行；</p>
</li>
<li data-nodeid="1865">
<p data-nodeid="1866">如果在真实业务场景中有耗时的操作，也需要带事务时（如扣款环节），那么请注意增加数据源配置的连接池数；</p>
</li>
<li data-nodeid="1867">
<p data-nodeid="1868">我们通过 MVC 的应用请求连接池数量，也要根据连接池的数量和事务的耗时情况灵活配置；而 tomcat 默认的请求连接池数量是 200 个，可以根据实际情况来增加或者减少请求的连接池数量，从而减少并发处理对事务的依赖。</p>
</li>
</ol>
<h3 data-nodeid="1869">总结</h3>
<p data-nodeid="63173" class="te-preview-highlight">本讲中，我们通过 MySQL 的基本原理、Spring 的事务处理日志及其源码分析，知道了 Spring 里面处理事务的全过程。通过日志，你也可以学会分析设置的事务和 SQL 是不是按照预期执行的。</p>


<p data-nodeid="1871">同时，我也为你讲述了连接和事务之间的关系，当你需要设置连接池的时候，可以进行参考；并且在工作中，如果遇到报连接池不够用的情况，也可以从容地知道原因：是不是事务的方法执行比较耗时？等等。</p>
<p data-nodeid="1872">此外，当事务不起作用的时候，我也为你介绍了 TransactionTemplate 和 TransactionHelper 的方法，你可以拿去借鉴。</p>
<p data-nodeid="1873">希望这一讲的内容可以帮助你搞清楚事务、连接池之间的关系。下一讲我们会介绍 Hibernate 在 JPA 中的配置有哪些。你可以先思考一下，也可以查找资料预习一下。我们下一讲再见。</p>
<blockquote data-nodeid="1874">
<p data-nodeid="1875" class="">点击下方链接查看源码（不定时更新）<br>
<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="2224">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>
</blockquote>

---

### 精选评论


