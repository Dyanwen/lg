<p data-nodeid="12437" class="">上一讲我们介绍了 DataSource 的相关内容，今天我们来介绍一下多数据源的处理方法有哪些。</p>


<p data-nodeid="11734">工作中我们时常会遇到跨数据库操作的情况，这时候就需要配置多数据源，那么如何配置呢？常用的方式及其背后的原理支撑是什么呢？我们下面来了解一下。</p>
<p data-nodeid="11735">首先看看两种常见的配置方式，分别为通过多个 @Configuration 文件、利用 AbstractRoutingDataSource 配置多数据源。</p>
<h3 data-nodeid="11736">第一种方式：多个数据源的 @Configuration 的配置方法</h3>
<p data-nodeid="11737">这种方式的主要思路是，不同 Package 下面的实体和 Repository 采用不同的 Datasource。所以我们改造一下我们的 example 目录结构，来看看不同 Repositories 的数据源是怎么处理的。</p>
<p data-nodeid="11738"><strong data-nodeid="11841">第一步：规划 Entity 和 Repository 的目录结构，为了方便配置多数据源。</strong></p>
<p data-nodeid="13363">将 User 和 UserAddress、UserRepository 和 UserAddressRepository 移动到 db1 里面；将 UserInfo 和 UserInfoRepository 移动到 db2 里面。如下图所示：</p>
<p data-nodeid="13364" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/C0/Ciqc1F-rk6mAO4voAAEl2cIHNqg269.png" alt="Drawing 0.png" data-nodeid="13368"></p>


<p data-nodeid="11741">我们把实体和 Repository 分别放到了 db1 和 db2 两个目录里面，这时我们假设数据源 1 是 MySQL，User 表和 UserAddress 在数据源 1 里面，那么我们需要配置一个 DataSource1 的 Configuration 类，并且在里面配置 DataSource、TransactionManager 和 EntityManager。</p>
<p data-nodeid="11742"><strong data-nodeid="11850">第二步：配置 DataSource1Config 类。</strong></p>
<p data-nodeid="11743">目录结构调整完之后，接下来我们开始配置数据源，完整代码如下：</p>
<pre class="lang-java" data-nodeid="11744"><code data-language="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-comment">//开启事务</span>
<span class="hljs-comment">//利用EnableJpaRepositories配置哪些包下面的Repositories，采用哪个EntityManagerFactory和哪个trannsactionManager</span>
<span class="hljs-meta">@EnableJpaRepositories(
      basePackages = {"com.example.jpa.example1.db1"},//数据源1的repository的包路径
      entityManagerFactoryRef = "db1EntityManagerFactory",//改变数据源1的EntityManagerFactory的默认值，改为db1EntityManagerFactory
      transactionManagerRef = "db1TransactionManager"//改变数据源1的transactionManager的默认值，改为db1TransactionManager
      )</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSource1Config</span> </span>{
   <span class="hljs-comment">/**
    * 指定数据源1的dataSource配置
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Primary</span>
   <span class="hljs-meta">@Bean(name = "db1DataSourceProperties")</span>
   <span class="hljs-meta">@ConfigurationProperties("spring.datasource1")</span> <span class="hljs-comment">//数据源1的db配置前缀采用spring.datasource1</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProperties <span class="hljs-title">dataSourceProperties</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProperties();
   }
   <span class="hljs-comment">/**
    * 可以选择不同的数据源，这里我用HikariDataSource举例，创建数据源1
    * <span class="hljs-doctag">@param</span> db1DataSourceProperties
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Primary</span>
   <span class="hljs-meta">@Bean(name = "db1DataSource")</span>
   <span class="hljs-meta">@ConfigurationProperties(prefix = "spring.datasource.hikari.db1")</span> <span class="hljs-comment">//配置数据源1所用的hikari配置key的前缀</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> HikariDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("db1DataSourceProperties")</span> DataSourceProperties db1DataSourceProperties)</span> </span>{
      HikariDataSource dataSource = db1DataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
      <span class="hljs-keyword">if</span> (StringUtils.hasText(db1DataSourceProperties.getName())) {
         dataSource.setPoolName(db1DataSourceProperties.getName());
      }
      <span class="hljs-keyword">return</span> dataSource;
   }
   <span class="hljs-comment">/**
    * 配置数据源1的entityManagerFactory命名为db1EntityManagerFactory，用来对实体进行一些操作
    * <span class="hljs-doctag">@param</span> builder
    * <span class="hljs-doctag">@param</span> db1DataSource entityManager依赖db1DataSource
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Primary</span>
   <span class="hljs-meta">@Bean(name = "db1EntityManagerFactory")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactory</span><span class="hljs-params">(EntityManagerFactoryBuilder builder, <span class="hljs-meta">@Qualifier("db1DataSource")</span> DataSource db1DataSource)</span> </span>{
      <span class="hljs-keyword">return</span> builder.dataSource(db2DataSource)
.packages(<span class="hljs-string">"com.example.jpa.example1.db1"</span>) <span class="hljs-comment">//数据1的实体所在的路径</span>
.persistenceUnit(<span class="hljs-string">"db1"</span>)<span class="hljs-comment">// persistenceUnit的名字采用db1</span>
.build();
   }
   <span class="hljs-comment">/**
    * 配置数据源1的事务管理者，命名为db1TransactionManager依赖db1EntityManagerFactory
    * <span class="hljs-doctag">@param</span> db1EntityManagerFactory 
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Primary</span>
   <span class="hljs-meta">@Bean(name = "db1TransactionManager")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("db1EntityManagerFactory")</span> EntityManagerFactory db1EntityManagerFactory)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(db1EntityManagerFactory);
   }
}
</code></pre>
<p data-nodeid="13835">到这里，数据源 1 我们就配置完了，下面再配置数据源 2。</p>
<p data-nodeid="13836"><strong data-nodeid="13841">第三步：配置 DataSource2Config类，加载数据源 2。</strong></p>

<pre class="lang-java" data-nodeid="11746"><code data-language="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span><span class="hljs-comment">//开启事务</span>
<span class="hljs-comment">//利用EnableJpaRepositories，配置哪些包下面的Repositories，采用哪个EntityManagerFactory和哪个trannsactionManager</span>
<span class="hljs-meta">@EnableJpaRepositories(
        basePackages = {"com.example.jpa.example1.db2"},//数据源2的repository的包路径
        entityManagerFactoryRef = "db2EntityManagerFactory",//改变数据源2的EntityManagerFactory的默认值，改为db2EntityManagerFactory
        transactionManagerRef = "db2TransactionManager"//改变数据源2的transactionManager的默认值，改为db2TransactionManager
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSource2Config</span> </span>{
    <span class="hljs-comment">/**
     * 指定数据源2的dataSource配置
     *
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@Bean(name = "db2DataSourceProperties")</span>
    <span class="hljs-meta">@ConfigurationProperties("spring.datasource2")</span> <span class="hljs-comment">//数据源2的db配置前缀采用spring.datasource2</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceProperties <span class="hljs-title">dataSourceProperties</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProperties();
    }
    <span class="hljs-comment">/**
     * 可以选择不同的数据源，这里我用HikariDataSource举例，创建数据源2
     *
     * <span class="hljs-doctag">@param</span> db2DataSourceProperties
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@Bean(name = "db2DataSource")</span>
    <span class="hljs-meta">@ConfigurationProperties(prefix = "spring.datasource.hikari.db2")</span> <span class="hljs-comment">//配置数据源2的hikari配置key的前缀</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> HikariDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("db2DataSourceProperties")</span> DataSourceProperties db2DataSourceProperties)</span> </span>{
        HikariDataSource dataSource = db2DataSourceProperties.initializeDataSourceBuilder().type(HikariDataSource.class).build();
        <span class="hljs-keyword">if</span> (StringUtils.hasText(db2DataSourceProperties.getName())) {
            dataSource.setPoolName(db2DataSourceProperties.getName());
        }
        <span class="hljs-keyword">return</span> dataSource;
    }
    <span class="hljs-comment">/**
     * 配置数据源2的entityManagerFactory命名为db2EntityManagerFactory，用来对实体进行一些操作
     *
     * <span class="hljs-doctag">@param</span> builder
     * <span class="hljs-doctag">@param</span> db2DataSource entityManager依赖db2DataSource
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@Bean(name = "db2EntityManagerFactory")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactory</span><span class="hljs-params">(EntityManagerFactoryBuilder builder, <span class="hljs-meta">@Qualifier("db2DataSource")</span> DataSource db2DataSource)</span> </span>{
        <span class="hljs-keyword">return</span> builder.dataSource(db2DataSource)
            .packages(<span class="hljs-string">"com.example.jpa.example1.db2"</span>) <span class="hljs-comment">//数据2的实体所在的路径</span>
            .persistenceUnit(<span class="hljs-string">"db2"</span>)<span class="hljs-comment">// persistenceUnit的名字采用db2</span>
            .build();
    }
    <span class="hljs-comment">/**
     * 配置数据源2的事务管理者，命名为db2TransactionManager依赖db2EntityManagerFactory
     *
     * <span class="hljs-doctag">@param</span> db2EntityManagerFactory
     * <span class="hljs-doctag">@return</span>
     */</span>
    <span class="hljs-meta">@Bean(name = "db2TransactionManager")</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("db2EntityManagerFactory")</span> EntityManagerFactory db2EntityManagerFactory)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(db2EntityManagerFactory);
    }
}
</code></pre>
<p data-nodeid="14308">这一步你需要注意，DataSource1Config 和 DataSource2Config 不同的是，1 里面每个 @Bean 都 @Primary，而 2 里面不是的。</p>
<p data-nodeid="14309"><strong data-nodeid="14314">第四步：通过 application.properties 配置两个数据源的值，代码如下：</strong></p>

<pre class="lang-java" data-nodeid="11748"><code data-language="java">###########datasource1 采用Mysql数据库
spring.datasource1.url=jdbc:mysql://localhost:3306/test2?logger=Slf4JLogger&amp;profileSQL=true
spring.datasource1.username=root
spring.datasource1.password=root
##数据源1的连接池的名字
spring.datasource.hikari.db1.pool-name=jpa-hikari-pool-db1
##最长生命周期15分钟够了
spring.datasource.hikari.db1.maxLifetime=900000
spring.datasource.hikari.db1.maximumPoolSize=8
###########datasource2 采用h2内存数据库
spring.datasource2.url=jdbc:h2:~/test
spring.datasource2.username=sa
spring.datasource2.password=sa
##数据源2的连接池的名字
spring.datasource.hikari.db2.pool-name=jpa-hikari-pool-db2
##最长生命周期15分钟够了
spring.datasource.hikari.db2.maxLifetime=500000
##最大连接池大小和数据源1区分开，我们配置成6个
spring.datasource.hikari.db2.maximumPoolSize=6
</code></pre>
<p data-nodeid="11749"><strong data-nodeid="11867">第五步：我们写个 Controller 测试一下。</strong></p>
<pre class="lang-java" data-nodeid="11750"><code data-language="java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>{
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> UserRepository userRepository;
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> UserInfoRepository userInfoRepository;
   <span class="hljs-comment">//操作user的Repository</span>
   <span class="hljs-meta">@PostMapping("/user")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">saveUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>{
      <span class="hljs-keyword">return</span> userRepository.save(user);
   }
   <span class="hljs-comment">//操作userInfo的Repository</span>
  <span class="hljs-meta">@PostMapping("/user/info")</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">saveUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> UserInfo userInfo)</span> </span>{
     <span class="hljs-keyword">return</span> userInfoRepository.save(userInfo);
  }
}
</code></pre>
<p data-nodeid="11751"><strong data-nodeid="11871">第六步：直接启动我们的项目，测试一下。</strong></p>
<p data-nodeid="15231">请看这一步的启动日志：</p>
<p data-nodeid="15928" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/CC/CgqCHl-rk8WAV0LYAAIUPl37DVs337.png" alt="Drawing 1.png" data-nodeid="15931"><br>
<img src="https://s0.lgstatic.com/i/image/M00/6C/CC/CgqCHl-rk8qAZkCgAAHBFDKIWG0269.png" alt="Drawing 2.png" data-nodeid="15935"></p>





<p data-nodeid="16860">可以看到启动的是两个数据源，其对应的连接池的监控也是不一样的：数据源 1 有 8 个，数据源 2 有 6 个。</p>
<p data-nodeid="16861" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/CC/CgqCHl-rk8-AK9nMAABPduIgKR4098.png" alt="Drawing 3.png" data-nodeid="16865"></p>


<p data-nodeid="11757">如果我们分别请求 Controller 写的两个方法的时候，也会分别插入到不同的数据源里面去。</p>
<p data-nodeid="11758">通过上面的六个步骤你应该知道了如何配置多数据源，那么它的原理基础是什么呢？我们看一下</p>
<p data-nodeid="11759">Datasource 与 TransactionManager、EntityManagerFactory 的关系和职责分别是怎么样的。</p>
<h4 data-nodeid="11760">Datasource 与 TransactionManager、EntityManagerFactory 的关系分析</h4>
<p data-nodeid="17790">我们通过一个类的关系图来分析一下：</p>
<p data-nodeid="17791" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/CC/CgqCHl-rk9aAfRipAAB6oNvBMnM239.png" alt="Drawing 4.png" data-nodeid="17795"></p>


<p data-nodeid="11763">其中，</p>
<ol data-nodeid="11764">
<li data-nodeid="11765">
<p data-nodeid="11766">HikariDataSource 负责实现 DataSource，交给 EntityManager 和 TransactionManager 使用；</p>
</li>
<li data-nodeid="11767">
<p data-nodeid="11768">EntityManager 是利用 Datasouce 来操作数据库，而其实现类是 SessionImpl；</p>
</li>
<li data-nodeid="11769">
<p data-nodeid="11770">EntityManagerFactory 是用来管理和生成 EntityManager 的，而 EntityManagerFactory 的实现类是 LocalContainerEntityManagerFactoryBean，通过实现 FactoryBean<entitymanagerfactory> 接口实现，利用了 FactoryBean 的 Spring 中的 bean 管理机制，所以需要我们在 Datasource1Config 里面配置 LocalContainerEntityManagerFactoryBean 的 bean 的注入方式；</entitymanagerfactory></p>
</li>
<li data-nodeid="11771">
<p data-nodeid="11772">JpaTransactionManager 是用来管理事务的，实现了 TransactionManager 并且通过 EntityFactory 和 Datasource 进行 db 操作，所以我们要在 DataSourceConfig 里面告诉 JpaTransactionManager 用的 TransactionManager 是 db1EntityManagerFactory。</p>
</li>
</ol>
<p data-nodeid="11773">上一讲我们介绍了 Datasource 的默认加载和配置方式，那么默认情况下 Datasource 的 EntityManagerFactory 和 TransactionManager 是怎么加载和配置的呢？</p>
<h4 data-nodeid="11774">默认的 JpaBaseConfiguration 的加载方式分析</h4>
<p data-nodeid="18720">上一讲我只简单说明了 DataSource 的配置，其实我们还可以通过 HibernateJpaConfiguration，找到父类 JpaBaseConfiguration 类，如图所示：</p>
<p data-nodeid="18721" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/C1/Ciqc1F-rk-GAXBLMAABJWH1P9Qs574.png" alt="Drawing 5.png" data-nodeid="18725"></p>


<p data-nodeid="19650">接着打开 JpaBaseConfiguration 就可以看到多数据源的参考原型，如下图所示：</p>
<p data-nodeid="19651" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/C1/Ciqc1F-rk-iAMO5TAAIqJTa-4bI250.png" alt="Drawing 6.png" data-nodeid="19655"></p>


<p data-nodeid="11779">通过上面的代码，可以看到在单个数据源情况下的 EntityManagerFactory 和 TransactionManager 的加载方法，并且我们在多数据源的配置里面还加载了一个类：EntityManagerFactoryBuilder entityManagerFactoryBuilder，也正是从上面的方法加载进去的，看第 120 行代码就知道了。</p>
<p data-nodeid="11780">那么除了上述的配置多数据源的方式，还有没有其他方法了呢？我们接着看一下。</p>
<h3 data-nodeid="11781">第二种方式：利用 AbstractRoutingDataSource 配置多数据源</h3>
<p data-nodeid="11782">我们都知道 DataSource 的本质是获得数据库连接，而 AbstractRoutingDataSource 帮我们实现了动态获得数据源的可能性。下面还是通过一个例子看一下它是怎么使用的。</p>
<p data-nodeid="11783"><strong data-nodeid="11915">第一步：定一个数据源的枚举类，用来标示数据源有哪些。</strong></p>
<pre class="lang-java" data-nodeid="11784"><code data-language="java"><span class="hljs-comment">/**
 * 定义一个数据源的枚举类
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> RoutingDataSourceEnum {
   DB1, <span class="hljs-comment">//实际工作中枚举的语义可以更加明确一点；</span>
   DB2;
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RoutingDataSourceEnum <span class="hljs-title">findbyCode</span><span class="hljs-params">(String dbRouting)</span> </span>{
      <span class="hljs-keyword">for</span> (RoutingDataSourceEnum e : values()) {
         <span class="hljs-keyword">if</span> (e.name().equals(dbRouting)) {
            <span class="hljs-keyword">return</span> e;
         }
      }
      <span class="hljs-keyword">return</span> db1;<span class="hljs-comment">//没找到的情况下，默认返回数据源1</span>
   }
}
</code></pre>
<p data-nodeid="11785"><strong data-nodeid="11919">第二步：新增 DataSourceRoutingHolder，用来存储当前线程需要采用的数据源。</strong></p>
<pre class="lang-java" data-nodeid="11786"><code data-language="java"><span class="hljs-comment">/**
 * 利用ThreadLocal来存储，当前的线程使用的数据
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceRoutingHolder</span> </span>{
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;RoutingDataSourceEnum&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBranchContext</span><span class="hljs-params">(RoutingDataSourceEnum dataSourceEnum)</span> </span>{
      threadLocal.set(dataSourceEnum);
   }
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RoutingDataSourceEnum <span class="hljs-title">getBranchContext</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> threadLocal.get();
   }
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearBranchContext</span><span class="hljs-params">()</span> </span>{
      threadLocal.remove();
   }
}
</code></pre>
<p data-nodeid="11787"><strong data-nodeid="11923">第三步：配置 RoutingDataSourceConfig，用来指定哪些 Entity 和 Repository 采用动态数据源。</strong></p>
<pre class="lang-java" data-nodeid="11788"><code data-language="java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableTransactionManagement</span>
<span class="hljs-meta">@EnableJpaRepositories(
      //数据源的repository的包路径，这里我们覆盖db1和db2的包路径
      basePackages = {"com.example.jpa.example1"},
      entityManagerFactoryRef = "routingEntityManagerFactory",
      transactionManagerRef = "routingTransactionManager"
)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoutingDataSourceConfig</span> </span>{
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-meta">@Qualifier("db1DataSource")</span>
   <span class="hljs-keyword">private</span> DataSource db1DataSource;
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-meta">@Qualifier("db2DataSource")</span>
   <span class="hljs-keyword">private</span> DataSource db2DataSource;
   <span class="hljs-comment">/**
    * 创建RoutingDataSource，引用我们之前配置的db1DataSource和db2DataSource
    *
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Bean(name = "routingDataSource")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>{
      Map&lt;Object, Object&gt; dataSourceMap = Maps.newHashMap();
      dataSourceMap.put(RoutingDataSourceEnum.DB1, db1DataSource);
      dataSourceMap.put(RoutingDataSourceEnum.DB2, db2DataSource);
      RoutingDataSource routingDataSource = <span class="hljs-keyword">new</span> RoutingDataSource();
      <span class="hljs-comment">//设置RoutingDataSource的默认数据源</span>
      routingDataSource.setDefaultTargetDataSource(db1DataSource);
      <span class="hljs-comment">//设置RoutingDataSource的数据源列表</span>
      routingDataSource.setTargetDataSources(dataSourceMap);
      <span class="hljs-keyword">return</span> routingDataSource;
   }
   <span class="hljs-comment">/**
    * 类似db1和db2的配置，唯一不同的是，这里采用routingDataSource
    * <span class="hljs-doctag">@param</span> builder
    * <span class="hljs-doctag">@param</span> routingDataSource entityManager依赖routingDataSource
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Bean(name = "routingEntityManagerFactory")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactory</span><span class="hljs-params">(EntityManagerFactoryBuilder builder, <span class="hljs-meta">@Qualifier("routingDataSource")</span> DataSource routingDataSource)</span> </span>{
      <span class="hljs-keyword">return</span> builder.dataSource(routingDataSource).packages(<span class="hljs-string">"com.example.jpa.example1"</span>) <span class="hljs-comment">//数据routing的实体所在的路径，这里我们覆盖db1和db2的路径</span>
            .persistenceUnit(<span class="hljs-string">"db-routing"</span>)<span class="hljs-comment">// persistenceUnit的名字采用db-routing</span>
            .build();
   }
   <span class="hljs-comment">/**
    * 配置数据的事务管理者，命名为routingTransactionManager依赖routtingEntityManagerFactory
    *
    * <span class="hljs-doctag">@param</span> routingEntityManagerFactory
    * <span class="hljs-doctag">@return</span>
    */</span>
   <span class="hljs-meta">@Bean(name = "routingTransactionManager")</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(<span class="hljs-meta">@Qualifier("routingEntityManagerFactory")</span> EntityManagerFactory routingEntityManagerFactory)</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(routingEntityManagerFactory);
   }
}
</code></pre>
<p data-nodeid="11789">路由数据源配置与 DataSource1Config 和 DataSource2Config 有相互覆盖关系，这里我们直接覆盖 db1 和 db2 的包路径，以便于我们的动态数据源生效。</p>
<p data-nodeid="11790"><strong data-nodeid="11928">第四步：写一个 MVC 拦截器，用来指定请求分别采用什么数据源。</strong></p>
<p data-nodeid="11791">新建一个类 DataSourceInterceptor，用来在请求前后指定数据源，请看代码：</p>
<pre class="lang-java" data-nodeid="11792"><code data-language="java"><span class="hljs-comment">/**
 * 动态路由的实现逻辑，我们通过请求里面的db-routing，来指定此请求采用什么数据源
 */</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourceInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HandlerInterceptorAdapter</span> </span>{
   <span class="hljs-comment">/**
    * 请求处理之前更改线程里面的数据源
    */</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request,
                      HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>{
      String dbRouting = request.getHeader(<span class="hljs-string">"db-routing"</span>);
      DataSourceRoutingHolder.setBranchContext(RoutingDataSourceEnum.findByCode(dbRouting));
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.preHandle(request, response, handler);
   }
   <span class="hljs-comment">/**
    * 请求结束之后清理线程里面的数据源
    */</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>{
      <span class="hljs-keyword">super</span>.afterCompletion(request, response, handler, ex);
      DataSourceRoutingHolder.clearBranchContext();
   }
}
</code></pre>
<p data-nodeid="11793">同时我们需要在实现 WebMvcConfigurer 的配置里面，把我们自定义拦截器 dataSourceInterceptor 加载进去，代码如下：</p>
<pre class="lang-java" data-nodeid="11794"><code data-language="java"><span class="hljs-comment">/**
 * 实现WebMvcConfigurer
 */</span>
<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>{
   <span class="hljs-meta">@Autowired</span>
   <span class="hljs-keyword">private</span> DataSourceInterceptor dataSourceInterceptor;
   <span class="hljs-comment">//添加自定义拦截器</span>
   <span class="hljs-meta">@Override</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>{
      registry.addInterceptor(dataSourceInterceptor).addPathPatterns(<span class="hljs-string">"/**"</span>);
      WebMvcConfigurer.<span class="hljs-keyword">super</span>.addInterceptors(registry);
   }
...<span class="hljs-comment">//其他不变的代码省略}</span>
</code></pre>
<p data-nodeid="20122">此处我们采用的是 MVC 的拦截器机制动态改变的数据配置，你也可以使用自己的 AOP 任意的拦截器，如事务拦截器、Service 的拦截器等，都可以实现。需要注意的是，要在开启事务之前配置完毕。</p>
<p data-nodeid="20123"><strong data-nodeid="20128">第五步：启动测试。</strong></p>

<p data-nodeid="11796">我们在 Http 请求头里面加上 db-routing：DB2，那么本次请求就会采用数据源 2 进行处理，请求代码如下：</p>
<pre class="lang-java" data-nodeid="11797"><code data-language="java">POST /user/info HTTP/<span class="hljs-number">1.1</span>
Host: <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8089</span>
Content-Type: application/json
db-routing: DB2
Cache-Control: no-cache
Postman-Token: <span class="hljs-number">56</span>d8dc02-<span class="hljs-number">7f</span>3e-<span class="hljs-number">7</span>b95-<span class="hljs-number">7f</span>f1-<span class="hljs-number">572</span>a4bb7d102
{<span class="hljs-string">"ages"</span>:<span class="hljs-number">10</span>}
</code></pre>
<p data-nodeid="11798">通过上面五个步骤，我们可以利用 AbstractRoutingDataSource 实现动态数据源，实际工作中可能会比我讲述的要复杂，有的需要考虑多线程、线程安全等问题，你要多加注意。<br>
在实际应用场景中，对于多数据源的问题，我还有一些思考，下面分享给你。</p>
<h3 data-nodeid="11799">微服务下多数据源的思考：还需要这样用吗？</h3>
<p data-nodeid="11800">通过上面的两种方式，我们分别可以实现同一个 application 应用的多数据源配置，那么有什么注意事项呢？我简单总结如下几点建议。</p>
<h4 data-nodeid="11801">多数据源实战注意事项</h4>
<ol data-nodeid="21053">
<li data-nodeid="21054">
<p data-nodeid="21055">此种方式利用了当前线程事务不变的原理，所以要注意异步线程的处理方式；</p>
</li>
<li data-nodeid="21056">
<p data-nodeid="21057">此种方式利用了 DataSource 的原理，动态地返回不同的 db 连接，一般需要在开启事务之前使用，需要注意事务的生命周期；</p>
</li>
<li data-nodeid="21058">
<p data-nodeid="21059">比较适合读写操作分开的业务场景；</p>
</li>
<li data-nodeid="21060">
<p data-nodeid="21061">多数据的情况下，避免一个事务里面采用不同的数据源，这样会有意想不到的情况发生，比如死锁现象；</p>
</li>
<li data-nodeid="21062">
<p data-nodeid="21063">学会通过日志检查我们开启请求的方法和开启的数据源是否正确，可以通过 Debug 断点来观察数据源是否选择的正确，如下图所示：</p>
</li>
</ol>
<p data-nodeid="21064" class=""><img src="https://s0.lgstatic.com/i/image/M00/6C/CC/CgqCHl-rlAGARlxqAAVdbojSwxw751.png" alt="Drawing 7.png" data-nodeid="21072"></p>

<h4 data-nodeid="20595">微服务下的实战建议</h4>



<p data-nodeid="11816">在实际工作中，为了便捷省事，更多开发者喜欢配置多个数据源，但是我强烈建议不要在对用户直接提供的 API 服务上面配置多数据源，否则将出现令人措手不及的 Bug。</p>
<p data-nodeid="11817">如果你是做后台管理界面，供公司内部员工使用的，那么这种 API 可以为了方便而使用多数据源。</p>
<p data-nodeid="11818">微服务的大环境下，服务越小，内聚越高，低耦合服务越健壮，所以一般跨库之间一定是是通过 REST 的 API 协议，进行内部服务之间的调用，这是最稳妥的方式，原因有如下几点：</p>
<ol data-nodeid="11819">
<li data-nodeid="11820">
<p data-nodeid="11821">REST 的 API 协议更容易监控，更容易实现事务的原子性；</p>
</li>
<li data-nodeid="11822">
<p data-nodeid="11823">db 之间解耦，使业务领域代码职责更清晰，更容易各自处理各种问题；</p>
</li>
<li data-nodeid="11824">
<p data-nodeid="11825">只读和读写的 API 更容易分离和管理。</p>
</li>
</ol>
<h3 data-nodeid="21772">总结</h3>




<p data-nodeid="11828">到这里，这一讲的内容就结束了。多数据的配置是一个比较复杂的事情，在本讲中我通过两种方式，带领你自定义 entityManager 和 transactionManager，实现了多数据源的配置。如果对此你有不懂的地方，欢迎你在下方留言，我会尽快给你回复。</p>
<p data-nodeid="22236" class="te-preview-highlight">此外，你需要掌握的一个简单的基础知识，就是线程、事务和数据源之间的关系。下一讲我们再详细分析一下事务中需要我们关心的内容有哪些。</p>

<blockquote data-nodeid="11830">
<p data-nodeid="11831">点击下方链接查看源码（不定时更新）<br>
<a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" data-nodeid="11966">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p>
</blockquote>

---

### 精选评论

##### *平：
> 老师的代码很详细啊

