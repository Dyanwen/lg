<p data-nodeid="26343" class="">今天，我们讨论 ShardingSphere 中的数据脱敏模块。通过在 <strong data-nodeid="26462">“10 | 数据脱敏：如何确保敏感数据的安全访问？”</strong> 课时中的介绍，我们知道 ShardingSphere 提供了一套自动的数据加解密机制来实现透明化的数据脱敏。</p>
<h3 data-nodeid="26344">数据脱敏模块整体架构</h3>
<p data-nodeid="26345">与普通的编程模式一样，对于数据脱敏而言，我们同样先获取一个 DataSource 作为整个流程的入口，当然这里获取的不是一个普通的 DataSource，而是一个专门针对数据脱敏的 EncryptDataSource。对于数据脱敏模块，我们的思路还是从上到下，从 EncryptDataSource 开始进入到 ShardingSphere 数据脱敏的世界中。</p>
<p data-nodeid="26346">同时，我们这次讲解数据脱敏模块不是零基础，因为在前面介绍 ShardingDataSource、ShardingConnection、ShardingStatement 等内容时，已经对整个 SQL 执行流程的抽象过程做了全面介绍，所涉及的很多内容对于数据脱敏模块而言也都是适用的。</p>
<p data-nodeid="26996">让我们结合下图来做一些回顾：</p>
<p data-nodeid="26997" class=""><img src="https://s0.lgstatic.com/i/image/M00/57/0A/CgqCHl9sS86ASFTbAAB-yuAnnt4924.png" alt="image (9).png" data-nodeid="27006"></p>





<p data-nodeid="26350">上图中，可以看到与数据脱敏模块相关的类实际上都继承了一个抽象类，而这些抽象类在前面的内容都已经做了介绍。因此，我们对数据脱敏模块将重点关注于几个核心类的讲解，对于已经介绍过的内容我们会做一些回顾，但不会面面俱到。</p>
<p data-nodeid="26351">基于上图，我们从 EncryptDataSource 开始入手，EncryptDataSource 的创建依赖于工厂类 EncryptDataSourceFactory，其实现如下所示：</p>
<pre class="lang-java" data-nodeid="26352"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptDataSourceFactory</span> </span>{

&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DataSource dataSource, <span class="hljs-keyword">final</span> EncryptRuleConfiguration encryptRuleConfiguration, <span class="hljs-keyword">final</span> Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EncryptDataSource(dataSource, <span class="hljs-keyword">new</span> EncryptRule(encryptRuleConfiguration), props);
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26353">这里直接创建了一个 EncryptDataSource，依赖于 EncryptRule 规则对象，我们先来梳理一下 EncryptRule 中具体包含了哪些内容。</p>
<h3 data-nodeid="26354">EncryptRule</h3>
<p data-nodeid="26355">EncryptRule 是数据脱敏模块的一个核心对象，值得我们专门进行展开。在 EncryptRule 中，定义了如下所示的三个核心变量：</p>
<pre class="lang-java" data-nodeid="26356"><code data-language="java"><span class="hljs-comment">//加解密器</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ShardingEncryptor&gt; encryptors = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
<span class="hljs-comment">//脱敏数据表</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, EncryptTable&gt; tables = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
<span class="hljs-comment">//脱敏规则配置</span>
<span class="hljs-keyword">private</span> EncryptRuleConfiguration ruleConfiguration;
</code></pre>
<p data-nodeid="26357">我们可以把这三个变量分成两部分，其中 ShardingEncryptor 用于完成加解密，而 EncryptTable 和 EncryptRuleConfiguration 则更多的与数据脱敏的配置体系相关。</p>
<p data-nodeid="26358">接下来我将对这两部分分别展开讲解。</p>
<h4 data-nodeid="26359">1.ShardingEncryptor</h4>
<p data-nodeid="26360">在 EncryptRule 中，ShardingEncryptor 是一个接口，代表具体的加密器类，该接口定义如下：</p>
<pre class="lang-java" data-nodeid="26361"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ShardingEncryptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TypeBasedSPI</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//初始化</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//加密</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function">String <span class="hljs-title">encrypt</span><span class="hljs-params">(Object plaintext)</span></span>;
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//解密</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function">Object <span class="hljs-title">decrypt</span><span class="hljs-params">(String ciphertext)</span></span>;
}
</code></pre>
<p data-nodeid="26362">ShardingEncryptor 接口中存在一对用于加密和解密的方法，同时该接口也继承了 TypeBasedSPI 接口，意味着会通过 SPI 的方式进行动态类加载。</p>
<p data-nodeid="26363">ShardingEncryptorServiceLoader 完成了这个工作，同时在 sharding-core-common 工程中，我们也找到了 SPI 的配置文件，如下所示：</p>
<p data-nodeid="26364"><img src="https://s0.lgstatic.com/i/image/M00/50/A8/CgqCHl9jFdmATyqTAAC9ufzW9Ag886.png" alt="Drawing 1.png" data-nodeid="26483"></p>
<div data-nodeid="26365"><p style="text-align:center">ShardingEncryptor 的 SPI 配置文件</p></div>
<p data-nodeid="26366">可以看到这里有两个实现类，分别是 MD5ShardingEncryptor 和 AESShardingEncryptor。对于 MD5 算法而言，我们知道它是单向散列的，无法根据密文反推出明文，MD5ShardingEncryptor 的实现类如下所示：</p>
<pre class="lang-java" data-nodeid="26367"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MD5ShardingEncryptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ShardingEncryptor</span> </span>{

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> Properties properties = <span class="hljs-keyword">new</span> Properties();

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">"MD5"</span>;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object plaintext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> DigestUtils.md5Hex(String.valueOf(plaintext));
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String ciphertext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> ciphertext;
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26368">而 AES 是一个对称加密算法，所以可以根据密文反推出明文，对应的 AESShardingEncryptor 如下所示：</p>
<pre class="lang-java" data-nodeid="26369"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESShardingEncryptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ShardingEncryptor</span> </span>{

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String AES_KEY = <span class="hljs-string">"aes.key.value"</span>;

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> Properties properties = <span class="hljs-keyword">new</span> Properties();

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-string">"AES"</span>;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@SneakyThrows</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object plaintext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">byte</span>[] result = getCipher(Cipher.ENCRYPT_MODE).doFinal(StringUtils.getBytesUtf8(String.valueOf(plaintext)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//使用 Base64 进行加密</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> Base64.encodeBase64String(result);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@SneakyThrows</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String ciphertext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == ciphertext) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//使用 Base64 进行解密</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">byte</span>[] result = getCipher(Cipher.DECRYPT_MODE).doFinal(Base64.decodeBase64(String.valueOf(ciphertext)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(result, StandardCharsets.UTF_8);
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">private</span> Cipher <span class="hljs-title">getCipher</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> decryptMode)</span> <span class="hljs-keyword">throws</span> NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Preconditions.checkArgument(properties.containsKey(AES_KEY), <span class="hljs-string">"No available secret key for `%s`."</span>, AESShardingEncryptor.class.getName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cipher result = Cipher.getInstance(getType());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.init(decryptMode, <span class="hljs-keyword">new</span> SecretKeySpec(createSecretKey(), getType()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> result;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] createSecretKey() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Preconditions.checkArgument(<span class="hljs-keyword">null</span> != properties.get(AES_KEY), String.format(<span class="hljs-string">"%s can not be null."</span>, AES_KEY));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//创建秘钥</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> Arrays.copyOf(DigestUtils.sha1(properties.get(AES_KEY).toString()), <span class="hljs-number">16</span>);
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26370">这里就是对一些常用加密库的直接使用，不做展开讨论。</p>
<h4 data-nodeid="26371">2.EncryptRuleConfiguration</h4>
<p data-nodeid="26372">我们接下来关注于 EncryptRule 中的第二组变量，即 EncryptTable，以及与之相关的配置类 EncryptRuleConfiguration 之间的关系。</p>
<p data-nodeid="26373">我们先来看 EncryptRuleConfiguration，内部包含了两部分内容：</p>
<pre class="lang-java" data-nodeid="26374"><code data-language="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, EncryptorRuleConfiguration&gt; encryptors;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, EncryptTableRuleConfiguration&gt; tables;
</code></pre>
<p data-nodeid="26375">而在 EncryptTableRuleConfiguration 内部，同样保存着一个 EncryptColumnRuleConfiguration 列表，如下所示：</p>
<pre class="lang-java" data-nodeid="26376"><code data-language="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, EncryptColumnRuleConfiguration&gt; columns = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();
</code></pre>
<p data-nodeid="26377">我们再来看 EncryptColumnRuleConfiguration 的数据结构，如下所示：</p>
<pre class="lang-java" data-nodeid="26378"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptColumnRuleConfiguration</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//存储明文的字段</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String plainColumn;
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//存储密文的字段</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String cipherColumn;
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//辅助查询字段</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String assistedQueryColumn;
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//加密器名字</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String encryptor;
}
</code></pre>
<p data-nodeid="26379">终于，我们在这里看到了指定存放明文的 plainColumn、存放密文的 cipherColumn，以及加密器 encryptor 等信息。</p>
<p data-nodeid="26380">我们可以回顾案例中的相关配置项来加深理解：</p>
<pre class="lang-xml" data-nodeid="26381"><code data-language="xml">spring.shardingsphere.encrypt.tables.encrypt_user.columns.user_name.plainColumn=user_name_plain
spring.shardingsphere.encrypt.tables.encrypt_user.columns.user_name.cipherColumn=user_name
spring.shardingsphere.encrypt.tables.encrypt_user.columns.user_name.encryptor=name_encryptor
</code></pre>
<p data-nodeid="26382">我们回到最上层的 EncryptRule，发现它的构造函数如下所示：</p>
<pre class="lang-java" data-nodeid="26383"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EncryptRule</span><span class="hljs-params">(<span class="hljs-keyword">final</span> EncryptRuleConfiguration encryptRuleConfig)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">this</span>.ruleConfiguration = encryptRuleConfig;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Preconditions.checkArgument(isValidRuleConfiguration(), <span class="hljs-string">"Invalid encrypt column configurations in EncryptTableRuleConfigurations."</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initEncryptors(encryptRuleConfig.getEncryptors());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initTables(encryptRuleConfig.getTables());
}
</code></pre>
<p data-nodeid="26384">上述 initEncryptors 方法就是初始化加解密器 Encryptor，而 initTables 方法会根据 EncryptRuleConfiguration 中的 EncryptTableRuleConfiguration 来初始化 EncryptTable。这里的 EncryptTable 更多是一种中间领域模型，用于简化对各种配置信息的处理，其内部保存着一个 EncryptColumn 列表，如下所示：</p>
<pre class="lang-java" data-nodeid="26385"><code data-language="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, EncryptColumn&gt; columns;
</code></pre>
<p data-nodeid="26386">而这个 EncryptColumn 中的变量则跟前面介绍的 EncryptColumnRuleConfiguration 一样，包含了存放明文的 plainColumn、存放密文的 cipherColumn，以及加密器 encryptor 等信息。</p>
<p data-nodeid="26387">在了解了 EncryptRule 中所持有的数据模型之后，我们就可以来看一下 EncryptDataSource，在 EncryptDataSource 的构造函数中使用到了 EncryptRule，如下所示：</p>
<pre class="lang-java" data-nodeid="26388"><code data-language="java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EncryptRuntimeContext runtimeContext;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EncryptDataSource</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DataSource dataSource, <span class="hljs-keyword">final</span> EncryptRule encryptRule, <span class="hljs-keyword">final</span> Properties props)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">super</span>(dataSource);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runtimeContext = <span class="hljs-keyword">new</span> EncryptRuntimeContext(dataSource, encryptRule, props, getDatabaseType());
}
</code></pre>
<p data-nodeid="26389">可以看到所传入的 EncryptRule 和 Properties 是用来构建一个 EncryptRuntimeContext，该类继承自 AbstractRuntimeContext 类，而 EncryptRuntimeContext 内部主要保存了用于描述表元数据的 TableMetas 数据结构。</p>
<h3 data-nodeid="26390">基于改写引擎的数据脱敏实现方案</h3>
<p data-nodeid="26391">我们知道 EncryptDataSource 继承了适配器类 AbstractDataSourceAdapter，而它的作用就是生成 EncryptConnection。而对于 EncryptConnection，我们同样也明确它的职责是创建各种 EncryptStatement 和 EncryptPreparedStatement，如下所示：</p>
<pre class="lang-java" data-nodeid="26392"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Statement <span class="hljs-title">createStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EncryptStatement(<span class="hljs-keyword">this</span>);
}
	&nbsp;
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> PreparedStatement <span class="hljs-title">prepareStatement</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EncryptPreparedStatement(<span class="hljs-keyword">this</span>, sql);
}
</code></pre>
<p data-nodeid="26393">然后，我们再快速来到 EncryptStatement，来看它的 executeQuery 方法，如下所示：</p>
<pre class="lang-java" data-nodeid="26394"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> ResultSet <span class="hljs-title">executeQuery</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String sql)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (Strings.isNullOrEmpty(sql)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SQLException(SQLExceptionConstant.SQL_STRING_NULL_OR_EMPTY);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//获取改写后的 SQL 并执行</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResultSet resultSet = statement.executeQuery(getRewriteSQL(sql));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">this</span>.resultSet = <span class="hljs-keyword">new</span> EncryptResultSet(connection.getRuntimeContext(), sqlStatementContext, <span class="hljs-keyword">this</span>, resultSet);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.resultSet;
}
</code></pre>
<p data-nodeid="26395">显然这里需要重点关注的是 getRewriteSQL 方法，该方法用于获取改写后的 SQL，如下所示：</p>
<pre class="lang-java" data-nodeid="26396"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getRewriteSQL</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String sql)</span> </span>{ 
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//通过 ParseEngine 对 SQL 进行解析</span>
&nbsp;&nbsp;&nbsp;  SQLStatement sqlStatement = connection.getRuntimeContext().getParseEngine().parse(sql, <span class="hljs-keyword">false</span>);
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//获取关系元数据 RelationMetas</span>
&nbsp;&nbsp;&nbsp;  RelationMetas relationMetas = getRelationMetas(connection.getRuntimeContext().getTableMetas());
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//构建 SQLStatementContext</span>
&nbsp;&nbsp;&nbsp;  sqlStatementContext = SQLStatementContextFactory.newInstance(relationMetas, sql, Collections.emptyList(), sqlStatement);
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//构建 SQLRewriteContext</span>
&nbsp;&nbsp;&nbsp;  SQLRewriteContext sqlRewriteContext = <span class="hljs-keyword">new</span> SQLRewriteContext(relationMetas, sqlStatementContext, sql, Collections.emptyList());
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//判断是否根据数据脱敏列进行查询</span>
&nbsp;&nbsp;&nbsp;  <span class="hljs-keyword">boolean</span> isQueryWithCipherColumn = connection.getRuntimeContext().getProps().&lt;Boolean&gt;getValue(ShardingPropertiesConstant.QUERY_WITH_CIPHER_COLUMN);
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//构建 EncryptSQLRewriteContextDecorator 对 SQLRewriteContext 进行装饰</span>
&nbsp;&nbsp;&nbsp;  <span class="hljs-keyword">new</span> EncryptSQLRewriteContextDecorator(connection.getRuntimeContext().getRule(), isQueryWithCipherColumn).decorate(sqlRewriteContext);
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//生成 SQLTokens</span>
&nbsp;&nbsp;&nbsp;  sqlRewriteContext.generateSQLTokens();
&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//使用 DefaultSQLRewriteEngine 进行改写</span>
&nbsp;&nbsp;&nbsp; String result = <span class="hljs-keyword">new</span> DefaultSQLRewriteEngine().rewrite(sqlRewriteContext).getSql();
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//打印结果</span>
&nbsp;&nbsp;&nbsp; showSQL(result);
&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//返回结果</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p data-nodeid="26397">这个方法的部分代码有一种让人似曾相识的感觉，我们回想一下 <strong data-nodeid="26510">“20 | 改写引擎：如何理解装饰器模式下的 SQL 改写实现机制？”</strong> 中介绍的 BaseShardingEngine的rewriteAndConvert 方法，也看到过 isQueryWithCipherColumn 判断，以及 EncryptSQLRewriteContextDecorator，当时我们没有具体展开，今天就来一起看一下。</p>
<h4 data-nodeid="26398">1.EncryptSQLRewriteContextDecorator</h4>
<p data-nodeid="26399">EncryptSQLRewriteContextDecorator 实现如下所示：</p>
<pre class="lang-java" data-nodeid="26400"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptSQLRewriteContextDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SQLRewriteContextDecorator</span> </span>{

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EncryptRule encryptRule;

&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isQueryWithCipherColumn;

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decorate</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SQLRewriteContext sqlRewriteContext)</span> </span>{
&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp; <span class="hljs-comment">//参数改写</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">for</span> (ParameterRewriter each : <span class="hljs-keyword">new</span> EncryptParameterRewriterBuilder(encryptRule, isQueryWithCipherColumn).getParameterRewriters(sqlRewriteContext.getRelationMetas())) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (!sqlRewriteContext.getParameters().isEmpty() &amp;&amp; each.isNeedRewrite(sqlRewriteContext.getSqlStatementContext())) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; each.rewrite(sqlRewriteContext.getParameterBuilder(), sqlRewriteContext.getSqlStatementContext(), sqlRewriteContext.getParameters());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//SQLTokenGenerator 初始化</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sqlRewriteContext.addSQLTokenGenerators(<span class="hljs-keyword">new</span> EncryptTokenGenerateBuilder(encryptRule, isQueryWithCipherColumn).getSQLTokenGenerators());
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26401">我们还是来对比 ShardingSQLRewriteContextDecorator 类，会发现它与 EncryptSQLRewriteContextDecorator 类的结构完全一致。区别在于这里创建的 ParameterRewriterBuilder 和 SQLTokenGeneratorBuilder 分别是 EncryptParameterRewriterBuilder 和 EncryptTokenGenerateBuilder，而不是ShardingParameterRewriterBuilder 和 ShardingTokenGenerateBuilder。但这两组类的内部结构同样是完全一致的。</p>
<p data-nodeid="26402">在 EncryptParameterRewriterBuilder 内部，同样使用如下方法获取一组 ParameterRewriter：</p>
<pre class="lang-java" data-nodeid="26403"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> Collection&lt;ParameterRewriter&gt; <span class="hljs-title">getParameterRewriters</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection&lt;ParameterRewriter&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.add(<span class="hljs-keyword">new</span> EncryptAssignmentParameterRewriter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.add(<span class="hljs-keyword">new</span> EncryptPredicateParameterRewriter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.add(<span class="hljs-keyword">new</span> EncryptInsertValueParameterRewriter());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p data-nodeid="26404">接下来，我们先以 EncryptAssignmentParameterRewriter 为例来看用于数据脱敏的具体 ParameterRewriter 的实现机制。</p>
<h4 data-nodeid="26405">2.EncryptAssignmentParameterRewriter</h4>
<p data-nodeid="26406">EncryptAssignmentParameterRewriter 类完成在数据脱敏场景下对参数赋值过程的改写。我们首先注意到 EncryptAssignmentParameterRewriter 中存在一个 isNeedRewriteForEncrypt 方法用于判断是否需要改写。</p>
<pre class="lang-java" data-nodeid="26407"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNeedRewriteForEncrypt</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SQLStatementContext sqlStatementContext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> sqlStatementContext.getSqlStatement() <span class="hljs-keyword">instanceof</span> UpdateStatement
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; || sqlStatementContext <span class="hljs-keyword">instanceof</span> InsertSQLStatementContext &amp;&amp; sqlStatementContext.getSqlStatement().findSQLSegment(SetAssignmentsSegment.class).isPresent();
}
</code></pre>
<p data-nodeid="26408">这里的判断条件有两个，一个是 UpdateStatement，一个是 InsertSQLStatementContext（且其中的 SQLStatement 中包含 SetAssignmentsSegment）。我们知道在 SQL 语法中，INSERT 和 UPDATE 语句中都具有如下所示的 SET 赋值部分：</p>
<pre class="lang-xml" data-nodeid="26409"><code data-language="xml">SET userId = 1, task_name = 'taskName'
</code></pre>
<p data-nodeid="26410">EncryptAssignmentParameterRewriter 类针对的就是这种场景。我们来看它的 Rewrite 核心方法，如下所示：</p>
<pre class="lang-java" data-nodeid="26411"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rewrite</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ParameterBuilder parameterBuilder, <span class="hljs-keyword">final</span> SQLStatementContext sqlStatementContext, <span class="hljs-keyword">final</span> List&lt;Object&gt; parameters)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String tableName = sqlStatementContext.getTablesContext().getSingleTableName();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//获取 SetAssignmentsSegment 并进行遍历</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">for</span> (AssignmentSegment each : getSetAssignmentsSegment(sqlStatementContext.getSqlStatement()).getAssignments()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp; <span class="hljs-comment">//判断是否存在 ShardingEncryptor</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (each.getValue() <span class="hljs-keyword">instanceof</span> ParameterMarkerExpressionSegment &amp;&amp; getEncryptRule().findShardingEncryptor(tableName, each.getColumn().getName()).isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StandardParameterBuilder standardParameterBuilder = parameterBuilder <span class="hljs-keyword">instanceof</span> StandardParameterBuilder
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? (StandardParameterBuilder) parameterBuilder : ((GroupedParameterBuilder) parameterBuilder).getParameterBuilders().get(<span class="hljs-number">0</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <span class="hljs-comment">//对参数进行加密</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; encryptParameters(standardParameterBuilder, tableName, each, parameters);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26412">这里通过 getSetAssignmentsSegment 方法获取 SetAssignmentsSegment，实现过程就是根据 SQLStatement 类型分别获取 InsertStatement 和 UpdateStatement 中的 SetAssignment。</p>
<p data-nodeid="26413">然后，我们循环遍历每一个 SetAssignmentsSegment，针对表中的每一个 Column 判断是否存在 ShardingEncryptor，如果有的话就返回对应的加解密器。</p>
<p data-nodeid="26414">这部分判断工作就是在前面介绍的 EncryptRule 中完成，如下所示：</p>
<pre class="lang-java" data-nodeid="26415"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;ShardingEncryptor&gt; <span class="hljs-title">findShardingEncryptor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String logicTable, <span class="hljs-keyword">final</span> String logicColumn)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (!tables.containsKey(logicTable)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> Optional.absent();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional&lt;String&gt; encryptor = tables.get(logicTable).findShardingEncryptor(logicColumn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> encryptor.isPresent() ? Optional.of(encryptors.get(encryptor.get())) : Optional.&lt;ShardingEncryptor&gt;absent();
}
</code></pre>
<p data-nodeid="26416">然后我们获取 StandardParameterBuilder，并调用 encryptParameters 方法完成参数的数据脱敏操作，如下所示：</p>
<pre class="lang-java" data-nodeid="26417"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encryptParameters</span><span class="hljs-params">(<span class="hljs-keyword">final</span> StandardParameterBuilder parameterBuilder, <span class="hljs-keyword">final</span> String tableName, <span class="hljs-keyword">final</span> AssignmentSegment assignmentSegment, <span class="hljs-keyword">final</span> List&lt;Object&gt; parameters)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String columnName = assignmentSegment.getColumn().getName();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">int</span> parameterMarkerIndex = ((ParameterMarkerExpressionSegment) assignmentSegment.getValue()).getParameterMarkerIndex();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object originalValue = parameters.get(parameterMarkerIndex);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//通过 ShardingEncryptor 进行加密，并替换原来存储密文的 cipherColumn</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object cipherValue = getEncryptRule().getEncryptValues(tableName, columnName, Collections.singletonList(originalValue)).iterator().next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameterBuilder.addReplacedParameters(parameterMarkerIndex, cipherValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection&lt;Object&gt; addedParameters = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//如果存在 assistedQueryColumn，则添加辅助查询字段</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (getEncryptRule().findAssistedQueryColumn(tableName, columnName).isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object assistedQueryValue = getEncryptRule().getEncryptAssistedQueryValues(tableName, columnName, Collections.singletonList(originalValue)).iterator().next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addedParameters.add(assistedQueryValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//如果存在 plainColumn，则添加明文字段</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (getEncryptRule().findPlainColumn(tableName, columnName).isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addedParameters.add(originalValue);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (!addedParameters.isEmpty()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameterBuilder.addAddedParameters(parameterMarkerIndex + <span class="hljs-number">1</span>, addedParameters);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26418">这里的核心逻辑就是继续通过 EncryptRule 的 getEncryptValues 方法获取密文，然后通过获取具体的 ShardingEncryptor 并调用其方法完成这一操作，如下所示：</p>
<pre class="lang-java" data-nodeid="26419"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getEncryptValues</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String logicTable, <span class="hljs-keyword">final</span> String logicColumn, <span class="hljs-keyword">final</span> List&lt;Object&gt; originalValues)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">final</span> Optional&lt;ShardingEncryptor&gt; shardingEncryptor = findShardingEncryptor(logicTable, logicColumn);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Preconditions.checkArgument(shardingEncryptor.isPresent(), String.format(<span class="hljs-string">"Can not find ShardingQueryAssistedEncryptor by %s.%s."</span>, logicTable, logicColumn));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> Lists.transform(originalValues, <span class="hljs-keyword">new</span> Function&lt;Object, Object&gt;() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">apply</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object input)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == input ? <span class="hljs-keyword">null</span> : String.valueOf(shardingEncryptor.get().encrypt(input.toString()));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });
}
</code></pre>
<p data-nodeid="27896">关于 EncryptAssignmentParameterRewriter 的实现，这里面涉及的类也比较多，我们可以先来画张图作为后续讨论的基础，如下所示：</p>
<p data-nodeid="27897" class=""><img src="https://s0.lgstatic.com/i/image/M00/57/0A/CgqCHl9sS-OAJsx-AACWGMkVQXg279.png" alt="image (10).png" data-nodeid="27906"></p>





<h4 data-nodeid="26423">3.EncryptAssignmentTokenGenerator</h4>
<p data-nodeid="26424">讨论完 EncryptParameterRewriterBuilder 之后，我们再来讨论 EncryptTokenGenerateBuilder。这里，我们也是以 EncryptAssignmentTokenGenerator 为例来进行展开，在这个类中，核心方法是 generateSQLTokens，如下所示：</p>
<pre class="lang-java" data-nodeid="26425"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;EncryptAssignmentToken&gt; <span class="hljs-title">generateSQLTokens</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SQLStatementContext sqlStatementContext)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Collection&lt;EncryptAssignmentToken&gt; result = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String tableName = sqlStatementContext.getTablesContext().getSingleTableName();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//获取 SetAssignmentsSegment 并进行遍历</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">for</span> (AssignmentSegment each : getSetAssignmentsSegment(sqlStatementContext.getSqlStatement()).getAssignments()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <span class="hljs-comment">//判断是否存在 ShardingEncryptor</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <span class="hljs-keyword">if</span> (getEncryptRule().findShardingEncryptor(tableName, each.getColumn().getName()).isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-comment">//生成 SQLToken</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Optional&lt;EncryptAssignmentToken&gt; sqlToken = generateSQLToken(tableName, each);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (sqlToken.isPresent()) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.add(sqlToken.get());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p data-nodeid="26426">这里同样根据是否找到 ShardingEncryptor 来执行后续的 generateSQLToken 方法，该方法最终会调用类似如下所示的 generateLiteralSQLToken 方法：</p>
<pre class="lang-java" data-nodeid="26427"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> EncryptAssignmentToken <span class="hljs-title">generateLiteralSQLToken</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String tableName, <span class="hljs-keyword">final</span> AssignmentSegment assignmentSegment)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EncryptLiteralAssignmentToken result = <span class="hljs-keyword">new</span> EncryptLiteralAssignmentToken(assignmentSegment.getColumn().getStartIndex(), assignmentSegment.getStopIndex());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addCipherAssignment(tableName, assignmentSegment, result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addAssistedQueryAssignment(tableName, assignmentSegment, result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addPlainAssignment(tableName, assignmentSegment, result);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p data-nodeid="26428">以上面的 addCipherAssignment 方法为例，我们不难想象该方法通过调用 ShardingEncryptor 来完成了 CipherColumn 的设置。</p>
<pre class="lang-java" data-nodeid="26429"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCipherAssignment</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String tableName, <span class="hljs-keyword">final</span> AssignmentSegment assignmentSegment, <span class="hljs-keyword">final</span> EncryptLiteralAssignmentToken token)</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object originalValue = ((LiteralExpressionSegment) assignmentSegment.getValue()).getLiterals();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object cipherValue = getEncryptRule().getEncryptValues(tableName, assignmentSegment.getColumn().getName(), Collections.singletonList(originalValue)).iterator().next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; token.addAssignment(getEncryptRule().getCipherColumn(tableName, assignmentSegment.getColumn().getName()), cipherValue);
}
</code></pre>
<p data-nodeid="26430">至此，我们对 EncryptSQLRewriteContextDecorator 的介绍就告一段落，这部分内容可以结合 <strong data-nodeid="26540">“20 | 改写引擎：如何理解装饰器模式下的 SQL 改写实现机制？”</strong> 一起来看，以便加深理解。</p>
<h3 data-nodeid="26431">数据脱敏和结果归并</h3>
<p data-nodeid="26432">介绍完了 EncryptSQLRewriteContextDecorator 之后，接下来我们回到 EncryptStatement 类，继续探讨 getRewriteSQL 方法的后续流程。</p>
<p data-nodeid="26433">我们回到 EncryptStatement 的 executeQuery 方法，回顾如下语句：</p>
<pre class="lang-java" data-nodeid="26434"><code data-language="java">ResultSet resultSet = statement.executeQuery(getRewriteSQL(sql));
</code></pre>
<p data-nodeid="26435">我们通过执行 executeQuery 方法获取了 ResultSet，但并不是直接返回这个 resultSet 对象，而是需要对其进行封装，构建一个 EncryptResultSet 对象，如下所示：</p>
<pre class="lang-java" data-nodeid="26436"><code data-language="java"><span class="hljs-keyword">this</span>.resultSet = <span class="hljs-keyword">new</span> EncryptResultSet(connection.getRuntimeContext(), sqlStatementContext, <span class="hljs-keyword">this</span>, resultSet);
</code></pre>
<p data-nodeid="26437">EncryptResultSet 继承了 AbstractUnsupportedOperationResultSet 类，而 AbstractUnsupportedOperationResultSet 又继承了 AbstractUnsupportedUpdateOperationResultSet，这个 AbstractUnsupportedUpdateOperationResultSet 又继承了 WrapperAdapter 类并实现了 ResultSet 接口。所以 EncryptResultSet 也是一种适配器，这点和 EncryptDataSource、EncryptConnection 在本质上是一样的。</p>
<p data-nodeid="26438">对于 EncryptResultSet 而言，存在一大批 get 方法，我们都不需要专门进行介绍，关键点在于构造函数中的如下方法：</p>
<pre class="lang-dart" data-nodeid="26439"><code data-language="dart">mergedResult = createMergedResult(queryWithCipherColumn, resultSet);
</code></pre>
<p data-nodeid="26440">我们知道 ShardingSphere 中，执行引擎之后就是归并引擎，而在 EncryptResultSet 中我们就用到了归并引擎并生成了 MergedResult。</p>
<p data-nodeid="26441">EncryptResultSet 会先判断传入的 SQLStatement 是否是一种 DALStatement，如果是，则会调用 DALEncryptMergeEngine 完成结果归并；如果不是，则会使用 DQLEncryptMergeEngine，我们同样重点关注 DQLEncryptMergeEngine。</p>
<pre class="lang-java" data-nodeid="26442"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DQLEncryptMergeEngine</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MergeEngine</span> </span>{
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EncryptorMetaData metaData;
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MergedResult mergedResult;
&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> queryWithCipherColumn;

&nbsp;&nbsp;&nbsp; <span class="hljs-meta">@Override</span>
&nbsp;&nbsp;&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> MergedResult <span class="hljs-title">merge</span><span class="hljs-params">()</span> </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> EncryptMergedResult(metaData, mergedResult, queryWithCipherColumn);
&nbsp;&nbsp;&nbsp; }
}
</code></pre>
<p data-nodeid="26443">DQLEncryptMergeEngine 非常简单，其 merge 方法只是构建了一个 EncryptMergedResult 对象并进行返回。EncryptMergedResult 中核心方法 getValue 如下所示：</p>
<pre class="lang-java" data-nodeid="26444"><code data-language="java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> columnIndex, <span class="hljs-keyword">final</span> Class&lt;?&gt; type)</span> <span class="hljs-keyword">throws</span> SQLException </span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object value = mergedResult.getValue(columnIndex, type);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == value || !queryWithCipherColumn) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Optional&lt;ShardingEncryptor&gt; encryptor = metaData.findEncryptor(columnIndex);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="hljs-keyword">return</span> encryptor.isPresent() ? encryptor.get().decrypt(value.toString()) : value;
}
</code></pre>
<p data-nodeid="26445">显然，从上述流程中不难看出，数据脱敏模块中的归并实现实际上就是调用 ShardingEncryptor 的 decrypt 方法将加密列的密文解密成明文即可。</p>
<p data-nodeid="26446">这样整个 EncryptStatement 的 executeQuery 方法的整体流程就介绍完毕了，理解了这个方法的实现过程之后，对于 EncryptStatement 和 EncryptPreparedStatement 的其他方法而言，理解起来就比较容易了。</p>
<h3 data-nodeid="26447">从源码解析到日常开发</h3>
<p data-nodeid="26448">对于今天讨论的主题而言，能够直接应用到日常开发过程中的内容就是 ShardingEncryptor 的抽象过程，以及内部的加解密实现机制。ShardingSphere 使用了 DigestUtils 工具类来完成 MD5 算法的应用，以及 Base64 工具类来完成AES算法的实现。</p>
<p data-nodeid="26449">这两个工具类都可以完全照搬到我们自己的系统中，从而添加成熟的加解密算法实现方案。</p>
<h3 data-nodeid="26450">小结与预告</h3>
<p data-nodeid="26451">今天，我们讨论了 ShardingSphere 中实现数据脱敏机制的底层原理。我们发现数据脱敏模块同时依赖于分片引擎中的改写引擎和归并引擎这两大块内容，尤其是改写引擎在数据脱敏过程中起到了核心作用，通过补列的方式完成明文数据与密文数据之间的自动加解密，以及透明的 SQL 转换过程。</p>
<p data-nodeid="26452">这里留一道思考题：ShardingSphere 中，数据脱敏模块与改写引擎和归并引擎之间是怎么样的协作关系？欢迎你在留言区与大家讨论，我将逐一点评解答。</p>
<p data-nodeid="26453">在介绍完今天的数据脱敏机制之后，明天将介绍一个同样非常有用的编排和治理功能，我们将基于配置中心解析实现配置信息动态化管理的底层原理。</p>
<p data-nodeid="26454" class=""><a href="https://wj.qq.com/s2/7238084/d702/" data-nodeid="26562">课程评价入口，挑选 5 名小伙伴赠送小礼品~</a></p>

---

### 精选评论


