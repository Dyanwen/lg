<p data-nodeid="3">本讲是一题多解模块的最后一讲，之所以安排这一讲，是因为通常情况下，一道算法题目有多种的解法。我们与别人交流时，大家的思路和解题方法可能不同，每个人写出来的代码差异巨大。那么这些不同的<strong data-nodeid="176">正确解法</strong>，可以理解成“一题多解”吗？换句话说，你能分清什么是真正的“多解”，什么是“伪多解”吗？</p>
<p data-nodeid="4">通过这些“伪多解”，有助于我们看透题目的本质，从而掌握核心知识点，同时也可以降低我们需要理解和记忆的知识量。</p>
<p data-nodeid="5">所以，在本讲，你将掌握以下三种思考方法：</p>
<ul data-nodeid="6">
<li data-nodeid="7">
<p data-nodeid="8">如何通过“多解”看透知识点的本质（分清“伪多解”“真多解”）？</p>
</li>
<li data-nodeid="9">
<p data-nodeid="10">如何用多种技巧满足题目要求？</p>
</li>
<li data-nodeid="11">
<p data-nodeid="12">如何深挖题目特点，达到一题多解的目标？</p>
</li>
</ul>
<h3 data-nodeid="13">题目</h3>
<p data-nodeid="14">给定一系列的会议，时间间隔intervals，包括起始和结束时间<code data-backticks="1" data-nodeid="184">[[s``1``,e1],[s``2``,e2],``...``]````(``s``i &lt; ei)</code>，找到所需的最小的会议室数量。</p>
<p data-nodeid="15">输入：会议时间表 [[0, 30],[5, 10],[15, 20]]</p>
<p data-nodeid="16">输出：最少需要的会议室数量 2</p>
<blockquote data-nodeid="17">
<p data-nodeid="18">注意：如果有两个会议 [6,8] 和 [8,10]，我们认为这两个会议不冲突。</p>
</blockquote>
<h3 data-nodeid="19">特点 1：时间分布</h3>
<p data-nodeid="20">拿到这个题时，我们要特别注意一点：</p>
<blockquote data-nodeid="21">
<p data-nodeid="22">如果有两个会议，其中一个会议结束于时间点x，下一个会议同时从时间点y 开始，这两个会议可以用同一个会议室。也就是说，这两个时间段并不重合（虽然在时间点 x 相接）。</p>
</blockquote>
<p data-nodeid="23">我们从<strong data-nodeid="218">时间点</strong>出发来考虑这个问题，有以下 3 种情况。</p>
<h4 data-nodeid="24">情况 1：需 1 个会议室</h4>
<p data-nodeid="25">首先我们考虑一种简单的情况，假设会议与会议之间均没有重合的情况。比如输入如下：</p>
<blockquote data-nodeid="26">
<p data-nodeid="27">intervals=[0,1],[1,2],[2, 3]</p>
</blockquote>
<p data-nodeid="28">在下图中，x 轴表示会议的时间表，y 轴表示将哪些会议放在哪个会议室，蓝色、橘色和红色分别表示不同的会议。</p>
<p data-nodeid="4429" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3D/CC/CioPOWCWS3qAAHo4AADc4BKJoU0568.png" alt="Drawing 0.png" data-nodeid="4432"></p>




<p data-nodeid="32">在这种情况下，每个时间点只可以被染上一种颜色，时间衔接得非常好，此时只需要一个会议室。接下来我们再看一下衔接得不那么好的情况。</p>
<p data-nodeid="5685" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS4GAbC39AACrd4MbmYc760.png" alt="Drawing 2.png" data-nodeid="5688"></p>


<p data-nodeid="35">在这种情况下，每个时间点只可以被染上一种颜色，或者没有染上颜色，同样此时最多也只需要一个会议室。</p>
<p data-nodeid="36">不过，我们还需要处理一种很麻烦的情况，此时 [6, 8] 和 [8, 10] 两个会议的时间点都会将时间点 8 进行染色。那岂不是时间点 8 会有两种颜色？针对这种情况，我们在染色的时候，可以做一点更正。</p>
<blockquote data-nodeid="37">
<p data-nodeid="38">针对会议时间[start,end]染色时，只需要渲染[start,end)，不需要将end点进行染色。</p>
</blockquote>
<p data-nodeid="39">此时，即可满足：</p>
<blockquote data-nodeid="40">
<p data-nodeid="41">区间 [6,8)与区间[8,10)不相交。</p>
</blockquote>
<p data-nodeid="42">并且，我们不需要再对这种前后时间相接的情况做特殊判断。</p>
<h4 data-nodeid="43">情况 2：需 2 个会议室</h4>
<p data-nodeid="44">前面我们考虑的都是没有重合的情况，接下来，再看一下两个会议室 [0, 2) 和 [1, 4) 有重合的情况。</p>
<p data-nodeid="6933" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS4uACkpsAAE9Ulp4bYY214.png" alt="Drawing 4.png" data-nodeid="6936"></p>

<p data-nodeid="46">此时，只需要对 [0, 2) 和区间 [1, 4) 进行染色。我们发现，如果在时刻 1画一条竖线，会分别遇到两种颜色：蓝色和红色。</p>
<h4 data-nodeid="47">情况 3：需多个会议室</h4>
<p data-nodeid="48">前面考虑了需要 1 个和 2 个会议室的情况，接下来我们看一下稍微复杂一点的场景。</p>
<p data-nodeid="8175" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3D/C4/Cgp9HWCWS5KAbk7KAAMAlgj142s581.png" alt="Drawing 6.png" data-nodeid="8178"></p>


<p data-nodeid="10634" class="">通过画图可以发现规律，y 轴的会议室的数目与某个点染色的次数相关。那么，我们可以把这个题转换为一个<strong data-nodeid="10640">更加容易理解的题目</strong>：</p>


<blockquote data-nodeid="52">
<p data-nodeid="53">给定一个数组A[]，再给定一系列区间[start, end)，我们将此区间中A[start...end)都加上1。最后求数组 A[] 中的最大值。</p>
</blockquote>
<h4 data-nodeid="54">差分数组</h4>
<p data-nodeid="55">差分数组是一种求解区间累加的有效手段。我们先考虑只有一个区间 [start, end) 的情况。</p>
<p data-nodeid="56">一种暴力的写法是下面这样：</p>
<pre class="lang-java" data-nodeid="57"><code data-language="java"><span class="hljs-comment">// 给定数组A[]已经初始化为0</span>
<span class="hljs-comment">// 处理一个区间的情况</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) {
  A[i]++;
}
<span class="hljs-comment">// 这里是累加之后的A[]数组</span>
</code></pre>
<p data-nodeid="58">我们可以通过画图表示操作后的结果，如下图所示：</p>
<p data-nodeid="11859" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3D/CD/CioPOWCWS6CAMsbXAACSuolYP0Y214.png" alt="Drawing 8.png" data-nodeid="11862"></p>


<p data-nodeid="61">如果我们只关心每个时间点的涨幅与跌幅，那么可以对每个点进行标注，如下图所示：</p>
<p data-nodeid="13073" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3D/C4/Cgp9HWCWS6eAWdrcAACUf94Rarg748.png" alt="Drawing 10.png" data-nodeid="13076"></p>


<p data-nodeid="64">你可以按照如下操作，得到任意时刻的累计值（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="65"><code data-language="java"><span class="hljs-comment">// 给定数组A[]已初始化全为0</span>
<span class="hljs-comment">// 处理一个区间</span>
A[start] += <span class="hljs-number">1</span>;
A[end] -= <span class="hljs-number">1</span>;
<span class="hljs-comment">// 最后求前缀和，得到任意时刻的值</span>
pre = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) {
  pre += A[i];
  A[i] += pre;
}
</code></pre>
<p data-nodeid="66">无论是一个区间还是多个区间，我们都可以参考上述方式进行处理，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="67"><code data-language="java"><span class="hljs-comment">// 给定数组A[]已初始化全为0</span>
<span class="hljs-keyword">for</span> (Interval range: intervals) {
  A[range.start] += <span class="hljs-number">1</span>;
  A[range.end] -= <span class="hljs-number">1</span>;
}
<span class="hljs-comment">// 最后求前缀和，得到任意时刻的值</span>
pre = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; end; i++) {
  pre += A[i];
  A[i] += pre;
}
</code></pre>
<p data-nodeid="68">基于这个知识点，我还给你留了一个练习题。</p>
<p data-nodeid="69"><strong data-nodeid="360">练习题 1</strong>：假设你有一个长度为<code data-backticks="1" data-nodeid="346">n</code>的数组，数组的所有元素初始化为<code data-backticks="1" data-nodeid="348">0</code>，并且给定<code data-backticks="1" data-nodeid="350">k</code>个更新操作。每个更新操作表示为一个三元组：<code data-backticks="1" data-nodeid="352">[startIndex, endIndex, inc]</code>。这个更新操作给子数组<code data-backticks="1" data-nodeid="354">A[start``I``ndex````... endIndex]</code>（包括startIndex和endIndex）中的每一个元素增加<code data-backticks="1" data-nodeid="356">inc</code>。返回执行<code data-backticks="1" data-nodeid="358">k</code>个更新操作后的新数组。</p>
<blockquote data-nodeid="70">
<p data-nodeid="71">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="364">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="368">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/903.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="372">Python</a></p>
</blockquote>
<h4 data-nodeid="72">改进 1： 哈希表</h4>
<p data-nodeid="73">如果我们直接使用差分数组，好像无法直接破解这个题，因为题目中并没有约定所有整数的范围。比如，如果给定的某个会议时间段是 [0, 10000000000]，就无法直接申请 A[10000000000] 这么大的数组。</p>
<p data-nodeid="74">因此，我们还需要对差分数组做一点改进：可以尝试用哈希表来表示数组。</p>
<h4 data-nodeid="75">改进 2：范围</h4>
<p data-nodeid="76">在标准的差分数组中，我们需要返回的是一个操作之后的数组，也就是求出每一个 A[i] 的值。但是在这个题中，只需要拿到数组的最大值就可以了。因此，我们也没有必要求出每一个 A[i] 的值。</p>
<p data-nodeid="77">综上，可以写出基于差分数组的改进的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="78"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(Integer k)</span> </span>{
        <span class="hljs-keyword">return</span> containsKey(k) ? <span class="hljs-keyword">super</span>.get(k) : <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer k, <span class="hljs-keyword">int</span> v)</span> </span>{
        put(k, get(k) + v);
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> intervals: an array of meeting time intervals
   * <span class="hljs-doctag">@return</span>: the minimum number of conference rooms required
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(List&lt;Interval&gt; intervals)</span> </span>{
      <span class="hljs-comment">// Write your code here</span>
      <span class="hljs-comment">// 利用Hash表生成A[]数组</span>
      Counter A = <span class="hljs-keyword">new</span> Counter();
      <span class="hljs-keyword">for</span> (Interval range: intervals) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = range.start;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = range.end;
        A.add(start, <span class="hljs-number">1</span>);
        A.add(end, -<span class="hljs-number">1</span>);
      }
      List&lt;Integer&gt; idx = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(A.keySet());
      Collections.sort(idx);
      <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">for</span> (Integer i: idx) {
        pre += A.get(i);
        ans = Math.max(ans, pre);
      }
      <span class="hljs-keyword">return</span> ans;
  }
}
</code></pre>
<blockquote data-nodeid="16702">
<p data-nodeid="16703" class="">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="16707">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="16711">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%86.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="16715">Python</a></p>
</blockquote>



<p data-nodeid="81"><strong data-nodeid="420">复杂度分析</strong>：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。</p>
<p data-nodeid="82">我们发现，这个题目的考点就是在差分数组上的两点变化：</p>
<ul data-nodeid="83">
<li data-nodeid="84">
<p data-nodeid="85">利用哈希表表示数组；</p>
</li>
<li data-nodeid="86">
<p data-nodeid="87">由于只需要求最大值，因此我们求出区间端点的值就可以了。</p>
</li>
</ul>
<p data-nodeid="88">接下来，我们来看另外一种思路。</p>
<h3 data-nodeid="89">特点 2：变招 1</h3>
<p data-nodeid="90">我们继续讨论一下差分数组的解法。在本题中，我们需要的并不是一个标准的差分解法。经过分析之后，实际上只需要处理以下情况：</p>
<ul data-nodeid="91">
<li data-nodeid="92">
<p data-nodeid="93">给定区间 [start, end)；</p>
</li>
<li data-nodeid="94">
<p data-nodeid="95">只需要遇到 start 时 +1；</p>
</li>
<li data-nodeid="96">
<p data-nodeid="97">只需要遇到 end时 -1；</p>
</li>
<li data-nodeid="98">
<p data-nodeid="99">然后再利用累计求和的方式计算每个位置的值。</p>
</li>
</ul>
<p data-nodeid="100">在前面我们用了哈希数组的办法，那么，哈希数组就是必需的吗？</p>
<p data-nodeid="101">由于我们并不像差分数组一样返回操作之后的整个数组，而是返回最大值。因此只需要经过以下两步，就可以得到最大值。</p>
<ul data-nodeid="102">
<li data-nodeid="103">
<p data-nodeid="104">Step 1. 将所有的下标放到一个数组中，并且进行排序。</p>
</li>
<li data-nodeid="105">
<p data-nodeid="106">Step 2. 从头倒尾遍历下标，如果遇到区间的起始点，那么 +1；如果遇到区间的终点，那么 -1。</p>
</li>
</ul>
<p data-nodeid="107">操作伪代码如下：</p>
<pre class="lang-java" data-nodeid="108"><code data-language="java">item = [收集了所有的下标]
sort(item)
ans = <span class="hljs-number">0</span>
pre = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> 坐标 in item:
    <span class="hljs-keyword">if</span> 坐标是区间的起始点:
        pre += <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        pre -= <span class="hljs-number">1</span>
    ans = max(ans, pre)
<span class="hljs-keyword">return</span> ans
</code></pre>
<p data-nodeid="109">这里还有两个地方需要处理：</p>
<p data-nodeid="20278" class="">1 ) 如何判断经过排序之后的下标，是区间的终点还是一个区间的起始点？</p>



<p data-nodeid="113">解决方法：在放到 item 里面的时候，我们可以将起始点设置为正值，终点设置为负值。</p>
<p data-nodeid="21460" class="">2 ）如果经过排序之后的下标分了正负，那么一个区间的终点将会位于 x 轴的负半轴，起始点位于 x 轴的正半轴，这并没有按照原本的坐标排序。</p>


<p data-nodeid="115">解决方法：排序时，我们只需要按照下标的绝对值排序即可。</p>
<p data-nodeid="116">基于这样的处理技巧，可以写出代码如下：</p>
<pre class="lang-java" data-nodeid="117"><code data-language="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> intervals: an array of meeting time intervals
   * <span class="hljs-doctag">@return</span>: the minimum number of conference rooms required
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(List&lt;Interval&gt; intervals)</span> </span>{
    List&lt;Integer&gt; item = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    <span class="hljs-keyword">for</span> (Interval range: intervals) {
      item.add(range.start);
      item.add(<span class="hljs-number">0</span> - range.end);
    }
    Collections.sort(item, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer a, Integer b)</span> </span>{
          <span class="hljs-keyword">return</span> Math.abs(a) - Math.abs(b);
        }
    });
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; item.size(); i++) {
      <span class="hljs-keyword">if</span> (item.get(i) &gt;= <span class="hljs-number">0</span>) {
        pre++;
      } <span class="hljs-keyword">else</span> {
        pre--;
      }
      ans = Math.max(ans, pre);
    }
    <span class="hljs-keyword">return</span> ans;
  }
}
</code></pre>
<blockquote data-nodeid="26230">
<p data-nodeid="26231" class="">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="26235">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="26239">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%862.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="26243">Python</a></p>
</blockquote>




<p data-nodeid="120"><strong data-nodeid="466">复杂度分析</strong>：时间复杂度为 O(NlgN)，空间复杂度为 O(N)。</p>
<p data-nodeid="121">在这里，我们已经快找不到差分数组的影子了，但是本质上还是基于差分数组进行求解。那么，还有其他的解法吗？</p>
<h3 data-nodeid="122">特点 3：变招 2</h3>
<p data-nodeid="123">前面在处理区间的时候：是将所有区间的起始点标记为非负，区间的终点标记为负数；排序时按照绝对值进行排序。然后再利用<strong data-nodeid="474">差分数组的核心思想</strong>：遇到区间的起始点 +1；遇到区间的终点 -1。</p>
<p data-nodeid="124">那么还有没有其他的招法呢？我们再认真地研究一下这个题目，不难发现，破题的关键就在两处条件：</p>
<ol data-nodeid="28586">
<li data-nodeid="28587">
<p data-nodeid="28588" class="">需要将所有的坐标排序，并且需要知道每个坐标是属于一个区间的起始点还是终点。<strong data-nodeid="28596">即顺序遍历坐标，知道每个坐标是起始点还是终点</strong>；</p>
</li>
<li data-nodeid="28589">
<p data-nodeid="28590">利用差分数组的核心思想，然后求出最大值。</p>
</li>
</ol>


<p data-nodeid="130">根据条件 2，我们已知可以利用差分数组的思路，那么条件 1 这里还可以用别的方法吗？下面我们尝试完成条件 1 。</p>
<p data-nodeid="131">首先将所有区间的起始点坐标放到 starts 数组中，将所有区间的终点坐标放到 end 数组中。然后，再将 starts 和 end 采用<strong data-nodeid="495">合并排序</strong>的方法进行合并（注意，此时我们不是直接使用合并排序，准确来说是使用合并排序中的合并的技巧）。</p>
<p data-nodeid="132">此时，我们可以达成条件 1 的两个目的：</p>
<ul data-nodeid="133">
<li data-nodeid="134">
<p data-nodeid="135">顺序遍历每个坐标；</p>
</li>
<li data-nodeid="136">
<p data-nodeid="137">知道每个坐标是区间起始坐标，还是终点坐标。</p>
</li>
</ul>
<p data-nodeid="138">伪代码如下：</p>
<pre class="lang-java" data-nodeid="139"><code data-language="java">starts = [...区间的起始点...]
ends = [...区间的终点...]
sort(start);
sort(ends);
slen = len(starts)
elen = len(ends)
i = <span class="hljs-number">0</span>
j = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; slen || j &lt; elen:
    <span class="hljs-keyword">if</span> j &gt;= elen || i &lt; slen:
        遍历到了start[i]；并且我们知道这个坐标是区间的起始点
    <span class="hljs-keyword">else</span>:
        遍历到了end[i]；并且我们知道这个坐标是区间的终点
</code></pre>
<p data-nodeid="140">基于这样的思想，再加上我们的差分核心思路，那么就可以写出如下代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="141"><code data-language="java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">/**
     * <span class="hljs-doctag">@param</span> intervals: an array of meeting time intervals
     * <span class="hljs-doctag">@return</span>: the minimum number of conference rooms required
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(List&lt;Interval&gt; intervals)</span> </span>{
        <span class="hljs-comment">// Write your code here</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = intervals == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : intervals.size();
        <span class="hljs-keyword">int</span>[] start = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
        <span class="hljs-keyword">int</span>[] end = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (Interval range: intervals) {
          start[i] = range.start;
          end[i] = range.end;
          i++;
        }
        Arrays.sort(start);
        Arrays.sort(end);
        i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (i &lt; N || j &lt; N) {
          <span class="hljs-keyword">if</span> (j &gt;= N || i &lt; N &amp;&amp; start[i] &lt; end[j]) {
            <span class="hljs-comment">// 是个坐标的起始点</span>
            pre++;
            i++;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 是个坐标的终点</span>
            pre--;
            j++;
          }
          ans = Math.max(ans, pre);
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="142">
<p data-nodeid="143">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="504">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="508">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.%E5%B7%AE%E5%88%863.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="512">Python</a></p>
</blockquote>
<p data-nodeid="144"><strong data-nodeid="517">复杂度分析</strong>：时间复杂度为 O(NlgN)，空间复杂度为O(N)。</p>
<p data-nodeid="145">接下来，我们再看看有没有其他的解法。</p>
<h3 data-nodeid="146">特点 4：最少</h3>
<p data-nodeid="147">再回到原始题目，要想会议室最少，那么我们在拿到一个 meeting = [start,end] 的时候，尽量不去开新的会议室，而是<strong data-nodeid="530">选择一个已有会议结束时间</strong>&lt;= start 的会议室开会。</p>
<p data-nodeid="148">要做到这一点，我们需要记录每个会议室的结束时间；当给定 meeting = [start,end] 的时候，就需要找到一个 &lt;= start 的会议室提供给这个 meeting使用。</p>
<p data-nodeid="30910" class="">到这里，不知道你是否想起了我们在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="30914">《03 | 优先级队列：堆与优先级队列，筛选最优元素》</a>中介绍的“例 3”。我们可以把会议室也放到优先级队列中，每次总是取出结束时间最早的会议室。</p>


<p data-nodeid="150">由于给定的所有的 meeting 并没有排好序。因此，我们还需要做一点预处理——对 meeting进行排序。此时你还会面临一个问题，在排序的时候，meeting有 [start,end]，那么应该按照 start 值来排序，还是按照 end 来排序呢？</p>
<p data-nodeid="151">答案是按照 start 值来排序。因为我们在选择会议室的时候，需要两个输入，分别是 meeting 的开始时间 start 和会议室的结束时间。</p>
<p data-nodeid="152">基于这样的思想，我们就可以写出如下的代码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="153"><code data-language="java">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(List&lt;Interval&gt; intervals)</span> </span>{
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = intervals == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : intervals.size();
      
      <span class="hljs-comment">// 把所有的会议时间段都按start来排序</span>
      Collections.sort(intervals, <span class="hljs-keyword">new</span> Comparator&lt;Interval&gt;() {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Interval a, Interval b)</span> </span>{
          <span class="hljs-keyword">return</span> a.start - b.start;
        }
      });
      
      <span class="hljs-comment">// 这里要按照会议室的结束时间来排序</span>
      Queue&lt;Integer&gt; meetingRooms = 
          <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v1 - v2);
          
      <span class="hljs-keyword">for</span> (Interval meeting : intervals) {
        <span class="hljs-keyword">if</span> (!meetingRooms.isEmpty() &amp;&amp;
              meetingRooms.peek() &lt;= meeting.start) {
              
          <span class="hljs-comment">// 我们需要把这个会议室的结束时间修改一下</span>
          <span class="hljs-comment">// 当然，优先级队列里面是不好直接修改元素值的</span>
          <span class="hljs-comment">// 那我们只能采用先出队，再把当前会议结束时间入队的方式</span>
          meetingRooms.poll();
          meetingRooms.add(meeting.end);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 如果找不到会议室，那么新开一间</span>
          <span class="hljs-comment">// 标记其结束时间</span>
          meetingRooms.add(meeting.end);
        }
      }
      <span class="hljs-keyword">return</span> meetingRooms.size();
  }
}
</code></pre>
<blockquote data-nodeid="32048">
<p data-nodeid="32049" class="">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="32053">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="32057">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/919.%E4%BC%9A%E8%AE%AE%E5%AE%A4II.PQ.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="32061">Python</a></p>
</blockquote>

<p data-nodeid="156"><strong data-nodeid="581">复杂度分析</strong>：时间复杂度为O(NlgN)，空间复杂度为 O(N)。</p>
<h3 data-nodeid="157">总结</h3>
<p data-nodeid="158">最后，我将本讲用到的知识整理成在一张思维导图中，方便你复习。</p>
<p data-nodeid="33188" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3D/CD/CioPOWCWTAeAaIcSAAGls-nmvb0606.png" alt="Drawing 13.png" data-nodeid="33191"></p>


<p data-nodeid="161">通过总结我们发现，这个题目的核心解法实际上只有两种，但是基于差分方法又出现了三种“伪多解”的做法，我们一一进行了分析，透过代码，相信你也学会了如何运用多种技巧来满足题目的条件。</p>
<p data-nodeid="162">当然，在面试中，如果你遇到这道题之后，面试官有可能还会深入地问你一些问题，比如下面这道一个思考题。</p>
<p data-nodeid="163">题目仍然不变，要求输出最少会议室的个数，并且还要输出每个会议室里面召开哪些会议。</p>
<p data-nodeid="164">输入：会议时间表[[0,30],[5,10],[15,20]]</p>
<p data-nodeid="165">输出：最少需要的会议室数量 2，[[0,30]] 放到会议室 1，[[5,10], [15,20]] 放到会议室 2。</p>
<blockquote data-nodeid="166">
<p data-nodeid="167">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="627">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="631">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/21.Meets/ans.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="635">Python</a></p>
</blockquote>
<p data-nodeid="168">你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于这道会议室的题目就介绍到这里。接下来，下一讲介绍“22|数据结构模板：如何让解题变成搭积木？”，让我们继续前进。</p>

---

### 精选评论


