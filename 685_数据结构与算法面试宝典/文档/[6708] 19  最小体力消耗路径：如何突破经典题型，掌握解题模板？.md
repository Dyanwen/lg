<p data-nodeid="4">今天我们继续从多个角度去求解一个题目，尝试运用丰富的解题工具，比如我们的“老熟人”BFS/DFS/Dijkstra 算法，帮助你巩固和应用已经学习过的知识点。除此之外，本讲还会重点介绍一些在“一题多解”中尚未覆盖到的算法：</p>
<ul data-nodeid="5">
<li data-nodeid="6">
<p data-nodeid="7">并查集</p>
</li>
<li data-nodeid="8">
<p data-nodeid="9">二分搜索</p>
</li>
<li data-nodeid="10">
<p data-nodeid="11">动态规划（Bellman-Ford 算法）</p>
</li>
</ul>
<p data-nodeid="12">通过“一题多解”的训练，拓展我们的思维，一起去探索“五彩缤纷”的解题技巧。让我们马上开始。</p>
<h3 data-nodeid="13">题目</h3>
<p data-nodeid="14">你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。</p>
<ul data-nodeid="15">
<li data-nodeid="16">
<p data-nodeid="17">一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。</p>
</li>
<li data-nodeid="18">
<p data-nodeid="19">你每次可以往 上、下、左、右<strong data-nodeid="306">四个方向</strong>之一移动，你想要找到耗费体力最小的一条路径。</p>
</li>
</ul>
<p data-nodeid="20"><strong data-nodeid="323">一条路径耗费的体力值</strong>是由路径上相邻格子之间<strong data-nodeid="324">高度差绝对值</strong>的<strong data-nodeid="325">最大值</strong>决定的。请你返回从左上角走到右下角的最小体力消耗值 。矩阵中最大值不超过 10<sup>6</sup>。</p>
<p data-nodeid="21">例如给定如下地图：</p>
<p data-nodeid="5191" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuSAJ2gJAAPuzNBJ23A021.png" alt="Drawing 0.png" data-nodeid="5194"></p>

<p data-nodeid="23"><strong data-nodeid="347">输入</strong>：heights = [[1,2,2],[3,8,2],[5,3,5]]</p>
<p data-nodeid="24"><strong data-nodeid="352">输出</strong>：2</p>
<p data-nodeid="25"><strong data-nodeid="365">解释</strong>：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</p>
<p data-nodeid="26">注意：我们在处理这个题目的时候，一定要注意题目要求的结果是：</p>
<blockquote data-nodeid="27">
<p data-nodeid="28">从左上角走到右下，路径上<strong data-nodeid="380">高度差绝对值</strong>的<strong data-nodeid="381">最大值</strong>要<strong data-nodeid="382">最小</strong>。</p>
</blockquote>
<p data-nodeid="29">即不是求路径和，也不是求最短路径。</p>
<h3 data-nodeid="30">预处理</h3>
<p data-nodeid="31">当拿到这个题之后，我们发现，与脑海里熟悉的题目还是有点差异的。因此需要对题目进行一些预处理，尽量将题目转换成为我们熟悉的题目。</p>
<h4 data-nodeid="32">点的处理</h4>
<p data-nodeid="33">首先，如果我们把矩阵中的每个位置都当成一个图（算法中的图 Graph）中的一个点。那么可以将点表示如下：</p>
<p data-nodeid="7265" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbuuAUw3wAABvcGwSSqs667.png" alt="Drawing 1.png" data-nodeid="7268"></p>

<p data-nodeid="35">这里，为了表示方便，我们将每个点独立进行编号。当然，这种编号只是为了方便我们索引每个点的具体信息。</p>
<blockquote data-nodeid="36">
<p data-nodeid="37">如果我们想用一维数组存放点的信息，就需要将点编号为一维的整数。<br>
如果我们想用二维数组存放点的信息，就需要用 &lt;row, col&gt; 来表示一个点的编号。</p>
</blockquote>
<p data-nodeid="38">至于使用一维数组还是二维数组，要根据具体的算法和题目进行分析。我们来看下面两种情况。</p>
<ul data-nodeid="39">
<li data-nodeid="40">
<p data-nodeid="41">因为我们平常使用的并查集便是在一维数组上操作，那么把点编号为一维的整数无疑更方便。</p>
</li>
<li data-nodeid="42">
<p data-nodeid="43">DFS/BFS 遍历的时候，对于矩阵而言，二维的信息遍历时更方便，因此搜索时，我们经常使用 &lt;row, col&gt; 来表示一个点的编号。</p>
</li>
</ul>
<h4 data-nodeid="44">边的处理</h4>
<p data-nodeid="45">通常图的题目，都会直接给出边的 &lt;出发点，终点，权重&gt;，但是这道题却没有直接给出来。当然，在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="408">18 | 单词接龙：如何巧用深搜与广搜的变形？</a>”中，我们也遇到过没有直接给出边的信息的情况。当时的处理方式是采用“预处理”挖掘出图中边的信息。</p>
<p data-nodeid="46">于是，需要我们把这边的信息给挖掘出来。那么，在这个题中，边的信息是什么？根据题目的定义，当我们从结点 A&lt;r 行,c 列&gt; 走到结点 B&lt;nr 行, nc 列&gt; 的时候，消耗的体力值是：</p>
<blockquote data-nodeid="47">
<p data-nodeid="48">Math.abs(heights[r][c] - heights[nr][nc])</p>
</blockquote>
<p data-nodeid="49">因此，边可以表示为：</p>
<blockquote data-nodeid="50">
<p data-nodeid="51">edge = [&lt;r,c&gt; &lt;nr,nc&gt;, cost]<br>
cost = Math.abs(heights[r][c] - heights[nr][nc])</p>
</blockquote>
<p data-nodeid="52">加上边之后，图问题就可以表示如下：</p>
<p data-nodeid="9339" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbvSAD3NzAAB-KL3zX7g895.png" alt="Drawing 2.png" data-nodeid="9342"></p>

<p data-nodeid="54">根据上述分析，题目就可以转换成我们非常熟悉的题目：</p>
<blockquote data-nodeid="55">
<p data-nodeid="56">给定图的点和边，以及出发点和终点，找出一条路径，使得这条路径上边的权重的最大值尽可能最小。输出这个最小值。</p>
</blockquote>
<h3 data-nodeid="57">特点 1：连通性</h3>
<p data-nodeid="58">题目要求找一个最小的值 ans，并且出发点和终点必须在一条路径上，这条路径上所有的边的权重都 &lt;= ans。</p>
<p data-nodeid="59">那么反过来说，如果我们把权重大于 ans 的边都删除，出发点与终点的这条路径仍然是存在的。</p>
<p data-nodeid="11413" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbvuAHbqbAATbsJyOIcc083.png" alt="Drawing 3.png" data-nodeid="11416"></p>

<p data-nodeid="61">既然如此，那么我们采用如下动图所示的方式应该也可以工作：</p>
<p data-nodeid="13487" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbwOAWL-qAAv2KyBnV5o934.gif" alt="1.gif" data-nodeid="13490"></p>


<p data-nodeid="64">通过这种方式，我们需要解决的问题，可以表示如下：</p>
<ol data-nodeid="65">
<li data-nodeid="66">
<p data-nodeid="67">取出所有的边，并且按权重排序（因为我们要按权重加入图）；</p>
</li>
<li data-nodeid="68">
<p data-nodeid="69">当加入一条边之后，我们需要查看一下图中的两点是否连通。</p>
</li>
</ol>
<p data-nodeid="70">其中第一个问题比较容易处理。现在问题的核心与重点就是需要<strong data-nodeid="481">尽快判断两个点是否连通</strong>。</p>
<p data-nodeid="71">根据我们之前学过的知识，判断图中两个点是否连通，可以使用：</p>
<ul data-nodeid="72">
<li data-nodeid="73">
<p data-nodeid="74">并查集</p>
</li>
<li data-nodeid="75">
<p data-nodeid="76">BFS</p>
</li>
<li data-nodeid="77">
<p data-nodeid="78">DFS</p>
</li>
</ul>
<p data-nodeid="79">但是，BFS/DFS 如果需要每加入一条边都进行判断，很明显是不适合的。当有一个 N x N 的矩阵，每次 BFS/DFS 的时间复杂度为 O(N x N)，整个算法的时间复杂度就达到 O(E x N x N)。</p>
<p data-nodeid="80">那么只能使用并查集，因为我们知道，并查集检查两个点是否连通的时候，时间杂度可以达到 O(lgN)。因此，这里我们需要使用并查集来判断出发点与终点的连通性。</p>
<p data-nodeid="81">至此，我们可以写出伪代码如下：</p>
<pre class="lang-java" data-nodeid="82"><code data-language="java">edges = getAllEdges();
sort(edges);
<span class="hljs-keyword">for</span> edge in edges:
     addEdge(edge);
     <span class="hljs-keyword">if</span> (connected(start, endNode)):
       <span class="hljs-keyword">return</span> edge.cost;
</code></pre>
<p data-nodeid="83">有了以上的思路，我们就可以写出并查集的求解代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="84"><code data-language="java"><span class="hljs-comment">// 并查集类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    Init(n);
  }
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      F[i] = i;
    }
  }
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == F[x]) {
      <span class="hljs-keyword">return</span> x;
    }
    F[x] = Find(F[x]);
    <span class="hljs-keyword">return</span> F[x];
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
    F[Find(x)] = Find(y);
  }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
</span>{
  <span class="hljs-comment">// 行数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 列数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 四个方向</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
                           { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
  
  <span class="hljs-comment">// 由于并查集是一维的，我们需要将二维的点映射到</span>
  <span class="hljs-comment">// 一维的点</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPointMapping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
    <span class="hljs-keyword">return</span> r * Cols + c;
  }
  <span class="hljs-comment">// 这个函数并不是把edge加到图中，而是在收集一条边</span>
  <span class="hljs-comment">// edge: startNode = &lt;r,c&gt;, toNode=&lt;nr,nc&gt;, cost</span>
  <span class="hljs-comment">// 加入边数组中</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] edges,
                       <span class="hljs-keyword">int</span> iter,
                       <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c,
                       <span class="hljs-keyword">int</span> nr, <span class="hljs-keyword">int</span> nc,
                       <span class="hljs-keyword">int</span> cost)</span> </span>{
    edges[iter][<span class="hljs-number">0</span>] = getPointMapping(r, c);
    edges[iter][<span class="hljs-number">1</span>] = getPointMapping(nr, nc);
    edges[iter][<span class="hljs-number">2</span>] = cost;
  }
  <span class="hljs-comment">// 处理的主函数</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// 收集行数</span>
    Rows = heights.length;
    <span class="hljs-comment">// 收集列数</span>
    Cols = heights[<span class="hljs-number">0</span>].length;
   
    <span class="hljs-comment">// 如果只有一个点</span>
    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
   
    <span class="hljs-comment">// 采用并查集的做法</span>
    <span class="hljs-comment">// 横向的无向边的数目</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hNumber = Rows * (Cols - <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 纵向的无向边的数目</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> vNumber = Cols * (Rows - <span class="hljs-number">1</span>);
    
    <span class="hljs-comment">// 无向边</span>
    <span class="hljs-comment">// 记录起点，终点，权重</span>
    <span class="hljs-keyword">int</span>[][] edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[hNumber + vNumber][<span class="hljs-number">3</span>];
    
    <span class="hljs-comment">// 得到所有的边</span>
    <span class="hljs-keyword">int</span> edgeIter = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
        <span class="hljs-comment">// 看一下 右边的点</span>
        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; Cols) {
          <span class="hljs-comment">// 得到边的权重</span>
          <span class="hljs-keyword">int</span> edgeCost =
            Math.abs(heights[r][c] - heights[r][c + <span class="hljs-number">1</span>]);
          <span class="hljs-comment">// 将边放到边集中</span>
          putEdge(edges, edgeIter,
            r, c, r, c + <span class="hljs-number">1</span>, edgeCost);
          
          edgeIter++;
        }
        
        <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; Rows) {
          <span class="hljs-comment">// 得到一条向下的边的权重</span>
          <span class="hljs-keyword">int</span> edgeCost =
            Math.abs(heights[r][c] - heights[r + <span class="hljs-number">1</span>][c]);
          <span class="hljs-comment">// 将边放到边集中</span>
          putEdge(edges, edgeIter,
            r, c, r + <span class="hljs-number">1</span>, c, edgeCost);
            
          edgeIter++;
        }
      }
    }
    
    <span class="hljs-comment">// 再将边进行排序</span>
    Arrays.sort(edges, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
      }
    });
    
    <span class="hljs-comment">// 排序结束之后，再使用并查集，依次加入边</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> totalNodes = Rows * Cols;
    
    <span class="hljs-comment">// 并查集</span>
    UnionFind uf = <span class="hljs-keyword">new</span> UnionFind(totalNodes);
    
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> src = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> dst = getPointMapping(Rows - <span class="hljs-number">1</span>, Cols - <span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) {
      uf.Union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]);
      <span class="hljs-comment">// 如果能让 src dst连通</span>
      <span class="hljs-comment">// 那么就是当前的cost</span>
      <span class="hljs-keyword">if</span> (uf.Find(src) == uf.Find(dst)) {
        <span class="hljs-keyword">return</span> edge[<span class="hljs-number">2</span>];
      }
    }
    
    <span class="hljs-keyword">assert</span> <span class="hljs-number">0</span> &gt; -<span class="hljs-number">1</span>; <span class="hljs-comment">// Should not reach here!</span>
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
}
</code></pre>
<blockquote data-nodeid="85">
<p data-nodeid="86">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="493">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="497">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="501">Python</a></p>
</blockquote>
<p data-nodeid="87"><strong data-nodeid="506">复杂度分析</strong>：一个 N x M 的数组，可以认为一共有 O(N x M) 条边，收集到这些边之后，然后进行排序，排序的时间复杂度为 O(N x M x lg(N x M))，存放边的空间复杂度为 O(N x M)。接下来，我们需要利用并查集进行处理，一共有 O(N x M) 个点，O(N x M) 条边。那么并查集处理的时间复杂度为 O(N x M x lg(N x M))。所以，整个问题时间复杂度为 O(N x M x lg(N x M))，空间复杂度为 O(N x M)。</p>
<p data-nodeid="88">当你看完这个题，你还可以回过头去看看“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6696&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="510">07 | 并查集：如何利用两行代码写并查集？</a>”里面的例 1，在那里，我们同样用到了相同的方法进行处理——最小生成树的思想。通过这些比较，可以发现我们可以通过掌握一种算法思想，在不同的题目中游刃有余。</p>
<h3 data-nodeid="89">特点 2：最小值</h3>
<p data-nodeid="90">我们再回到题目，题目要求的是最小值。那么我们想一想：最小值 ans 肯定是一个分界，这个分界体现在两个方向：</p>
<ul data-nodeid="91">
<li data-nodeid="92">
<p data-nodeid="93">比 ans 更小的值，不会让出发点和终点之间可以连通；</p>
</li>
<li data-nodeid="94">
<p data-nodeid="95">大于等于 ans 的值，那么肯定可以让出发点与终点可以连通。</p>
</li>
</ul>
<p data-nodeid="96">如果我们用数组进行表示，那么可以达到如下图所示的效果：</p>
<p data-nodeid="15557" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/91/Cgp9HWCLbxKAEgdXAAA4xI3NFuI649.png" alt="Drawing 5.png" data-nodeid="15560"></p>

<p data-nodeid="98">如果我们分别用 -1 表示 NO，0 表示 OK。那么问题转变成下面这样：</p>
<p data-nodeid="17627" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyKAejCRAAA2P_x4DC8327.png" alt="Drawing 6.png" data-nodeid="17630"></p>

<p data-nodeid="100">我们需要在一个左边为 -1，右边为 0 的数组中，找到第一个为 0 的下标的位置。那么，最适合解决这个问题的算法就是<strong data-nodeid="529">二分搜索</strong>了。</p>
<h4 data-nodeid="101">四步法</h4>
<p data-nodeid="102">现在算法方向已经确定了，是时候拿出我们的“二分搜索四步法”了。如果你对这个方法还不太熟悉，可以先回到“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6698&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="534">09 | 二分搜索：为什么说有序皆可用二分？</a>”复习一下二分搜索的内容，再来看接下来的分析。</p>
<ul data-nodeid="103">
<li data-nodeid="104">
<p data-nodeid="105"><strong data-nodeid="540">第一步</strong>：要什么，什么就是 x。</p>
</li>
<li data-nodeid="106">
<p data-nodeid="107"><strong data-nodeid="545">第二步</strong>：满足约束条件的 f(x) = 0。</p>
</li>
<li data-nodeid="108">
<p data-nodeid="109"><strong data-nodeid="554">第三步</strong>：<strong data-nodeid="555">不满足</strong>约束条件的 f(x) 设置为 -1 或者 1。</p>
</li>
<li data-nodeid="110">
<p data-nodeid="111"><strong data-nodeid="563">第四步</strong>：最优解 0 在 C[] 的最左边还是最右边，决定使用 lowerBound 还是 upperBound。</p>
</li>
</ul>
<p data-nodeid="112">接下来，我们一步一步展开。</p>
<p data-nodeid="113"><strong data-nodeid="568">第一步</strong></p>
<p data-nodeid="114">我们的问题是要输出一个最小体力消耗值，也就是 x。确定 x 之后，我们还需要确定 x 的范围。在这个题中，所有的边都加上之后，出发点与终点是肯定有路径的。所以 x 的范围就确定了：</p>
<ul data-nodeid="115">
<li data-nodeid="116">
<p data-nodeid="117">x 的最小值，就是图中边的权重的最小值</p>
</li>
<li data-nodeid="118">
<p data-nodeid="119">x 的最大值，就是图中边的权重的最大值</p>
</li>
</ul>
<p data-nodeid="120"><strong data-nodeid="575">第二步</strong></p>
<p data-nodeid="121">这里需要确定 f(x) = 0。根据题意，当我们得到最小消耗的体力值 x 之后，在遍历图的时候，当发现边的权重大于 x，直接把这条边禁用即可。当发现出发点与终点之间存在通路，我们就可以认为 f(x) = 0。</p>
<p data-nodeid="122"><strong data-nodeid="580">第三步</strong></p>
<p data-nodeid="123">得到最小消耗体力值 x 之后，在遍历时，把权重大于 x 的边禁用，如果发现出发点与终点之间不存在通路，此时设置 f(x) = -1。</p>
<p data-nodeid="124">在这个题中，由于出发点与终点只有连通与不连通两种情况。所以我们“二分搜索”映射之后的数组里面只会有 -1 和 0。</p>
<p data-nodeid="125"><strong data-nodeid="586">第四步</strong></p>
<p data-nodeid="19697">在本题中，当映射到一个数组之后，我们要求的是满足 f(x) = 0 的最小值。</p>
<p data-nodeid="19698" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbyyALJXRAAA2NUdivXw497.png" alt="Drawing 7.png" data-nodeid="19702"></p>


<p data-nodeid="128">也就是求数组中值为 0 的第一个下标，那么肯定应该使用 lowerBound。</p>
<h4 data-nodeid="129">f 函数</h4>
<p data-nodeid="130">根据前面四步分析法，我们已经可以写出二分搜索的伪代码了：</p>
<pre class="lang-java" data-nodeid="131"><code data-language="java">l = minCost
r = maxCost
<span class="hljs-keyword">while</span> l &lt; r:
    mid = l + ((r-l)&gt;&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">// mid表示x</span>
    mv = f(mid) <span class="hljs-comment">// 调用f(x)</span>
    <span class="hljs-keyword">if</span> (mv &lt; <span class="hljs-number">0</span>):
        l = mid + <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        r = mid
</code></pre>
<p data-nodeid="132">不过在正式写代码之前，还是要想一下 f 函数如何写。我们可以先回想一下 f(x) 要解决的问题：</p>
<blockquote data-nodeid="133">
<p data-nodeid="134">禁用所有权重大于 x 的边之后，图中出发点与终点之间是否还有路径。</p>
</blockquote>
<p data-nodeid="135">我们可以把禁用权重大于 x 的边，看成是利用一个旧图，生成了一张新图。比如：</p>
<p data-nodeid="21769" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9A/CioPOWCLbzOAbNdGAACu5sMfhbM647.png" alt="Drawing 8.png" data-nodeid="21772"></p>

<p data-nodeid="137"><strong data-nodeid="604">那么 f(x) 的本质就是在一个新图上判断两点之间的连通性</strong>。关于连通性的判定，我们前面提到过，有 3 种办法：</p>
<ul data-nodeid="138">
<li data-nodeid="139">
<p data-nodeid="140">并查集</p>
</li>
<li data-nodeid="141">
<p data-nodeid="142">BFS</p>
</li>
<li data-nodeid="143">
<p data-nodeid="144">DFS</p>
</li>
</ul>
<p data-nodeid="145">在特点 1 中，我们说明了只能选用并查集，不能使用 BFS 与 DFS，还给出了时间复杂度上的证明。在这里，恰恰相反，三种办法都是可以使用的。下面我们一起证明一下。</p>
<p data-nodeid="146">假设给定了 N x M 大小的矩阵。</p>
<ul data-nodeid="147">
<li data-nodeid="148">
<p data-nodeid="149">并查集：一共有 O(N x M) 条边，时间复杂度主要由并查集的 Union 决定，一共需要 Union O(N x M) 次，每次 Union 时间复杂度为 O(lg(N x M)（因为一共有 O(N x M) 个点）。所以总共的时间复杂度为 O(N x M lg(N x M))。</p>
</li>
<li data-nodeid="150">
<p data-nodeid="151">BFS：一共有 O(N x M) 个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N x M)。</p>
</li>
<li data-nodeid="152">
<p data-nodeid="153">DFS：一共有 O(N x M) 个点，最差情况下，每个点都会遍历，所以时间复杂度为 O(N x M)。</p>
</li>
</ul>
<p data-nodeid="154">也就是说，f(x) 函数的时间复杂度都差不多（并查集多了一个 O(lg)）。</p>
<p data-nodeid="155">如果再算上最外层二分搜索的时间复杂度，由于最大的数为 10<sup>6</sup>，所以整个二分搜索的时间复杂度为：</p>
<ul data-nodeid="156">
<li data-nodeid="157">
<p data-nodeid="158">O(lg(10<sup>6</sup>) N x M)  ← 二分 + BFS/DFS；</p>
</li>
<li data-nodeid="159">
<p data-nodeid="160">或者 O(lg(10<sup>6</sup>) N x M x lg (N x M)) ← 二分 + 并查集。</p>
</li>
</ul>
<p data-nodeid="161">基于这样的思路，我们就可以写出二分搜索的代码了（二分搜索 + DFS）：</p>
<pre class="lang-java" data-nodeid="162"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-comment">//  二分搜索</span>
  <span class="hljs-comment">// 行数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 列数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 一个点周围的四个方向</span>
  <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> }, { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
  
  <span class="hljs-keyword">boolean</span>[][] vis = <span class="hljs-keyword">null</span>;
  
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clearVisRecord</span><span class="hljs-params">()</span>
  </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
        vis[r][c] = <span class="hljs-keyword">false</span>;
      }
    }
  }
  
  <span class="hljs-comment">// 这里采用DFS来寻路</span>
  <span class="hljs-comment">// &lt;r,c&gt;是当前的出发点</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights, <span class="hljs-keyword">int</span> maxValue,
                      <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>{
    <span class="hljs-comment">// 如果已经走到了目标点&lt;rows-1, cols-1&gt;</span>
    <span class="hljs-keyword">if</span> (r == Rows - <span class="hljs-number">1</span> &amp;&amp; c == Cols - <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    
    <span class="hljs-comment">// 查看 &lt;r,c&gt;点的四周</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
      
      <span class="hljs-comment">// 如果周边的点有效，并且没有被访问过</span>
      <span class="hljs-keyword">if</span> ((!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= Rows || nc &gt;= Cols))
           &amp;&amp; !vis[nr][nc]) {
           
        <span class="hljs-comment">// 获取边的代价</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cost =
            Math.abs(heights[r][c] - heights[nr][nc]);
            
        <span class="hljs-comment">// 在走的时候，如果比midValue大，那么这条路就不能走了</span>
        <span class="hljs-keyword">if</span> (cost &lt;= maxValue) {
          vis[nr][nc] = <span class="hljs-keyword">true</span>;
          <span class="hljs-keyword">if</span> (dfs(heights, maxValue, nr, nc)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
          }
        }
        
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
  }
  
  <span class="hljs-comment">// f(x)函数</span>
  <span class="hljs-comment">// 重新映射之的一维数组</span>
  <span class="hljs-comment">// midValue是在二分的时候给定的值</span>
  <span class="hljs-comment">// 我们在进行搜索的时候，路径上的绝对值不能比这个大</span>
  <span class="hljs-comment">// 只能是 &lt;= midValue.</span>
  <span class="hljs-comment">// 此时我们只需要寻找看看是否存在一条路径即可</span>
  <span class="hljs-comment">// 如果存在一条路径，上面的绝对值 &lt;= midValue</span>
  <span class="hljs-comment">// 那么满足条件-&gt; 返回0</span>
  <span class="hljs-comment">// 如果没有这样的路径，那么返回-1</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights, <span class="hljs-keyword">int</span> midValue)</span> </span>{
    clearVisRecord();
    vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">return</span> dfs(heights, midValue, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : -<span class="hljs-number">1</span>;
  }
  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    Rows = heights.length;
    Cols = heights[<span class="hljs-number">0</span>].length;
    
    <span class="hljs-comment">// if just one node</span>
    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 生成vis数组</span>
    vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[Rows][Cols];
    
    <span class="hljs-comment">// 二分搜索</span>
    <span class="hljs-comment">// 找到搜索范围里：最大值/最小值</span>
    <span class="hljs-keyword">int</span> minCost = Integer.MAX_VALUE;
    <span class="hljs-keyword">int</span> maxCost = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
        <span class="hljs-comment">// 看一下 右边的点</span>
        <span class="hljs-keyword">if</span> (c + <span class="hljs-number">1</span> &lt; Cols) {
          <span class="hljs-keyword">int</span> rightValue =
              Math.abs(heights[r][c] - heights[r][c + <span class="hljs-number">1</span>]);
          minCost = Math.min(minCost, rightValue);
          maxCost = Math.max(maxCost, rightValue);
        }
        <span class="hljs-keyword">if</span> (r + <span class="hljs-number">1</span> &lt; Rows) {
          <span class="hljs-keyword">int</span> downValue =
              Math.abs(heights[r][c] - heights[r + <span class="hljs-number">1</span>][c]);
          minCost = Math.min(minCost, downValue);
          maxCost = Math.max(maxCost, downValue);
        }
      }
    }
    
    <span class="hljs-comment">// 那么应该有一个值 target</span>
    <span class="hljs-comment">// 当 路径的最大绝对值差为 x</span>
    <span class="hljs-comment">// 并且 x &gt;= target的时候</span>
    <span class="hljs-comment">// 总是可以走通的</span>
    <span class="hljs-comment">// 所以我们二分搜索的范围就为[minCost, maxCost + 1)</span>
    <span class="hljs-comment">// 我们定义-1: 表示左上角与右下有没有通路</span>
    <span class="hljs-comment">//        0: 表示左上角与右下角有通路</span>
    <span class="hljs-comment">// 那么形成的C数组就是[-1,-1,-1,-1, 0, 0, 0, 0]</span>
    <span class="hljs-comment">// 这样的结构</span>
    <span class="hljs-comment">// 因此，我们在利用二分搜索的时候，只需要找到最左边的</span>
    <span class="hljs-comment">// 0的位置就可以了。</span>
    <span class="hljs-keyword">int</span> l = minCost, r = maxCost + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (l &lt; r) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mv = getC(heights, mid);
      <span class="hljs-keyword">if</span> (mv &lt; <span class="hljs-number">0</span>) {
        l = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        r = mid;
      }
    }
    <span class="hljs-keyword">return</span> l;
  }
}
</code></pre>
<blockquote data-nodeid="163">
<p data-nodeid="164">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="633">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="637">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="641">Python</a></p>
</blockquote>
<p data-nodeid="165"><strong data-nodeid="650">复杂度分析</strong>：时间复杂度O(lg(10<sup>6</sup>) N x M)，空间复杂度为O(N x M)。</p>
<p data-nodeid="166"><strong data-nodeid="655">练习题 1</strong>：在文中，我们已经证明了这道题还可以使用二分搜索 + BFS / 并查集来解决。你能写一下代码吗？</p>
<blockquote data-nodeid="167">
<p data-nodeid="168">二分 + BFS：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="659">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="663">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="667">Python</a><br>
二分 + 并查集：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="672">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="676">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="680">Python</a></p>
</blockquote>
<h3 data-nodeid="169">特点 3：再看最小值</h3>
<p data-nodeid="170">谈到图中两点之间路径的最小值，有没有觉得很熟悉？我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="685">18 | 单词接龙：如何巧用深搜与广搜的变形？</a>”中刚刚介绍过“<strong data-nodeid="691">求解两个点的最短路径</strong>”的方法：</p>
<ul data-nodeid="171">
<li data-nodeid="172">
<p data-nodeid="173">两点之间的最短路径（BFS 算法/Dijkstra 算法/BF 算法，即 Bellman-Ford 算法）；</p>
</li>
<li data-nodeid="174">
<p data-nodeid="175">一个点到其他所有点的最短路径（Dijkstra 算法/BF 算法）；</p>
</li>
<li data-nodeid="176">
<p data-nodeid="177"><strong data-nodeid="698">每两点</strong>之间的最短路径（Floyd 算法）。</p>
</li>
</ul>
<p data-nodeid="23839" class="">在这里，<strong data-nodeid="23849">一个点到其他所有点的最短路径</strong>当然是包含了“两点之间的最短路径”的情况。所以后面我们在讨论的时候，都是<strong data-nodeid="23850">一个点到其他所有点的最短路径</strong>场景下的 BF 算法。</p>

<p data-nodeid="179">下面尝试一下 BF 算法（我们讲的场）。在“1<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="716">8 | 单词接龙：如何巧用深搜与广搜的变形？</a>”的“练习题 1”里提到了可以用 BF 算法进行求解，但是没有详细介绍如何用 BF 算法。这里我们详细介绍一下。</p>
<p data-nodeid="180">如果直接看BF 算法的代码，容易看得一头雾水，但其实这是一种比较容易理解的算法。在拿出BF算法的模板代码前，我们先讲一下这个算法的本质（下图中橙色点表示出发点）。注意：是<strong data-nodeid="723">本质</strong>！并不完全是一个计算过程的模拟。</p>
<p data-nodeid="25911" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLclCAcTHPAACthA1b_fY994.png" alt="Drawing 9.png" data-nodeid="25914"></p>

<p data-nodeid="182">Step 0. 首先我们有一些离散的点， 此时还没有加入任何边。</p>
<p data-nodeid="27975" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcluAc9DMAADTk0wp1dQ877.png" alt="Drawing 10.png" data-nodeid="27978"></p>

<p data-nodeid="184">Step 1. 把<strong data-nodeid="740">所有的边</strong>加入图中。只有一部分点（绿色）会在这一轮迭代中得到<strong data-nodeid="741">最终的</strong>src 出发的最短路径。</p>
<blockquote data-nodeid="185">
<p data-nodeid="186">注意：有一些点，经过这一轮的操作之后，虽然会与出发点 src 连通，但并没有得到<strong data-nodeid="747">最终</strong>最短路径，在图中我们就没有画出这些点与 src 的连线。</p>
</blockquote>
<p data-nodeid="187">此时，我们可以再次从绿色点（因为它们已经是<strong data-nodeid="753">最终的</strong>最短路径了）出发，如果再次利用所有的边，应该可以再更新一波，得到一些新的最短路径的点。</p>
<p data-nodeid="30039" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcmKAARFYAADrQRM28nQ863.png" alt="Drawing 11.png" data-nodeid="30042"></p>

<p data-nodeid="189">Step 2. 再次把所有的边加入图中，得到第二波最短路径的点（紫色）。</p>
<p data-nodeid="32103" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcmmAPC1XAAD3iedUdk4707.png" alt="Drawing 12.png" data-nodeid="32106"></p>

<p data-nodeid="191">Step 3: 如果我们再从紫色点出发，把所有的边加到图中，那么可以得到最后一波最短路径的点（红色）。</p>
<p data-nodeid="192">这里只是假设更新 3 次就结束了，实际上有可能更多。那么问题来了，到底要把所有的边用来更新多少次呢？</p>
<p data-nodeid="193">这里可以有两种办法。</p>
<ul data-nodeid="194">
<li data-nodeid="195">
<p data-nodeid="196">积极的办法：当发现不能更新出一波新的最短路径的点的时候，就应该停止了。</p>
</li>
<li data-nodeid="197">
<p data-nodeid="198">消极的办法：假设每一波最差情况下只有一个点得到了最终的最短路径，那么一共需要更新 N-1 轮（在有 N 个点的情况下）。</p>
</li>
</ul>
<p data-nodeid="199">那么问题的时间复杂度为 O(E x N)，其中 E 为边的数目，N 表示最差情况下更新的次数。</p>
<p data-nodeid="200">基于这种思想，我们就可以写出 BF 算法的代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="201"><code data-language="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) {
        <span class="hljs-comment">//对m条边进行循环</span>
        <span class="hljs-keyword">var</span> edge = edges[j];
        <span class="hljs-comment">// 松弛操作</span>
        <span class="hljs-keyword">if</span>(distance[edge.to] &gt;
          distance[edge.from] + edge.weight ) {
            distance[edge.to] = distance[edge.from] + edge.weight;
        }
   }
}
</code></pre>
<p data-nodeid="202">不过，要解决本题，还需要注意，<strong data-nodeid="778">经典的 BF 算法的最短路径是最小路径和为度量的，<strong data-nodeid="777">而在本题中，是以</strong>一条路径上的最大权重</strong>进行度量的，所以我们还需要对 BF 算法做度量函数的微调，调整之后的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="203"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-comment">// 行数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 列数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 一个点周围的四个方向</span>
  <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
                  { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
                  
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    Rows = heights.length;
    Cols = heights[<span class="hljs-number">0</span>].length;
    
    <span class="hljs-comment">// 如果只有一个结点</span>
    <span class="hljs-keyword">if</span> (Rows == <span class="hljs-number">1</span> &amp;&amp; Cols == <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-comment">// 采用BF算法</span>
    <span class="hljs-comment">// 从左上角走到右下角，最多只需要走Rows + Cols次</span>
    <span class="hljs-comment">// 所以我们在更新的时候，最多只需要更新Rows + Cols次</span>
    <span class="hljs-comment">// 并且，在更新的过程中，如果我们发现，没有任何一个点被更新的时候</span>
    <span class="hljs-comment">// 我们就可以退出来了</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">4</span>;
    
    <span class="hljs-keyword">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Rows][Cols];
    <span class="hljs-comment">// 初始化整个距离</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
        dist[r][c] = maxDist;
      }
    }
    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxUpdateTimes = Rows + Cols;
    
    <span class="hljs-comment">// 用BF算法来更新</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> updateTimes = <span class="hljs-number">0</span>;
        updateTimes &lt; maxUpdateTimes; updateTimes++) {
        
      <span class="hljs-keyword">boolean</span> hasUpdateItem = <span class="hljs-keyword">false</span>;
      
      <span class="hljs-comment">// 用所有的边来进行更新</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
            <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
            <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> ||
                  nr &gt;= Rows || nc &gt;= Cols)) {
                  
              <span class="hljs-comment">// 拿到边的代价</span>
              <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cost =
                  Math.abs(heights[r][c] - heights[nr][nc]);
                  
              <span class="hljs-comment">// 这条路径走过来的最大代价</span>
              <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextCost = Math.max(dist[r][c], cost);
              <span class="hljs-keyword">if</span> (nextCost &lt; dist[nr][nc]) {
                dist[nr][nc] = nextCost;
                hasUpdateItem = <span class="hljs-keyword">true</span>;
              }
              
            }
            
          }
        }
      }
      
      <span class="hljs-comment">// 如果没有更新</span>
      <span class="hljs-keyword">if</span> (!hasUpdateItem) {
        <span class="hljs-keyword">break</span>;
      }
    }
    
    <span class="hljs-keyword">return</span> dist[Rows - <span class="hljs-number">1</span>][Cols - <span class="hljs-number">1</span>];
  }
}
</code></pre>
<blockquote data-nodeid="204">
<p data-nodeid="205">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="782">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="786">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="790">Python</a></p>
</blockquote>
<p data-nodeid="206">写完代码之后，我们再考虑一下 BF 算法与 Dijkstra 算法的联系与区别。</p>
<ol data-nodeid="207">
<li data-nodeid="208">
<p data-nodeid="209"><strong data-nodeid="796">联系</strong>：BF 算法与 Dijkstra 算法都会用更小的“最短路径”来更新。</p>
</li>
<li data-nodeid="210">
<p data-nodeid="211"><strong data-nodeid="801">区别</strong>：BF 算法属于动态规划算法，而 Dijkstra 算法则是属于贪心算法。</p>
</li>
</ol>
<p data-nodeid="212">1）相对来说，BF 算法在每一轮的更新中，都会得到一波点，这些点有最终的最短路径。但是更新的时候，需要用到所有的边。</p>
<p data-nodeid="213">2）Dijkstra 算法在更新点的距离时，则是从点的角度出发。既然每一波点都会得到最短距离，那么我就利用这波点去更新别的点的最短距离。</p>
<h3 data-nodeid="214">特点 4: 又看最小值</h3>
<p data-nodeid="215">谈到图中两点之间关于路径的最小值。在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6707&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="808">第 18 讲</a>”中我们讲过，在求两个点的最短路径的时候，可以有 3 种情况：两点最短、点与其他点最短路径、每两点之间的最短路径。我们接触的最短路径的题目中，很多题目都是将“<strong data-nodeid="814">最短</strong>”定义为：</p>
<blockquote data-nodeid="216">
<p data-nodeid="217">一条路径上所有边的权重之和，要最小！</p>
</blockquote>
<p data-nodeid="218">但是，在<strong data-nodeid="821">本题</strong>中却不是这样，我们要求的是：</p>
<blockquote data-nodeid="219">
<p data-nodeid="220">一条路径上所有边的权重的最大值，要最小！</p>
</blockquote>
<p data-nodeid="221">那么，当这个“<strong data-nodeid="828">最短</strong>”定义发生变化的时候，我们是否还可以使用 BFS/Dijkstra/BF 算法呢？</p>
<p data-nodeid="222">这里我们先回顾一下原始 Dijkstra 算法。</p>
<ul data-nodeid="223">
<li data-nodeid="224">
<p data-nodeid="225">在 Dijkstra 算法中，我们需要用一个 dist 数组来记录“最短路径”和。</p>
</li>
<li data-nodeid="226">
<p data-nodeid="227">当出发点 src 走到点 x，导致 dist[x] 有<strong data-nodeid="840">更新</strong>的时候，那么点 x 还可以走到它周围的点，进一步更新周围的点。因此，需要将点 x 放到一个优先级队列中。</p>
</li>
<li data-nodeid="228">
<p data-nodeid="229">每次从优先级队列中取出最值得更新的点，作为出发点，用来<strong data-nodeid="846">更新</strong>其周围的点。</p>
</li>
</ul>
<p data-nodeid="230">如果将 Dijkstra 算法迁移到这个题目，我们只需要改变 dist[] 数组的含义就可以了。</p>
<ul data-nodeid="231">
<li data-nodeid="232">
<p data-nodeid="233">原始的 Dijkstra 算法的 dist[x] 表示：从出发点 src 走到点 x 的最小路径和。</p>
</li>
<li data-nodeid="234">
<p data-nodeid="235">本题的 Dijkstra 中的 dist[x] 的含义：从出发点 src 走到点 x 路径上<strong data-nodeid="865">边的权重的最大值</strong>。</p>
</li>
</ul>
<p data-nodeid="236">基于这个微小的改动，我们就可以利用 Dijkstra 算法解决这道题目了。代码如下：</p>
<pre class="lang-java" data-nodeid="237"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-comment">// 行数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Rows = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 列数</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> Cols = <span class="hljs-number">0</span>;
  
  <span class="hljs-comment">// 四个方向</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] dir = { { <span class="hljs-number">0</span>, <span class="hljs-number">1</span> }, { <span class="hljs-number">0</span>, -<span class="hljs-number">1</span> },
                           { <span class="hljs-number">1</span>, <span class="hljs-number">0</span> }, { -<span class="hljs-number">1</span>, <span class="hljs-number">0</span> } };
                           
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minimumEffortPath</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] heights)</span> </span>{
    <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    Rows = heights.length;
    Cols = heights[<span class="hljs-number">0</span>].length;
    
    <span class="hljs-comment">// 设置矩阵的最大距离</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxDist = Integer.MAX_VALUE &gt;&gt; <span class="hljs-number">4</span>;
    <span class="hljs-keyword">int</span>[][] dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[Rows][Cols];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; Rows; r++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; Cols; c++) {
        dist[r][c] = maxDist;
      }
    }
    dist[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// java小堆</span>
    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; Q =
      <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt;
            dist[v1[<span class="hljs-number">0</span>]][v1[<span class="hljs-number">1</span>]] - dist[v2[<span class="hljs-number">0</span>]][v2[<span class="hljs-number">1</span>]]);
            
    <span class="hljs-comment">// 放入出发点</span>
    Q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">0</span>, <span class="hljs-number">0</span> });
    
    <span class="hljs-keyword">while</span> (!Q.isEmpty()) {
      <span class="hljs-comment">// 取出最近的点</span>
      <span class="hljs-keyword">int</span>[] topNode = Q.poll();
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> r = topNode[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> c = topNode[<span class="hljs-number">1</span>];
      
      <span class="hljs-comment">// 我们看一下这个点四周的点</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++) {
        <span class="hljs-comment">//  找到周边的下一个点</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
        
        <span class="hljs-comment">// 看一下这个点的权重是否会更新</span>
        <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= Rows || nc &gt;= Cols)) {
        
          <span class="hljs-comment">// 如果要走过去的点是合法的点</span>
          <span class="hljs-comment">// 点之间的边上的权重</span>
          <span class="hljs-comment">// 是由点与点之间的abs()决定的</span>
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> weight =
              Math.abs(heights[r][c] - heights[nr][nc]);
              
          <span class="hljs-comment">// 注意，题目要求是取整条路径上的绝对值的最大值</span>
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nextDist = Math.max(dist[r][c], weight);
          
          <span class="hljs-keyword">if</span> (nextDist &lt; dist[nr][nc]) {
            dist[nr][nc] = nextDist;
            Q.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { nr, nc });
          }
          
        }
      }
    }
    <span class="hljs-keyword">return</span> dist[Rows - <span class="hljs-number">1</span>][Cols - <span class="hljs-number">1</span>];
  }
}
</code></pre>
<blockquote data-nodeid="238">
<p data-nodeid="239">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="870">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="874">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="878">Python</a></p>
</blockquote>
<p data-nodeid="240"><strong data-nodeid="883">复杂度分析</strong>：当给定图为 N x M 时，时间复杂度为 O(N x M x lg(N x M))，空间复杂度最差情况下，所有的元素都在队列中 O(N x M)。</p>
<h3 data-nodeid="241">总结</h3>
<p data-nodeid="242">在这一讲中，我们通过题目<strong data-nodeid="890">两方面的特点：连通性、最小值</strong>展开，介绍了以下算法：</p>
<ul data-nodeid="243">
<li data-nodeid="244">
<p data-nodeid="245">并查集</p>
</li>
<li data-nodeid="246">
<p data-nodeid="247">二分搜索</p>
</li>
<li data-nodeid="248">
<p data-nodeid="249">动态规划</p>
</li>
<li data-nodeid="250">
<p data-nodeid="251">Dijkstra 算法</p>
</li>
</ul>
<p data-nodeid="34167">这里我将这些知识点浓缩在一张思维导图里面，有助于帮助你总结和复习。</p>
<p data-nodeid="34168" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3C/92/Cgp9HWCLcnuABwKAAADpTh1CXZI925.png" alt="Drawing 13.png" data-nodeid="34172"></p>


<h3 data-nodeid="254">思考题</h3>
<p data-nodeid="255">给定一个包含非负整数的<code data-backticks="1" data-nodeid="901">m x n</code>网格<code data-backticks="1" data-nodeid="903">grid</code>，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p data-nodeid="36233" class=""><strong data-nodeid="36238">说明：</strong> 每次只能向下或者向右移动一步。</p>

<p data-nodeid="38301" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3C/9B/CioPOWCLcoSATajPAAEcd1cL5m8325.png" alt="Drawing 14.png" data-nodeid="38304"></p>

<p data-nodeid="258">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</p>
<p data-nodeid="259">输出：7</p>
<p data-nodeid="260">解释：因为路径 1→3→1→1→1 的总和最小。</p>
<blockquote data-nodeid="261">
<p data-nodeid="262">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="931">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="935">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="939">Python</a></p>
</blockquote>
<p data-nodeid="263">你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于最小体力消耗题目就介绍到这里。接下来，下一讲介绍“20 | 5 种解法，如何利用常量空间求解最长有效括号长度？”，让我们继续前进。</p>
<h3 data-nodeid="264">附录：题目出处和代码汇总</h3>
<table data-nodeid="40368">
<thead data-nodeid="40369">
<tr data-nodeid="40370">
<th data-nodeid="40372">题目</th>
<th data-nodeid="40373"><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/description/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40386">测试平台</a></th>
<th data-nodeid="40374">并查集：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40390">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40394">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.uf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40398">Python</a><br>二分 + DFS：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40403">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40407">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40411">Python</a><br>二分 + BFS：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40416">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40420">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_bfs.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40424">Python</a><br>二分 + 并查集：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40429">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40433">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.binarySearch_uf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40437">Python</a><br><br>BF 算法：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40443">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40447">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.bf.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40451">Python</a><br><br>Dijkstra 算法：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40457">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40461">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/1631.%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84.Dijkstra.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40465">Python</a></th>
</tr>
</thead>
<tbody data-nodeid="40378">
<tr data-nodeid="40379">
<td data-nodeid="40380">思考题</td>
<td data-nodeid="40381"><a href="https://leetcode-cn.com/problems/minimum-path-sum/description/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40469">测试平台</a></td>
<td data-nodeid="40382">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40473">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40477">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/19.Efforts/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="40481">Python</a></td>
</tr>
</tbody>
</table>

---

### 精选评论


