<p data-nodeid="3681" class="">今天我会带你深度思考子集，介绍掌握 5 种通用解法。</p>
<p data-nodeid="3682">不知道你对子集问题是否还有印象，我们曾在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="3901">12 | 回溯：我把回溯总结成一个公式，回溯题一出就用它</a>”，花了大量篇幅深入讨论过子集相关的问题。但当时的思路是已经知道了解题方法，然后再对题目实施“精确制导的定向爆破”。</p>
<p data-nodeid="3683">但是，子集问题的解法就只有回溯吗？我们是否还可以继续深挖题目给予的信息？在这个“一题多解”的模块里面，我们需要重新审视子集问题，比如看一看：</p>
<ul data-nodeid="3684">
<li data-nodeid="3685">
<p data-nodeid="3686">能否挖掘出更多的信息？</p>
</li>
<li data-nodeid="3687">
<p data-nodeid="3688">能不能匹配到更多的算法和数据结构？</p>
</li>
<li data-nodeid="3689">
<p data-nodeid="3690">能不能找到更多有趣的解法。</p>
</li>
</ul>
<p data-nodeid="3691">下面请你带着以上三个问题，开启今天的探索旅程。</p>
<h3 data-nodeid="3692">题目</h3>
<p data-nodeid="3693">首先，子集问题实际上包含两类问题。下面我们通过两个题目详细介绍一下。</p>
<p data-nodeid="3694">【<strong data-nodeid="3915">题目 1</strong>】给你一个整数数组 nums ，数组中的元素互不相同。返回该数组所有可能的子集。</p>
<p data-nodeid="3695">解集<strong data-nodeid="3925">不能</strong>包含重复的子集。你可以按<strong data-nodeid="3926">任意顺序</strong>返回解集。</p>
<p data-nodeid="3696"><strong data-nodeid="3930">示例 1</strong></p>
<p data-nodeid="3697">输入：nums = [1,2,3]</p>
<p data-nodeid="3698">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>
<p data-nodeid="3699">【<strong data-nodeid="3985">题目 2</strong>】给你一个整数数组 nums ，其中<strong data-nodeid="3986">可能包含重复</strong>元素，请你返回该数组所有可能的子集。解集<strong data-nodeid="3987">不能</strong>包含重复的子集。返回的解集中，子集可以按<strong data-nodeid="3988">任意顺序</strong>排列。</p>
<p data-nodeid="3700"><strong data-nodeid="3992">示例 1</strong></p>
<p data-nodeid="3701">输入：nums = [1,2,2]</p>
<p data-nodeid="3702">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p>
<p data-nodeid="3703">注：在后文中，我们将分别用题目 1、题目 2 来引用这两个题目。</p>
<p data-nodeid="3704">声明：对于这个题目，在最差情况下，时间复杂度都是 O(N2<sup>N</sup>)。不算返回值的情况下，空间复杂度为 O(N)（BFS 的空间复杂度会到 O(2<sup>N</sup>)）。因此，后面的代码不会再对时间复杂度和空间复杂度做特别的声明。</p>
<h3 data-nodeid="3705">通用方法 1：回溯</h3>
<p data-nodeid="3706">首先，因为题目中已经说明了，数组中的每个元素都是不相同的，因此题目 1 不涉及去重。我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4036">第 12 讲</a>”中利用“回溯法：一个核心，三个条件”写过题目 1 的回溯代码。关于这种方法，不再做过多的叙述，你可以参考如下代码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3707"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(List&lt;Integer&gt; box, List&lt;List&lt;Integer&gt;&gt; all)</span> </span>{
  all.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
  <span class="hljs-keyword">for</span> (Integer x : box) {
    all.get(all.size() - <span class="hljs-number">1</span>).add(x);
  }
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backTrace</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A,
               <span class="hljs-keyword">int</span> start, <span class="hljs-comment">/*第i个人的选择范围[start, N)*/</span>
               List&lt;Integer&gt; box,
               List&lt;List&lt;Integer&gt;&gt; all)</span> </span>{

  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-comment">// 公布当前箱子的状态</span>
  append(box, all);
  <span class="hljs-comment">// 如果我是最后一个人，并且没有东西给我选了</span>
  <span class="hljs-comment">// 那么原样返回箱子</span>
  <span class="hljs-keyword">if</span> (start &gt;= N) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// 我还是有宝石可以选择的。</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = start; j &lt; N; j++) {
    box.add(A[j]);
    backTrace(A, j + <span class="hljs-number">1</span>, box, all);
    box.remove(box.size() - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] A) {
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  List&lt;Integer&gt; box = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
  List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
  backTrace(A, <span class="hljs-number">0</span>, box, ans);
  <span class="hljs-keyword">return</span> ans;
</code></pre>
<blockquote data-nodeid="3708">
<p data-nodeid="3709">代码:<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4041">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4045">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/78.%E5%AD%90%E9%9B%86.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4049">Python</a></p>
</blockquote>
<p data-nodeid="3710">可以看到，题目 2 与题目 1 有一点不同：</p>
<blockquote data-nodeid="3711">
<p data-nodeid="3712">题目 2 给定的数组可能存在重复元素，因此，还需要对子集进行去重。</p>
</blockquote>
<p data-nodeid="3713">接下来我们讨论题目 2 中涉及的去重问题。</p>
<p data-nodeid="3714">当时，我们采用“<strong data-nodeid="4058">排序 + 判断元素是否出现过</strong>”的方法进行去重。经过优化后的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3715"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(List&lt;Integer&gt; box,
                      List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>{
    ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
    <span class="hljs-keyword">for</span> (Integer x : box) {
      ans.get(ans.size() - <span class="hljs-number">1</span>).add(x);
    }
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A,
                         <span class="hljs-keyword">int</span> start, <span class="hljs-comment">/*第i个人的选择范围(start, N)*/</span>
                         List&lt;Integer&gt; box,
                         List&lt;List&lt;Integer&gt;&gt; ans)</span>
  </span>{
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
      append(box, ans);
      <span class="hljs-comment">// 已经没得选了</span>
      <span class="hljs-keyword">if</span> (start &gt;= N) {
          <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = start; j &lt; N; j++) {
        <span class="hljs-keyword">if</span> (j &gt; start &amp;&amp; A[j] == A[j-<span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;
        box.add(A[j]);
        backtrace(A, j + <span class="hljs-number">1</span>, box, ans);
        box.remove(box.size()-<span class="hljs-number">1</span>);
      }
  }
 
  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] A) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
      List&lt;Integer&gt; box = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
      List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
      <span class="hljs-keyword">if</span> (N &lt;= <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> ans;
      }
      Arrays.sort(A);
      backtrace(A, <span class="hljs-number">0</span>, box, ans);
      <span class="hljs-keyword">return</span> ans;
  }
}
</code></pre>
<blockquote data-nodeid="3716">
<p data-nodeid="3717">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4062">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4066">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/12.BackTrack/90.%E5%AD%90%E9%9B%86-ii.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4070">Python</a></p>
</blockquote>
<p data-nodeid="3718">其实，这是一道非常经典的题目，我们可以从不同角度思考这个题目，进而得到不同的解法。</p>
<h3 data-nodeid="3719">通用方法 2：BFS</h3>
<p data-nodeid="3720">既然可以利用回溯（可以认为回溯是某种形式的 DFS），那么应该也可以尝试往 BFS 方向思考。因为大部分时候，DFS 的代码都可以改写为 BFS 的代码，</p>
<p data-nodeid="3721">题目 1 不需要考虑去重的问题。我们可以假设数组为 A[] = {1, 2, 3}，那么可以进行如下的操作（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3722"><code data-language="java">cur = {{}}; <span class="hljs-comment">// 一开始我只有一个空集</span>
<span class="hljs-keyword">for</span> x in A:
    tmp = {};
    <span class="hljs-keyword">for</span> subset in cur: <span class="hljs-comment">// 复制当前已有的子集subset</span>
        subset.add(x)  <span class="hljs-comment">// 把数组中元素x加到子集中</span>
        tmp.add(subset)<span class="hljs-comment">// 把更新后的subset放到tmp中。</span>
    <span class="hljs-keyword">for</span> subset in tmp:
        cur.add(subset)
<span class="hljs-keyword">return</span> cur
</code></pre>
<p data-nodeid="3723">不过，我们也要注意到，这里在进行 BFS 的时候，与常规的 BFS 不太一样。</p>
<blockquote data-nodeid="3724">
<p data-nodeid="3725">BFS 的方法有两种，一种是使用 Queue，另一种是使用“两段击”。这里我们指的是两段击。<br>
如果你忘了什么是“两段击”，那么快去看一下“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4086">02 | 队列：FIFO 队列与单调队列的深挖与扩展</a>”。</p>
</blockquote>
<p data-nodeid="3726">常规的 BFS 流程如下（我们<strong data-nodeid="4093">聚焦</strong>于 BFS 的一轮迭代）：</p>
<p data-nodeid="3727"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1C/CioPOWCChpeATCyQAABtL-4I4AU783.png" alt="Drawing 0.png" data-nodeid="4096"></p>
<p data-nodeid="3728">我们发现，进行 BFS 的时候，在生成 next 之后，并不是直接赋值给 cur，而是采用了 cur + next。这里我建议你花点时间完成下面两道常规 BFS 的练习题，巩固一下 BFS 的知识。</p>
<p data-nodeid="3729"><strong data-nodeid="4102">练习题 1</strong>：从上到下按层打印二叉树，同一层结点按照从左到右的顺序打印，每一层打印到一行。</p>
<blockquote data-nodeid="3730">
<p data-nodeid="3731">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4106">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4110">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/01.TreeLevelOrder.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4114">Python</a></p>
</blockquote>
<p data-nodeid="3732"><strong data-nodeid="4119">练习题 2</strong>：有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。</p>
<p data-nodeid="3733">输入：n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1</p>
<p data-nodeid="3734">输出：200</p>
<p data-nodeid="3735">城市航班图如下：</p>
<p data-nodeid="3736"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChp6Ab6B3AAB6kPgo4wQ968.png" alt="Drawing 1.png" data-nodeid="4139"></p>
<p data-nodeid="3737">从城市 0 到城市 2 在 1 站中转的最便宜价格是 200，如上图中红色所示：</p>
<blockquote data-nodeid="3738">
<p data-nodeid="3739">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4144">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4148">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/787.k-%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4152">Python</a></p>
</blockquote>
<p data-nodeid="3740">既然我们已经知道子集的 BFS 的程序框架了，针对题目 1，可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3741"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) {
        List&lt;List&lt;Integer&gt;&gt; cur = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// cur里面会有一个空集</span>
        cur.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
        List&lt;List&lt;Integer&gt;&gt; next = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) {
            next.clear();
            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset: cur) {
                List&lt;Integer&gt; newSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(subset);
                newSubset.add(x);
                next.add(newSubset);
            }
            <span class="hljs-comment">// cur = cur + next;</span>
            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; newSubset: next) {
                cur.add(newSubset);
            }
        }
        <span class="hljs-keyword">return</span> cur;
    }
}
</code></pre>
<blockquote data-nodeid="3742">
<p data-nodeid="3743">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4157">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4161">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4165">Python</a></p>
</blockquote>
<p data-nodeid="3744">当<strong data-nodeid="4178">题目 1</strong>解决之后，我们再来看一下能不能用同样的BFS 方法解决<strong data-nodeid="4179">题目 2</strong>。假设 A[] = {1,2,2}。看看是否会出现什么问题，步骤如下：</p>
<p data-nodeid="3745">Step 1. 一开始 cur = [{}]；</p>
<p data-nodeid="3746">Step 2. 当加入元素 1，生成 next = [{1}]；</p>
<p data-nodeid="3747">Step 3. cur = cur + next = [{}, {1}]；</p>
<p data-nodeid="3748">Step 4. 再加入元素 2，生成 next = [{2}, {1,2}]；</p>
<p data-nodeid="3749">Step 5. cur = cur + next = [{}, {1}, {2}, {1,2}]；</p>
<p data-nodeid="3750">Step 6. 再加入元素 2，生成 next = [{2}, {1,2}, {2,2}, {1,2,2}]；</p>
<p data-nodeid="3751">Step 7. 最后执行cur = cur + next = [{}, {1}, {2}, {1,2},{2}, {1,2}, {2,2}, {1,2,2}]。</p>
<p data-nodeid="3752">我们发现，如果还是沿用题目 1 的 BFS 方法，会在最终解中<strong data-nodeid="4220">产生重复的子集</strong>。那么，有没有办法去除这些重复的子集？</p>
<p data-nodeid="3753">下面我们需要追踪一下这些重复元素是如何生成的，可以画出下图：</p>
<p data-nodeid="3754"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChqiAdm7xAADFwWCKF6U657.png" alt="Drawing 2.png" data-nodeid="4224"></p>
<p data-nodeid="3755">重复元素 [{2}, {1,2}] 是由 [{}, {1}] 加入元素 2 后生成的。重复的元素分别是在 Step 4 和 Step 6 生成的，如下图所示：</p>
<p data-nodeid="3756"><img src="https://s0.lgstatic.com/i/image6/M00/3B/14/Cgp9HWCChq-AbWGFAACfXWp9Low360.png" alt="Drawing 3.png" data-nodeid="4236"></p>
<p data-nodeid="3757">因此，在更新的时候，应该要注意，如果一些元素，比如 [{}, {1}] 已经被元素 2 更新过了。那么后面就不应该再去更新了。</p>
<p data-nodeid="3758">此时，我们应该可以写出伪代码了：</p>
<pre class="lang-java" data-nodeid="3759"><code data-language="java">cur = [{}]
<span class="hljs-keyword">for</span> x in A:
    next = []
    <span class="hljs-keyword">for</span> subset in cur:
        <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">updated</span><span class="hljs-params">(subset, x)</span> </span>== False:
            next.add(subset.clone().add(x))
    <span class="hljs-keyword">for</span> newSubset in next:
        cur.add(newSubset)
<span class="hljs-keyword">return</span> cur
</code></pre>
<p data-nodeid="3760">现在问题的重点在于：如何完成 updated(subset, x) 的检查。我们发现可以按照下图这样的方式操作：</p>
<p data-nodeid="3761"><img src="https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChs6ASdvfAAY7y-x_0T0475.gif" alt="3.gif" data-nodeid="4246"></p>
<p data-nodeid="3762">通过上述分析， 我们可以总结出如下结论：</p>
<ul data-nodeid="3763">
<li data-nodeid="3764">
<p data-nodeid="3765">如果加入的元素与前面加入的元素一样，那么只需要更新“<strong data-nodeid="4253">新增的部分</strong>”；</p>
</li>
<li data-nodeid="3766">
<p data-nodeid="3767">为了同时达到，就需要与前面一轮的元素进行比较，并且记住前面新增的部分。</p>
</li>
</ul>
<p data-nodeid="3768">也就是说，我们需要做两个事情：</p>
<ul data-nodeid="3769">
<li data-nodeid="3770">
<p data-nodeid="3771">对数组排序，排序之后，我们总是可以很容易得出与前面一轮的元素是否相等；</p>
</li>
<li data-nodeid="3772">
<p data-nodeid="3773">记住前面新增的部分，我们只需要每次<strong data-nodeid="4262">更新之前</strong>，记录一下 cur 的 size 就可以了。</p>
</li>
</ul>
<p data-nodeid="3774">基于这两点，可以写出题目 2 的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3775"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) {
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; cur = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// cur里面会有一个空集</span>
        cur.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
        List&lt;List&lt;Integer&gt;&gt; next = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// 前面用来更新的元素的值</span>
        <span class="hljs-keyword">int</span> pre = Integer.MAX_VALUE;
        <span class="hljs-comment">// 在利用pre元素更新之前</span>
        <span class="hljs-comment">// cur里面item的个数</span>
        <span class="hljs-comment">// 注意：是利用pre更新之前，不是pre更新之后的元素的个数!</span>
        <span class="hljs-keyword">int</span> beforePreUpdateSize = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> curValue: nums) {
            next.clear();
            <span class="hljs-comment">// 在更新之前，我们需要判断一下，是从cur的哪里开始更新</span>
            <span class="hljs-comment">// 正常情况下，都是从cur[0]开始更新</span>
            <span class="hljs-keyword">int</span> startUpdatePos = <span class="hljs-number">0</span>;
            <span class="hljs-comment">// 如果与pre值相等</span>
            <span class="hljs-keyword">if</span> (curValue == pre) {
                <span class="hljs-comment">// 那么在更新的时候，需要从beforePreUpdateSize这里开始更新。</span>
                <span class="hljs-comment">// 因为[0, ...., beforePreUpdateSize)这部分内容</span>
                <span class="hljs-comment">// 肯定已经被等于pre的值给更新过了</span>
                startUpdatePos = beforePreUpdateSize;
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = startUpdatePos; i &lt; cur.size(); i++) {
                List&lt;Integer&gt; newSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(cur.get(i));
                newSubset.add(curValue);
                next.add(newSubset);
            }
            <span class="hljs-comment">// 记录一下更新前的大小</span>
            <span class="hljs-keyword">int</span> beforeCurValueUpdateSize = cur.size();

            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset: next) {
                cur.add(subset);
            }
            <span class="hljs-comment">// 更新一下大小的情况</span>
            beforePreUpdateSize = beforeCurValueUpdateSize;
            pre = curValue;
        }
        <span class="hljs-keyword">return</span> cur;
    }
}
</code></pre>
<blockquote data-nodeid="3776">
<p data-nodeid="3777">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4267">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4271">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4275">Python</a></p>
</blockquote>
<p data-nodeid="3778">【<strong data-nodeid="4281">小结</strong>】我们不妨将用到的 BFS 进行比较，通过比较它们之间的异同，有助于梳理知识点里面的考点（红色部分是变更之后的考点）。</p>
<p data-nodeid="3779"><img src="https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChtmACSQgAAByLMtH9fw534.png" alt="Drawing 5.png" data-nodeid="4284"></p>
<p data-nodeid="3780">我们发现，题目 1 与题目 2 无非就是在原始的 BFS 上不停地更改 BFS 的条件，然后就出现了新的题型与考点。</p>
<p data-nodeid="3781">这里我再给你留一个练习题，通过这些练习，可以和我们以前学习过的知识产生联动，让你对题目、知识点的理解更加深刻。</p>
<p data-nodeid="3782"><strong data-nodeid="4299">练习题 3</strong>：在学习“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4293">第 12 讲</a>”回溯中例 4 的时候，也讲到了题目 2。在那里，我们同样用到了去重的技巧，并且也用到了排序。那么请问，“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6701&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4297">第 12 讲</a>”中用到的排序和这里 BFS 的排序的目的有什么异同点？</p>
<p data-nodeid="3783"><strong data-nodeid="4310">练习题 4</strong>：题目 2 在进行 BFS 的时候，采用了使用部分 cur 里面的元素来进行更新，并且生成 next 的办法。我们在讲解“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4308">11 | 贪心：这种思想，没有模板，如何才能掌握它？</a>”贪心算法例 3“青蛙跳”的时候，曾说过可以采用类似 BFS 的方法进行思考。那么题目 2 和“青蛙跳”有什么异同呢？</p>
<h3 data-nodeid="3784">通用方法 3：选与不选</h3>
<p data-nodeid="3785">现在我们换一种思路来看这个题目：生成一个子集的时候，对于一个元素而言，就只有选与不选两种选择。如果用二进制 bit，0 表示选中，1 表示没有选中。</p>
<p data-nodeid="3786">那么对于一个有 n 个元素的数组，可以用一个二进制串表示一个子集。比如空集就是所有的二进制 bit 都是 0。</p>
<p data-nodeid="3787"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChuGAZqi8AAChWwRZV6U128.png" alt="Drawing 6.png" data-nodeid="4316"></p>
<p data-nodeid="3788">比如，我们还可以用 b0110 表示子集 {A[1], A[2]}。那么现在你应该明白，针对四个元素的子集，可以按照 [0, ~ b1111] 顺序遍历，然后依次遍历二进制串的每一位，通过 bit 0/1 决定是否需要把相应的元素放到集合中。</p>
<p data-nodeid="3789">通过这种思路，我们可以写出<strong data-nodeid="4337">题目 1</strong>的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3790"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = nums == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : nums.length;
        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;N); i++) {
            List&lt;Integer&gt; subset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-comment">// 看一下哪些元素会被选择</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) {
                <span class="hljs-comment">// 如果要选择nums[j]</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; j;
                <span class="hljs-keyword">if</span> ((i &amp; mask) != <span class="hljs-number">0</span>) {
                    subset.add(nums[j]);
                }
            }
            <span class="hljs-comment">// 然后把tmp 加到 ans里面 </span>
            ans.add(subset);
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="3791">
<p data-nodeid="3792">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4341">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4345">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.binary.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4349">Python</a></p>
</blockquote>
<p data-nodeid="3793">学完这种解法之后，我们会发现和“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4355">14 | DP：我是怎么治好‘DP 头痛症’的？</a>”里面的状态压缩有非常类似的地方：</p>
<blockquote data-nodeid="3794">
<ol data-nodeid="3795">
<li data-nodeid="3796">
<p data-nodeid="3797">都是用 0/1 bit 位来表示一个元素的选中和不选中；</p>
</li>
<li data-nodeid="3798">
<p data-nodeid="3799">都是用一个整数来表示一个集合的状态。</p>
</li>
</ol>
</blockquote>
<p data-nodeid="3800">题目 1 解决之后，我们接下来看一下<strong data-nodeid="4367">题目 2</strong>。如果仍然采用这种方法，可能会面临一个问题。对于给定数组 A[] = {1,2,2,2}。如下图所示：</p>
<p data-nodeid="3801"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChvGAQ8GAAACmdtVGGo0109.png" alt="Drawing 7.png" data-nodeid="4370"></p>
<p data-nodeid="3802">虽然用了两个不同的二进制串，但是会导致它们映射到同样的子集。因此，也就存在重复的可能性。那么，有没有什么办法可以去重呢？</p>
<p data-nodeid="3803">我们接着来看下面这个例子。对于数组 A[] = {1,2,2,2,2}，可以发现有些二进制串实际上是等价的。比如只选中一个 1 的时候，如下图所示：</p>
<p data-nodeid="3804"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChviAf9KNAAFHgJCoZvU511.png" alt="Drawing 8.png" data-nodeid="4378"></p>
<p data-nodeid="3805">例 2：只选择 2 个 2 到子集里面的时候。如下图所示：<br>
<img src="https://s0.lgstatic.com/i/image6/M01/3B/1D/CioPOWCChv-AG6oSAAFVoOOh6qQ752.png" alt="Drawing 9.png" data-nodeid="4383"></p>
<p data-nodeid="3806">假设需要选择 x 个 2 出来，只需要数字 2 对应的位置 bit = 1 的总数有 x 个就可以了。比如，以选择 2 个 2 为例，只需 2 对应的位置有 2 个 bit=1 就可以了。</p>
<p data-nodeid="3807"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChwaAefbdAAB7Y8WLUUY506.png" alt="Drawing 10.png" data-nodeid="4387"></p>
<p data-nodeid="3808">那么，在这些二进制串中，需要选择一个我们想要的数字出来。所以，现在问题的重点，就是<strong data-nodeid="4393">选谁</strong>。</p>
<p data-nodeid="3809">经过一系列挑选，我们<strong data-nodeid="4403">精心</strong>按照<strong data-nodeid="4404">一定规则，即</strong>相同的数的 bit = 1，挑选了如下数组的所有二进制串：</p>
<pre class="lang-java" data-nodeid="3810"><code data-language="java"><span class="hljs-comment">// 比如A[] = [1, 2, 2, 2, 2]</span>
<span class="hljs-comment">//      0  0  0  0  0</span>
<span class="hljs-comment">//      0  1  0  0  0</span>
<span class="hljs-comment">//      0  1  1  0  0</span>
<span class="hljs-comment">//      0  1  1  1  0</span>
<span class="hljs-comment">//      0  1  1  1  1</span>
<span class="hljs-comment">//      1  0  0  0  0</span>
<span class="hljs-comment">//      1  1  0  0  0</span>
<span class="hljs-comment">//      1  1  1  0  0</span>
<span class="hljs-comment">//      1  1  1  1  0</span>
<span class="hljs-comment">//      1  1  1  1  1</span>
</code></pre>
<p data-nodeid="3811">也就是说，本质上我们是在具有重复含义的二进制串中选出了“代表”。比如下面这两个二进制串：</p>
<p data-nodeid="3812"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChw6AT5_KAAETiNOj7Xs819.png" alt="Drawing 11.png" data-nodeid="4408"></p>
<p data-nodeid="3813">两个二进制串都表示往集合中添加：</p>
<ul data-nodeid="3814">
<li data-nodeid="3815">
<p data-nodeid="3816">1 个 1</p>
</li>
<li data-nodeid="3817">
<p data-nodeid="3818">2 个 3</p>
</li>
<li data-nodeid="3819">
<p data-nodeid="3820">2 个 4</p>
</li>
</ul>
<p data-nodeid="3821">你可以观察上图中红色勾选的二进制串，上述选择规则有 2 个条件。注意，这里的条件都是针对数组中值相同的元素：</p>
<ul data-nodeid="3822">
<li data-nodeid="3823">
<p data-nodeid="3824">对于数组中的相同的元素，选中的时候，bit 为 1 时，都必须<strong data-nodeid="4419">连</strong>在一起；</p>
</li>
<li data-nodeid="3825">
<p data-nodeid="3826">对于数组中的相同的元素，bit 为 1 时，都必须靠<strong data-nodeid="4425">左边</strong>连续存放。</p>
</li>
</ul>
<p data-nodeid="3827">注意：这里的“靠左存放”不是靠整个二进制串的左边，而是靠着相同元素的左边界存放。如下图所示：</p>
<p data-nodeid="3828"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChxeAQxZXAACagi2nfs8308.png" alt="Drawing 12.png" data-nodeid="4429"></p>
<p data-nodeid="3829">我们认为上图中相同元素 3 和元素 4 的 bit = 1 都是靠其左边连续存放的。</p>
<p data-nodeid="3830">这里我给出一些示例，如下图所示：</p>
<p data-nodeid="3831"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChx6AF3lnAAB7jvDEfhA419.png" alt="Drawing 13.png" data-nodeid="4434"></p>
<p data-nodeid="3832">例 1，满足条件 1，不满足条件 2。因为选中元素 2 的 bit = 1 没有连续靠左存放。</p>
<p data-nodeid="3833"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChyWACm9rAAB7k7a6eos642.png" alt="Drawing 14.png" data-nodeid="4438"></p>
<p data-nodeid="3834">例 2，不满足条件 1，也不满足条件 2，因为选中相同元素的 bit = 1 没有连续，也没有靠左存放。</p>
<p data-nodeid="3835"><img src="https://s0.lgstatic.com/i/image6/M01/3B/14/Cgp9HWCChyuAd3A7AAB4Cz6xpA8058.png" alt="Drawing 15.png" data-nodeid="4442"></p>
<p data-nodeid="3836">例 3，满足条件 1，也满足条件 2。针对相同元素 3 的 bit = 1 同时满足上面两个条件。</p>
<p data-nodeid="3837"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChzGAQNfYAAB_IwcBfBU453.png" alt="Drawing 16.png" data-nodeid="4446"></p>
<p data-nodeid="3838">例 4，针对元素 3 的选择，同时满足两个条件。</p>
<p data-nodeid="3839"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCChziACLWvAACesKL-RlQ770.png" alt="Drawing 17.png" data-nodeid="4450"></p>
<p data-nodeid="3840">例 5，针对相同元素 3 和 4，其中元素 3 的 bit = 1 满足两个条件，但是元素 4 的 bit 位不满足条件 2。因此，这个二进制串也不满足两个条件。</p>
<p data-nodeid="3841">那么按照这个规则，在生成子集的同时，我们还要<strong data-nodeid="4457">检查一下二进制串是否满足条件 1 和条件 2</strong>。</p>
<blockquote data-nodeid="3842">
<p data-nodeid="3843">注意：这里只是为了方便写代码，所以采用这个规则来挑选二进制串，挑选二进制串的方法并不是唯一的，你也可以选择其他简便的方法。</p>
</blockquote>
<p data-nodeid="3844">经过前面的分析，我们可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3845"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = nums == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : nums.length;
        Arrays.sort(nums);
        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span>&lt;&lt;N); i++) {
            List&lt;Integer&gt; subset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-comment">// 这里在检查每个bit的时候，还要带个逻辑</span>
            <span class="hljs-comment">// 那就是如果值相同的时候，我们希望是有连续的1bit</span>
            <span class="hljs-keyword">boolean</span> validSubset = <span class="hljs-keyword">true</span>;
            <span class="hljs-comment">// 我们依次查看每个bit</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N; j++) {
                <span class="hljs-comment">// 如果当前值与之前的值是一样的。</span>
                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] == nums[j-<span class="hljs-number">1</span>]) {
                    <span class="hljs-comment">// 取出当前bit</span>
                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curBit = i &amp; (<span class="hljs-number">1</span>&lt;&lt;j);
                    <span class="hljs-comment">// 取出之前一位bit</span>
                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> preBit = i &amp; (<span class="hljs-number">1</span>&lt;&lt;(j-<span class="hljs-number">1</span>));
                    <span class="hljs-comment">// 如果当前位为1，但是之前位为0</span>
                    <span class="hljs-comment">// 这种情况是不允许的</span>
                    <span class="hljs-keyword">if</span> (curBit != <span class="hljs-number">0</span> &amp;&amp; preBit == <span class="hljs-number">0</span>) {
                        validSubset = <span class="hljs-keyword">false</span>;
                        <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-comment">// 如果这个bit为1，那么被选中</span>
                <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span>&lt;&lt;j)) != <span class="hljs-number">0</span>) {
                    subset.add(nums[j]);
                }
            }
            <span class="hljs-keyword">if</span> (validSubset) {
                ans.add(subset);
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="3846">
<p data-nodeid="3847">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4463">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4467">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.binary.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4471">Python</a></p>
</blockquote>
<h3 data-nodeid="3848">通用方法 4：以退为进</h3>
<p data-nodeid="3849">接下来，我们重点讨论一下题目 2。在题目 2 去重的时候。如果我们再深入思考一下挑选二进制串的本质。不难发现，当数组为 A[] = {1, 2, 2, 2, 2} 时，我们只是想往子集中加入 2 的时候，分别往子集中添加：</p>
<pre class="lang-java" data-nodeid="3850"><code data-language="java"><span class="hljs-comment">// 比如A[] = [1, 2, 2, 2, 2]</span>
<span class="hljs-comment">//      0  0  0  0  0</span>
<span class="hljs-comment">//      0  1  0  0  0 &lt;-- 加入1个2</span>
<span class="hljs-comment">//      0  1  1  0  0 &lt;-- 加入2个2</span>
<span class="hljs-comment">//      0  1  1  1  0 &lt;-- 加入3个2</span>
<span class="hljs-comment">//      0  1  1  1  1 &lt;-- 加入4个2</span>
<span class="hljs-comment">//      1  0  0  0  0</span>
<span class="hljs-comment">//      1  1  0  0  0 &lt;-- 加入1个2</span>
<span class="hljs-comment">//      1  1  1  0  0 &lt;-- 加入2个2</span>
<span class="hljs-comment">//      1  1  1  1  0 &lt;-- 加入3个2</span>
<span class="hljs-comment">//      1  1  1  1  1 &lt;-- 加入4个2</span>
</code></pre>
<p data-nodeid="3851">那么，我们有没有可能采用下面这种思路？</p>
<p data-nodeid="3852">首先记录数组中每个数出现的次数 hash[number] = count；接着，将数组中的元素去重。最后，当我们需要往子集中加入某个数的时候，只需要在题目 1 的基础上做一点变动：</p>
<blockquote data-nodeid="3853">
<p data-nodeid="3854">选中某个数的时候，需要加入 1 个,2 个, ..., hash[number] 个这样的数。</p>
</blockquote>
<p data-nodeid="3855">处理题目 2 的过程，实际上是先退回了题目 1（这里我们选中了 BFS 算法），然后再在加入元素的次数上做了调整。</p>
<p data-nodeid="3856">通过这种思路，就可以写出题目 2 代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3857"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">Integer</span>, <span class="hljs-title">Integer</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(Integer k)</span> </span>{
        <span class="hljs-keyword">return</span> containsKey(k) ? <span class="hljs-keyword">super</span>.get(k) : <span class="hljs-number">0</span>;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span> </span>{
        put(k, get(k) + v);
        <span class="hljs-keyword">if</span> (get(k) &lt;= <span class="hljs-number">0</span>) {
            remove(k);
        }
    }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) {
        Counter cnt = <span class="hljs-keyword">new</span> Counter();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) {
            cnt.add(x, <span class="hljs-number">1</span>);
        }
        List&lt;List&lt;Integer&gt;&gt; cur = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        cur.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; en: cnt.entrySet()) {
            <span class="hljs-comment">// BFS的next</span>
            List&lt;List&lt;Integer&gt;&gt; next = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> addTimes = <span class="hljs-number">1</span>; 
                 addTimes &lt;= en.getValue(); addTimes++) {
                <span class="hljs-comment">// 遍历cur中的每一个subset</span>
                <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset: cur) {
                    <span class="hljs-comment">// 生成新的subset</span>
                    List&lt;Integer&gt; newSubset = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(subset);
                    <span class="hljs-comment">// 添加选中的数 addTimes次到集合中</span>
                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; addTimes; j++) {
                        newSubset.add(en.getKey());
                    }
                    next.add(newSubset);
                }
            }
            <span class="hljs-comment">// 将next放到cur中。</span>
            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; subset: next) {
                cur.add(subset);
            }
        }
        <span class="hljs-keyword">return</span> cur;
    }
}
</code></pre>
<blockquote data-nodeid="3858">
<p data-nodeid="3859">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4493">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4497">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.BFS.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4501">Python</a></p>
</blockquote>
<h3 data-nodeid="3860">通用方法 5：分治</h3>
<p data-nodeid="3861">首先我们看一下<strong data-nodeid="4511">题目 1</strong>，如果给定的数组 A[] = {1, 2}。实际上我们同然可以这样操作，得到所有的子集。</p>
<blockquote data-nodeid="3862">
<p data-nodeid="3863">分治算法总是可以画成二叉树的样子，所以这里我们借助二叉树来展示分治的过程。</p>
</blockquote>
<p data-nodeid="3864"><img src="https://s0.lgstatic.com/i/image6/M01/3B/15/Cgp9HWCCh0eATulfAAT7HVtlTIg477.gif" alt="1.gif" data-nodeid="4515"></p>
<p data-nodeid="3865">基于这种思想，可以得到<strong data-nodeid="4521">题目 1</strong>分治的解法，代码如下：</p>
<pre class="lang-java" data-nodeid="3866"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">// 将两个合并成一个</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">merge</span><span class="hljs-params">(List&lt;Integer&gt; a, List&lt;Integer&gt; b)</span> </span>{
        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);
        <span class="hljs-keyword">for</span> (Integer x: b) {
            tmp.add(x);
        }
        <span class="hljs-keyword">return</span> tmp;
    }
    <span class="hljs-comment">// 注意：这里给的区间是左闭右开[b, e)</span>
    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; dq(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e) {
        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
        <span class="hljs-keyword">if</span> (b &gt;= e) {
            <span class="hljs-keyword">return</span> ans;
        }
        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
            tmp.add(nums[b]);
            ans.add(tmp);
            <span class="hljs-keyword">return</span> ans;
        }
        <span class="hljs-comment">// 如果数组里面没有重复元素，那么只需要从中间切分开就可以了</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = b + ((e-b)&gt;&gt;<span class="hljs-number">1</span>);
        List&lt;List&lt;Integer&gt;&gt; l = dq(nums, b, mid);
        List&lt;List&lt;Integer&gt;&gt; r = dq(nums, mid, e);
        <span class="hljs-comment">// 两两组合</span>
        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; x: l) {
            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; y: r) {
                <span class="hljs-comment">// 由于我们已经在ans中存放了空集，所以如果遇到两个都是空集的时候</span>
                <span class="hljs-comment">// 我们就不再进行merge</span>
                <span class="hljs-keyword">if</span> (x.isEmpty() &amp;&amp; y.isEmpty()) {
                    <span class="hljs-keyword">continue</span>;
                }
                ans.add(merge(x, y));
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = nums == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : nums.length;
        <span class="hljs-keyword">return</span> dq(nums, <span class="hljs-number">0</span>, N);
    }
}
</code></pre>
<blockquote data-nodeid="3867">
<p data-nodeid="3868">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4525">Jav</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4528">a/</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4531">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/78.%E5%AD%90%E9%9B%86.dq.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4535">Python</a><br>
我们需要格外注意空集的处理，合并的时候，如果两个集合都是空集，就不要再加入返回值了。因为它们之前已经加入空集（代码 13 行）了，重复加入会导致返回值中存在很多空集。</p>
</blockquote>
<p data-nodeid="3869">那么，我们应该如何处理题目 2 呢？如果仍然延续上述处理思路，在处理 A[] = {1, 2, 2, 2} 的时候，就会遇到问题。</p>
<p data-nodeid="3870"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh1SAOfdmABHxRZZnCOw782.gif" alt="2.gif" data-nodeid="4544"></p>
<p data-nodeid="3871">那么，有没有办法解决冲突 1 和冲突 2 呢？</p>
<p data-nodeid="3872">首先来看<strong data-nodeid="4555">冲突 1</strong>，产生冲突 1 的本质是因为，当数组已经被切分成 [2, 2] 的时候，实际上可以直接通过计算 2 的个数来生成子集。这里有 2 个 2，所以可以直接生成如下子集：</p>
<pre class="lang-java" data-nodeid="3873"><code data-language="java">{},   <span class="hljs-number">0</span>个<span class="hljs-number">2</span>
{<span class="hljs-number">2</span>},  <span class="hljs-number">1</span>个<span class="hljs-number">2</span>
{<span class="hljs-number">2</span>,<span class="hljs-number">2</span>} <span class="hljs-number">2</span>个<span class="hljs-number">2</span>
</code></pre>
<p data-nodeid="3874">也就是说，当数组里面的元素都是一样的时候，我们不能再进行切分。</p>
<p data-nodeid="3875">那么再查看<strong data-nodeid="4562">冲突 2</strong>。产生冲突 2 的根本原因在于：元素 2 分散在很多地方，每次合并的时候，都有可能生成重复的子集。在切分的时候，我们应该采用如下图所示的方法进行切分：</p>
<p data-nodeid="3876"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh16AHJ7BAABqOFr59u8458.png" alt="Drawing 20.png" data-nodeid="4565"></p>
<p data-nodeid="3877">那么，这里可以总结为两个原则。</p>
<ul data-nodeid="3878">
<li data-nodeid="3879">
<p data-nodeid="3880">原则 1：当范围里面的数都是一样的时候，不能切分，而是采用计数的原则来生成子集。</p>
</li>
<li data-nodeid="3881">
<p data-nodeid="3882">原则 2：相同的数，不能被切分开，而是要当成一个整体。</p>
</li>
</ul>
<p data-nodeid="3883">基于这两个原则，我们就可以写出题目 2 的分治的代码了，如下所示（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="3884"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">// 将两个合并成一个</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">merge</span><span class="hljs-params">(List&lt;Integer&gt; a, List&lt;Integer&gt; b)</span> </span>{
        List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);
        <span class="hljs-keyword">for</span> (Integer x: b) {
            tmp.add(x);
        }
        <span class="hljs-keyword">return</span> tmp;
    }
    <span class="hljs-comment">// 查看这段区域里面的值是不是都是一样的</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSame</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
        <span class="hljs-keyword">boolean</span> same = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b; i &lt; e; i++) {
            <span class="hljs-keyword">if</span> (nums[i] != nums[b]) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-comment">// 注意：这里给的区间是左闭右开[b, e)</span>
    <span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; dq(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e) {
        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());
        <span class="hljs-keyword">if</span> (b &gt;= e) {
            <span class="hljs-keyword">return</span> ans;
        }
        <span class="hljs-comment">// 如果整段区间里面的值都是一样的</span>
        <span class="hljs-comment">// 那么在选择的时候，只有e - b种情况</span>
        <span class="hljs-comment">// 比如有[2, 2]</span>
        <span class="hljs-comment">// 那么这里会添加子集</span>
        <span class="hljs-comment">// - [2]</span>
        <span class="hljs-comment">// - [2, 2]</span>
        <span class="hljs-comment">// 使用原则1：</span>
        <span class="hljs-keyword">boolean</span> same =isSame(nums, b, e);
        <span class="hljs-keyword">if</span> (same) {
            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b; i &lt; e; i++) {
                tmp.add(nums[i]);
                ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(tmp));
            }
            <span class="hljs-keyword">return</span> ans;
        }
        <span class="hljs-comment">// 如果数组里面没有重复元素，那么只需要从中间切分开就可以了</span>
        <span class="hljs-keyword">int</span> mid = b + ((e-b)&gt;&gt;<span class="hljs-number">1</span>);
        <span class="hljs-comment">// 接下来是使用原则2：要让所有相同的数，必须要当成一个整体</span>
        <span class="hljs-comment">// 不能被切散了</span>
        <span class="hljs-keyword">int</span> l = mid - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &gt;= b &amp;&amp; nums[l] == nums[mid]) {
            l--;
        }
        <span class="hljs-keyword">int</span> r = mid;
        <span class="hljs-keyword">while</span> (r &lt; e &amp;&amp; nums[r] == nums[mid]) {
            r++;
        }
        <span class="hljs-comment">// 正常情况下，我们切分点都选择 r</span>
        <span class="hljs-keyword">int</span> cutPos = r;
        <span class="hljs-comment">// 但是如果右边[r, e)这个区间已经没有数了</span>
        <span class="hljs-keyword">if</span> (r &gt;= e) {
            <span class="hljs-comment">// 我们需要把(l, r)这个区间划给右边</span>
            cutPos = l + <span class="hljs-number">1</span>;
        }
        List&lt;List&lt;Integer&gt;&gt; lans = dq(nums, b, cutPos);
        List&lt;List&lt;Integer&gt;&gt; rans = dq(nums, cutPos, e);
        <span class="hljs-comment">// 两两组合</span>
        <span class="hljs-keyword">for</span> (List&lt;Integer&gt; x: lans) {
            <span class="hljs-keyword">for</span> (List&lt;Integer&gt; y: rans) {
                <span class="hljs-comment">// 由于我们已经在ans中存放了空集，所以如果遇到两个都是空集的时候</span>
                <span class="hljs-comment">// 我们就不再进行merge</span>
                <span class="hljs-keyword">if</span> (x.isEmpty() &amp;&amp; y.isEmpty()) {
                    <span class="hljs-keyword">continue</span>;
                }
                ans.add(merge(x, y));
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="hljs-keyword">int</span>[] nums) {
        <span class="hljs-keyword">if</span> (nums == <span class="hljs-keyword">null</span> || nums.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        }
        Arrays.sort(nums);
        <span class="hljs-keyword">return</span> dq(nums, <span class="hljs-number">0</span>, nums.length);
    }
}
</code></pre>
<blockquote data-nodeid="3885">
<p data-nodeid="3886">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4573">Jav</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4576">a</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4580">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/17.Subset/90.%E5%AD%90%E9%9B%86-ii.dq.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="4584">Python</a></p>
</blockquote>
<h3 data-nodeid="3887">总结</h3>
<p data-nodeid="6453">在本讲，我们通过分析题目的不同特点，展开了不同的解题思路，构造出了 5 种不同的解法。这里，我将 5 种解法进行了一个总结，如下图所示：</p>
<p data-nodeid="6454" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/9C/CioPOWCGG5KAdVEJAAHM2pBloNY568.png" alt="图片1.png" data-nodeid="6458"></p>






<p data-nodeid="3890">题目是做不完的，但是我们可以通过分析每一个题目来锻炼挖掘题目信息的能力，以及匹配到我们大脑中已经存储的数据结构与算法的能力。同时，也可以通过这种方式，将学会的知识变成我们解决问题的能力，只有这样“学习”才能变成“学会”。</p>
<h3 data-nodeid="3891">思考题</h3>
<p data-nodeid="3892"><strong data-nodeid="4596">最后，我再给你留一个思考题：在求解题目 2 的每一种方法中，我们都提前对数组进行了排序的处理，每次排序的原因和目的分别是什么</strong>？</p>
<p data-nodeid="3893">可以把你的分析写在留言区，我们一起讨论。如果你觉得今天的内容对你有所启发，欢迎分享给身边的朋友。</p>
<p data-nodeid="3894" class="">好了，子集问题我们就学习到这里，希望你还能找出更多有趣的解法。接下来让我们前进到18 | 单词接龙：如何巧用深搜与广搜的变形？记得按时来探险。</p>

---

### 精选评论

##### **威：
> 太强了～

