<p data-nodeid="3">今天开始进行算法模板的复习和整理。授人以鱼，不如授人以渔。在本讲，我的目的是教会你如何做知识的整理和模板的整理，而不是直接给你一些现成的东西，让你去死记硬背。无论是思维导图，还是代码模板，你自己整理一遍的收获会更大。</p>
<p data-nodeid="4">今天我们主要介绍两种方法：</p>
<ul data-nodeid="5">
<li data-nodeid="6">
<p data-nodeid="7">通过思维导图将学过的知识添加到你的知识树中；</p>
</li>
<li data-nodeid="8">
<p data-nodeid="9">将刷过的题目整理成代码模板，放到你的代码模板库中。</p>
</li>
</ul>
<h3 data-nodeid="10">排序</h3>
<p data-nodeid="11">我们在学习排序的时候，主要讨论了合并模板和快速排序两种排序，现在就可以利用下面这个思维导图进行快速复习。</p>
<p data-nodeid="1808" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/78/CioPOWCeKsyAZhzxAAKp0wZR38g731.png" alt="Drawing 0.png" data-nodeid="1811"></p>

<h4 data-nodeid="13">合并的技巧</h4>
<p data-nodeid="14">对于合并排序来说，我觉得最重要的是掌握下面这段合并的小技巧：</p>
<pre class="lang-java" data-nodeid="15"><code data-language="java">    <span class="hljs-keyword">int</span> i = b;
    <span class="hljs-keyword">int</span> j = m;
    <span class="hljs-keyword">int</span> to = b;
    
    <span class="hljs-comment">// 将两个子数组进行合并, 注意下面是一个很重要的模板</span>
    <span class="hljs-comment">// 这里的判断条，是只要两个子数组中还有元素</span>
    <span class="hljs-keyword">while</span> (i &lt; m || j &lt; e) {
      <span class="hljs-comment">// 如果右子数组没有元素 或 左子数组开头的元素小于右子数组开头的元素</span>
      <span class="hljs-comment">// 那么取走左子数组开头的元素</span>
      <span class="hljs-comment">// 考点：a[i] &lt;= a[j]这样可以保证合并排序是稳定的，不要写错!</span>
      <span class="hljs-keyword">if</span> (j &gt;= e || i &lt; m &amp;&amp; a[i] &lt;= a[j]) {
        t[to++] = a[i++];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 否则就是取右子数组开头的元素</span>
        t[to++] = a[j++];
      }
    }
</code></pre>
<blockquote data-nodeid="16">
<p data-nodeid="17">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="136">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="140">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/mergeSort.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="144">Python</a></p>
</blockquote>
<p data-nodeid="18">可以看到 while 语句中 if 语句的写法（上述代码第 11 行）用了最简洁的代码处理了各种边界条件！</p>
<h4 data-nodeid="19">三路切分</h4>
<p data-nodeid="20">在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="150">《08 | 排序：如何利用合并与快排的小技巧，解决算法难题？》</a>介绍快速排序时，三路切分也是一个高频出现的知识点，所以我们需要掌握这个代码模板，如下所示：</p>
<pre class="lang-java" data-nodeid="21"><code data-language="java"><span class="hljs-comment">// 辅助函数：交换数组中的两个元素</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">int</span> t = A[i];
  A[i] = A[j];
  A[j] = t;
}
<span class="hljs-comment">// 三路切分</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">threeSplit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
  <span class="hljs-keyword">if</span> (b &gt;= e) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-comment">// 我们取数组中间的数 </span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[m];
  <span class="hljs-comment">// 注意我们的初始区间有四个：</span>
  <span class="hljs-comment">// [b, l) [l, i) [i, r] (r, N)</span>
  <span class="hljs-comment">// [小于)  [等于) [未知]  (大于)</span>
  <span class="hljs-keyword">int</span> l = b;
  <span class="hljs-keyword">int</span> i = b;
  <span class="hljs-keyword">int</span> r = e - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (i &lt;= r) {
    <span class="hljs-keyword">if</span> (A[i] &lt; x) {
      swap(A, l++, i++);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[i] == x) {
      i++;
    } <span class="hljs-keyword">else</span> {
      swap(A, r--, i);
    }
  }
  <span class="hljs-comment">// 切分完毕之后，只有三个区间</span>
  <span class="hljs-comment">// [b, l) [l, i) [i, N)</span>
  <span class="hljs-comment">// 首先看中间的区间</span>
  <span class="hljs-keyword">if</span> (i - l == <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> A[l];
  <span class="hljs-comment">// 再看左区间</span>
  <span class="hljs-keyword">if</span> (((l - b) &amp; <span class="hljs-number">0x01</span>) == <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> threeSplit(A, b, l);
  }
  <span class="hljs-comment">// 再看右区间</span>
  <span class="hljs-keyword">return</span> threeSplit(A, i, e);
}
</code></pre>
<blockquote data-nodeid="22">
<p data-nodeid="23">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="155">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="159">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/136.%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="163">Python</a></p>
</blockquote>
<h3 data-nodeid="2530">二分</h3>


<p data-nodeid="26">我们将二分的知识点整理如下：</p>
<p data-nodeid="3248" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/70/Cgp9HWCeKtqAJXLXAAJ_yPY2KLM148.png" alt="Drawing 1.png" data-nodeid="3251"></p>

<p data-nodeid="28">当已知一个题目可以用二分进行破解时，就可以使用 lowerBound 和 upperBound 这两个标准的二分的模板了。</p>
<p data-nodeid="29">此外，我们还需要记住这两个模板的使用的条件：</p>
<ul data-nodeid="30">
<li data-nodeid="31">
<p data-nodeid="32">lowerBound 用于查找有序数组中最左边出现的元素（闭）。</p>
</li>
<li data-nodeid="33">
<p data-nodeid="34">upperBound 用于查找有序数组中最右边出现的元素（开）。</p>
</li>
</ul>
<p data-nodeid="35">注意，我们在条件部分加了“<strong data-nodeid="178">开闭</strong>”两个字！其含义如下：</p>
<p data-nodeid="36">当给定数组 A[] = {1,2,2,2,3}，运行 lowerBound(A, 2) 返回下标 1，而运行 upperBound(A,2) 却返回下标 4，但此时 A[4] = 3。</p>
<p data-nodeid="37">因此，我们还需要注意，lowerBound 与 upperBound 返回值组成的区间是一个<strong data-nodeid="192">左闭右开</strong>的区间，如下所示：</p>
<pre class="lang-java" data-nodeid="38"><code data-language="java">[lowerBound(A,<span class="hljs-number">2</span>), upperBound(A,<span class="hljs-number">2</span>)) = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)
</code></pre>
<p data-nodeid="39">一定要记住这里的<strong data-nodeid="198">左闭右开原则</strong>！</p>
<h4 data-nodeid="40">lowerBound</h4>
<p data-nodeid="41">其中 lowerBound 的代码模板如下：</p>
<pre class="lang-java" data-nodeid="42"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> target)</span> </span>{
  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
  <span class="hljs-keyword">while</span> (l &lt; r) {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (A[m] &lt; target) {
      l = m + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      r = m;
    }
  }
  <span class="hljs-keyword">return</span> l;
}
</code></pre>
<blockquote data-nodeid="43">
<p data-nodeid="44">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="204">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="208">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1560.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="212">Python</a></p>
</blockquote>
<h4 data-nodeid="3968">upperBound</h4>


<p data-nodeid="47">upperBound 的<strong data-nodeid="219">模板代码</strong>如下：</p>
<pre class="lang-java" data-nodeid="48"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upperBound</span><span class="hljs-params">(<span class="hljs-keyword">long</span>[] A, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">long</span> target)</span> </span>{
  <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = n;
  <span class="hljs-keyword">while</span> (l &lt; r) {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">if</span> (A[m] &lt;= target) {
      l = m + <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      r = m;
    }
  }
  <span class="hljs-keyword">return</span> l;
}
</code></pre>
<blockquote data-nodeid="49">
<p data-nodeid="50">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="223">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="227">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/09.BinarySearch/T1562.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="231">Python</a></p>
</blockquote>
<p data-nodeid="51">其实我们只需要记忆 lowerBound 模板就够了，因为两个模板之间的差异只有一处：</p>
<blockquote data-nodeid="52">
<p data-nodeid="53">lowerBound：A[m] &lt; target<br>
upperBound：A[m] &lt;= target</p>
</blockquote>
<p data-nodeid="54">这里和你分享一个我的记忆方法。当 A[m] &lt;= target 的时候，标志着 m 还可以往右移动一段距离，因为 upperBound 找到的一般都在更右边的位置，因此带有“A[m] &lt;= target”的是 upperBound。</p>
<h3 data-nodeid="55">双指针</h3>
<p data-nodeid="56">双指针的知识我们总结如下：</p>
<p data-nodeid="4684" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/70/Cgp9HWCeKvKAN-9UAAD_-oFBQLA882.png" alt="Drawing 2.png" data-nodeid="4687"></p>

<p data-nodeid="58">需要熟练掌握的代码模板，一共有 3 个。</p>
<h4 data-nodeid="59">最长区间</h4>
<p data-nodeid="60">求最长区间的代码模板长成这样：</p>
<pre class="lang-java" data-nodeid="61"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">int</span> N = A.length;
  <span class="hljs-comment">// 区间的左指针</span>
  <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-comment">// assert 在加入A[i]之前，(left, i-1]是一个合法有效的区间</span>
    <span class="hljs-comment">// step 1. 直接将A[i]加到区间中，形成(left, i]</span>
    <span class="hljs-comment">// step 2. 将A[i]加入之后，惰性原则</span>
    <span class="hljs-keyword">while</span> (check((left, i]))<span class="hljs-comment">/*TODO 检查区间状态是否满足条件*/</span>) {
      ++left; <span class="hljs-comment">// 如果不满足条件，移动左指针</span>
      <span class="hljs-comment">// TODO 修改区间的状态</span>
    }
    <span class="hljs-comment">// assert 此时(left, i]必然满足条件</span>
    ans = max(ans, i - left);
  }
  <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回最优解</span>
}
</code></pre>
<p data-nodeid="62">注意：在解题的时候，需要根据具体的题目条件，在模板的基础上写一点状态更新的代码，也就是要替换掉代码模板中的“TODO”部分。</p>
<h4 data-nodeid="63">定长区间</h4>
<p data-nodeid="64">其实定长区间就是固定窗口大小的滑动窗口算法，这里我整理好了一个通用的模板，如下所示：</p>
<pre class="lang-java" data-nodeid="65"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fixedLength</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> windowSize)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-comment">// step 1. 直接将A[i]加到区间中，形成(left, i]</span>
    <span class="hljs-comment">// TODO 修改区间的状态</span>

    <span class="hljs-comment">// 如果滑动窗口还太小</span>
    <span class="hljs-keyword">if</span> (i - left &lt; windowSize) {
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-comment">// assert 此时(left, i]长度必然等于windowSize</span>
    <span class="hljs-comment">// TODO 判断区间的状态是否满足约束条件</span>
    left++;
    <span class="hljs-comment">// step 2. 移除A[left]</span>
    <span class="hljs-comment">// TODO 修改区间状态</span>
  }
  <span class="hljs-keyword">return</span> ans; <span class="hljs-comment">// 返回最优解</span>
</code></pre>
<p data-nodeid="66">注意：这个代码模板也是需要根据具体的题目条件完成“TODO”的部分。不同的题目，状态更新的代码可能会稍有不同。</p>
<h4 data-nodeid="67">最短区间</h4>
<p data-nodeid="68">最短区间的代码模板如下：</p>
<pre class="lang-java" data-nodeid="69"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimalRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-comment">// 子串的左边，采用左开右闭原则(left, i]表示一个子串</span>
  <span class="hljs-keyword">int</span> left = -<span class="hljs-number">1</span>;
  <span class="hljs-comment">// 记录最短的子串的长度</span>
  <span class="hljs-keyword">int</span> ans = A.length + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-comment">// 注意 在加入A[i]之前，(left, i-1]可能不满足条件!</span>
    <span class="hljs-comment">// step 1. 直接将A[i]加到区间中，形成(left, i]</span>
    <span class="hljs-comment">// step 2. TODO 更新区间的状态</span>
    <span class="hljs-keyword">while</span> (区间超出/满足条件) {
      ans = Math.min(ans, i - left);
      <span class="hljs-comment">// step 3. 移除A[++left];</span>
      <span class="hljs-comment">// step 4. TODO 更新区间的状态</span>
    }
    <span class="hljs-comment">// assert ! 区间(left, i]到这里肯定不满足条件</span>
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<p data-nodeid="70">注意：状态更新的代码同样需要根据题目的条件完成“TODO”的部分。</p>
<h3 data-nodeid="71">贪心</h3>
<p data-nodeid="72">虽然说贪心算法是一种思想，不过还是有一些代码模板需要你掌握。比如<strong data-nodeid="282">区间不重复的最大数目模板</strong>，如下所示：</p>
<pre class="lang-java" data-nodeid="73"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nonOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-comment">// 将区间进行排序</span>
  Arrays.sort(A, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
      <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
    }
  });
  <span class="hljs-comment">// 已重叠的区间的最右端点</span>
  <span class="hljs-keyword">int</span> maxEnd = Integer.MIN_VALUE;
  <span class="hljs-comment">// 不重叠 的区间的个数</span>
  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 开始贪心算法</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = A[i][<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (maxEnd &lt;= start) {
      maxEnd = A[i][<span class="hljs-number">1</span>];
      ans++;
    }
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="74">
<p data-nodeid="75">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="286">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="290">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="294">Python</a></p>
</blockquote>
<p data-nodeid="76">此外，在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="298">《11 | 贪心：这种思想，没有模板，如何才能掌握它？》</a>中我们介绍过“青蛙跳”问题， 实际上该解法还可以解决一系列题目，比如“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="302">第 11 讲</a>”的练习题 5，练习题 6 等。因此，我把这个算法模板叫作<strong data-nodeid="308">青蛙跳模板</strong>。</p>
<pre class="lang-java" data-nodeid="77"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-comment">// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过</span>
  <span class="hljs-comment">// 所以之记录之前扫描位置设置为-1</span>
  <span class="hljs-keyword">int</span> preScanedPos = -<span class="hljs-number">1</span>;
  <span class="hljs-comment">// 根据题意</span>
  <span class="hljs-comment">// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素</span>
  <span class="hljs-keyword">int</span> curCoveredRange = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 如果当前</span>
  <span class="hljs-keyword">while</span> (curCoveredRange &lt; N - <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">int</span> oldCoveredRange = curCoveredRange;
    <span class="hljs-comment">// 根据优化1和优化2，我们只需要遍历</span>
    <span class="hljs-comment">// [preScanedPos + 1, oldCoveredRange]即可。</span>
    <span class="hljs-comment">// 然后不停更新curCoveredRange</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = preScanedPos + <span class="hljs-number">1</span>; i &lt;= oldCoveredRange; i++) {
      <span class="hljs-comment">// 1. 这个区间和我们已经覆盖的范围是相连的!</span>
      <span class="hljs-comment">// 满足相连性</span>
      <span class="hljs-comment">// 2. 如果这个区间能覆盖得更远</span>
      <span class="hljs-keyword">if</span> (i + A[i] &gt; curCoveredRange) {
        <span class="hljs-comment">// 更新我们能cover的范围</span>
        curCoveredRange = i + A[i];
      }
    }
    <span class="hljs-comment">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span>
    <span class="hljs-keyword">if</span> (oldCoveredRange == curCoveredRange) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-comment">// 我们记住上次已经扫描过的位置</span>
    preScanedPos = oldCoveredRange;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
}
</code></pre>
<blockquote data-nodeid="78">
<p data-nodeid="79">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="312">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="316">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="320">Python</a></p>
</blockquote>
<h3 data-nodeid="5402">回溯</h3>


<p data-nodeid="82">关于回溯，我经常从两个方向思考：</p>
<ul data-nodeid="83">
<li data-nodeid="84">
<p data-nodeid="85">只看第 i 个人怎么选；</p>
</li>
<li data-nodeid="86">
<p data-nodeid="87">“有借有还”。</p>
</li>
</ul>
<p data-nodeid="88">关于这两点，希望你看了下面的这个思维导图还能够想起来。</p>
<p data-nodeid="6116" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/70/Cgp9HWCeKwaAJ2zMAAIfg-QqiDc133.png" alt="Drawing 3.png" data-nodeid="6119"></p>

<p data-nodeid="90">回溯的代码模板只有一个，如下所示：</p>
<pre class="lang-java" data-nodeid="91"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A,
               <span class="hljs-keyword">int</span> i, <span class="hljs-comment">/*第i个人*/</span>
               Box s, <span class="hljs-comment">/*箱子*/</span>
               answer<span class="hljs-comment">/*存放所有的答案*/</span>)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">if</span> (状态满足要求) {
    answer.add(s);
  }
 
  <span class="hljs-keyword">if</span> ([i, ...., 后面）的人都没有任何选项了) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">for</span> 宝石 in {第i个人当前所有宝石选项} {
    s.push(宝石);
    backtrace(A, i + <span class="hljs-number">1</span>, s, answer);
    s.pop();
  }
}
</code></pre>
<h3 data-nodeid="6832">DFS 与 BFS</h3>


<p data-nodeid="94">DFS 与 BFS 的知识点我压缩在了一张思维导图里：</p>
<p data-nodeid="7544" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3F/70/Cgp9HWCeKxCAccrHAADkE8e9C7Y821.png" alt="Drawing 4.png" data-nodeid="7547"></p>

<p data-nodeid="96">关于代码模板，你只需要掌握两个。</p>
<h4 data-nodeid="97">DFS</h4>
<p data-nodeid="98">通常而言，DFS 算法会用到两个模板，一个用于遍历，另一个用于收集符合条件的解。其中用于遍历的代码模板如下：</p>
<pre class="lang-java" data-nodeid="99"><code data-language="java"><span class="hljs-keyword">boolean</span> vis[N];
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>{
  <span class="hljs-keyword">if</span> start == end {
      success = <span class="hljs-keyword">true</span>
      <span class="hljs-keyword">return</span>
  }
  <span class="hljs-comment">// 遍历当前可以做出的选择</span>
  <span class="hljs-function"><span class="hljs-keyword">for</span> opt in <span class="hljs-title">getOptions</span><span class="hljs-params">(start)</span> </span>{
      <span class="hljs-keyword">if</span> (vis[opt]) <span class="hljs-keyword">continue</span>;
      vis[opt] = <span class="hljs-keyword">true</span>;
      dfs(opt);
      <span class="hljs-keyword">if</span> success {
          <span class="hljs-keyword">return</span>;
      }
  }
}
</code></pre>
<p data-nodeid="100">用于收集符合条件的解的代码模板如下：</p>
<pre class="lang-java" data-nodeid="101"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(A,
         <span class="hljs-keyword">int</span> start, <span class="hljs-comment">/* start 表示出发点*/</span>
         vis,  <span class="hljs-comment">/* 记录每个点是否已经访问 */</span>
         path, <span class="hljs-comment">/* 路径*/</span>
         answer<span class="hljs-comment">/*存放最优的答案*/</span>)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
 
  <span class="hljs-keyword">if</span> (状态满足要求) { <span class="hljs-comment">// 是更好的解吗？</span>
    <span class="hljs-keyword">if</span> (s better_than ans) {
        ans = s
    }
    <span class="hljs-keyword">return</span>;
  }
  
  <span class="hljs-keyword">for</span> next in {start点的后继点} {
    <span class="hljs-keyword">if</span> !vis[next] {
      path.append(next);
      vis[next] = <span class="hljs-keyword">true</span>;
      dfs(A, next, vis, path, answer);
      path.pop();
      vis[next] = <span class="hljs-keyword">false</span>;
    }
  }
}
</code></pre>
<h4 data-nodeid="8258">BFS</h4>


<p data-nodeid="104">巧合的是，BFS 也有两种写法，一种是使用队列，另一种是使用“两段击”。其中使用队列的代码写法如下：</p>
<pre class="lang-java" data-nodeid="105"><code data-language="java">bfs(s) { <span class="hljs-comment">// s表示出发点</span>
  q = <span class="hljs-keyword">new</span> queue()
  q.push(s), visited[s] = <span class="hljs-keyword">true</span> <span class="hljs-comment">// 标记s为已访问</span>
  <span class="hljs-keyword">while</span> (!q.empty()) {
    u = q.pop() <span class="hljs-comment">// 拿到当前结点 </span>
    <span class="hljs-function"><span class="hljs-keyword">for</span> next in <span class="hljs-title">getNext</span><span class="hljs-params">(u)</span> </span>{ <span class="hljs-comment">// 拿到u的后继next</span>
      <span class="hljs-keyword">if</span> (!visited[next]) { <span class="hljs-comment">// 如果next还没有访问过 </span>
        q.push(next)
        visited[next] = <span class="hljs-keyword">true</span>
      }
    }
  }
}
</code></pre>
<p data-nodeid="106">使用“两段击”的代码写法如下：</p>
<pre class="lang-java" data-nodeid="107"><code data-language="java">bfs(s) { <span class="hljs-comment">// s表示出发点</span>
  cur = {s};
  visited[s] = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// 标记s为已访问</span>
  <span class="hljs-keyword">while</span> (!cur.empty()) {
    next = [];
    <span class="hljs-keyword">for</span> c in cur {
      <span class="hljs-function"><span class="hljs-keyword">for</span> next in <span class="hljs-title">getNext</span><span class="hljs-params">(c)</span> </span>{
        <span class="hljs-keyword">if</span> (!visited[next]) { <span class="hljs-comment">// 如果next还没有访问过 </span>
          next.append(next);
          visited[next] = <span class="hljs-keyword">true</span>;
        }
      }
    }
    cur = next;
  }
}
</code></pre>
<h3 data-nodeid="8968">动态规划</h3>


<p data-nodeid="110">动态规划其实并没有太多的模板可以套，你需要通过实战练习不停地提高自己的应对能力。掌握动态规划的重点在于 6 步分析法，如下图所示：</p>
<p data-nodeid="9676" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3F/78/CioPOWCeKxyAAzKlAADATI1rcXE081.png" alt="Drawing 5.png" data-nodeid="9679"></p>

<p data-nodeid="112">这里我们重点看一下需要你熟练掌握的  KMP 算法模板（你还记得求 next 数组时的动态规划吗？），如下所示：</p>
<pre class="lang-java" data-nodeid="113"><code data-language="java"><span class="hljs-keyword">int</span>[] buildNext(String sub) {
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = sub == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : sub.length();
  <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span>;
  next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (i &lt; N) {
    <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || sub.charAt(i) == sub.charAt(j)) {
      i++;
      j++;
      <span class="hljs-keyword">if</span> (i &lt; sub.length() &amp;&amp; j &lt; sub.length() &amp;&amp;
          sub.charAt(i) == sub.charAt(j)) {
        next[i] = next[j];
      } <span class="hljs-keyword">else</span> {
        next[i] = j;
      }
    } <span class="hljs-keyword">else</span> {
      j = next[j];
    }
  }
  <span class="hljs-keyword">return</span> next;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(String main, String sub)</span> </span>{
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> alen = main.length();
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> blen = sub.length();
  <span class="hljs-keyword">int</span>[] next = buildNext(sub);
  <span class="hljs-keyword">while</span> (i &lt; alen &amp;&amp; j &lt; blen) {
    <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == j || main.charAt(i) == sub.charAt(j)) {
      <span class="hljs-comment">// 如果匹配成功，那么向前走</span>
      <span class="hljs-comment">// 这里和暴力的方法没有区别</span>
      i++;
      j++;
    } <span class="hljs-keyword">else</span> {
      j = next[j];
    }
  }
  <span class="hljs-comment">// 看一下是不是匹配完了</span>
  <span class="hljs-keyword">return</span> j == blen ? i - blen : -<span class="hljs-number">1</span>;
}
</code></pre>
<blockquote data-nodeid="114">
<p data-nodeid="115">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="351">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="355">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="359">Python</a></p>
</blockquote>
<h3 data-nodeid="116">总结</h3>
<p data-nodeid="117">整理好算法的代码模板之后，最后我再强调一点，也是新手往往容易犯错的地方。</p>
<p data-nodeid="118">不要试图把刷过的所有题都放到代码模板中，因为你复习的时候容易没有重点。另外，人的记忆能力是有限的，如果你强记一段代码，可能效果并不好。更重要的是勤于将知识进行整理、归纳以及压缩。然后将它们打包成知识库中的“积木”，在需要的时候直接拿来用，而不是再从 0 到 1 推导。</p>
<p data-nodeid="119">算法模板就整理到这里了，接下来，我将和你聊聊我的大厂面试经历，谈谈我对算法学习的看法，让我们继续前进。</p>

---

### 精选评论


