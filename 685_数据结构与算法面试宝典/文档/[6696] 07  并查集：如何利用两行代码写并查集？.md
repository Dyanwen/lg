<p data-nodeid="35077" class=""><strong data-nodeid="35440">并查集</strong>是一种树型的数据结构，用于处理一些<strong data-nodeid="35441">不交集（Disjoint Sets）的合并及查询问题</strong>。通常会用到两种操作。</p>
<ul data-nodeid="35078">
<li data-nodeid="35079">
<p data-nodeid="35080">Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</p>
</li>
<li data-nodeid="35081">
<p data-nodeid="35082">Union：将两个子集合并成同一个集合。</p>
</li>
</ul>
<p data-nodeid="35083">因此，这种数据结构称为<strong data-nodeid="35449">并查集</strong>。</p>
<p data-nodeid="35084">在工程中，<strong data-nodeid="35455">并查集往往较多用于数据清理分类等操作</strong>，并且能够以 O(N) 的时间复杂度处理较大的数据量，出现在大厂的面试题中也就不奇怪了。</p>
<p data-nodeid="35085">学完这一讲，你将会收获：</p>
<ul data-nodeid="35086">
<li data-nodeid="35087">
<p data-nodeid="35088">并查集的模板代码</p>
</li>
<li data-nodeid="35089">
<p data-nodeid="35090">如何利用并查集解决<strong data-nodeid="35463">连通域</strong>问题</p>
</li>
<li data-nodeid="35091">
<p data-nodeid="35092">如何利用虚拟点与虚拟边</p>
</li>
<li data-nodeid="35093">
<p data-nodeid="35094">如何利用路径压缩的技巧</p>
</li>
</ul>
<h3 data-nodeid="35095">并查集基础</h3>
<p data-nodeid="35096">首先来看一下并查集要解决的问题，主要有两个。</p>
<ul data-nodeid="35097">
<li data-nodeid="35098">
<p data-nodeid="35099">Find：查询 item 属于<strong data-nodeid="35472">哪个集合</strong></p>
</li>
<li data-nodeid="35100">
<p data-nodeid="35101">Union：将两个集合<strong data-nodeid="35477">进行合并</strong></p>
</li>
</ul>
<p data-nodeid="35102">我们以一个有趣的问题展开。在《倚天屠龙记》这部武侠小说中，有很多帮派，比如：</p>
<p data-nodeid="35103"><img src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZN2AGezPAABjCi7FK4I525.png" alt="Drawing 0.png" data-nodeid="35481"></p>
<p data-nodeid="35104">其中张无忌、谢逊、韦一笑属于明教，而张三丰、莫声谷、宋远桥属于武当派。</p>
<h4 data-nodeid="35105">方法 1</h4>
<p data-nodeid="35106">我们首先设计这样一种方案：采用数组/哈希的方法，记录每个人所在的门派。伪代码如下：</p>
<pre class="lang-java" data-nodeid="35107"><code data-language="java"><span class="hljs-comment">// 伪代码</span>
Map&lt;String, String&gt; = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
H[<span class="hljs-string">"谢逊"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"张无忌"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"韦一笑"</span>] = <span class="hljs-string">"明教"</span>
H[<span class="hljs-string">"莫声谷"</span>] = <span class="hljs-string">"武当"</span>
H[<span class="hljs-string">"张三丰"</span>] = <span class="hljs-string">"武当"</span>
H[<span class="hljs-string">"宋远桥"</span>] = <span class="hljs-string">"武当"</span>
</code></pre>
<p data-nodeid="35108">那么就可以这样查询：</p>
<pre class="lang-java" data-nodeid="35109"><code data-language="java"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String person)</span> </span>{
  <span class="hljs-keyword">return</span> H.get(person);
}
</code></pre>
<p data-nodeid="35110">至此，我们已经完成一个功能了。时间复杂度也很低，可以达到 O(1)。</p>
<p data-nodeid="35111">那我们再看一下合并。假设某一天，张三丰要闭关修炼，决定将武当派暂时交给张无忌代管理，为了方便管理两个帮派，张无忌号令明教的人前往武当派。那么此时就需要进行一个合并 Union 操作，也就是将所有“明教”的人归入“武当”。代码如下：</p>
<pre class="lang-java" data-nodeid="35112"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
  <span class="hljs-keyword">for</span> (item : H) {
    <span class="hljs-keyword">if</span> item.value == <span class="hljs-string">"明教"</span>:
      item.value = <span class="hljs-string">"武当"</span>
  }
}
</code></pre>
<p data-nodeid="35113">但是如此一来，整个时间复杂度就上去了，Union 的时候，时间复杂度变成 O(N)。如果 Union 操作很频繁，那么这种算法就变得不可接受。</p>
<h4 data-nodeid="35114">方法 2</h4>
<p data-nodeid="35115">在这里我们换一种思路，看看能不能解决 Union 复杂度过高的问题。采用江湖中通常的做法，认帮主！当帮主一样的时候，就认为我们是一个帮派的。</p>
<p data-nodeid="35116"><img src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZOaADgCUAABGlTOU4Ak099.png" alt="Drawing 1.png" data-nodeid="35493"></p>
<p data-nodeid="35117">每个人都指向自己的大哥，帮主最牛，指向帮主自己。那么要进行 Union 操作的时候。直接修改指针就可以了。代码如下：</p>
<pre class="lang-java" data-nodeid="35118"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(String A, String B)</span> </span>{
  String A帮主 = Find(A);
  String B帮主 = Find(B);
  H.put(A帮主, B帮主); <span class="hljs-comment">// 成功将A所在帮派归入B帮派</span>
}
</code></pre>
<p data-nodeid="35119">在 Union 的最后，我们只需要将 A 帮主指向 B 帮主就可以了。比如，将明教与武当合并，如下图所示：</p>
<p data-nodeid="35120"><img src="https://s0.lgstatic.com/i/image6/M01/21/80/Cgp9HWBUZO6APF37AABG3_a_Q6c057.png" alt="Drawing 2.png" data-nodeid="35498"></p>
<p data-nodeid="35121">我们再看一下 Find 函数，代码如下：</p>
<pre class="lang-java" data-nodeid="35122"><code data-language="java"><span class="hljs-comment">// 返回A的帮主</span>
<span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
  <span class="hljs-keyword">while</span> (A != H.get(A)) {
    <span class="hljs-comment">// 如果我还有大哥，那么就顺着大哥一路往上找</span>
    A = H.get(A);
  }
  <span class="hljs-comment">// 最终找到了帮主</span>
  <span class="hljs-keyword">return</span> A;
}
</code></pre>
<p data-nodeid="35123">虽然这种办法在 Union 时比较方便，但是在 Find 时却容易引入较高的复杂度。下面我们一起来看一下为什么 Find 起来比较麻烦：</p>
<p data-nodeid="35124"><img src="https://s0.lgstatic.com/i/image6/M01/21/7D/CioPOWBUZQSANG0HAAUZirp5p1k748.gif" alt="1 (1).gif" data-nodeid="35503"></p>
<p data-nodeid="35125">在这种情况下，Find 查询时，总是会查询很多次 O(N)。也就是说，Union 的时间复杂度较低的时候，Find 的时间复杂度又上升了。</p>
<p data-nodeid="35126">那么，有没有更好一点的办法呢？能让 Union 和 Find 的时间复杂度都低一点。</p>
<h4 data-nodeid="35127">路径压缩</h4>
<p data-nodeid="35128">办法还是有的，就叫<strong data-nodeid="35512">路径压缩</strong>，我们发现，在方法 2 中，如果能将层级结构“拍扁”，那么 Find 和 Union 的时间复杂度都会特别低。</p>
<p data-nodeid="35129">因此，我们还需要在 Find 函数里面做一些手脚。当我们找到一帮主之后，就把这条路径上的所有人的大哥都改成帮主。代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35130"><code data-language="java"><span class="hljs-function">String <span class="hljs-title">Find</span><span class="hljs-params">(String A)</span> </span>{
  <span class="hljs-comment">// start记为出发点</span>
  String start = A;
  <span class="hljs-keyword">while</span> (A != H.get(A)) {
    A = H.get(A);
  }
  <span class="hljs-comment">// 此时A是帮主</span>
  <span class="hljs-comment">// 我们再从出发点开始，把每个人的大哥改成帮主</span>
  <span class="hljs-comment">// 路径压缩的关键代码</span>
  <span class="hljs-keyword">while</span> (H.get(start) != A) {
    String next = H.get(start);
    H.put(start, A);
    start = next;
  }
  <span class="hljs-keyword">return</span> A;
}
</code></pre>
<p data-nodeid="35131">再看这个例子：经过合并，成立糖葫芦帮之后。如下图所示：</p>
<p data-nodeid="35132"><img src="https://s0.lgstatic.com/i/image6/M00/23/F4/CioPOWBX_4mAPpHfAABECA7Vc3g627.png" alt="image.png" data-nodeid="35517"></p>
<p data-nodeid="35133">如果一旦执行 Find("韦一笑")，那么糖葫芦帮派就会变成大饼帮派。</p>
<p data-nodeid="35134"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZgaAOFDCAABeZqcuW0s773.png" alt="Drawing 6.png" data-nodeid="35525"></p>
<p data-nodeid="35135">所有人的帮主都会指向张三丰。也就是说，除了第一次 Find 复杂度为 O(N)，后面的查询复杂度都是 O(1)。至此，我们已经讲清楚带路径压缩的并查集的原理。接下来我们看代码如何实现。</p>
<h3 data-nodeid="35136">并查集模板</h3>
<p data-nodeid="35137">前面使用的都是比较形式化的语言和伪代码。接下来我们看一下具体如何实现并查集。这里我<strong data-nodeid="35533">以整数替换前面的人名</strong>，操作起来更加方便。</p>
<h4 data-nodeid="35138">初始化</h4>
<p data-nodeid="35139">首先假设有 N 个整数，范围为 [0, N)。那么记录每个人的信息，就需要一个长度为 N 的数组。</p>
<pre class="lang-java" data-nodeid="35140"><code data-language="java"><span class="hljs-keyword">int</span> F[N]; <span class="hljs-comment">// 记录每个人的大哥是谁</span>
</code></pre>
<p data-nodeid="35141">在初始化的时候，每个人都是自成一派。</p>
<pre class="lang-java" data-nodeid="35142"><code data-language="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
  F[i] = i;
}
</code></pre>
<h4 data-nodeid="35143">查询</h4>
<p data-nodeid="35144">根据前面所讲，可以得到查询操作的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35145"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-comment">// 查找根结点</span>
  <span class="hljs-keyword">int</span> b = x;
  <span class="hljs-keyword">while</span> (F[x] != x) {
    x = F[x];
  }
  <span class="hljs-comment">// 路径压缩的实现</span>
  <span class="hljs-comment">// 将路径上的每个点指向根结点x</span>
  <span class="hljs-keyword">while</span> (F[b] != x) {
    <span class="hljs-keyword">int</span> p = F[b];
    F[b] = x;
    b = p;
  }
  <span class="hljs-keyword">return</span> x;
}
</code></pre>
<h4 data-nodeid="35146">合并</h4>
<p data-nodeid="35147">完成查询操作，我们就要把两个集合进行合并，代码如下：</p>
<pre class="lang-java" data-nodeid="35148"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  F[find(x)] = find(y);
}
</code></pre>
<p data-nodeid="35149">这两个函数的代码还是显得有点长，并且不太容易记。我在刷题和面试时，更喜欢，或者说常用一份精简过的代码。下面我将分享给你。</p>
<h4 data-nodeid="35150">两行代码</h4>
<p data-nodeid="35151">这里我整理了：<strong data-nodeid="35553">两行</strong>并查集核心代码模板（用 C 语言实现，<strong data-nodeid="35554">方便记忆）：</strong></p>
<pre class="lang-c++" data-nodeid="35152"><code data-language="c++"><span class="hljs-keyword">int</span> F[N];
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
 <span class="hljs-keyword">return</span> x == F[x] ? x : F[x] = Find(F[x]); <span class="hljs-comment">// &lt;-- 1. 查找</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  F[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// &lt;- 2. 合并</span>
}
</code></pre>
<p data-nodeid="35153">注：根据不同的语言，你可能需要修改不同的 Find 函数。</p>
<h4 data-nodeid="35154">两个功能</h4>
<p data-nodeid="35155">当真正使用并查集的时候，面试官可能会问你两个问题：</p>
<ul data-nodeid="35156">
<li data-nodeid="35157">
<p data-nodeid="35158">有多少个集合？</p>
</li>
<li data-nodeid="35159">
<p data-nodeid="35160">每个集合里面有多少个元素？</p>
</li>
</ul>
<p data-nodeid="35161">下面我们依次回答这两个问题。</p>
<p data-nodeid="35162"><strong data-nodeid="35569">1</strong>. <strong data-nodeid="35570">集合数目</strong>：在执行 Find 的时候，集合个数不可能有变化。如果发生变化，只可能发生在两个集合合并的时候。</p>
<p data-nodeid="35163">再来具体看一下初始化和合并操作。</p>
<ul data-nodeid="35164">
<li data-nodeid="35165">
<p data-nodeid="35166">初始化：在并查集开始初始化的时候，一共有 N 个元素，那么一开始集合个数为 N。</p>
</li>
<li data-nodeid="35167">
<p data-nodeid="35168">合并：合并的时候，需要查看合并的两个集合是不是同一个，如果不是，那么集合个数减 1。<br>
<strong data-nodeid="35583">2</strong>. <strong data-nodeid="35584">每个集合中元素的个数</strong>：在执行 Find 的时候，每个集合中元素的个数不可能发生变化。如果发生变化，只可能是两个集合合并的时候。</p>
</li>
</ul>
<p data-nodeid="35169">下面我们具体看一下初始化和合并操作。</p>
<ul data-nodeid="35170">
<li data-nodeid="35171">
<p data-nodeid="35172">初始化：在并查集开始初始化的时候，每个元素都属于独立的元素，那么一开始每个集合里面的个数都是 1。如果我们用 Count[] 数组记录每个元素的个数，那么一开始初始化 Count[] = 1。</p>
</li>
<li data-nodeid="35173">
<p data-nodeid="35174">合并：当 A 集合要合并到 B 集合里面的时候，可以认为 A 集合里面所有的元素都变成 B 集合里面的元素。当然是 B 集合里面的个数增加了，那么 Count[Find(B)] + = Count[Find(A)]。</p>
</li>
</ul>
<p data-nodeid="35175"><strong data-nodeid="35622">注意</strong>：在记录集合中元素个数的时候，<strong data-nodeid="35623">只有根结点的信息是准确的</strong>。当查询结点i所属集合的信息时，只能使用 Count[Find(i)]，而不能使用 Count[i]。因为如果要保证每个点 Count[i] 的信息都是准确的，那么每次合并的时候，整个集合中的元素的信息都要更新，这样时间复杂度就很高了，Union 操作的时间复杂度就不再是O(lgN)，而变成O(N)。</p>
<p data-nodeid="35176">为了方便你刷题和应对面试，这里我给出了并查集的完整代码，你可以作为参考。</p>
<h4 data-nodeid="35177">完整 Java 代码</h4>
<pre class="lang-java" data-nodeid="35178"><code data-language="java"><span class="hljs-comment">// 并查集数组</span>
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 记录并查集中集合的个数</span>
<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 记录集合中点的个数，比如要知道i所在集合的点有多少个: C[Find(i)]</span>
<span class="hljs-comment">// 注意：这里不能直接使用C[i]</span>
<span class="hljs-comment">// 因为只有根结点的统计才是正确的</span>
<span class="hljs-keyword">int</span>[] Cnt = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 并查集的初始化</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  Cnt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
    Cnt[i] = <span class="hljs-number">1</span>;
  }
  count = n;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">int</span> xpar = Find(x);
  <span class="hljs-keyword">int</span> ypar = Find(y);
  <span class="hljs-comment">// 将x所在集合，合并到y所在集合</span>
  <span class="hljs-keyword">if</span> (xpar != ypar) {
    F[xpar] = ypar;
    <span class="hljs-comment">// y集合里面的个数要增加</span>
    Cnt[ypar] += Cnt[xpar];
    count--;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
  <span class="hljs-keyword">return</span> Cnt[Find(i)];
}
</code></pre>
<p data-nodeid="35179">注：这里是以<strong data-nodeid="35635">整数</strong>和<strong data-nodeid="35636">数组</strong>为例。如果关键字是 String，也可以使用哈希表将字符串映射到整数再进行并查集的操作。</p>
<blockquote data-nodeid="35180">
<p data-nodeid="35181">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35640">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35644">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35648">Python</a></p>
</blockquote>
<p data-nodeid="35182"><strong data-nodeid="35653">复杂度分析</strong>：并查集的初始化时间复杂度为 O(N)，而 Find 和 Union 的操作时间复杂度都是 O(lgN)，其中 N 为点的总数。这里只使用了长度为 N 的数组，所以空间复杂度为 O(2N)。</p>
<h4 data-nodeid="35183">例 1：最小生成树</h4>
<p data-nodeid="35184">【<strong data-nodeid="35660">题目</strong>】给定一个图的点集，边集和权重，返回构建最小生成树的代价。</p>
<p data-nodeid="35185">输入：N = 2， conn = [[1, 2, 37], [2, 1, 17], [1, 2, 68]]</p>
<p data-nodeid="35186">输出：17</p>
<p data-nodeid="35187"><strong data-nodeid="35687">解释</strong>：图中只有两个点 [1, 2]，当然是选择最小连接 [2, 1, 17]</p>
<p data-nodeid="35188">【<strong data-nodeid="35701">分析</strong>】利用并查集 + 贪心算法，可以生成一个图的<strong data-nodeid="35703">最小生成树，<strong data-nodeid="35702">这种方法也被称为</strong> Kruskal 算法</strong>。并查集可以用来将两个点进行 Union，不过在并查集的 Union 代码中，并没有权重这一项，那我们该怎么办呢？</p>
<p data-nodeid="35189">在 Union 的时候，就直接根据边的权重来排序，然后再处理，这不就是经典的 <strong data-nodeid="35709">Kruskal 算法</strong>。</p>
<p data-nodeid="35190">这里我们可以讲一下最小生成树的思路：</p>
<ul data-nodeid="35191">
<li data-nodeid="35192">
<p data-nodeid="35193">首先初始化并查集</p>
</li>
<li data-nodeid="35194">
<p data-nodeid="35195">将边集<strong data-nodeid="35716">按照权重排序</strong></p>
</li>
<li data-nodeid="35196">
<p data-nodeid="35197">利用边集将不同的两点进行 Union</p>
</li>
<li data-nodeid="35198">
<p data-nodeid="35199">将不同的集合进行 Union 时需要加上新加入的边的代价（即边的权重）。</p>
</li>
</ul>
<p data-nodeid="35200">【<strong data-nodeid="35724">代码</strong>】这里我们可以写出经典的 Kruskal 算法，代码如下（解析在注释里）：</p>
<pre class="lang-java te-preview-highlight" data-nodeid="40088"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> cost = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 这里直接申请了足够多的内存</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
  <span class="hljs-comment">// 并查集初始化</span>
  <span class="hljs-comment">// 注意点的编号是从1~n</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
      F[i] = i;
    }
    cost = <span class="hljs-number">0</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == F[x]) {
      <span class="hljs-keyword">return</span> x;
    }
    F[x] = Find(F[x]);
    <span class="hljs-keyword">return</span> F[x];
  }
  <span class="hljs-comment">// 在合并的时候，需要加上代价</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) cost += pay;
    F[Find(x)] = Find(y);
  }
  <span class="hljs-comment">// 一共有n个点，编号从1~n</span>
  <span class="hljs-comment">// conn表示输入的边的集合</span>
  <span class="hljs-comment">// 每一项是一个三元组[点a, 点b, 需要费用c]</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">Kruskal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
    Init(n);
    <span class="hljs-comment">// 边集的排序</span>
    Arrays.sort(conn, <span class="hljs-number">0</span>, m, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
      }
    });
    <span class="hljs-comment">// 顺次将边集添加到集合中</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
    }
    <span class="hljs-keyword">return</span> cost;
  }
}
</code></pre>


<blockquote data-nodeid="35202">
<p data-nodeid="35203">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35728">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35732">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/P1287.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35736">Python</a></p>
</blockquote>
<p data-nodeid="35204"><strong data-nodeid="35741">复杂度分析</strong>：程序主要分为两块，一部分为边集 E 的排序，复杂度为 O(ElgE)；另外一部分为每条边的 Union 操作，复杂度为 O(ElgN)。在大部分时候，边的数目往往比点的数目要多，因此时间复杂度为 O(ElgE)。</p>
<p data-nodeid="35205">【<strong data-nodeid="35747">小结</strong>】本质上 Kruskal 算法就是并查集算法 + 贪心算法。使用 Kruskal 算法有一个很重要的前提——题目是假设输入边能将所有的点加到一个连通域中，也就是保证最后必然能够生成一棵树。</p>
<p data-nodeid="35206">这里给你留一道练习题，你可以利用它检验和巩固自己的学习成果。</p>
<p data-nodeid="35207"><strong data-nodeid="35755">练习题 1</strong>：给定点集和边集，求最小生成树的代价，如果最后不能生成最小生成树，那么返回MAX_INT。</p>
<blockquote data-nodeid="35208">
<p data-nodeid="35209">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35759">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35763">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%BB%A3%E4%BB%B7.md?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35767">Python</a></p>
</blockquote>
<p data-nodeid="35210">接下来我们一起看一下关于并查集的其他考察形式与考点。</p>
<h3 data-nodeid="35211">连通域的数目</h3>
<p data-nodeid="35212">我们可以把最小生成树当成一个连通域，只不过需要用最小的代价来生成这么一个连通域。除了求解最小生成树，并查集的另外一个常见的用途是求解连通域的数目。在<strong data-nodeid="35775">微软和 EMC</strong> 的面试中都出现过，但是可能会通过两种方式给出图的结构，比如：</p>
<ul data-nodeid="35213">
<li data-nodeid="35214">
<p data-nodeid="35215">点集和边集，告诉你有哪些点，以及哪些边；</p>
</li>
<li data-nodeid="35216">
<p data-nodeid="35217">矩阵表示。</p>
</li>
</ul>
<p data-nodeid="35218">不管是通过哪一种图表示，利用<strong data-nodeid="35783">并查集解决连通域数目的步骤都是以下两步</strong>：</p>
<ol data-nodeid="35219">
<li data-nodeid="35220">
<p data-nodeid="35221">用 F[] 数组和点集进行初始化</p>
</li>
<li data-nodeid="35222">
<p data-nodeid="35223">利用边集进行 Union</p>
</li>
</ol>
<p data-nodeid="35224">最后的集合数目就是连通域的数目。</p>
<p data-nodeid="35225">利用本讲前面学过的模板和思路，相信你已经可以解决面试中的高频出现的算法题了。</p>
<h4 data-nodeid="35226">例 2：帮派的数目</h4>
<p data-nodeid="35227">【<strong data-nodeid="35803">题目</strong>】江湖上有 N 个人，编号从 [1 ~ N]，现在只能告诉你，其中两人是一个帮派的，请你输出帮派的数目。</p>
<p data-nodeid="35228">输入：N = 4, [[1, 2], [2,3]]</p>
<p data-nodeid="35229">输出：2</p>
<p data-nodeid="35230"><strong data-nodeid="35827">解释</strong>：一共有 4 个人，[1,2, 3] 成为一个帮派，[4] 独自成为一个帮派，那么一共有 2 个帮派。</p>
<p data-nodeid="35231">【<strong data-nodeid="35833">分析</strong>】在一开始，你可以认为他们都是独自成为一个帮派，当告诉你每两个人是一个帮派时，相当于要把这两个人合并到一个集合中。问题是一共有多少个帮派，显然这就是一个非常标准的并查集的问题了。我们可以直接套用前面所讲的并查集的模板进行求解。</p>
<p data-nodeid="35232">【<strong data-nodeid="35839">代码</strong>】直接利用并查集的代码模板，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35233"><code data-language="java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
    F[i] = i;
  }
  count = n;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">if</span> (Find(x) != Find(y))
    count--;
  F[Find(x)] = Find(y);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findGangNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] conn)</span> </span>{
  Init(n);
  <span class="hljs-keyword">int</span> m = conn.length;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
    Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>]);
  }
  <span class="hljs-comment">// 帮派里面帮主的个数</span>
  <span class="hljs-keyword">return</span> count;
}
</code></pre>
<blockquote data-nodeid="35234">
<p data-nodeid="35235">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35843">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35847">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/T1260.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35851">Python</a><br>
<strong data-nodeid="35857">复杂度分析</strong>：整个算法的时间复杂度为 O(mlogN) ，这里 n 表示人的数目，而 m 表示两两成对的输入数目。</p>
</blockquote>
<p data-nodeid="35236">【<strong data-nodeid="35863">小结</strong>】在这里我们直接利用并查集的模板搞定了一道题目。</p>
<p data-nodeid="35237"><strong data-nodeid="35868">延伸</strong>：如果将这里的每个点都当成一个“图”结构中的一个点，将两两成对的输入当成“图”结构中的边。那么问题就变成了求解图的连通域个数。</p>
<p data-nodeid="35238">下面我们一起来看一下这个曾经在<strong data-nodeid="35874">微软</strong>的电面中出现的 2 道题目。</p>
<p data-nodeid="35239"><strong data-nodeid="35887">练习题 2</strong>：给定一个黑白图像，其中白色像素用 '1' 表示，黑色像素用 '0' 表示。如果把上下左右相邻的白色像素看成一个连通域，给定一幅图（用矩阵表示），请问图中有几个连通域。</p>
<p data-nodeid="35240">输入：A = [['1', '1', '0'], ['0', '1', '0']]</p>
<p data-nodeid="35241">输出：1</p>
<p data-nodeid="35242"><strong data-nodeid="35927">解释</strong>：图中所有的 '1' 都是连在一起的，所以只有一个连通域。</p>
<blockquote data-nodeid="35243">
<p data-nodeid="35244">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35931">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35935">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/200.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35939">Python</a></p>
</blockquote>
<p data-nodeid="35245"><strong data-nodeid="35951">练习题 3</strong>：给定一个图（不是图像）的矩阵，A[i][j] = 1 表示点 i 与点 j 相连，求这个图里面连通域的数目。</p>
<p data-nodeid="35246">输入：A = [[1,0,0],[0,1,0],[0,0,1]]</p>
<p data-nodeid="35247">输出：3</p>
<p data-nodeid="35248"><strong data-nodeid="35975">解释</strong>：[0, 1, 2] 三个点中，每个点都不与其他点相连，所以连通域有 3 个。</p>
<blockquote data-nodeid="35249">
<p data-nodeid="35250">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35979">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35983">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/547.%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="35987">Python</a></p>
</blockquote>
<h4 data-nodeid="35251">例 3: 换工位</h4>
<p data-nodeid="35252">【<strong data-nodeid="36019">题目</strong>】因为要实施结对编程，想让两个员工的工位挨在一起：要求 [0,1] 员工坐在一起，[2, 3] 员工坐在一起，以此类推。不过挨着具体坐的位置并不重要，只要能挨在一起就可以了。比如 [0, 1, 3, 2] 与 [2, 3, 1, 0] 都是满足要求的。现在给定一个数组 A[]，求换工位的最少次数，尽量让两个员工坐在一起。（给定 N 个员工，他们的编号总是 [0~N-1] ，并且 N 总是偶数）。</p>
<p data-nodeid="35253">输入：A[] = [0, 3, 2, 1]</p>
<p data-nodeid="35254">输出：1</p>
<p data-nodeid="35255"><strong data-nodeid="36032">解释</strong>：只需要换 1 次就可以了，比如，将 0 号员工与 2 号员工交换。</p>
<p data-nodeid="35256">【<strong data-nodeid="36038">分析</strong>】初看这道题的时候，没有什么思路，那么我们进行一下模拟，看看能不能发现什么规律。</p>
<p data-nodeid="35257"><strong data-nodeid="36046">1</strong>. <strong data-nodeid="36047">模拟</strong></p>
<p data-nodeid="35258">当 N = 2 时，无论是 [0, 1] 还是 [1, 0] 这两种排列都满足要求，因为我们总是想让 [0, 1] 这两个员工坐在一起，而只有两个员工时，他们总是挨在一起的。假设结对成功的两个人坐在一起的时候，就像做在链条上的环一样。</p>
<p data-nodeid="35259">由于 N 必须为偶数，所以接下来我们看一下 N = 4 时的情况。比如 A = [0, 3, 2, 1]，此时 4 个人都没有结对成功，相当于两个环还扣一起。</p>
<p data-nodeid="35260">这时我们只需要交换 0, 2 形成 [2,3,0,1]，如果按配对划分，那就是 [2, 3] 和 [0, 1]。结对成功之后，这两个环就可以拆开了。操作如下图所示：</p>
<p data-nodeid="35261"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZpeADOaKAADoS6Y44b0977.png" alt="Drawing 7.png" data-nodeid="36081"></p>
<p data-nodeid="35262">通过这个示例，还可以发现，如果不经过交换，虽然 [3, 2] 这两个员工已经坐在一起了，但是不操作，那么 0 号员工和 1 号员工是无法结对编程的。</p>
<p data-nodeid="35263"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZqCAfrFNAACU4aaiqjc231.png" alt="Drawing 8.png" data-nodeid="36089"></p>
<p data-nodeid="35264">因此，我们可以得到<strong data-nodeid="36111">结论 1：结对的时候，数组中只能偶数下标与奇数下标配比</strong>。比如 A[0] 与 A[1] 结对。不能奇数下标与偶数下标结对，比如 A[1] 与 A[2] 结对。</p>
<p data-nodeid="35265">接下来我们再看一下 N = 6 的情况， 比如 A = [0, 2, 3, 5, 1, 4]：我们在执行交换的时候，可以这样操作：</p>
<p data-nodeid="35266"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZqqADNgZAAU5MW4PWoI242.gif" alt="2 (1).gif" data-nodeid="36119"></p>
<p data-nodeid="35267">所以成功切分出三个配对集合 [0, 1], [3, 2], [5, 4]，需要 2 步。</p>
<p data-nodeid="35268"><strong data-nodeid="36140">2</strong>. <strong data-nodeid="36141">规律</strong></p>
<p data-nodeid="35269">通过前面的模拟，我们还需要进一步的总结规律。将里面没有成功结对的序列看成一条锁链。并且拆分出结对成功的两个元素，独立位于一个环中，并不与别人相扣在一起。</p>
<p data-nodeid="35270"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZrSALzFBAADhm_fwnRk393.png" alt="Drawing 10.png" data-nodeid="36145"></p>
<p data-nodeid="35271">每 1 次操作，交换两个元素，就相当于从锁链中成功拆一个环下来。</p>
<p data-nodeid="35272"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZryASSNEAAEb64nhdKE214.png" alt="Drawing 11.png" data-nodeid="36149"></p>
<p data-nodeid="35273">那么，我们可以得到<strong data-nodeid="36155">结论 2：有 2x 个元素，也就是 x 个环的锁链，就需要 x-1 次操作</strong>。</p>
<p data-nodeid="35274">至此，我们就将题目成功变成了：给定一个数组，需要找到里面有几条锁链。比如给定数组 A = [6, 4, 5, 2, 3, 7, 0, 1]。</p>
<p data-nodeid="35275">此时应该可以分出两条锁链来，如下图所示：</p>
<p data-nodeid="35276"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZsWAPW0xAADZQU20JEU856.png" alt="Drawing 12.png" data-nodeid="36164"></p>
<p data-nodeid="35277">我们再看每个锁链中的环的数目就可以得到最少操作次数。比如这里的 A[] 数组有 2 条锁链，需要的操作次数是 (3 - 1) + (1-1) = 2。也就是最少操作 2 次。</p>
<p data-nodeid="35278">那么现在问题的关键就是，如何才能通过数组得到锁链呢？这里我们还发现一个有趣的<strong data-nodeid="36174">结论 3：本就结对的两个员工必然在同一个链条中</strong>。比如 6 和 5 在没有结对的情况下，也必然在同一条锁链中。</p>
<p data-nodeid="35279"><strong data-nodeid="36182">3</strong>. <strong data-nodeid="36183">匹配</strong></p>
<p data-nodeid="35280">如果将锁链当成集合，就可以对应到并查集了。这里再细化一下：</p>
<ul data-nodeid="35281">
<li data-nodeid="35282">
<p data-nodeid="35283">通过结论 3，我们应该将一个偶数 x 以及和它配对的数 x+1 先放到同一个集合中；</p>
</li>
<li data-nodeid="35284">
<p data-nodeid="35285">偶数下标 A[i]，需要与 A[i+1] 进行 Union，完成放到同一个锁链的操作。</p>
</li>
</ul>
<p data-nodeid="35286">虽然最后我们可以通过去数锁链中环的个数，再通过结论 2 得到答案。但是如果你能想到拆环的次数，实际上就是不同集合 Union 的次数。那么求解的时候，只需要在并查集模板的基础上对 Union 稍做更改就可以了。</p>
<p data-nodeid="35287"><strong data-nodeid="36203">4</strong>. <strong data-nodeid="36204">边界</strong></p>
<p data-nodeid="35288">注意处理空数组，注意结对的时候，要满足结论 1。</p>
<p data-nodeid="35289">【<strong data-nodeid="36215">画图</strong>】接下来我们画图演示一下使用并查集的过程。这里我们以数组 A = [6, 4, 5, 2, 3, 7, 0, 1] 为例。</p>
<p data-nodeid="35290"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZteAaZlrABz3L57gQK4855.gif" alt="3.gif" data-nodeid="36218"></p>
<p data-nodeid="35291">我们发现，不同集合的合并次数一共为 2 次，所以只需要 2 次操作就可以完成结对编程的要求。</p>
<p data-nodeid="35292">【<strong data-nodeid="36225">代码</strong>】接下来我们可以写一下代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35293"><code data-language="java"><span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-keyword">int</span> unionCount = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    <span class="hljs-comment">// 注意这里在初始化的时候</span>
    <span class="hljs-comment">// [0, 1]需要处在一个集合里面</span>
    <span class="hljs-comment">// 无论他们在数组里面是不是相邻</span>
    F[i] = i - (i &amp; <span class="hljs-number">0x01</span>);
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
    unionCount++;
  }
  F[Find(x)] = Find(y);
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSwapsCouples</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  Init(N);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">2</span>) {
    Union(A[i], A[i + <span class="hljs-number">1</span>]);
  }
  <span class="hljs-keyword">return</span> unionCount;
}
</code></pre>
<blockquote data-nodeid="35294">
<p data-nodeid="35295">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36229">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36233">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36237">Python</a></p>
</blockquote>
<p data-nodeid="35296"><strong data-nodeid="36242">复杂度分析</strong>：一共有 N/2 对元素要合并，每次合并的时间复杂度为 O(lgN)。所以时间复杂度为 O(NlgN)。</p>
<p data-nodeid="35297">【<strong data-nodeid="36248">小结</strong>】在这里，我们学习了将锁链处理成一个连通域，并且巧妙地通过求解合并次数解决了最小操作次数。</p>
<p data-nodeid="35298">我认为这道题目最核心的考点是分析出<strong data-nodeid="36258">结论 2</strong>：<strong data-nodeid="36259">有 2x 个元素，也就是 x 个环的锁链，就需要 x-1 次操作</strong>。</p>
<p data-nodeid="35299">一旦得到了每条锁链中的操作次数，然后利用并查集的模板，这道题目就解决了。我再给你留道练习题，希望你可以尝试做一下。</p>
<p data-nodeid="35300"><strong data-nodeid="36265">练习题 4</strong>：给定一个单词数组，如果两个单词相等，或者说其中一个单词 A 经过一次字符交换，可以得到单词 B，那么我们说单词 {A, B} 是同构的。请问单词数组中，一共有多少组这样的同构集合？</p>
<p data-nodeid="35301">输入：{"AB", "BA", "AB", "BC", "CD"}</p>
<p data-nodeid="35302">输出：3</p>
<p data-nodeid="35303"><strong data-nodeid="36312">解释</strong>：一共有三组同构集合，{"AB", "BA", "AB"}, {"BC"}, {"CD"}</p>
<blockquote data-nodeid="35304">
<p data-nodeid="35305">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36316">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36320">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/839.%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36324">Python</a></p>
</blockquote>
<p data-nodeid="35306">接下来我们讲解并查集的进一步运用。</p>
<h3 data-nodeid="35307">虚拟点与虚拟边</h3>
<p data-nodeid="35308">在求解连通域的过程中，我们经常利用现有的点与现有的边进行并查集的初始化与合并。</p>
<p data-nodeid="35309">但是在有些题目中，需要加入一些<strong data-nodeid="36333">虚拟的边和虚拟的点</strong>到并查集的点集与边集中。通过这种方式可以极大地方便我们使用并查集。</p>
<h4 data-nodeid="35310">例 4: 替换字母</h4>
<p data-nodeid="35311">【<strong data-nodeid="36360">题目</strong>】给你一个矩阵 A，里面只包含字母 ‘O’ 和 'X'，如果一个 'O' 上下左右四周都被 'X' 包围，那么这个 'O' 会被替换成 'X'。请你写程序处理一下这个过程。</p>
<p data-nodeid="35312"><img src="https://s0.lgstatic.com/i/image6/M01/21/7E/CioPOWBUZumAF_CYAAA1NGN0dU0625.png" alt="Drawing 14.png" data-nodeid="36363"></p>
<p data-nodeid="35313"><strong data-nodeid="36387">解释</strong>：由于中心的 'O' 四周都被包围，所以需要被换成 'X'，而第 A[0][0] = 'O' 靠着边，所以不能被替换。</p>
<p data-nodeid="35314">【<strong data-nodeid="36397">分析</strong>】这道题目曾经在<strong data-nodeid="36398">微软</strong>的面试中出现过。看起来就是一个连通域的问题，所以可以使用并查集来处理。思路如下：</p>
<ul data-nodeid="35315">
<li data-nodeid="35316">
<p data-nodeid="35317">首先用并查集标记所有 'O' 的连通域；</p>
</li>
<li data-nodeid="35318">
<p data-nodeid="35319">将所有在边上的 'O' 的“帮主”放到 set 集合中；</p>
</li>
<li data-nodeid="35320">
<p data-nodeid="35321">遍历每个 'O' 的“帮主”，看看是不是在 set 集合中，如果在，那么这个 'O' 不能替换。</p>
</li>
</ul>
<p data-nodeid="35322">可以发现，有一步操作可以优化：将所有在边上的 'O' 的“帮主”放到 set 集合中，有两种办法：</p>
<ul data-nodeid="35323">
<li data-nodeid="35324">
<p data-nodeid="35325">随便选择边上的一个点，作为所有边上点的“帮主”；</p>
</li>
<li data-nodeid="35326">
<p data-nodeid="35327">选一个虚拟的点，作为所有边上的点的“帮主”。</p>
</li>
</ul>
<p data-nodeid="35328">你可以根据自己的喜好任选其一，这里我用第 2 种“虚拟点”的办法。下面就可以直接套用模板了。</p>
<p data-nodeid="35329">【<strong data-nodeid="36431">代码</strong>】采用虚拟点的并查集的代码实现如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35330"><code data-language="java"><span class="hljs-keyword">int</span>[][] dir = {{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">0</span>}};
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">if</span> (x == F[x]) {
    <span class="hljs-keyword">return</span> x;
  }
  F[x] = Find(F[x]);
  <span class="hljs-keyword">return</span> F[x];
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{ F[Find(x)] = Find(y); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] A)</span> </span>{
  <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A[<span class="hljs-number">0</span>] == <span class="hljs-keyword">null</span>) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> R = A.length;
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> C = A[<span class="hljs-number">0</span>].length;
  Init(R * C + <span class="hljs-number">1</span>);
  <span class="hljs-comment">// 我们将vNode设置为R * C</span>
  <span class="hljs-comment">// 这是一个在矩阵中不存在的点</span>
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> vNode = R * C;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
        <span class="hljs-comment">// 如果是边上的点</span>
        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span> || r == R - <span class="hljs-number">1</span> || c == <span class="hljs-number">0</span> || c == C - <span class="hljs-number">1</span>) {
          <span class="hljs-comment">// 那么将其与vNode进行Union</span>
          Union(r * C + c, vNode);
        }
        <span class="hljs-comment">// 将其与四面的点进行Union</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">2</span>; d++) {
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nr = r + dir[d][<span class="hljs-number">0</span>];
          <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> nc = c + dir[d][<span class="hljs-number">1</span>];
          <span class="hljs-keyword">if</span> (!(nr &lt; <span class="hljs-number">0</span> || nr &gt;= R || nc &lt; <span class="hljs-number">0</span> || nc &gt;= C)) {
            <span class="hljs-keyword">if</span> (A[nr][nc] == <span class="hljs-string">'O'</span>) {
              Union(r * C + c, nr * C + nc);
            }
          }
        }
      }
    }
  }
  <span class="hljs-comment">// 查看是不是和vNode一个集合，如果不是就要修改成'X'</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; R; r++) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; C; c++) {
      <span class="hljs-keyword">if</span> (A[r][c] == <span class="hljs-string">'O'</span>) {
        <span class="hljs-keyword">if</span> (Find(r * C + c) != Find(vNode)) {
          A[r][c] = <span class="hljs-string">'X'</span>;
        }
      }
    }
  }
}
</code></pre>
<blockquote data-nodeid="35331">
<p data-nodeid="35332">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36435">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36439">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/130.%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36443">Python</a></p>
</blockquote>
<p data-nodeid="35333"><strong data-nodeid="36452">复杂度分析</strong>：由于每个点只遍历两遍。<strong data-nodeid="36453">所有点的数目为 N</strong>，所以时间复杂度为 O(NlgN)，此外，每个点都记录了所在集合，所以空间复杂度为 O(N)。</p>
<p data-nodeid="35334">【<strong data-nodeid="36459">小结</strong>】在这里我们学习了一种新的处理技巧，那就是利用并查集 + 虚拟结点，将原本不在一起的结点，统一放到了一个虚拟集合中。</p>
<p data-nodeid="35335">所以解决这道题目的考点我们可以总结如下：</p>
<p data-nodeid="35336"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZvmACQxmAAC2H_g_eZk099.png" alt="Drawing 15.png" data-nodeid="36463"></p>
<p data-nodeid="35337">在面试中，如果你有了并查集的模板，再加上虚拟点的思路，那么快速解决这类问题就轻而易举了。</p>
<h4 data-nodeid="35338">例 5：上网的最小费用</h4>
<p data-nodeid="35339">【<strong data-nodeid="36481">题目</strong>】园区里面有很多大楼，编号从 1~N。第 i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]，也可以从别的大楼拉一根网线来上网，比如大楼 a 和大楼 b 之间拉网线的费用为 c，表示为一条边 [a, b, c]。输入为每个大楼自己买路由器和拉网线的费用，请问，让所有大楼都能够上网的最小费用是多少？上网具有联通性，只要与能够上网的大楼连通，即可上网。</p>
<p data-nodeid="35340">输入：cost = [1, 2, 3], edges = [[1,2,100], [2,3,3]]</p>
<p data-nodeid="35341">输出：6</p>
<p data-nodeid="35342"><strong data-nodeid="36509">解释</strong>：最优方案是 1 号大楼买路由器 cost[0] = 1，2 号楼买路由器 cost[1] = 2，然后和 3 号楼之间可拉一根网线，费用为 3，所以一共花费 6 元。如图（红色部分标记为费用 ）：</p>
<p data-nodeid="35343"><img src="https://s0.lgstatic.com/i/image6/M01/21/81/Cgp9HWBUZwOAOXuWAABVP6uBCvA003.png" alt="Drawing 16.png" data-nodeid="36512"></p>
<p data-nodeid="35344">【<strong data-nodeid="36526">分析</strong>】这是一道<strong data-nodeid="36527">头条</strong>面试中出现过的题目。首先如果不考虑自己买路由器的情况，只依赖给定的边集构建这个图，且要求最小费用，这道题目就和最小生成树一模一样了。可是，这里与最小生成树不一样的地方在于：第 i 大楼可以自己花钱买路由器上网，费用为 cost[i-1]。</p>
<p data-nodeid="35345">在最小生成树里面，可是没有说“自己买路由”这个操作。那怎么办？我们有什么方法可以转化一下吗？</p>
<p data-nodeid="35346">可以采用加入虚拟点的方法。首先假设有一个结点 0 已经自己买了路由器，花费为 0 元。而其他结点要自己买路由器，本质等价于与结点 0 进行联通。只不过这个网线的费用，就是你自己买路由器的费用。</p>
<p data-nodeid="35347">比如，给定 3 个点，分别自己买路由器的费用为 [1, 2, 3]。那么我们可以把图变成下图这样子：</p>
<p data-nodeid="35348"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZwyAA5MpAABxWS4ICiA231.png" alt="Drawing 17.png" data-nodeid="36537"></p>
<p data-nodeid="35349">也就是说，我们添加了一个虚拟结点 0，然后也添加了 3 条虚拟边。这里虚拟的元素我们都用绿色表示。</p>
<p data-nodeid="35350">如果最后生成的连通图里面把 0~3 这四个点都包含进去，那么所有的大楼肯定都是可以上网的。此时最小代价问题就可以用最小生成树的方法来解决了。</p>
<p data-nodeid="35351">【<strong data-nodeid="36547">代码</strong>】到这里，相信你已经知道可以怎么写代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35352"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalCost = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 注意，编号是从1 ~ n</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) {
      F[i] = i;
    }
    totalCost = <span class="hljs-number">0</span>;
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
    <span class="hljs-keyword">if</span> (x == F[x]) {
      <span class="hljs-keyword">return</span> x;
    }
    F[x] = Find(F[x]);
    <span class="hljs-keyword">return</span> F[x];
  }
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> pay)</span> </span>{
    <span class="hljs-keyword">if</span> (Find(x) != Find(y)) {
      totalCost += pay;
    }
    F[Find(x)] = Find(y);
  }
  <span class="hljs-comment">// N 表示结点数目</span>
  <span class="hljs-comment">// cost[i-1]表示结点i自己买路由器的代价</span>
  <span class="hljs-comment">// es[x] = [a, b, c]表示大楼a,b之间拉网线的费用</span>
  <span class="hljs-comment">// 输出所有大楼通网的最小费用</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minCostToSupplyWater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] cost, <span class="hljs-keyword">int</span>[][] es)</span> </span>{
    <span class="hljs-comment">// 初始化并查集</span>
    Init(N);
    <span class="hljs-comment">// 每个结点都要自己买路由器，那么我们可以认为这样</span>
    <span class="hljs-comment">// 0号楼已经有网络了，可以用0费用上网</span>
    <span class="hljs-comment">// i号楼与0号楼拉网线，需要的费用是cost[i-1]</span>
    <span class="hljs-comment">// 那么这里就多了N条边</span>
    <span class="hljs-keyword">int</span>[][] conn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[es.length + N][<span class="hljs-number">3</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; es.length; i++) {
      conn[i][<span class="hljs-number">0</span>] = es[i][<span class="hljs-number">0</span>];
      conn[i][<span class="hljs-number">1</span>] = es[i][<span class="hljs-number">1</span>];
      conn[i][<span class="hljs-number">2</span>] = es[i][<span class="hljs-number">2</span>];
    }
    <span class="hljs-keyword">int</span> to = es.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) {
      conn[to][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
      conn[to][<span class="hljs-number">1</span>] = i;
      conn[to][<span class="hljs-number">2</span>] = cost[i - <span class="hljs-number">1</span>];
      to++;
    }
    <span class="hljs-comment">// 接下来采用Krukal最小生成树算法</span>
    Arrays.sort(conn, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">2</span>] - b[<span class="hljs-number">2</span>];
      }
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; conn.length; i++) {
      Union(conn[i][<span class="hljs-number">0</span>], conn[i][<span class="hljs-number">1</span>], conn[i][<span class="hljs-number">2</span>]);
    }
    <span class="hljs-keyword">return</span> totalCost;
  }
}
</code></pre>
<blockquote data-nodeid="35353">
<p data-nodeid="35354">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36551">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36555">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/1168.%E5%A4%A7%E6%A5%BC%E9%80%9A%E7%BD%91.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36559">Python</a></p>
</blockquote>
<p data-nodeid="35355"><strong data-nodeid="36564">复杂度分析</strong>： 一共有 N 个点，M 条边，N 个点进行 Find/Union 的时间复杂度为 O(lgN)，所以总的时间复杂度为 M(lgN)。</p>
<p data-nodeid="35356">【<strong data-nodeid="36570">小结</strong>】接下来我们从面试官的角度看一下，这道题的考点是什么：</p>
<ul data-nodeid="35357">
<li data-nodeid="35358">
<p data-nodeid="35359">将特殊条件转化为一般的条件，通过引入一些虚拟点，虚拟边来实现</p>
</li>
<li data-nodeid="35360">
<p data-nodeid="35361">并查集的模板代码</p>
</li>
<li data-nodeid="35362">
<p data-nodeid="35363">最小生成树的 Kruskal 算法</p>
</li>
</ul>
<p data-nodeid="35364">如果在面试中抓住了这 3 个点，就很容易击破这道算法题。接下来我们看一下并查集的另外一个的考点。</p>
<h3 data-nodeid="35365">路径压缩</h3>
<p data-nodeid="35366">并查集除了前面提到了考点之外，还有一个比较不容易出现的考点。那就是关于路径压缩的考点。</p>
<p data-nodeid="35367">处理这种题时，需要利用路径压缩同时将节点之间的信息进行层层压缩和汇总。求解过程还是很有趣的。下面让我们通过一个例题学习一下这个知识点。</p>
<h4 data-nodeid="35368">例 6: 倍数关系</h4>
<p data-nodeid="35369"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZx2AJlAhAAB9L5EmBj8559.png" alt="Drawing 26.png" data-nodeid="36581"></p>
<p data-nodeid="35370">【<strong data-nodeid="36587">分析</strong>】那么首先我们进行一下模拟。</p>
<p data-nodeid="35371"><strong data-nodeid="36595">1</strong>. <strong data-nodeid="36596">模拟</strong></p>
<p data-nodeid="35372">变量之间的除法关系，我们需要记录一个链式信息。如果将除法当成一个有向边，然后变量与变量之间的除法就可以看成图结构。比如：<br>
<img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZziAOXBLAAAF8Wyu_as055.png" alt="Drawing 30.png" data-nodeid="36601"><br>
可以表示为下图：</p>
<p data-nodeid="35373"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ0OAaHLpAABvAPNQMEI372.png" alt="Drawing 31.png" data-nodeid="36606"></p>
<p data-nodeid="35374">如果我们将上图进行压缩，那么可以得到下图：</p>
<p data-nodeid="35375"><img src="https://s0.lgstatic.com/i/image6/M00/21/7E/CioPOWBUZ02AEcbFAABhq26WhTE347.png" alt="Drawing 32.png" data-nodeid="36610"></p>
<p data-nodeid="35376">经过压缩之后，可以发现这几个元素之间的关系就变成了下面这个样子：</p>
<ul data-nodeid="35377">
<li data-nodeid="35378">
<p data-nodeid="35379">a = 8 * c</p>
</li>
<li data-nodeid="35380">
<p data-nodeid="35381">c = 1 * c</p>
</li>
<li data-nodeid="35382">
<p data-nodeid="35383">b = 4 * c</p>
</li>
</ul>
<p data-nodeid="35384">此时，可以得到任意两个变量之间的比值。实际上，这几个数也可以以 a 元素为根，如下图所示：</p>
<p data-nodeid="35385"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ1qASIekAAC-iYLl5-E217.png" alt="Drawing 33.png" data-nodeid="36624"></p>
<p data-nodeid="35386">几个元素之间的关系就是这样：</p>
<ul data-nodeid="35387">
<li data-nodeid="35388">
<p data-nodeid="35389">b = 0.5 * a</p>
</li>
<li data-nodeid="35390">
<p data-nodeid="35391">a = 1 * a</p>
</li>
<li data-nodeid="35392">
<p data-nodeid="35393">c = 0.125 * a</p>
</li>
</ul>
<p data-nodeid="35394">此时，我们可以得到任意两个变量之间的比值。</p>
<p data-nodeid="35395"><strong data-nodeid="36643">2</strong>. <strong data-nodeid="36644">规律</strong></p>
<p data-nodeid="35396">在这里，可以通过模拟找到一个<strong data-nodeid="36650">规律：只要是相连通的几个元素，可以选择任意一个结点做根结点。连通性好办，重点是：需要记录元素与根元素的比例</strong>。</p>
<p data-nodeid="35397">并且我们发现其实哪个点做根结点都一样。但是比例关系怎么办？再回看一下模拟的过程，可以发现：<strong data-nodeid="36656">比例关系就是顺着图中，有向边的方向乘过去即可</strong>。</p>
<p data-nodeid="35398">这里我们画图表示如下：</p>
<p data-nodeid="35399"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ2WAYuNmAADbi_WkYTo775.png" alt="Drawing 34.png" data-nodeid="36660"></p>
<p data-nodeid="35400">也就是说，在压缩的时候，需要把路径上边的权重依次乘起来。</p>
<p data-nodeid="35401"><strong data-nodeid="36669">3</strong>. <strong data-nodeid="36670">匹配</strong></p>
<p data-nodeid="35402">通过前面的一番分析，可以发现题目具有两个特点：</p>
<ul data-nodeid="35403">
<li data-nodeid="35404">
<p data-nodeid="35405">连通性</p>
</li>
<li data-nodeid="35406">
<p data-nodeid="35407">路径压缩性</p>
</li>
</ul>
<p data-nodeid="35408">能匹配到这两个特点的算法刚好是今天所讲的并查集。</p>
<p data-nodeid="35409"><strong data-nodeid="36682">4</strong>. <strong data-nodeid="36683">边界</strong></p>
<p data-nodeid="35410"><strong data-nodeid="36692">面试官提醒</strong>：<strong data-nodeid="36693">由于涉及除法，在面试中，你一定要主动提出是否可能存在除 0 的情况。如果给定的输入里面可能有，那么一定要记得处理</strong>。</p>
<p data-nodeid="35411">【<strong data-nodeid="36699">代码</strong>】我们已经有了并查集的代码，那么处理路径压缩，应该也不是什么问题，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="35412"><code data-language="java"><span class="hljs-comment">// 小技巧：</span>
<span class="hljs-comment">// 记录字符串与整数的映射</span>
<span class="hljs-comment">// 将字符串映射成整数之后，在操作并查集的数组的时候</span>
<span class="hljs-comment">// 我们就可以使用整数组，速度也更快。</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToMap</span><span class="hljs-params">(String key, Map&lt;String, Integer&gt; H)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = H.size();
  <span class="hljs-keyword">if</span> (!H.containsKey(key)) {
    H.put(key, id);
  }
}
<span class="hljs-comment">// 并查集的数组 </span>
<span class="hljs-keyword">int</span>[] F = <span class="hljs-keyword">null</span>;
<span class="hljs-comment">// 结点与其父结点的比例关系，我们总是用子结点除以父结点</span>
<span class="hljs-comment">// 当 a / c = 8时，并且当前 a的父结点就是c</span>
<span class="hljs-comment">// 那么 C[a] = 8</span>
<span class="hljs-comment">// 当并查集的结构调整之后，a的父结点变成了d</span>
<span class="hljs-comment">// 并且a/d=16，那么此时C[a] = 16</span>
<span class="hljs-keyword">double</span>[] C = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
  F = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
  C = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[n];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    F[i] = i;
    C[i] = <span class="hljs-number">1</span>;
  }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">int</span> b = x;
  <span class="hljs-comment">// base用来保存从x -&gt; .... root</span>
  <span class="hljs-comment">// 这条路径上所有的乘积</span>
  <span class="hljs-comment">// 最后保证可以得到</span>
  <span class="hljs-comment">// x = base * root</span>
  <span class="hljs-keyword">double</span> base = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (x != F[x]) {
    base *= C[x];
    x = F[x];
  }
  <span class="hljs-comment">// 这里x就是root</span>
  <span class="hljs-comment">// base x -&gt; root的映射值</span>
  <span class="hljs-comment">// 把路径上的其他值一并压缩</span>
  <span class="hljs-keyword">int</span> root = x;
  <span class="hljs-keyword">while</span> (F[b] != root) {
    <span class="hljs-comment">// 修改值上的变化</span>
    <span class="hljs-keyword">double</span> next = base / C[b];
    C[b] = base;
    base = next;
    <span class="hljs-keyword">int</span> par = F[b];
    F[b] = root;
    b = par;
  }
  <span class="hljs-keyword">return</span> root;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> T, <span class="hljs-keyword">int</span> D, <span class="hljs-keyword">double</span> v)</span> </span>{
  <span class="hljs-comment">// T / D = v;</span>
  <span class="hljs-comment">// 给定的输入表示 T = v * D;</span>
  <span class="hljs-comment">// 那么找到T的root</span>
  <span class="hljs-keyword">int</span> tpar = Find(T);
  <span class="hljs-comment">// T = C[T] * par</span>
  <span class="hljs-keyword">int</span> dpar = Find(D);
  <span class="hljs-comment">// D = C[D] * dpar;</span>
  <span class="hljs-comment">// T = v * D = v * C[D] * dpar = C[T] * tpar;</span>
  <span class="hljs-comment">// 如果我们要让tpar 指向dpar</span>
  <span class="hljs-comment">// tpar = v * C[D] * dpar / C[T]</span>
  F[tpar] = dpar;
  C[tpar] = v * C[D] / C[T];
}
<span class="hljs-keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations,
                       <span class="hljs-keyword">double</span>[] values,
                       List&lt;List&lt;String&gt;&gt; queries) {
  <span class="hljs-comment">// 为了方便后面操作，我们把所有的字符串都映射成整数</span>
  Map&lt;String, Integer&gt; H = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
  <span class="hljs-keyword">for</span> (List&lt;String&gt; l : equations) {
    String t = l.get(<span class="hljs-number">0</span>), d = l.get(<span class="hljs-number">1</span>);
    addToMap(t, H);
    addToMap(d, H);
  }
  <span class="hljs-comment">// 初始化并查集</span>
  Init(H.size());
  <span class="hljs-comment">// 开始执行Union操作</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; equations.size(); i++) {
    List&lt;String&gt; l = equations.get(i);
    Union(H.get(l.get(<span class="hljs-number">0</span>)), H.get(l.get(<span class="hljs-number">1</span>)), values[i]);
  }
  <span class="hljs-comment">// 在进行query之前，对所有的点执行Find操作。让后面的query</span>
  <span class="hljs-comment">// 的Find操作时间复杂度为O(1)</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; H.size(); i++) {
    Find(i);
  }
  <span class="hljs-keyword">double</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[queries.size()];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; queries.size(); i++) {
    List&lt;String&gt; l = queries.get(i);
    <span class="hljs-keyword">int</span> tidx = H.containsKey(l.get(<span class="hljs-number">0</span>)) ? H.get(l.get(<span class="hljs-number">0</span>)) : -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> didx = H.containsKey(l.get(<span class="hljs-number">1</span>)) ? H.get(l.get(<span class="hljs-number">1</span>)) : -<span class="hljs-number">1</span>;
    <span class="hljs-comment">// 如果变量不存在，那么比例关系照题意设置为-1</span>
    <span class="hljs-keyword">if</span> (tidx == -<span class="hljs-number">1</span> || didx == -<span class="hljs-number">1</span>) {
      ans[i] = -<span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">int</span> troot = Find(tidx);
      <span class="hljs-keyword">int</span> droot = Find(didx);
      <span class="hljs-comment">// 如果两个变量从来没有过交集 </span>
      <span class="hljs-keyword">if</span> (troot != droot) {
        ans[i] = -<span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        ans[i] = C[tidx] / C[didx];
      }
    }
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="35413">
<p data-nodeid="35414">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36703">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36707">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/07.UF/399.%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="36711">Python</a></p>
</blockquote>
<p data-nodeid="35415"><strong data-nodeid="36716">复杂度分析</strong>：假设有 N 个变量，构建并查集的时间复杂度为 O (NlgN)，如果有 M 个 Query，每次在询问为 O(1)，所以总的时间复杂度为 max(O(NlgN),M)。</p>
<p data-nodeid="35416">【<strong data-nodeid="36722">小结</strong>】如果要解决这道题，那么需要注意掌握以下三点。</p>
<ul data-nodeid="35417">
<li data-nodeid="35418">
<p data-nodeid="35419">连通域里面的所有变量都统一用一个变量表示倍数关系，那么任意的两个变量就可以直接询问倍数关系。</p>
</li>
<li data-nodeid="35420">
<p data-nodeid="35421">倍数关系具有传递性，即：<br>
<img src="https://uploader.shimo.im/f/LbdIya2siEFX52pW.png!thumbnail?fileGuid=xxQTRXtVcqtHK6j8" alt="图片" data-nodeid="36728"><br>
这是我们进行路径压缩的关键。</p>
</li>
<li data-nodeid="35422">
<p data-nodeid="35423">Union 操作时，注意变量倍数关系的调整。</p>
</li>
</ul>
<p data-nodeid="35424">如果想到了这些，再加上我介绍的并查集的代码模板，那么解决这道面试题也就没什么难度了。以后在面试中，你如果发现题目具有<strong data-nodeid="36737">传递性</strong>的特点，就可以使用并查集进行求解。</p>
<h3 data-nodeid="35425">总结</h3>
<p data-nodeid="35426" class="">在本讲中，我介绍了并查集面试时常见的考察点，并且给出了并查集的代码模板。最后我还给你准备了并查集的知识树，面试中并查集相关的问题基本上逃不出这个圈。希望你可以尝试自己对本讲的内容进行梳理，然后再对照下图查缺补漏。</p>
<p data-nodeid="35427"><img src="https://s0.lgstatic.com/i/image6/M00/21/82/Cgp9HWBUZ5KACZb3AAEzzay3PAM503.png" alt="Drawing 38.png" data-nodeid="36742"></p>
<h3 data-nodeid="35428">思考题</h3>
<p data-nodeid="35429">如果我们把例 5 的变量看成图上的点，变量与变量之间的关系看成是边。一旦构建好了并查集，在 Query 的时候，就可以 O(1) 的时间查询到两个变量之间的代价。那么为什么在图算法中，我们需要用 Floyd 算法求解图中两个点之间的最短路径？</p>
<p data-nodeid="35430">希望你可以把思考写在留言区，我们一起讨论，如果看到有趣的想法，我也会做成加餐和大家分享。：）</p>
<p data-nodeid="35431" class="">到这里，我们就要与并查集说再见了，接下来我们一起学习 08｜排序：如何利用合并与快排的小技巧，解决算法难题。记得按时来探险。</p>

---

### 精选评论

##### **方：
> 假期刷题 走起😅

##### **辉：
> 图的点集，边集，权重，最小生成树，代价等，这些概念能给讲下吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你好啊。我大概找了一下关于这些基本术语的介绍：https://zhuanlan.zhihu.com/p/25498681

由于这个专栏的重点是《面试》。所以这些知识点可能覆盖得不是全面，多多包涵。

讲面试的时候，别的老铁们就是想要又干又硬的货。（最好是别的课或者书上没有的）。拿基础知识点灌水的话，我防不住老铁们的口水

##### JackLi：
> 倍数关系具有传递性，即：这一段落的图片无法加载出来

##### *超：
> 初学并查集，第一遍完全懵，认真读两遍稍微好一点。

##### **正：
> 老师有些题在lt上找不到 可以在github上标注一下来源吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你可以看一下我们github repo的代码。里面每个题目我都在文件开头的注释中提供了题目的来源

##### **健：
> 老师union方法是不是有问题    private void union(int x, int y) {        F[x] = find(y);//        F[find(x)] = find(y);    }

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 先说答案，有问题。
假设的帮主链条是 1->2->3->4. 这4个数{1,2,3,4}都是属于一个帮派。
另外还有一个帮派是5->6
现在要实行Union(1,5)。那么正确的结果是大家都指向6。

但是，如果执行F[x] = F[find(y)]导致的后果就是1->6. 2->3->4. 5->6

会导致集合1中的{2,3,4}并没有合并过来

