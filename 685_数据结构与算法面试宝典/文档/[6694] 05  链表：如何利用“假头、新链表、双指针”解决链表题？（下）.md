<p data-nodeid="5677" class="">在上一讲中，我给你介绍了解决链表问题的“三板斧”中的<strong data-nodeid="6012">第一斧：假头</strong>，你知道了带假头的链表一共有 6 种基本的操作，分别是初始化、追加结点、头部插入结点、查找结点、插入指定位置之前和删除结点。</p>
<p data-nodeid="5678">如果说三板斧的第一斧平平淡淡，大巧不工；第二斧就是鬼斧神工，生成<strong data-nodeid="6026">新链表</strong>后，链表的交换、反转求解都会变得极其简单 ；第三斧则是奇思妙想，<strong data-nodeid="6027">双指针</strong>（<strong data-nodeid="6028">也叫快慢指针</strong>）用在链表上经常可以解决一些单个指针难以解决的问题。学会了这两种思路，算法面试中的链表题就如同探囊取物了。</p>
<p data-nodeid="5679"><em data-nodeid="6032">注：大部分链表题主要考查动手能力，因此在本讲将不再按照“分析四步法”进行讲解。</em></p>
<h3 data-nodeid="5680">三板斧的第二斧：新链表</h3>
<p data-nodeid="5681">做链表的反转、交换等操作时，我<strong data-nodeid="6049">不建议直接在原来的链表上进行操作</strong>。一种可取的思路是，把这些操作想象成要<strong data-nodeid="6050">生成新的链表</strong>，然后借助这些新的链表，完成原本比较复杂的操作。这个方法就是我们今天要讲的**“第二斧”——新链表**。</p>
<p data-nodeid="5682">接下来，我将采用这种新思路，带你解决一些面试中经常会遇到的疑难题目。</p>
<h4 data-nodeid="5683">例 1：链表反转</h4>
<p data-nodeid="5684">【<strong data-nodeid="6058">题目</strong>】输入一个链表的头结点，反转该链表，并返回反转后链表的头结点。</p>
<p data-nodeid="5685">输入：1-&gt;2-&gt;3</p>
<p data-nodeid="5686">输出：3-&gt;2-&gt;1</p>
<p data-nodeid="5687">【<strong data-nodeid="6070">分析</strong>】这里借助<strong data-nodeid="6071">假头和新链表求解</strong>，思路如下：</p>
<ul data-nodeid="5688">
<li data-nodeid="5689">
<p data-nodeid="5690">建立一个新的带假头的空链表；</p>
</li>
<li data-nodeid="5691">
<p data-nodeid="5692">遍历旧链表，依次取出旧链表中的每个结点；</p>
</li>
<li data-nodeid="5693">
<p data-nodeid="5694">采用<strong data-nodeid="6079">头部插入</strong>的方法放到新链表中；</p>
</li>
<li data-nodeid="5695">
<p data-nodeid="5696">返回 dummy.next。</p>
</li>
</ul>
<p data-nodeid="5697">【<strong data-nodeid="6086">画图</strong>】这里我们利用示意图演示如下：</p>
<p data-nodeid="5698"><img src="https://s0.lgstatic.com/i/image6/M01/1A/58/Cgp9HWBLPB-ADUhLAA5duiC4Cn0341.gif" alt="1.gif" data-nodeid="6089"></p>
<p data-nodeid="5699">【<strong data-nodeid="6095">代码</strong>】对应的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5700"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>{
        <span class="hljs-comment">// 建立一个新的带假头的新链表</span>
        ListNode dummy = <span class="hljs-keyword">new</span> ListNode();
        <span class="hljs-comment">// 开始遍历旧链表</span>
        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) {
            ListNode tmp = head.next;
            <span class="hljs-comment">// 把旧链表中的结点取出来，采用头部插入的方法添加到新链表中</span>
            head.next = dummy.next;
            dummy.next = head;
            head = tmp;
        }
        <span class="hljs-comment">// 返回新链表的头，注意，不要返回dummy!!</span>
        <span class="hljs-keyword">return</span> dummy.next;
    }
}
</code></pre>
<blockquote data-nodeid="5701">
<p data-nodeid="5702">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.java" data-nodeid="6099">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6103">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.py" data-nodeid="6107">Python</a></p>
</blockquote>
<p data-nodeid="5703"><strong data-nodeid="6112">复杂度分析</strong>：每个结点只遍历一次，所以时间复杂度为 O(N)，内存空间只使用了常量空间，因此空间复杂度为 O(1)。</p>
<p data-nodeid="5704">【<strong data-nodeid="6126">小结</strong>】仔细查看代码之后，链表反转的<strong data-nodeid="6127">考点</strong>就是之前我们学到的基本操作：<strong data-nodeid="6128">假头，头部插入法</strong>，再结合今天学习的新链表的思路。可以总结如下：</p>
<p data-nodeid="5705"><img src="https://s0.lgstatic.com/i/image6/M01/1A/55/CioPOWBLPCqAFbDdAAEIj8hvRD4018.png" alt="Drawing 1.png" data-nodeid="6131"></p>
<h4 data-nodeid="5706">例 2：删除结点</h4>
<p data-nodeid="5707">【<strong data-nodeid="6138">题目</strong>】给定一个链表头及一个整数值，要求把链表里面等于整数值的结点都从链表中移除出去。</p>
<p data-nodeid="5708">输入：1-&gt;2-&gt;3-&gt;2-&gt;4, remove = 2</p>
<p data-nodeid="5709">输出：1-&gt;3-&gt;4。</p>
<p data-nodeid="5710"><strong data-nodeid="6145">解释</strong>：要移除的整数值是 2。那么移除之后，返回的结果应该是 1-&gt;3-&gt;4。</p>
<p data-nodeid="5711">【<strong data-nodeid="6151">分析</strong>】这里我们不采用在原来的链表上进行删除的办法，而是采用新链表的操作思路：</p>
<ul data-nodeid="5712">
<li data-nodeid="5713">
<p data-nodeid="5714">建立一个新的带假头的空链表；</p>
</li>
<li data-nodeid="5715">
<p data-nodeid="5716">遍历旧链表，依次取出旧链表中的每个点，如果不删除这个结点，那么就采用尾部插入方法接到新链表中。</p>
</li>
</ul>
<p data-nodeid="5717">可以发现，在这里没有出现结点交换的操作。<strong data-nodeid="6159">采用新链表的思路，避免了在原链表上不停地做结点的删除</strong>。为了方便你理解，我制作了动图演示，如下所示：</p>
<p data-nodeid="5718"><img src="https://s0.lgstatic.com/i/image6/M00/1A/58/Cgp9HWBLPDmACYnZABNjwPGgFOE315.gif" alt="2.gif" data-nodeid="6162"></p>
<p data-nodeid="5719">【<strong data-nodeid="6168">代码</strong>】基于以上思想，可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5720"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;ListNode&nbsp;<span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode&nbsp;head,&nbsp;<span class="hljs-keyword">int</span>&nbsp;val)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;生成一个新链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;dummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;tail&nbsp;=&nbsp;dummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;依次取出旧链表中的每个结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;p&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(p&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;back&nbsp;=&nbsp;p.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果结点值需要保留，那么采用属部追加的方法</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;添加到新链表中</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(p.val&nbsp;!=&nbsp;val)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;back;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意设置尾巴的next为空</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意返回的是dummy.next</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;dummy.next;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5721">
<p data-nodeid="5722">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.java" data-nodeid="6172">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.cpp" data-nodeid="6176">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.py" data-nodeid="6180">Python</a></p>
</blockquote>
<p data-nodeid="5723"><strong data-nodeid="6185">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p data-nodeid="5724">【<strong data-nodeid="6195">小结</strong>】我们将这道题的考点层层剥离之后，就只剩下<strong data-nodeid="6196">生成 dummy 新链表，尾巴追加新结点，以及新链表的思路</strong>。关于解决这道这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结，再来看我给出的思维导图：</p>
<p data-nodeid="5725"><img src="https://s0.lgstatic.com/i/image6/M00/1A/56/CioPOWBLPEiANaaFAAGpHYE1Luw914.png" alt="Drawing 3.png" data-nodeid="6199"></p>
<p data-nodeid="5726">如果我们仔细对比链表反转与删除结点，会发现，这两者的不同之处在于：</p>
<ul data-nodeid="5727">
<li data-nodeid="5728">
<p data-nodeid="5729">链表反转使用的是头部插入的方法</p>
</li>
<li data-nodeid="5730">
<p data-nodeid="5731">删除结点采用的是尾部追加的方法</p>
</li>
</ul>
<p data-nodeid="5732">只是换了一个考点，题目就完全大变样了。如果我们再严格地对比这两个题目，可以发现：</p>
<ul data-nodeid="5733">
<li data-nodeid="5734">
<p data-nodeid="5735">链表反转时，头部插入是<strong data-nodeid="6209">无</strong>条件的</p>
</li>
<li data-nodeid="5736">
<p data-nodeid="5737">删除结点时，尾部 append 是<strong data-nodeid="6215">有</strong>条件的</p>
</li>
</ul>
<p data-nodeid="5738">这种<strong data-nodeid="6221">条件的千变万化</strong>，会带来很多有趣的题目。比如下面这道练习题。</p>
<p data-nodeid="5739"><strong data-nodeid="6226">练习题 1</strong>：给定一个排序链表，删除重复出现的元素，使得每个元素只出现一次。</p>
<p data-nodeid="5740">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p>
<p data-nodeid="5741">输出: 1-&gt;2-&gt;3</p>
<blockquote data-nodeid="5742">
<p data-nodeid="5743">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.java" data-nodeid="6232">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.cpp" data-nodeid="6236">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/83.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.py" data-nodeid="6240">Python</a></p>
</blockquote>
<p data-nodeid="5744"><strong data-nodeid="6245">练习题 2</strong>：给定一个排序链表，删除重复出现的元素，只留下没有重复出现的元素。</p>
<p data-nodeid="5745">输入：1-&gt;1-&gt;2-&gt;3-&gt;3</p>
<p data-nodeid="5746">输出：2</p>
<blockquote data-nodeid="5747">
<p data-nodeid="5748">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii.java" data-nodeid="6251">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii.cpp" data-nodeid="6255">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/82.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii.py" data-nodeid="6259">Python</a></p>
</blockquote>
<p data-nodeid="5749">你可以把答案或者思考的过程写在评论区，我们一起讨论。</p>
<h4 data-nodeid="5750">例 3 ：合并</h4>
<p data-nodeid="5751">【<strong data-nodeid="6267">题目</strong>】合并给定的两个有序链表。</p>
<p data-nodeid="5752">输入：a = 1-&gt;4-&gt;6, b = 3-&gt;5-&gt;7</p>
<p data-nodeid="5753">输出：1-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7</p>
<p data-nodeid="5754">【<strong data-nodeid="6279">分析</strong>】首先应该是生成一个带假头的新链表 C，然后把 A，B 中的元素从小到大，依次添加到新生成的链表 C 中。因此，我们还需要使用到<strong data-nodeid="6280">尾部插入法</strong>。</p>
<p data-nodeid="5755">具体操作方法如下。</p>
<ul data-nodeid="5756">
<li data-nodeid="5757">
<p data-nodeid="5758">第一步：A，B 两个指针分别指向 A，B 链表的表头。</p>
</li>
<li data-nodeid="5759">
<p data-nodeid="5760">第二步：依次取出 A，B 两个指针中更小的值加入新链表中。</p>
</li>
<li data-nodeid="5761">
<p data-nodeid="5762">第三步：返回 C 链表假头的 next。</p>
</li>
</ul>
<p data-nodeid="5763">具体演示如下所示：</p>
<p data-nodeid="5764"><img src="https://s0.lgstatic.com/i/image6/M00/1A/56/CioPOWBLPFmAUvWfABh66BN8Jpo146.gif" alt="3.gif" data-nodeid="6288"></p>
<p data-nodeid="5765">【<strong data-nodeid="6294">代码</strong>】有了前面的思路，可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5766"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;ListNode&nbsp;<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode&nbsp;l1,&nbsp;ListNode&nbsp;l2)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;首先生成空链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;dummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;tail&nbsp;=&nbsp;dummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;遍历两个有序链表,每次只取一个结点append到新链表里面</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(l1&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;l2&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果l2链表为空，或者l1链表里面的值更小，那么取l1结点追加到</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;新链表尾部</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(l2&nbsp;==&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;l1&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;l1.val&nbsp;&lt;&nbsp;l2.val)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;l1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;l1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l1&nbsp;=&nbsp;l1.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;其他情况，则把l2结点添加到新链表尾部</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;l2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;l2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l2&nbsp;=&nbsp;l2.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意：这里一定要记得把tail.next设置为空。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;虽然这个题可能并不需要，但是应该养成收尾的好习惯</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;返回dummy.next,&nbsp;不要返回dummy!!</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;dummy.next;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5767">
<p data-nodeid="5768">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.java" data-nodeid="6298">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6302">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.py" data-nodeid="6306">Python</a></p>
</blockquote>
<p data-nodeid="5769"><strong data-nodeid="6311">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p data-nodeid="5770">【<strong data-nodeid="6317">小结</strong>】如果我们再分析一下这道题目，可以发现考点仍然是：</p>
<ul data-nodeid="5771">
<li data-nodeid="5772">
<p data-nodeid="5773">生成 dummy 新链表</p>
</li>
<li data-nodeid="5774">
<p data-nodeid="5775">选择结点往新链表<strong data-nodeid="6323">尾部追加数据</strong></p>
</li>
</ul>
<p data-nodeid="5776">此时的尾部 append 是<strong data-nodeid="6333">有</strong>条件的：需要从两个链表头中<strong data-nodeid="6334">选择一个较小</strong>的数据进行追加。当然，有条件的 append 还可以变成各种其他的条件来操作。不过即使千变万化，只要你看清楚题的考点，就能轻松应对、。</p>
<p data-nodeid="5777">那么这里我们不妨再选择其中一个考点“<strong data-nodeid="6340">选择较小的数</strong>”进行练习。在原题中，只有两个链表，所以可以直接通过比较得到较小的结点。可是如果有 k 个链表要合并的时候，又应该怎么做呢？比如下面这道练习题：</p>
<p data-nodeid="5778"><strong data-nodeid="6345">练习题 3</strong>：给定 k 个有序链表，合并成一个有序链表</p>
<p data-nodeid="5779">输入：[1-&gt;4-&gt;5，1-&gt;3-&gt;4, 2-&gt;6]</p>
<p data-nodeid="5780">输出：[1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6]</p>
<blockquote data-nodeid="5781">
<p data-nodeid="5782">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.java" data-nodeid="6357">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6361">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.py" data-nodeid="6365">Python</a></p>
</blockquote>
<p data-nodeid="5783">你可以把答案或者思考的过程写在评论区，我们一起讨论。</p>
<h4 data-nodeid="5784">例 4：交换链表中的结点</h4>
<p data-nodeid="5785">【<strong data-nodeid="6373">题目</strong>】给定一个链表，需要将里面的结点两两交换。</p>
<p data-nodeid="5786">输入：[1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6]</p>
<p data-nodeid="5787">输出：[2-&gt;1-&gt;4-&gt;3-&gt;6-&gt;5]</p>
<p data-nodeid="5788">【分析】经过观察发现，只不过把偶数位置与奇数位置的结点进行了交换。为了避免在原始链表中进行结点间的交换操作，我们可以采用如下方法：</p>
<ol data-nodeid="5789">
<li data-nodeid="5790">
<p data-nodeid="5791">生成两个新链表，一个用来存放奇数位置结点的链表 odd，一个用来存放偶数位置结点的链表 even；</p>
</li>
<li data-nodeid="5792">
<p data-nodeid="5793">遍历旧链表，并且把奇数位置上的结点放到 odd 链表中，把偶数位置的结点放到链表 even 中；</p>
</li>
<li data-nodeid="5794">
<p data-nodeid="5795">合并 odd 链表与 even 链表。</p>
</li>
</ol>
<p data-nodeid="5796">为了方便你理解，我同样制作了动图演示，如下：</p>
<p data-nodeid="5797"><img src="https://s0.lgstatic.com/i/image6/M00/1A/56/CioPOWBLPHmASuS0ABO8i1nbo5k731.gif" alt="4.gif" data-nodeid="6389"></p>
<p data-nodeid="5798">到这里，<strong data-nodeid="6395">新增链表已经从一条变成了两条</strong>，来帮助我们解决这道题目。</p>
<p data-nodeid="5799">【<strong data-nodeid="6401">代码</strong>】有了思路，我们可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5800"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">private</span>&nbsp;ListNode&nbsp;<span class="hljs-title">mergeList</span><span class="hljs-params">(ListNode&nbsp;a,&nbsp;ListNode&nbsp;b)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;dummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;tail&nbsp;=&nbsp;dummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;合并两个链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(a&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;b&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果a不空，那么先取a结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(a&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;a;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;a;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;=&nbsp;a.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果b不空，再取b结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(b&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail&nbsp;=&nbsp;b;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;=&nbsp;b.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意收尾</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tail.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;dummy.next;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;ListNode&nbsp;<span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode&nbsp;head)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;生成奇数index应该存放的链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;oddDummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;oddTail&nbsp;=&nbsp;oddDummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;生成偶数index应该存放的链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;evenDummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;evenTail&nbsp;=&nbsp;evenDummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>&nbsp;index&nbsp;=&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;p&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(p&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;back&nbsp;=&nbsp;p.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;&nbsp;如果是偶数，放到偶数链表中</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;((index&nbsp;&amp;&nbsp;<span class="hljs-number">0x01</span>)&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenTail.next&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenTail&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="hljs-keyword">else</span>&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果是奇数，放到奇数链表中</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddTail.next&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddTail&nbsp;=&nbsp;p;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;back;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意两个链表的收尾</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oddTail.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evenTail.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意这里传入的是oddDummy.next和evenDummy.next</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;mergeList(oddDummy.next,&nbsp;evenDummy.next);
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5801">
<p data-nodeid="5802">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java" data-nodeid="6405">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.cpp" data-nodeid="6409">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.py" data-nodeid="6413">Python</a></p>
</blockquote>
<p data-nodeid="5803"><strong data-nodeid="6418">复杂度分析</strong>：每个结点会访问两次，拆分一次，合并一次，所以时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p data-nodeid="5804">【<strong data-nodeid="6424">小结</strong>】这道题的考点也比较明确了，可以拆分出以下考点：</p>
<ul data-nodeid="5805">
<li data-nodeid="5806">
<p data-nodeid="5807">拆分链表</p>
</li>
<li data-nodeid="5808">
<p data-nodeid="5809">新链表的思路</p>
</li>
<li data-nodeid="5810">
<p data-nodeid="5811">合并链表的操作</p>
</li>
</ul>
<p data-nodeid="5812">尤其需要注意的是，使用新链表思路时，可以通过<strong data-nodeid="6439">生成多条新链表</strong>来解决以前处理起来比较麻烦的问题。至此，我们一起进一步扩展了链表知识。此外，还发现了一些小型的组合操作，比如：**拆分链表，合并链表。**在合并时，如果按照不同的条件合并，就需要写出不一样的合并代码，结合前面例 3，可以知道合并分两种：</p>
<ul data-nodeid="5813">
<li data-nodeid="5814">
<p data-nodeid="5815">有序合并</p>
</li>
<li data-nodeid="5816">
<p data-nodeid="5817">先后合并</p>
</li>
</ul>
<p data-nodeid="5818">到这里可以总结出我们更加丰富的知识路线图，如下图所示：</p>
<p data-nodeid="5819"><img src="https://s0.lgstatic.com/i/image6/M00/1A/59/Cgp9HWBLPIuABvdjAAIdeUzaIaE820.png" alt="Drawing 6.png" data-nodeid="6445"></p>
<p data-nodeid="5820">在这道题中，链表是两两成对进行了<strong data-nodeid="6455">反转</strong>，那么如果是 k 个一组进行反转应该怎么办呢？我们再来看看与<strong data-nodeid="6456">交换</strong>有关的练习题。</p>
<p data-nodeid="5821"><strong data-nodeid="6461">练习题 4</strong>：给定一个链表，要求将链表 k 个一组进行反转，如果最后一组不足 k 个，那么不反转。返回反转之后的链表。</p>
<p data-nodeid="5822">输入：A = [1, 2, 3, 4, 5], k = 2</p>
<p data-nodeid="5823">输出: [2, 1, 4, 3, 5]</p>
<blockquote data-nodeid="5824">
<p data-nodeid="5825">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.java" data-nodeid="6474">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6478">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.py" data-nodeid="6482">Python</a></p>
</blockquote>
<p data-nodeid="5826"><strong data-nodeid="6487">练习题 5</strong>：给定一个链表，从链表尾部开始，k 个一组进行反转，如果左边的分组不足 k 个，那么不反转。返回反转之后的链表。</p>
<p data-nodeid="5827">输入：A = [1, 2, 3, 4, 5], k = 2</p>
<p data-nodeid="5828">输出：[1, 3, 2, 5, 4]</p>
<p data-nodeid="5829"><strong data-nodeid="6513">解释</strong>：注意是从链表的尾部开始k个一组的。所以这里是[1], [2, 3], [4, 5]这样分组来进行反转。</p>
<blockquote data-nodeid="5830">
<p data-nodeid="5831">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.%E9%80%86%E5%90%91k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.java" data-nodeid="6517">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.%E9%80%86%E5%90%91k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6521">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/25.%E9%80%86%E5%90%91k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.py" data-nodeid="6525">Python</a></p>
</blockquote>
<h3 data-nodeid="5832">三板斧的第三斧：双指针</h3>
<p data-nodeid="5833">虽然新链表的思路非常有趣，但是关于它的更多探索还是应该留给你自己。收拾好行囊，我们将要去看更加瑰丽的奇景——<strong data-nodeid="6532">双指针</strong>。</p>
<p data-nodeid="5834">双指针，顾名思义就是两个指针在链表上移动。实际上，我们在前面链表的查找中已经使用过双指针了：比如链表中指定位置插入一个新结点，就使用了<strong data-nodeid="6538">两个指针，一前一后两个指针在链表上前进</strong>。</p>
<p data-nodeid="5835">其实两个指针在链表上前进时，有很多种形式，常见的主要有以下两种。</p>
<ol data-nodeid="5836">
<li data-nodeid="5837">
<p data-nodeid="5838">间隔指针：前面的指针先走一步，然后后面的指针再一起走；前面的指针先走 k 步，后面的指针再一起走。</p>
</li>
<li data-nodeid="5839">
<p data-nodeid="5840">快慢指针：两个指针的速度一快一慢前进，比如一个每次走一步，一个每次走两步。</p>
</li>
</ol>
<p data-nodeid="5841">接下来，我们来看看双指针能解决什么类型的问题。</p>
<h4 data-nodeid="5842">例 5：链表的倒数第 k 个结点</h4>
<p data-nodeid="5843">【<strong data-nodeid="6553">题目</strong>】给定一个链表，删除链表中的倒数第 k 个结点。这里我们认为<strong data-nodeid="6554">最后一个结点是倒数第 1 个</strong>。</p>
<p data-nodeid="5844">输入：1-&gt;2-&gt;3, k = 2</p>
<p data-nodeid="5845">输出： 1-&gt;3</p>
<p data-nodeid="5846">【分析】首先第一种常规思路是，先统计出整个链表的长度 len, 再去取第 len-k 结点的前驱进行删除。</p>
<p data-nodeid="5847">但是，面试的时候，面试官往往会加一个限制条件 ：<strong data-nodeid="6563">只能遍历链表一次</strong>。</p>
<p data-nodeid="5848">以后凡是遇到链表题，看到这句话，实际上就是在告诉你“<strong data-nodeid="6569">用双指针吧</strong>”。思路如下：</p>
<ol data-nodeid="5849">
<li data-nodeid="5850">
<p data-nodeid="5851">在原链表前面加上 dummy，变成带假头的链表</p>
</li>
<li data-nodeid="5852">
<p data-nodeid="5853">front 指针从 dummy 开始，走 k 步，然后停下来</p>
</li>
<li data-nodeid="5854">
<p data-nodeid="5855">back 指针指向链表 dummy 假头</p>
</li>
<li data-nodeid="5856">
<p data-nodeid="5857">然后两个指针再一起走</p>
</li>
<li data-nodeid="5858">
<p data-nodeid="5859">当 front 指针指向<strong data-nodeid="6583">最后一个结点</strong>时，back 指针刚好指向<strong data-nodeid="6584">倒数第 k 个结点</strong>的前驱。</p>
</li>
</ol>
<p data-nodeid="5860">解题思路有了，还有两个细节需要你特别注意。</p>
<p data-nodeid="5861">【<strong data-nodeid="6591">细节 1</strong>】你需要小心处理三种情况：</p>
<ol data-nodeid="5862">
<li data-nodeid="5863">
<p data-nodeid="5864">链表长度 &lt; k，此时什么也不做；</p>
</li>
<li data-nodeid="5865">
<p data-nodeid="5866">链表长度 == k，此时删除原来的链表头结点；</p>
</li>
<li data-nodeid="5867">
<p data-nodeid="5868">链表长度 &gt; k，此时找到<strong data-nodeid="6605">倒数第 k 个结点</strong>的前驱，然后删除<strong data-nodeid="6606">倒数第 k 个结点</strong>。</p>
</li>
</ol>
<p data-nodeid="5869">接下来，我们分别讨论这三种情况。</p>
<p data-nodeid="5870"><strong data-nodeid="6612">情况 1</strong>：链表长度小于 k。front 指针会先走 k 步，如果链表长度小于 k，那么必然会导致 front 指针行走的步数小于 k，此时应该什么也不做。</p>
<p data-nodeid="5871"><img src="https://s0.lgstatic.com/i/image6/M00/1A/56/CioPOWBLPJiAJuL5AACldcUHsSo093.png" alt="Drawing 7.png" data-nodeid="6615"></p>
<p data-nodeid="5872"><strong data-nodeid="6620">情况 2</strong>：链表长度等于 k。此时需要删除倒数第 k 个结点，也就是旧链表的 head 结点。</p>
<p data-nodeid="5873">当 front 指针先走完 k 步之后，back 指针刚好位于 dummy 结点。而 dummy 结点就是倒数第 k+1 个结点，那么此时可以直接通过 back 指针删除它后面的结点（刚好是 head，也就是倒数第 k 个）。</p>
<p data-nodeid="5874"><img src="https://s0.lgstatic.com/i/image6/M00/1A/5A/Cgp9HWBLPKGAed19AADYq0JsnnQ189.png" alt="Drawing 8.png" data-nodeid="6624"></p>
<p data-nodeid="5875"><strong data-nodeid="6629">情况 3</strong>：链表长度大于 k。back 指针刚好位于倒数第 k+1 个结点，此时可以直接通过 back 指针删除它后面的结点（刚好是倒数第 k 个)。</p>
<p data-nodeid="5876"><img src="https://s0.lgstatic.com/i/image6/M00/1A/5A/Cgp9HWBLPKmAX36bAADfNLuJxK4304.png" alt="Drawing 9.png" data-nodeid="6632"></p>
<p data-nodeid="5877">我们发现：情况 2 和情况 3 实际上都是用 back 指针来删除后面的结点。因此，这两种情况可以一起处理。</p>
<p data-nodeid="5878"><img src="https://s0.lgstatic.com/i/image6/M00/1A/5A/Cgp9HWBLPLCAIVQrAADfNLuJxK4542.png" alt="Drawing 10.png" data-nodeid="6636"></p>
<p data-nodeid="5879">【<strong data-nodeid="6650">细节 2</strong>】任何时候，front 最后<strong data-nodeid="6651">停下来的位置一定</strong>要位于链表的<strong data-nodeid="6652">最后一个结点</strong>。这是因为：要想删除倒数第 k 个结点的前驱结点，需要 back 刚好指向倒数第 k+1 个结点，那么就必须要让 front 非空，即指向倒数第一个结点。</p>
<p data-nodeid="5880">【<strong data-nodeid="6658">代码</strong>】有了思路以及相应的细节，我们就可以利用代码来解决问题了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5881"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;ListNode&nbsp;<span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode&nbsp;head,&nbsp;<span class="hljs-keyword">int</span>&nbsp;k)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;将链表改造成带假头的链表</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;dummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummy.next&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;链表长度</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>&nbsp;preWalkedSteps&nbsp;=&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;front指针从dummy开始先走k步</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;front&nbsp;=&nbsp;dummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意front不能为空，需要指向链表的最后一个结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(preWalkedSteps&nbsp;&lt;&nbsp;k&nbsp;&amp;&amp;
               front&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;front.next&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;front&nbsp;=&nbsp;front.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;preWalkedSteps++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;back指针指向dummy，然后front与back指针一起走</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;back&nbsp;=&nbsp;dummy;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;注意front不能为空，需要指向链表的最后一个结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(front&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;front.next&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;back&nbsp;=&nbsp;back.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;front&nbsp;=&nbsp;front.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;如果preWalkedSteps&nbsp;==&nbsp;k</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;说明处于情况2和情况3，需要删除倒数第k个结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(preWalkedSteps&nbsp;==&nbsp;k)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;back.next&nbsp;=&nbsp;back.next.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;返回新的链表头</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;dummy.next;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5882">
<p data-nodeid="5883">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9.java" data-nodeid="6662">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9.cpp" data-nodeid="6666">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9.py" data-nodeid="6670">Python</a></p>
</blockquote>
<p data-nodeid="5884"><strong data-nodeid="6675">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)</p>
<p data-nodeid="5885">【<strong data-nodeid="6681">小结</strong>】当做完这道题之后，我们可以进一步完善双指针的技巧，总结的思维导图如下：</p>
<p data-nodeid="5886"><img src="https://s0.lgstatic.com/i/image6/M00/1A/5A/Cgp9HWBLPL2AMjj9AACVkYTuuog333.png" alt="Drawing 11.png" data-nodeid="6684"></p>
<p data-nodeid="5887">然后，我们再来总结一下这道题目的考点。首先除了思路“双指针”以外，你还需要注意写代码的技巧。</p>
<ul data-nodeid="5888">
<li data-nodeid="5889">
<p data-nodeid="5890">将旧链表改造成带 dummy 结点的链表，方便删除 head 结点。这是能让情况 2 和情况 3 统一处理的关键。</p>
</li>
<li data-nodeid="5891">
<p data-nodeid="5892">让指针指向链表最后一个结点的 while 语句的写法。</p>
</li>
<li data-nodeid="5893">
<p data-nodeid="5894">利用移动步数来判断链表长度与 k 的关系。</p>
</li>
</ul>
<p data-nodeid="5895">接下来我们一起看一下双指针的另外一种形式，<strong data-nodeid="6694">快慢指针</strong>。</p>
<h4 data-nodeid="5896">例 6：拆分链表</h4>
<p data-nodeid="5897">【<strong data-nodeid="6701">题目</strong>】给定一个链表，需要把链表从中间拆分成长度相等的两半（如果链表长度为奇数，那么拆分之后，前半部分长度更长一点）。</p>
<p data-nodeid="5898">输入：[1-&gt;2-&gt;3-&gt;4-&gt;5]</p>
<p data-nodeid="5899">输出：[1-&gt;2-&gt;3, 4-&gt;5]</p>
<p data-nodeid="5900">【<strong data-nodeid="6715">分析</strong>】我们需要分为 2 步：</p>
<ol data-nodeid="5901">
<li data-nodeid="5902">
<p data-nodeid="5903">找到链表的中间结点</p>
</li>
<li data-nodeid="5904">
<p data-nodeid="5905">从中间结点把链表分为两半</p>
</li>
</ol>
<p data-nodeid="5906">那么问题是，如何找到中间结点呢？如果是首先求出链表的长度，然后再利用 getPreNode(len/2) 函数的前驱，再把链表拆分成两半。</p>
<p data-nodeid="5907">但是，这可能不是面试官想要的解法，因为这种解法会将链表遍历两遍，面试官可能会说：“<strong data-nodeid="6724">只能遍历一次</strong>”。又听到了这个声音，这就是告诉你需要用双指针了。</p>
<p data-nodeid="5908">所以问题的关键就是<strong data-nodeid="6730">如何使用双指针找到链表的中间结点</strong>，可以采用如下办法：</p>
<ul data-nodeid="5909">
<li data-nodeid="5910">
<p data-nodeid="5911">假设链表头在左边，尾巴在右边，两个指针 s1、s2 从链表头开始往右走；</p>
</li>
<li data-nodeid="5912">
<p data-nodeid="5913">s1 表示每次只往前走一步，s2 则表示每次只往前走 2 步；</p>
</li>
<li data-nodeid="5914">
<p data-nodeid="5915">在同样的时间内，当 s2 指向链表的末尾，s1 指针便指向链表的中间结点。</p>
</li>
</ul>
<p data-nodeid="5916">只是在写代码的时候，需要特别注意以下 2 点：</p>
<p data-nodeid="5917">1.当有<strong data-nodeid="6748">偶数</strong>个结点，<strong data-nodeid="6749">s2 是空指针</strong>，此时，s1 位于后半部分指针的头部，因此需要返回<strong data-nodeid="6750">s1 的前驱</strong>；</p>
<p data-nodeid="5918"><img src="https://s0.lgstatic.com/i/image6/M00/1A/57/CioPOWBLPOWAC7-qAADDfwOq_28981.png" alt="Drawing 12.png" data-nodeid="6753"></p>
<p data-nodeid="5919">2.当有<strong data-nodeid="6767">奇数</strong>个结点，<strong data-nodeid="6768">s2 是最后一个结点</strong>，此时 s1 指针位于前半部分的最后，<strong data-nodeid="6769">直接返回 s1</strong>即可。</p>
<p data-nodeid="5920"><img src="https://s0.lgstatic.com/i/image6/M00/1A/5B/Cgp9HWBLPOuAGwrJAADd3JbVNuk045.png" alt="Drawing 13.png" data-nodeid="6772"></p>
<p data-nodeid="5921">如果找到了中间结点，那么就可以直接进行拆分了。</p>
<p data-nodeid="5922">【<strong data-nodeid="6779">代码</strong>】接下来我们就实现拆分链表的逻辑，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5923"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">private</span>&nbsp;ListNode&nbsp;<span class="hljs-title">findMiddleNode</span><span class="hljs-params">(ListNode&nbsp;head)</span>&nbsp;</span>{
        <span class="hljs-comment">// 注意这里转化为带假头的链表，免去了空链表的判断</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;dummy&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummy.next&nbsp;=&nbsp;head;
        <span class="hljs-comment">// 注意，假头并不算是链表的一部分，所以这里是从head开始走</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s2&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s1&nbsp;=&nbsp;head;
        <span class="hljs-comment">// dummy就是head的前驱，所以pre要指向dummy.</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;pre&nbsp;=&nbsp;dummy;
        <span class="hljs-comment">// 两个指针开始同时走</span>
        <span class="hljs-comment">// 因为s2指针每次都要走两步，所以判空需要这样判断。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(s2&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;s2.next&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pre&nbsp;=&nbsp;s1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;s1.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;s2.next.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
        <span class="hljs-comment">// 当有偶数个结点的时候，s2是空指针，</span>
        <span class="hljs-comment">// 此时，s1位于后半部分指针的头部，因此需要返回s1的前驱。</span>
        <span class="hljs-comment">// 当有奇数个结点的时候，s2是最后一个结点，</span>
        <span class="hljs-comment">// 此时s1指针位于前半部分的最后，直接返回s1即可。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;s2&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;?&nbsp;s1&nbsp;:&nbsp;pre;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public</span>&nbsp;ListNode[]&nbsp;split(ListNode&nbsp;head)&nbsp;{
        <span class="hljs-comment">// 这里获取了链表的中间结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;mid&nbsp;=&nbsp;findMiddleNode(head);
        <span class="hljs-comment">// 拿到链表的中间结点之后，可以得到链表的后半部分的开头</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;back&nbsp;=&nbsp;mid.next;
        <span class="hljs-comment">// 把链表拆分为两半</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid.next&nbsp;=&nbsp;<span class="hljs-keyword">null</span>;
        <span class="hljs-comment">// 返回两个链表的头部</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;ListNode[]{head,&nbsp;back};
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5924">
<p data-nodeid="5925">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.java" data-nodeid="6783">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.cpp" data-nodeid="6787">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.py" data-nodeid="6791">Python</a></p>
</blockquote>
<p data-nodeid="5926"><strong data-nodeid="6796">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)。</p>
<p data-nodeid="5927">【<strong data-nodeid="6806">小结</strong>】这道题的核心就是<strong data-nodeid="6807">如何通过双指针找到链表的中间结点</strong>。考点还是清晰明了，我们可以再将双指针的分析要点总结如下：</p>
<p data-nodeid="5928"><img src="https://s0.lgstatic.com/i/image6/M01/1A/5B/Cgp9HWBLPPiAZ1ICAACcFHDKHnU280.png" alt="Drawing 14.png" data-nodeid="6810"></p>
<p data-nodeid="5929">不过对于这道题，我想给你留几个<strong data-nodeid="6816">有趣的小问题</strong>，可以帮助你加深代码的理解，希望你可以尝试回答以下两个问题，并写在留言区，我们一起讨论。</p>
<ul data-nodeid="5930">
<li data-nodeid="5931">
<p data-nodeid="5932">为什么没有判断空链表，对于空链表的支持是怎么完成的？</p>
</li>
<li data-nodeid="5933">
<p data-nodeid="5934">为什么 s1, s2 要从 head 开始走，如果从 dummy 开始走可以吗？如果可以，会有什么样的代码改动？</p>
</li>
</ul>
<p data-nodeid="5935"><strong data-nodeid="6871">练习题 6：</strong> 将一个链表进行重排，如果我们用 L[x] 表示链表的第 x 个结点（从 0 开始）。将链表 L[0]-&gt;L[1]-&gt;L[2]-&gt;L[3]-&gt; .... -&gt;L[N-1] 重新排列为 L[0]-&gt;L[N-1]-&gt;L[1]-&gt;L[N-2]-&gt;L[2]-&gt;L[N-3].....。</p>
<p data-nodeid="5936">输入：1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p data-nodeid="5937">输出：1-&gt;5-&gt;2-&gt;4-&gt;3</p>
<blockquote data-nodeid="5938">
<p data-nodeid="5939">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.java" data-nodeid="6877">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6881">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/143.%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.py" data-nodeid="6885">Python</a></p>
</blockquote>
<h4 data-nodeid="5940">例 7：链表环问题</h4>
<p data-nodeid="5941">【<strong data-nodeid="6892">题目</strong>】给定一个链表，原本的链表尾巴如果不为空，并且指向了链表的中间结点，这样我们就认为这个链表存在一个环。给定一个链表，判断链表中是否存在环？</p>
<p data-nodeid="5942"><img src="https://s0.lgstatic.com/i/image6/M00/1D/11/Cgp9HWBPHjeAJc-1AACG-G5vmvk152.png" alt="image.png" data-nodeid="6895"></p>
<p data-nodeid="5943">【<strong data-nodeid="6901">分析</strong>】首先，如果链表中存在环，只用一个指针遍历肯定是永无止境的，这一个指针会在环里面打转。因此，我们可以再次利用双指针，s1，s2 两个指针都从链表头开始，s1 指针表示每次只往前走一步，s2 指针则是每次只往前走两步。那么链表最终只有两种情况：</p>
<p data-nodeid="5944"><strong data-nodeid="6906">1</strong>.s1 == s2，这个时候链表存在环；</p>
<p data-nodeid="5945"><img src="https://s0.lgstatic.com/i/image6/M01/1A/58/CioPOWBLPQ-ARKeiAABYprWvhEY284.png" alt="Drawing 16.png" data-nodeid="6909"></p>
<p data-nodeid="5946"><strong data-nodeid="6916">2</strong>.s1 != s2，这个时候链表不存在环。</p>
<p data-nodeid="5947"><img src="https://s0.lgstatic.com/i/image6/M01/1A/58/CioPOWBLPRyAebn8AABOBQ3Pto0204.png" alt="Drawing 17.png" data-nodeid="6919"></p>
<p data-nodeid="5948">不过我们还是需要处理<strong data-nodeid="6925">两种边界条件</strong>：</p>
<ol data-nodeid="5949">
<li data-nodeid="5950">
<p data-nodeid="5951">当为空链表的时候，s1 == s2，但是实际上此时链表无环；</p>
</li>
<li data-nodeid="5952">
<p data-nodeid="5953">当链表中只存在一个结点，并且无环的时候，运行的结果也会是 s1 == s2。</p>
</li>
</ol>
<p data-nodeid="5954">这两种边界条件的处理，只需要特殊判断一下即可。</p>
<p data-nodeid="5955">【<strong data-nodeid="6934">代码</strong>】有了前面了思路，那么我们就可以写出解问题的代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5956"><code data-language="java"><span class="hljs-keyword">public</span>&nbsp;<span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;<span class="hljs-keyword">boolean</span>&nbsp;<span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode&nbsp;head)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;空链表和只有一个结点的链表的实现。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(head&nbsp;==&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;head.next&nbsp;==&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">false</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;分别设置两个快慢指针，他们都从head出发。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;s1表示慢指针，一次只走一步</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;s2表示快指针，一次走两步</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s1&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s2&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;开始走动两个指针，</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;当相遇到的时候就停下来</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(s2&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;s2.next&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;s2.next.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;s1.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(s1&nbsp;==&nbsp;s2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">break</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;判断是否有环。如果有环，那么两个指针必定相遇。</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;s1&nbsp;==&nbsp;s2;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5957">
<p data-nodeid="5958">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.java" data-nodeid="6938">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.cpp" data-nodeid="6942">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.py" data-nodeid="6946">Python</a></p>
</blockquote>
<p data-nodeid="5959"><strong data-nodeid="6951">复杂度分析</strong>：时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p data-nodeid="5960">【<strong data-nodeid="6957">小结</strong>】至此，我们完成了快慢指针的学习，可以在知识图谱中加上链表环问题了，如下图所示：</p>
<p data-nodeid="5961"><img src="https://s0.lgstatic.com/i/image6/M01/1A/5B/Cgp9HWBLPS2AWdvLAACf7D3G1jI099.png" alt="Drawing 18.png" data-nodeid="6960"></p>
<p data-nodeid="5962">这里我还想给你留一个<strong data-nodeid="6966">小问题</strong>：在寻找链表环的过程中，对于两种特殊情况，我们实际上进行了特殊判断，那么有没有什么办法可以避免这种特殊的断呢？</p>
<p data-nodeid="5963">小提示：想想我们之前学习过的假头。</p>
<p data-nodeid="5964">老规矩，希望你尝试思考并把想法写在留言区，期待和你一起讨论。另外，我也会根据大家的留言反馈，不定时输出加餐内容，比如练习题详解、留言区问题点评等。</p>
<p data-nodeid="5965">【<strong data-nodeid="6974">扩展</strong>】在面试中，伴随着链表环问题的，往往还有后招：如果链表中存在环，能不能把形成环的那个结点找出来？</p>
<p data-nodeid="5966"><img src="https://s0.lgstatic.com/i/image6/M01/1A/58/CioPOWBLPTWAavliAAC_v6RSPzw758.png" alt="Drawing 19.png" data-nodeid="6977"></p>
<p data-nodeid="5967">我们可以把这个问题转化成一个数学问题。我们一起看一下下面这张图：</p>
<p data-nodeid="5968"><img src="https://s0.lgstatic.com/i/image6/M01/1A/58/CioPOWBLPTuAR6wcAACC03BCByU232.png" alt="Drawing 20.png" data-nodeid="6981"></p>
<p data-nodeid="5969">这里我们只考虑链表存在环的情况。假设 s1 慢指针与 s2 快指针在环中某个位置相遇。此时：</p>
<ul data-nodeid="5970">
<li data-nodeid="5971">
<p data-nodeid="5972">s1 指针走过的路径长度为 a = x + y</p>
</li>
<li data-nodeid="5973">
<p data-nodeid="5974">s2 指针走过的路径长度为 b = x + y + n * (y + z)</p>
</li>
</ul>
<p data-nodeid="5975">由于两个指针都是从同一个地点出发，s2 指针走得更快，那么走的长度肯定是 s1 指针的两倍。所以可以得到 b = 2a，即 b = x + y + n * (y + z) = 2x + 2y</p>
<p data-nodeid="5976">由此，可以推导出 x = n * (y + z) - y = (n-1)*(y+z) + z，即 x - z = (n-1) * (y + z)</p>
<p data-nodeid="5977">从 x-z 表达式可以看出，如果有两个指针同时从<strong data-nodeid="7008">头结点，相遇结点</strong>这两个地方出发，它们肯定会在环形入口相遇。因为它**们之间的差值刚好是圆环长度的整数倍（**更加严格一点的证明可以用数学归纳法）。</p>
<p data-nodeid="5978">经过数学证明，我们可以写出求解代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="5979"><code data-language="java"><span class="hljs-keyword">public</span>&nbsp;<span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">public</span>&nbsp;ListNode&nbsp;<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode&nbsp;head)</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;这里都是判断链表是否存在环</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(head&nbsp;==&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;head.next&nbsp;==&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s1&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ListNode&nbsp;s2&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(s2&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>&nbsp;&amp;&amp;&nbsp;s2.next&nbsp;!=&nbsp;<span class="hljs-keyword">null</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;s1.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;s2.next.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(s1&nbsp;==&nbsp;s2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">break</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;当不存在链表环的时候，直接返回null</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(s1&nbsp;!=&nbsp;s2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">null</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;s1指针重新指向链表head，从head出发</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;head;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;s2指针此时位于相遇的位置</span>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;然后两个指针一起走</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(s1&nbsp;!=&nbsp;s2)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s1&nbsp;=&nbsp;s1.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s2&nbsp;=&nbsp;s2.next;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//&nbsp;返回环形的入口结点</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;s1;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="5980">
<p data-nodeid="5981">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.java" data-nodeid="7013">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.cpp" data-nodeid="7017">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii.py" data-nodeid="7021">Python</a></p>
</blockquote>
<p data-nodeid="5982"><strong data-nodeid="7026">复杂度分析</strong>：时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<h3 data-nodeid="5983">总结与延伸</h3>
<p data-nodeid="5984">经过这两讲的学习，你终于可以用这三板斧来毒打链表题了，在抄家伙之前，我们一起回想下每招式的作用吧。</p>
<ul data-nodeid="5985">
<li data-nodeid="5986">
<p data-nodeid="5987"><strong data-nodeid="7033">第一斧：假头</strong>。假头的作用主要是避免关于空链表的判断与讨论，假头还可以用来避免检查前驱结点为空的情况。</p>
</li>
<li data-nodeid="5988">
<p data-nodeid="5989"><strong data-nodeid="7038">第二斧：新链表</strong>。新链表的引入是为了解决在旧链表中进行原地的交换、插入、删除，把复杂的操作变成在新链表中头部插入或者尾部添加。</p>
</li>
<li data-nodeid="5990">
<p data-nodeid="5991"><strong data-nodeid="7043">第三斧：双指针</strong>。双指针主要是用于寻找链表中的特定结点，双指针的走法可以一次一步，可以有快有慢，出发点也可以有前有后。</p>
</li>
</ul>
<p data-nodeid="22769" class="te-preview-highlight">了解了思路，你还需要深入理解操作的代码模板，然后就可以成功地进行解题实战了。这里我已经为你总结好了《<strong data-nodeid="22775">链表题通关路线图</strong>》，请参照此地图来通关链表题吧。</p>



<p data-nodeid="15652" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3E/39/CioPOWCYmIWAFXX4AASqbS526bc322.png" alt="图片1.png" data-nodeid="15658"></p>







<p data-nodeid="5994"><strong data-nodeid="7057">链表操作是很多其他复杂算法的基础，需要你熟练掌握，比如 LRU，跳表等数据结构里面都会用到链表。希望你课后能熟练地运行本讲介绍的思路</strong>。</p>
<p data-nodeid="5995">此外，从算法的难度上来说，实际上链表题并不算太难，但是非常考验基本功。我在处理链表题时，经常把文中介绍的题目作为模板深刻理解，达到熟练记忆的程度。我希望你在理解解题思路的基础上，也能够熟练记忆这些模板，逐渐建立一个系统的知识体系。</p>
<h3 data-nodeid="5996">思考题</h3>
<p data-nodeid="5997">最后，我再给你留一道<strong data-nodeid="7064">思考题。</strong></p>
<p data-nodeid="5998">链表排序：给定一个单向链表，如何给这个链表排序，要求复杂度达到 O(nlogn)。</p>
<ul data-nodeid="5999">
<li data-nodeid="6000">
<p data-nodeid="6001">你能使用所讲的创建新链表 + 快排的思想吗？</p>
</li>
<li data-nodeid="6002">
<p data-nodeid="6003">你能使用快慢指针 + 合并排序的思想来解决吗？</p>
</li>
</ul>
<blockquote data-nodeid="6004">
<p data-nodeid="6005">解法 1：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.java" data-nodeid="7071">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp" data-nodeid="7075">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.py" data-nodeid="7079">Python</a><br>
解法 2：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.java" data-nodeid="7084">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.cpp" data-nodeid="7088">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/08.Sort/148.%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.qsort.py" data-nodeid="7092">Python</a></p>
</blockquote>
<p data-nodeid="6006" class="">学会了链表的三板斧，处理链表问题，变得越来越容易了。不过我们可不能总是待在舒适区，还有很多算法与数结构等着我们去征服。下一讲将介绍 06 | 树：如何深度运用树的遍历？记得按时来探险。</p>

---

### 精选评论

##### *明：
> 德老师，总结的太到位了！回答一下合并k个有序链表的解题思路：（1）可以创建一个大小为 k 的 最小堆，先把所有链表的头部结点全部添加进去；（2）利用假头 dummy，初始化一个新链表，每次从最小堆中取出一个结点，即最小值，把它 append 到新链表的末尾；同时把该结点的下一个结点添加到 最小堆中（如果该结点的下一个结点不为空）。（3）返回 dummy. next。

##### **4943：
> 对于练习6的思考题：（1）由于增加了dummy节点作为假头，而s1和s2都是从head开始的，存在的两种特殊情况是head本身就是空节点和head.next为空节点，但是这两种情况都会由于pre的存在使得返回的mid就是pre,对应的分隔链表也就是正确的。（2）s1和s2从head开始就是为了不需要判断链表为空的情况；从dummy开始也是可以的，但是findMiddleNode方法里while的循环条件要改变，要改成s2.next != null s2.next.next != null,此时能同样解决（1）中提到的两种情况。如果分析的不对请老师指正

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 不错哦。(2)可能还需要想一下。

（1）做个参考：https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.2.java

（2）做个参考：https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.LinkedList/splitList.3.java

##### **伟：
> tail.next=xxxtail=xxx老师，我这两行代码任是没有绕过弯来，不知道啥意思？😂

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你玩老鹰抓小鸡游戏，你去抓住排在最后一只小鸡的尾巴(tail.next = p)。

然后，你就变成了队伍里面的最后一只小鸡。tail = p;

##### **0960：
> 链表中点的题目：如果使用dummy作为起始位置的话：奇数：最后front的节点是null，back走到了前半部分的最后一个，偶数：最后front的节点的next是null，back走到了前半部分的最后一个，所以没有必要区分

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 赞！

##### **8113：
> 老师，请问 例2 ，// 注意设置尾巴的next为空 尾部移到最新的节点，下一个节点应该也是为null的，为啥要这一步的操作呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 并不是所有的题目都能够保证最后的这个尾巴是空的。这里补刀是要保证所有的链表你的屁股都是擦干净的。养成好习惯。^_^

##### **健：
> 有个细节问题，在cpp的链表删除代码里，是否要对删去的节点进行内存回收呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 在面试的时候，一定要记得写上！在leetcode里面，如果是自己new的，那么删除的时候就自己delete。如果不是自己new的，那么就不要动它。

##### **亚：
> 不太懂为什么s1重新赋值然后和s2一块走😂

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 嗯。这里不要直接看代码，要先去看前面的那个数学上的证明。你可以想象成：你人在食堂。你室友在宿舍。你们约好一起去跑步（为什么要约室友去跑步，这个不重要！）。你们相约在操场入口碰头。假设你的路程更近（你们两个人移速一样！）先到了操场入口。然后你看你室友还没到。你就围着操场跑了起来。如果最后的跑的路程 - 室友走的路程 = 操场环形跑道的整数倍。   那么最后你和室友肯定是在操场入口相遇。而前面那一坨数学，就是在证明，这个路程就是圆环的整数倍。所以，你只需要保证移动速度一样就可以了。所以两个指针分别从各自的地方出发。然后再一步一步走。

s1指针就是你室友。s2指针就是你。你们移动速度一样。必然在操场入口碰头

##### **帆：
> 老师，关于新链表解题的空间复杂度是o(1)而不是o(n)是这样理解吗？我们虽然新建了一个链表，但链表中的每个节点只是原链表中对应节点的引用(并没有通过 new Node).

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 正解!

##### 周：
> 老师您好，扩展题里找链表开始入环的第一个节点那题，快指针s2走过的路径长度是不是应该是b = x + y + n * (y + z) 呢？这样才能推导出: x - z = (n - 1)*(y + z) 呢。另外，老师真的是总结很好，感觉以后链表题都有思路了而不是无从下手，谢谢老师的讲解！！

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 非常感谢你的指正。已更正

##### **一郎：
> 老师，这些题目都是从leetcode上面找的吧，下次能否把题目编号也给贴出来。

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 在每一道题的git repo里面的链接，有完整的代码，以及相应的测试平台或者leetcode 链接。

##### **7225：
> 双指针方法找链表倒数第k个数，相当于第一个指针遍历所有节点，第二个只是少遍历k个，总起来来说不是遍历一遍列表啊

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 遍历一遍与每个结点只访问一次是两个概念。并不是说每个结点只能访问一次！它的含义是指你只能从头到尾看一次。如果你先用while循环求出链表的长度，再一个while循环求倒数第k个。这样你遍历链表，你就遍历了两遍。

