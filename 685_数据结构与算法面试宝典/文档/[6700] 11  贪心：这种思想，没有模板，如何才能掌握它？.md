<p data-nodeid="95200" class="">贪心算法（Greedy Algorithms）指的是求解问题时，总是做出在当前看来是最好的选择。 一个全局最优解可以通过选择局部最优解来达到。</p>
<p data-nodeid="95201">贪心算法的运用非常广泛，比如哈夫曼（Huffman）树，单源最短路径（Dijkstra），构建最小生成树的 Prim 算法和 Kruskal 算法等。</p>
<p data-nodeid="95202">学完这一讲，你将会收获：</p>
<ul data-nodeid="95203">
<li data-nodeid="95204">
<p data-nodeid="95205">贪心算法类题目的特点</p>
</li>
<li data-nodeid="95206">
<p data-nodeid="95207">贪心算法的解题思路</p>
</li>
</ul>
<p data-nodeid="95208"><em data-nodeid="95531">注：贪心算法没有模板可以套，其重点在于对题目的分析，对结论的推导。因此，这一讲，我们不再延用“模拟、规律、匹配、画图”四步分析法，而是将重点放在介绍一些题目是如何演变而来的，以及如何推导出贪心所用的结论。我会尝试用尽量少的数学公式，且让你能看懂的方式来讲解。</em></p>
<h3 data-nodeid="95209">贪心的特点</h3>
<p data-nodeid="95210">面试中考察贪心算法的题目必然具备以下<strong data-nodeid="95543">2 个特点，<strong data-nodeid="95542">这里我用</strong>最通俗的话</strong>给你描述。</p>
<h4 data-nodeid="95211">特点 1：只选局部最优解</h4>
<p data-nodeid="95212">在求解过程中，我们可以通过<strong data-nodeid="95550">每一步都选择最优解</strong>，最终得到整个问题的最优解。下面我们通过一个简单的题目：寻找数组中最大的数，进一步说明一下这个特点。</p>
<pre class="lang-java" data-nodeid="95213"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">int</span> maxValue = Integer.MIN_VALUE; <span class="hljs-comment">// 初始集合里面的最大值</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    maxValue = Math.max(maxValue, A[i]);  <span class="hljs-comment">// 迭代当前最优解</span>
  }
  <span class="hljs-keyword">return</span> maxValue; <span class="hljs-comment">// 结束后，当前最优解变身全局最优解。</span>
}
</code></pre>
<p data-nodeid="95214"><strong data-nodeid="95557">首先：</strong> 在一个初始集（这里是一个空集），设置一个初始解。在这里，我们设置为 Integer.MIN_VALUE。</p>
<p data-nodeid="95215"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7DyAevBHAAB4d_r01V8988.png" alt="Drawing 0.png" data-nodeid="95560"></p>
<p data-nodeid="95216"><strong data-nodeid="95565">迭代</strong>：当有新元素进来的时候，我们需要迭代当前最优解。迭代后的最优解是已知数据的最优解。</p>
<p data-nodeid="95217"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7EOAYHjdAACrP3SVk1w191.png" alt="Drawing 1.png" data-nodeid="95568"></p>
<p data-nodeid="95218"><strong data-nodeid="95581">答案</strong>：当处理完所有的数据之后，<strong data-nodeid="95582">当前最优解</strong>立马<strong data-nodeid="95583">变身全局最优解</strong>。</p>
<p data-nodeid="95219"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7KuAMBTnAACDRzs75_E116.png" alt="Drawing 2.png" data-nodeid="95586"></p>
<p data-nodeid="95220"><em data-nodeid="95590">由此，我们也可以看出，贪心算法在操作的时候，总是把局部次优解直接扔掉，保留局部最优解，最终得到整个问题的最优解。</em></p>
<h4 data-nodeid="95221">特点 2：不能“逆袭”</h4>
<p data-nodeid="95222">下面我们用一道题目说明<strong data-nodeid="95597">什么是“逆袭”</strong>。给定如下图所示的图形，从上往下走的时候，只能走到相邻格子的左边或者右边。求从顶部走到底部的最大和。</p>
<p data-nodeid="95223"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7LSAaCRaAADJvxICzaI478.png" alt="Drawing 3.png" data-nodeid="95600"></p>
<p data-nodeid="95224">比如，这里我们给出合法与不合法的两种情况，如下图所示：</p>
<p data-nodeid="95225"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7LuAEeDiAAEUHK2pjOY488.png" alt="Drawing 4.png" data-nodeid="95604"></p>
<p data-nodeid="95226">如果使用贪心算法求解这个问题，你可以结合下图进行思考：</p>
<p data-nodeid="95227"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7MGALOGVAADo12H0WNA033.png" alt="Drawing 5.png" data-nodeid="95608"></p>
<p data-nodeid="95228">如果在每一步，我们总是选择当前能选择的最大值，那么得到的解就不是最优解。因为最优解是 2 + 3 + 100 = 105。</p>
<p data-nodeid="95229"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7MeAa4e_AAEETkRZECs168.png" alt="Drawing 6.png" data-nodeid="95612"></p>
<p data-nodeid="95230">那么问题出在哪里？这是因为在第二层有一个<strong data-nodeid="95618">次优解</strong> 2 + 3，在第三层能够从 3 跳到 100，最终变成整个问题的最优解。</p>
<p data-nodeid="95231"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7M6AWo3fAADom4u66Ss987.png" alt="Drawing 7.png" data-nodeid="95621"></p>
<p data-nodeid="95232">因此，在利用贪心算法的时候，必须要满足“<strong data-nodeid="95627">不能逆袭</strong>”的特性：</p>
<blockquote data-nodeid="95233">
<p data-nodeid="95234">局部次优解不能反超，不能成为问题的最终最优解！</p>
</blockquote>
<p data-nodeid="95235"><em data-nodeid="95632">注：这里我只是用一个例子来说明“不能逆袭”的特性，你能够意会到这种“次优解反超的特点”即可。</em></p>
<h4 data-nodeid="95236">记忆</h4>
<p data-nodeid="95237">在生活中，有一句有趣的歌诀形象地表现了贪心算法的特点：龙生龙，凤生凤，老鼠生儿会打洞。</p>
<p data-nodeid="95238">之前的最优解“龙”生成新的“龙”，依然处在食物链的高层，最后得出的仍然是最优解。而次优解“凤”和“老鼠”通过繁育是无法完成“逆袭”的，因此无法变成最优解。</p>
<p data-nodeid="95239">另外，贪心算法的题目比较依赖一些现有的结论。在日常学习算法和数据结构的过程中，你要特别注意总结经验和积累结论。下面我们一起通过几道例题深入学习贪心算法，然后我还会带你总结出一些有趣的结论。</p>
<h3 data-nodeid="95240">例 1：木桶装水</h3>
<p data-nodeid="95241">【<strong data-nodeid="95647">题目</strong>】给定一个数组，表示不同的木板的高度，在装水的时候，你可以选择<strong data-nodeid="95648">两根木板</strong>，然后装满水，在不能倾斜的情况下，里面能装多少水，应该由较短的木板决定。请问最多能装多少水？</p>
<p data-nodeid="95242"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7NeAbj76AAQd0dopTpA832.png" alt="Drawing 8.png" data-nodeid="95651"></p>
<p data-nodeid="95243">输入：A = [1, 0, 1, 1, 0]</p>
<p data-nodeid="95244">输出：3</p>
<p data-nodeid="95245">解释：你可以选择 index = 0 和 index = 3，由于高度都为 1，宽度为 3，装水为 3 x 1 = 3。这样组合装的水最多。</p>
<p data-nodeid="95246">【<strong data-nodeid="95663">分析</strong>】在正式求解这道题目之前，我们先从一些简单的题目进行展开。比如我们非常熟悉的：求一个数组中的最大值。相信你拿到这道题目就可以开始写代码了：</p>
<pre class="lang-java" data-nodeid="95247"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">int</span> ans = Integer.MIN_VALUE;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    ans = Math.max(ans, A[i]);
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<p data-nodeid="95248">如果我们仔细观察上述解法，可以发现贪心算法成立的关键在于：贪心的策略保证了在已知求解范围（绿色）区域里面始终是最大的。如下图所示：</p>
<p data-nodeid="95249"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8cmAJOBqAAC4ja2Veks049.png" alt="Drawing 9.png" data-nodeid="95667"></p>
<p data-nodeid="95250">在这个解法里面，我们采用的是从一侧推进来求最大值，如果我问你，是否有其他我们已经学过的办法可以解决这道题目呢？答案就是“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6699" data-nodeid="95673">10 | 双指针：如何掌握解决最长，定长，最短区间问题的决窍？</a>”介绍的<strong data-nodeid="95679">双指针</strong>。我们可以利用双指针从数组的两侧来推进，求解这个数组的最大值，代码可以写成如下这样：</p>
<pre class="lang-java" data-nodeid="95251"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A<span class="hljs-comment">/*输入保证非空*/</span>)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = N - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (i &lt; j) {
    <span class="hljs-keyword">if</span> (A[i] &gt; A[j]) {
      j--;
    } <span class="hljs-keyword">else</span> {
      i++;
    }
  }
  <span class="hljs-keyword">return</span> A[i];
}
</code></pre>
<p data-nodeid="95252">如果用比武打个比方，这种思路的依据就是每次取两个人来比武，胜者留下，那么留下来的当然是数组中的最大值。因此，可以得到<strong data-nodeid="95685">结论 1</strong>。</p>
<p data-nodeid="95253"><strong data-nodeid="95690">结论 1</strong>：</p>
<blockquote data-nodeid="95254">
<p data-nodeid="95255">max(A[i]，A[j]) 就是 [0...i] 和 [j ... N) 这两个区间里面的最大值。</p>
</blockquote>
<p data-nodeid="95256">前面我们都把注意力放在了较大的数。那么，有没有什么结论留给“较小的数”呢？</p>
<p data-nodeid="95257">实际上，对于较小的数，还有一个有用的结论。下面我们从头开始推导一下。</p>
<p data-nodeid="95258">首先，数组的最大值所在位置，最终肯定可以将数组切分成 3 个区域，分别用 3 种颜色来表示（如果数组中有多个同值的最大值，只需要挑一个出来当最大值即可）。但是具体如何切分，我们一开始并不清楚。</p>
<p data-nodeid="95259"><img src="https://s0.lgstatic.com/i/image6/M00/2D/CB/CioPOWBm8jCASGnfAACa3H_KBpM205.png" alt="Drawing 10.png" data-nodeid="95711"></p>
<p data-nodeid="95260">但是，如果利用 i，j 左右同时向中间走，最大值一定出现在 [i, j] 这个范围里面，所以 <strong data-nodeid="95722">[0, i) 区域肯定是绿色的，而 (j, N) 区域肯定是红色的</strong>。</p>
<p data-nodeid="95261"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8jeAPZokAACCr2BAJUs411.png" alt="Drawing 11.png" data-nodeid="95725"></p>
<p data-nodeid="95262">那么，如果 A[i] &gt; A[j]，留给较小的数 A[j] 的结论是什么呢？</p>
<p data-nodeid="95263">留下的便是<strong data-nodeid="95744">结论 2</strong>：</p>
<blockquote data-nodeid="95264">
<p data-nodeid="95265">异色区域，大于等于 A[j] 且离 j 最远的元素就是 A[i]。</p>
</blockquote>
<p data-nodeid="95266">我们用反证法简略证明一下：假设程序执行到 A[i] &gt; A[j] 成立，但是数组中有另外一个元素 0 &lt;= x &lt; i，并且 A[x] &gt; A[j] 成立。那么：</p>
<ul data-nodeid="95267">
<li data-nodeid="95268">
<p data-nodeid="95269">根据结论 1，[0, x] 区域，和 [j, N) 区域里面的最大值必然是 max(A[x], A[j])；</p>
</li>
<li data-nodeid="95270">
<p data-nodeid="95271">由于A[x] &gt; A[j]，所以 [0, x] 区域和 [j, N) 区域里面的最大值必然是 A[x]；</p>
</li>
<li data-nodeid="95272">
<p data-nodeid="95273">那么在执行算法的时候，当执行到 A[x] &gt; A[j] 时，会接着执行 j--，也就是说，程序不可能执行到 A[i] &gt; A[j] 位置，这与假设矛盾。</p>
</li>
</ul>
<p data-nodeid="95274">当然，结论 2 也可以针对 A[i] &lt; A[j] 写成：</p>
<blockquote data-nodeid="95275">
<p data-nodeid="95276">异色区域，大于等于 A[i] 且离 i 最远的元素就是 A[j]。</p>
</blockquote>
<p data-nodeid="95277">那么利用结论 2，我们能做什么呢？由于已经知道异色区域中更大的元素的位置。我们再回到原题，用木板装水的过程中，装水量是由最短的木板决定的。</p>
<p data-nodeid="95278">根据上述分析，我们是不是可以得出第三个结论：装水最多的时候，是否就是<strong data-nodeid="95854">异色且成对</strong>的 &lt;i, j&gt; 呢？我们假设该结论成立。</p>
<p data-nodeid="95279"><strong data-nodeid="95859">结论 3</strong>：</p>
<blockquote data-nodeid="95280">
<p data-nodeid="95281">装水最多的时候，必定由异色区域两根木板来装。</p>
</blockquote>
<p data-nodeid="95282">但是你可能很快会找到一个反例。如下图所示（注意，不同位置的竖线高度，分别表示相应位置元素的值的大小）：</p>
<p data-nodeid="97095" class=""><img src="https://s0.lgstatic.com/i/image6/M00/3B/15/Cgp9HWCCh6uAG6fTAACBJOzbUF4404.png" alt="2021423-163817.png" data-nodeid="97098"></p>

<p data-nodeid="95284">在 j 的同侧，还有一个 A[k] 比 A[j] 稍大且 A[k]，A[j] 离得很远。此时 A[i] 和 A[j] 装的水（1 号区域）肯定比 A[j] 和 A[k] 装的水（2 号区域）少。</p>
<p data-nodeid="95285">但是，既然已经出现这种情况，那么可以肯定的是，此时 A[i] &gt; A[j] 且 A[i] &gt; A[k]。并且 A[k] &gt; A[j]，实际上可以得到一个更大的装水区域。即由 A[i]，A[k] 形成的下图中 3 号区域：</p>
<p data-nodeid="100889" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh7OACEAIAAB4ET8YQCk104.png" alt="2021423-163823.png" data-nodeid="100892"></p>

<p data-nodeid="95287">同样也得出结论 3 是成立的。</p>
<p data-nodeid="95288">那么根据结论 3，我们就知道最优答案只能在异色区域里面选（可以想象成装水的水桶两根木板一定要不一样的颜色）。然后根据结论 2，我们又可以知道每个元素 A[x] 在异色区域里面离 x 最远且更大的是谁。那么这道题目就可以求解了。</p>
<p data-nodeid="95289">【<strong data-nodeid="95945">代码</strong>】根据结论 2 和结论 3 我们可以写出代码如下：</p>
<pre class="lang-java" data-nodeid="95290"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = N - <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span> (i &lt; j) {
    <span class="hljs-keyword">int</span> height = Math.min(A[i], A[j]);
    <span class="hljs-keyword">int</span> width = j - i;
    ans = Math.max(ans, height * width);
    <span class="hljs-keyword">if</span> (A[i] &gt; A[j]) {
      j--;
    } <span class="hljs-keyword">else</span> {
      i++;
    }
  }
  <span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="95291">
<p data-nodeid="95292">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="95949">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="95953">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="95957">Python</a></p>
</blockquote>
<p data-nodeid="95293"><strong data-nodeid="95962">复杂度分析</strong>：双指针左右同时遍历数组的元素，每个元素只访问一遍，因此，其复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p data-nodeid="95294">【<strong data-nodeid="95968">小结</strong>】本质上这道题就是从“求一个求数组的最大值”延伸和演变而来。只是我们通过双指针求解数组最大值的过程中，总结出了结论 1 和结论 2。然后再结合题意要求，得到结论 3，最后使这个问题得到解决。</p>
<p data-nodeid="95295">这道题目的考点我们进行一下归纳。</p>
<ul data-nodeid="95296">
<li data-nodeid="95297">
<p data-nodeid="95298">双指针：需要从左右两端向中间走（这和我们前面所讲的双指针略有不同）。</p>
</li>
<li data-nodeid="95299">
<p data-nodeid="95300">贪心算法：通过结论 1、结论 2、结论 3，每一步都选择最优解，最终得到整个问题的最优解。</p>
</li>
</ul>
<p data-nodeid="95301">为了帮助你巩固上述解题方法，这里我再给你留一道类似的题目。</p>
<p data-nodeid="95302"><strong data-nodeid="95984">练习题 1</strong>：给定一个数组 A[]，A[i] 表示柱子的高度，宽度为一个单位。如果我们不停往里面加水，直到所有柱子之间都加满为止。请问：给定一个图形，最多能接多少单位面积的水？</p>
<p data-nodeid="95303"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8nKAdTAFAAVvP6TxkfM792.png" alt="Drawing 14.png" data-nodeid="95987"></p>
<p data-nodeid="95304">输入：A = [0,1,0,2,1,0,1,3,2,1,2,1]</p>
<p data-nodeid="95305">输出：6</p>
<p data-nodeid="95306">解释：如图所示，最多只能接 6 个单位面积的水。蓝色部分是水，而黑色部分是柱子，数组中不同的值，由不同高度的柱子表示。</p>
<blockquote data-nodeid="95307">
<p data-nodeid="95308">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="95997">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96001">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96005">Python</a></p>
</blockquote>
<h3 data-nodeid="95309">例 2：不重叠区间</h3>
<p data-nodeid="95310">【<strong data-nodeid="96054">题目</strong>】给定一系列区间，请你选一个子集，使得这个子集里面区间都不相互重叠，并且这个子集里面元素个数最多。不重叠的定义：区间 [3,4] 和 [4,5] 就是不重叠。<br>
输入：A = [[1,2],[2, 3], [3,4], [1,3]<br>
输出：3<br>
解释：最多只能选出 3 个区间相互不重叠[1,2], [2,3], [3,4]。</p>
<p data-nodeid="95311">【<strong data-nodeid="96060">分析</strong>】这个问题，最后相互不重叠的区间应该是初始集合的一个子集。那么，当我们遇到一个区间的时候，应该取还是不取呢？</p>
<p data-nodeid="95312">下面我们从“单个区间：取和不取”来展开讲解。这里我们需要稍微进行一下推导。假设：</p>
<ol data-nodeid="95313">
<li data-nodeid="95314">
<p data-nodeid="95315">已经求解了下图中的绿色区域，并且得到了绿色区域的最优解 maxNum；</p>
</li>
<li data-nodeid="95316">
<p data-nodeid="95317">接下来我们要处理红色元素（也就是单个的区间）。</p>
</li>
</ol>
<p data-nodeid="95318">（注意：下文的 maxNum 和 newMaxNum 均表示区间里面的不重合区间的最大数目，其中 newMaxNum 表示区间<strong data-nodeid="96077">范围变长</strong>之后的<strong data-nodeid="96078">新的不重合区间</strong>的<strong data-nodeid="96079">最大数目</strong>）</p>
<p data-nodeid="95319"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8nuAQENIAACKoN1sPiQ926.png" alt="Drawing 15.png" data-nodeid="96082"></p>
<p data-nodeid="95320">那么当红色区间进来的时候，应该如何更新 maxNum 的值呢？新的 newMaxNum 的值又如何决定呢？</p>
<p data-nodeid="95321">这里可以分为两种情况。</p>
<p data-nodeid="95322">Case 1：newMaxNum <strong data-nodeid="96090">不包含</strong>新来的区间（红色部分），应该直接等于旧的 maxNum</p>
<p data-nodeid="95323">Case 2：newMaxNum<strong data-nodeid="96096">一定包含</strong>新来的区间（红色部分）</p>
<p data-nodeid="95324">如果进行迭代的话，就是：</p>
<blockquote data-nodeid="95325">
<p data-nodeid="95326">更新后的最优解 = max（不包含红色区间 =maxNum， 一定包含红色区间的最优解）</p>
</blockquote>
<p data-nodeid="95327">Case 1 的值是不需要求解的。那么接下来，我们只需要看 Case 2。</p>
<p data-nodeid="95328">这种情况又可以分为两种小情况。</p>
<p data-nodeid="95329">Case 2.1：新来的区间与旧的任何区间都没有交集，那么 newMaxNum = maxNum + 1。</p>
<p data-nodeid="95330">Case 2.2：新来的区间与旧的区间有交集。</p>
<p data-nodeid="95331">Case 2.1 的值已经计算出来了，我们再来看 Case 2.2。</p>
<p data-nodeid="95332">求解 Case 2.2，需要从区间的不重叠性出发。关于“区间不重叠”，有一个<strong data-nodeid="96109">性质</strong>：</p>
<blockquote data-nodeid="95333">
<p data-nodeid="95334">两个区间 [a, b] 和 [c,d] 不相交，只需要满足 b &lt;= c || d &lt;= a 就可以了。</p>
</blockquote>
<p data-nodeid="95335">现在，我们知道：区间的重叠只需要看两端的大小。可以将绿色区间部分<strong data-nodeid="96139">排序</strong>。<strong data-nodeid="96140">绿色区间集合</strong>将分为两部分：</p>
<ul data-nodeid="95336">
<li data-nodeid="95337">
<p data-nodeid="95338">集合 a. 与红色新进来的区间有交集（下图紫色部分）；</p>
</li>
<li data-nodeid="95339">
<p data-nodeid="95340">集合 b. 与红色新进来的区间没有交集（下图绿色部分）。</p>
</li>
</ul>
<p data-nodeid="95341">我们画图如下：</p>
<p data-nodeid="95342"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8oeACww_AACubbwdL_c165.png" alt="Drawing 16.png" data-nodeid="96146"></p>
<p data-nodeid="95343">假设已知集合 a 中不重叠的区间个数为 preMaxNum，那么我们就得到了 Case 2.2 的解：preMaxNum + 1。</p>
<p data-nodeid="95344">此外， preMaxNum 肯定小于 maxNum，所以此时 preMaxNum + 1 &lt;= maxNum。也就是说，Case 2.2 最优的时候，都没有 Case 1 好。所以对于整个问题：我们只需要考虑 Case 1 和 Case 2.1。</p>
<blockquote data-nodeid="95345">
<p data-nodeid="95346">Case 2.2 逆袭的最优情况也只是等同于 Case 1。次优解不能逆袭超车，正好使用贪心算法。</p>
</blockquote>
<p data-nodeid="95347">那么接下来，我们看 Case 1 与 Case 2.1，由此可以得到一个<strong data-nodeid="96157">结论 1</strong>：</p>
<blockquote data-nodeid="95348">
<p data-nodeid="95349"><strong data-nodeid="96161">如果新来的区间与前面的区间不重叠，那么不重叠区间数目就能增加一个。</strong></p>
</blockquote>
<p data-nodeid="95350">至此，我们知道通过排序，并且依赖性质 1 可以得出两个区间是否重叠。那么如何排序呢？区间有两个端点 [start, end]，是按照 start 排序还是按 end 排序呢？</p>
<p data-nodeid="95351">这里我们先用 end 来排序（很多博客上说不能用 start 排序，实际上是可以的，下面我们会具体分析）。</p>
<p data-nodeid="95352"><img src="https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8pGAPhp2AACThtOxY5g556.png" alt="Drawing 17.png" data-nodeid="96170"></p>
<p data-nodeid="95353">由于我们是按照每个区间的 [start, end] 来排序的，并且用了一个变量 maxEnd 记录已经处理的区间的最大 maxEnd。那么当新区间 [c, d] 进来的时候，只需要判断：</p>
<pre class="lang-java" data-nodeid="95354"><code data-language="java">newMaxNum = maxNum + (maxEnd &lt;= c ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
maxNum = newMaxNum;
</code></pre>
<p data-nodeid="95355">此外，还需要注意 maxEnd 的更新。在前面的图中，为了简化条件，我并没有清晰地指出 maxEnd 指代的含义。你需要注意 maxEnd 的含义：如果你选取的区间都是不重叠的，maxEnd 是你<strong data-nodeid="96189">选中的区间</strong>的最大 end，而<strong data-nodeid="96190">不是你查看过的区间</strong>的最大 end。</p>
<p data-nodeid="95356">因为，只有这样，我们才可以知道<strong data-nodeid="96196">要不要把新区间加入不重叠的集合</strong>里面。</p>
<p data-nodeid="95357">【<strong data-nodeid="96202">代码</strong>】原理已经讲清楚了，下面可以开始写代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="95358"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nonOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>{
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
<span class="hljs-comment">// 将区间进行排序</span>
Arrays.sort(A, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
<span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : (a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
}
});
<span class="hljs-comment">// 已重叠的区间的最右端点</span>
<span class="hljs-keyword">int</span> maxEnd = Integer.MIN_VALUE;
<span class="hljs-comment">// 不重叠 的区间的个数</span>
<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 开始贪心算法</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = A[i][<span class="hljs-number">0</span>];
<span class="hljs-keyword">if</span> (maxEnd &lt;= start) {
maxEnd = A[i][<span class="hljs-number">1</span>];
ans++;
}
}
<span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="95359">
<p data-nodeid="95360">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96206">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96210">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96214">Python</a></p>
</blockquote>
<p data-nodeid="95361"><strong data-nodeid="96219">复杂度分析</strong>：假设有 N个 区间，程序的核心分为排序与贪心。排序的时间复杂度为 O(NlgN)，而贪心的算法复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p data-nodeid="95362">【<strong data-nodeid="96225">小结</strong>】我们分析这道题目的时候，并不清楚是否要引入排序，而是一步步推导得出“需要使用排序来进行预处理”，然后再使用贪心算法。</p>
<p data-nodeid="95363">不过前文说到，排序的时候也可以使用区间 [start, end] 中的 start 排序。这里我就再给出根据 start 进行排序的代码。核心思路：<strong data-nodeid="96235">如果在区间排序的时候，根据 start 来排序，那么在处理的时候，需要逆序进行</strong>。</p>
<pre class="lang-java" data-nodeid="95364"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] A)</span> </span>{
<span class="hljs-comment">// 区间的总数</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
<span class="hljs-comment">// 将区间[start, end]根据start来排序</span>
Arrays.sort(A, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;() {
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span>[] b)</span> </span>{
<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? <span class="hljs-number">0</span> : (a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>] ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>);
}
});

<span class="hljs-keyword">int</span> preStart = Integer.MAX_VALUE;
<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 处理的时候，从后面开始处理</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = A[i][<span class="hljs-number">0</span>];
<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> end = A[i][<span class="hljs-number">1</span>];
<span class="hljs-keyword">if</span> (end &lt;= preStart) {
preStart = start;
ans++;
}
}
<span class="hljs-keyword">return</span> ans;
}
</code></pre>
<blockquote data-nodeid="95365">
<p data-nodeid="95366">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96239">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96243">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96247">Python</a></p>
</blockquote>
<p data-nodeid="95367">不重叠区间问题是很多问题的模板题。你掌握了这个模板就可以解决掉更多题目。下面请你尝试完成下面一批练习题。你一定要自己动手练习，不要偷懒哦！如果有你对哪里有疑问，也欢迎你写在留言区，我们一起讨论。</p>
<p data-nodeid="95368"><strong data-nodeid="96253">练习题 2</strong>：给定一系列区间，返回最少需要删除的区间数目，使得剩下的区间不重叠。</p>
<p data-nodeid="95369">输入：A = [[1,2], [2,3], [1,4]]</p>
<p data-nodeid="95370">输出：1</p>
<p data-nodeid="95371">解释：这里我们选择删除 [1, 4] 剩下的区间便不再重叠。这是最少的删除区间的数目。</p>
<blockquote data-nodeid="95372">
<p data-nodeid="95373">解法 1：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96277">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96281">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96285">Python</a><br>
解法 2：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96290">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96294">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96298">Python</a></p>
</blockquote>
<p data-nodeid="95374"><strong data-nodeid="96303">练习题 3</strong>：给定一个字符串，需要切分成尽可能多的切片，但是一个字母只能放在一个切片里面。</p>
<p data-nodeid="95375">输入：A = "abcabdefg"</p>
<p data-nodeid="95376">输出：5</p>
<p data-nodeid="95377">解释：最多可以分为 ["abcab" "d" "e" "f" "g"]。你不能切成 ["a", "b", "c", "a", "b", "d", "e", "f", "g"]，在这种情况下 'a' 字母并没有处于同一个切片。</p>
<blockquote data-nodeid="95378">
<p data-nodeid="95379">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96377">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96381">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96385">Python</a></p>
</blockquote>
<p data-nodeid="95380"><strong data-nodeid="96390">练习题 4</strong>：给定一系列区间，将重合的区间合并在一起。</p>
<p data-nodeid="95381">输入：A = [[1,2], [2,3], [2,6], [7, 8]]</p>
<p data-nodeid="95382">输出：[[1, 6], [7,8]]</p>
<blockquote data-nodeid="95383">
<p data-nodeid="95384">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96422">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96426">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96430">Python</a></p>
</blockquote>
<h3 data-nodeid="95385">例 3：青蛙跳</h3>
<p data-nodeid="95386">【<strong data-nodeid="96455">题目</strong>】给定一个数组 A[]，元素 A[i] &gt;= 0，一只青蛙站在 index = i，那它可以跳到 A[i+1], …, A[i+A[i]]（当然，它是不能跳出数组的）。那么请问这只青蛙从 index = 0 出发，能不能跳到 index = A.length - 1。</p>
<p data-nodeid="95387">输入：A = [2, 3, 1, 2, 1]</p>
<p data-nodeid="95388">输出：true</p>
<p data-nodeid="95389">解释：青蛙可以这样跳，A[0] → A[1] → A[4]</p>
<p data-nodeid="95390">【<strong data-nodeid="96488">分析</strong>】这个问题的重点在于，<strong data-nodeid="96489">站在 index = i，那它可以跳到 [i, ..., i + A[i]]</strong>。</p>
<p data-nodeid="95391">因此，它表示的信息就是两点：</p>
<ul data-nodeid="95392">
<li data-nodeid="95393">
<p data-nodeid="95394">起点 i</p>
</li>
<li data-nodeid="95395">
<p data-nodeid="95396">终点 i + A[i]</p>
</li>
</ul>
<p data-nodeid="95397">这货不就是一个区间吗？因此，数组里面的每一个元素，实际上都表示了一段区间 [i, i + A[i]]。并且，这些区间都已经按照区间的起始点排好序了。</p>
<p data-nodeid="95398">那么问题就演变成：给定一系列区间，这段区间是否可以<strong data-nodeid="96513">连续</strong>覆盖 [0, N-1] 这个范围。题目也就变成一个区间覆盖问题。</p>
<p data-nodeid="95399">当走到位置 i 的时候，相当于已经覆盖了范围 [0, i + A[i]]。那么接下来，由于我们需要实现的目标是：连续覆盖得越远越好。</p>
<p data-nodeid="95400">因此只需要选择这样的区间：</p>
<ul data-nodeid="95401">
<li data-nodeid="95402">
<p data-nodeid="95403">区间的起始位置 x 一定要在 [0, i + A[i]] 范围里面，也就是要<strong data-nodeid="96535">满足相连</strong>；</p>
</li>
<li data-nodeid="95404">
<p data-nodeid="95405">区间的终止位置 x + A[x] 一定要越远越好。</p>
</li>
</ul>
<p data-nodeid="95406">那么，我们可以写出暴力的算法<strong data-nodeid="96546">版本 1</strong>如下：</p>
<pre class="lang-java" data-nodeid="95407"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-comment">// 起始位置能拿到的区间是[0, 0 + A[0]]</span>
        <span class="hljs-keyword">int</span> coveredRange = A[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">int</span> used = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (coveredRange &lt; N - <span class="hljs-number">1</span> &amp;&amp; used &lt; N) {
            <span class="hljs-keyword">int</span> oldCoveredRange = coveredRange;
            <span class="hljs-comment">// 我们从0 ~ N - 1里面选一个区间</span>
            <span class="hljs-comment">// 注意，我们并不害怕重复选择同一个区间</span>
            <span class="hljs-comment">// 因为重复选择同一个区间，并不能让覆盖范围变长。</span>
            <span class="hljs-comment">// 不能变长的情况，我们就直接return false.</span>
            <span class="hljs-comment">//</span>
            <span class="hljs-comment">// （扫描循环:待优化）.....</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
                <span class="hljs-comment">// 1. 如果这个区间和我们已经覆盖的范围是相连的!</span>
                <span class="hljs-comment">// 满足相连性</span>
                <span class="hljs-keyword">if</span> (i &lt;= oldCoveredRange) {
                    <span class="hljs-comment">// 2. 如果这个区间能覆盖得更远</span>
                    <span class="hljs-keyword">if</span> (i + A[i] &gt; coveredRange) {
                        <span class="hljs-comment">// 更新我们能cover的范围</span>
                        coveredRange = i + A[i];
                    } 
                }
            }
            <span class="hljs-comment">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span>
            <span class="hljs-keyword">if</span> (oldCoveredRange == coveredRange) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            <span class="hljs-comment">// 否则，已经使用的区间数目++</span>
            used++;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>
<p data-nodeid="95408">暴力算法每次在完成区间更新的时候，都是搜索所有可能的解，因此其正确性是可以得到保证的。（在<a href="https://leetcode-cn.com/problems/jump-game/?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96550">测试平台</a>上也可以通过）。但是面试官要的肯定不是复杂度这么高的算法。因此，我们需要在此基础上继续优化。</p>
<p data-nodeid="95409"><strong data-nodeid="96562">【优化 1</strong>】由于连续性的要求，在扫描的时候，不需要遍历 [0, N) 的所有元素，只需要遍历 [0,oldCoveredRange] 这个范围里面的元素。那么扫描循环可以优化如下：</p>
<pre class="lang-java" data-nodeid="95410"><code data-language="java">            <span class="hljs-comment">// （扫描循环:待优化）.....</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= oldCoveredRange; i++) {
                <span class="hljs-comment">// 1. 这个区间和我们已经覆盖的范围是相连的!</span>
                <span class="hljs-comment">// 满足相连性</span>
                <span class="hljs-comment">// 2. 如果这个区间能覆盖得更远</span>
                <span class="hljs-keyword">if</span> (i + A[i] &gt; coveredRange) {
                    <span class="hljs-comment">// 更新我们能cover的范围</span>
                    coveredRange = i + A[i];
                } 
            }
</code></pre>
<p data-nodeid="95411"><strong data-nodeid="96567">【优化 2</strong>】我们发现：</p>
<ul data-nodeid="95412">
<li data-nodeid="95413">
<p data-nodeid="95414">如果有区间在覆盖范围 [0, A] 里面被扫描过了；</p>
</li>
<li data-nodeid="95415">
<p data-nodeid="95416">在下一轮覆盖范围 [0, B] 里面还会被扫描；</p>
</li>
<li data-nodeid="95417">
<p data-nodeid="95418">B &gt;= A。</p>
</li>
</ul>
<p data-nodeid="95419">而 [0, B] 实际上可以分为两段，[0, A] 和 [A+1, B]。既然 [0,A] 这一段已经扫描过了，那么为了避免重复扫描，接下来只需要扫描 [A+1, B] 即可。因此，每次扫描的时候，你都需要记住当前这次扫描的终点 A。</p>
<p data-nodeid="95420">【<strong data-nodeid="96605">代码</strong>】根据上述分析，我们就可以写出如下代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="95421"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-comment">// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过</span>
        <span class="hljs-comment">// 所以之记录之前扫描位置设置为-1</span>
        <span class="hljs-keyword">int</span> preScanedPos = -<span class="hljs-number">1</span>;
        <span class="hljs-comment">// 根据题意</span>
        <span class="hljs-comment">// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素</span>
        <span class="hljs-keyword">int</span> curCoveredRange = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 如果当前</span>
        <span class="hljs-keyword">while</span> (curCoveredRange &lt; N - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">int</span> oldCoveredRange = curCoveredRange;
            <span class="hljs-comment">// 根据优化1和优化2，我们只需要遍历</span>
            <span class="hljs-comment">// [preScanedPos + 1, oldCoveredRange]即可。</span>
            <span class="hljs-comment">// 然后不停更新curCoveredRange</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = preScanedPos + <span class="hljs-number">1</span>;
                i &lt;= oldCoveredRange; i++) {

                <span class="hljs-comment">// 1. 这个区间和我们已经覆盖的范围是相连的!</span>
                <span class="hljs-comment">// 满足相连性</span>
                <span class="hljs-comment">// 2. 如果这个区间能覆盖得更远</span>
                <span class="hljs-keyword">if</span> (i + A[i] &gt; curCoveredRange) {
                    <span class="hljs-comment">// 更新我们能cover的范围</span>
                    curCoveredRange = i + A[i];
                } 
            }
            <span class="hljs-comment">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span>
            <span class="hljs-keyword">if</span> (oldCoveredRange == curCoveredRange) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
            <span class="hljs-comment">// 我们记住上次已经扫描过的位置</span>
            preScanedPos = oldCoveredRange;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre>
<blockquote data-nodeid="95422">
<p data-nodeid="95423">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96609">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96613">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96617">Python</a></p>
</blockquote>
<p data-nodeid="95424"><strong data-nodeid="96622">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)。实际上，这里最多每个点遍历一次，所以时间复杂度为 O(N)。</p>
<p data-nodeid="95425">【<strong data-nodeid="96632">小结</strong>】在做完这个题之后，不妨和我们“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96630">第 02 讲</a>”学过的 FIFO 队列进行一个知识上的联动。</p>
<p data-nodeid="95426">记得我以前学习队列的时候，访问一个点时，会把后续的点都放到队列中，如下图所示：</p>
<p data-nodeid="95427"><img src="https://s0.lgstatic.com/i/image6/M00/2D/CD/CioPOWBm8tCAH_xHAADOxSUIRfw102.png" alt="Drawing 18.png" data-nodeid="96636"></p>
<p data-nodeid="95428">但是在这道题中，当访问 i 这个点的时候，后续能够走的点是 A[i+1] … A[i+A[i]]，但并没有把所有的点都入队，而是从里面选择了一个最优的点。</p>
<p data-nodeid="95429"><img src="https://s0.lgstatic.com/i/image6/M01/2D/C5/Cgp9HWBm8taAUbvHAADTudQRn6s636.png" alt="Drawing 19.png" data-nodeid="96651"></p>
<p data-nodeid="95430">如果把遍历的顺序也放到一个队列中，那么入队的时候，就只是把后面最优的点放到队列中。这个性质和优先级队列不太一样。优先级队列会把所有的元素都放到堆里面，然后堆内有序。但是对于贪心来说，只需要把最优秀的元素入队即可。</p>
<p data-nodeid="95431"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8t2ASM7CAADVY3j8Qig907.png" alt="Drawing 20.png" data-nodeid="96655"></p>
<p data-nodeid="95432">当然，由于每次都只选一个后续最优元素入队，因此这个 Queue 的长度最长是 1。这和我们之前学过的队列知识存在相似之处，但也有不同的地方。</p>
<p data-nodeid="95433">如果我们再从深度上挖掘一下这道题，还可以有得到下面这些练习题。</p>
<p data-nodeid="95434"><strong data-nodeid="96662">练习题 5</strong>：问题与例 3 一样，只不过这个题：需要输出最少跳跃的次数？如果不能跳到 A.length-1，请输出 -1。</p>
<p data-nodeid="95435">输入：A = [2, 3, 1, 2, 1]</p>
<p data-nodeid="95436">输出：2</p>
<p data-nodeid="95437">解释：A[0]→A[1]→A[4] 最少跳两次就可以到达最后一个下标。</p>
<blockquote data-nodeid="95438">
<p data-nodeid="95439">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96684">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96688">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96692">Python</a></p>
</blockquote>
<p data-nodeid="95440">接下来我们看一下：给定一系列区间，如果要完全覆盖 [start, end] 这个区间，应该如何处理呢？请看练习题 6。</p>
<p data-nodeid="95441"><strong data-nodeid="96710">练习题 6</strong>：一个大门安装了好几个摄像头，每个摄像头会录下一段时间的视频（假设起始时间与结束时间都是一个整数，可能为负数）。如果想找到 [0, T] 时间段的视频，请问最少需要提取几个摄像头的视频？如果不能得到 [0, T] 这个时间段的视频，输出 -1。</p>
<p data-nodeid="95442">输入：[[1,2], [0,2], [0,1], [2,3], [2,6], [3,8]], T = 5</p>
<p data-nodeid="95443">输出：2</p>
<p data-nodeid="95444">解释：只需要用 [0, 2]，[2,6] 就可以完全覆盖 [0, 5] 这个时间段。因此，最少需要看 2 个摄像头。</p>
<blockquote data-nodeid="95445">
<p data-nodeid="95446">代码：J<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96755">ava/</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96758">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96762">Python</a></p>
</blockquote>
<h3 data-nodeid="95447">例 4： 加油站</h3>
<p data-nodeid="95448">【<strong data-nodeid="96777">题目</strong>】巨大的环形赛道上有 N 个加油站，第 i 个加油站可以加油 G[i] 升，而从第 i 个加油站开到下一个加油站，需要 C[i] 升汽油。请你选择一个起始加油站，能够跑完环形赛道一圈。</p>
<p data-nodeid="95449">条件：1. 注意是环形赛道；2. 汽车油箱总是足够大。</p>
<p data-nodeid="95450">输入：G = [1,2], C=[2, 1]</p>
<p data-nodeid="95451">输出：1</p>
<p data-nodeid="95452">解释：从站点 0 出发，一开始只能收获 1 升油，而从 index = 0 跑到 index = 1 需要用掉 2 升汽油，所以不能从站点 0 出发。而从站点 1 出发，则可以绕着环形跑道跑一圈。</p>
<p data-nodeid="95453">【<strong data-nodeid="96796">分析</strong>】当拿到这个题的时候，我们首先考虑一种极端情况，那就是收入与付出不成正比。当 sum(G) &lt; sum(C) 的时候，应该是无论如何也不可能跑一圈的。</p>
<p data-nodeid="95454">那么接下来就<strong data-nodeid="96805">只需要考虑 sum(G) &gt;= sum(C) 的情况</strong>。在这种情况下，可以得到<strong data-nodeid="96806">结论 1：</strong></p>
<blockquote data-nodeid="95455">
<p data-nodeid="95456">当 sum(G) &gt;= sum(C) 时，必然存在某个点出发可以绕着赛道跑一圈的情况。</p>
</blockquote>
<p data-nodeid="95457">证明这个结论需要使用反证法。假设：当 sum(G) &gt;= sum(C)，<strong data-nodeid="96813">不存在</strong>某个点出发，可以绕着赛道跑一圈。若假设成立，那么必然可以将环形跑道切成几段，如下图所示：</p>
<p data-nodeid="95458"><img src="https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8uqAES68AAIfEBlAW9s655.png" alt="Drawing 21.png" data-nodeid="96816"></p>
<p data-nodeid="95459">并且每一段都是负数（因为不能绕着跑道跑一圈）。这时不同的段用不同的颜色表示。由于每一个小段和都是 sub_sum(G) &lt; sub_sum(C)，那么必然可以得到总和 sum(G) &lt; sum(C)。这与题目条件相矛盾。</p>
<p data-nodeid="95460"><em data-nodeid="96831">注：我们用 sub_sum() 函数表示求这一小段对应子数组的和。</em></p>
<p data-nodeid="95461">根据<strong data-nodeid="96837">结论 1</strong>，可以将 sum(G) &gt;= sum(C) 的情况再次分为两种。</p>
<ul data-nodeid="95462">
<li data-nodeid="95463">
<p data-nodeid="95464">Case 1：从站点 0 出发可以跑遍全场。</p>
</li>
<li data-nodeid="95465">
<p data-nodeid="95466">Case 2：从非 0 站点出发可以跑遍全场。</p>
</li>
</ul>
<p data-nodeid="95467">如果是Case 1，那么我们可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="95468"><code data-language="java"><span class="hljs-comment">// ans表示从哪里出发 </span>
<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 车里剩余的油量。</span>
<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 开始遍历每个站点</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
  total += G[i] - C[i];
  <span class="hljs-keyword">if</span> (left + G[i] - C[i] &gt;= <span class="hljs-number">0</span>) { <span class="hljs-comment">// 油量足够</span>
    left += G[i] - C[i]; <span class="hljs-comment">// 把油耗算上去</span>
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// &lt;-- 油量不够</span>
    <span class="hljs-comment">// 不能从站点0出发。! &lt;!待处理!&gt;</span>
  }
}

<span class="hljs-comment">// 可以从站点0出发，此时ans = 0</span>
<span class="hljs-keyword">return</span> ans;
</code></pre>
<p data-nodeid="95469">如果是Case 2，接下来我们再看一下<strong data-nodeid="96856">不能从站点 0 出发</strong>的情况。也就是存在某个点 i，使得汽油不够了。会有 left（余下的汽油） + G[i] - C[i] &lt; 0，那接下来应该从哪里开始呢？</p>
<ul data-nodeid="95470">
<li data-nodeid="95471">
<p data-nodeid="95472">首先，当 G[0] - C[0] &lt; 0 的时候，肯定是不能从 0 开始。</p>
</li>
<li data-nodeid="95473">
<p data-nodeid="95474">其次，当 G[0] - C[0] &gt;= 0 的时候，如果 [0, i] 的油量收益为负数。那么中间任意选一个点 x，且 0 &lt; x &lt;= i，那么 [x, i] 这个区间上的油量收益也必然为负（因为去掉了从 0 位置出发的正收益 G[0] - C[0]）。</p>
</li>
</ul>
<p data-nodeid="95475">这两种情况可以<strong data-nodeid="96902">统一处理</strong>如下：当出现油量不够的时候，下一个尝试的起点应该是 i + 1。</p>
<p data-nodeid="95476">此时我们可以统一用代码处理如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="95477"><code data-language="java"><span class="hljs-comment">// ans表示从哪里出发 </span>
<span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 车里剩余的油量。</span>
<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
<span class="hljs-comment">// 开始遍历每个站点</span>
<span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>; <span class="hljs-comment">// &lt;-- 结论1</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
  total += G[i] - C[i]; <span class="hljs-comment">// &lt;-- 结论1</span>
  <span class="hljs-keyword">if</span> (left + G[i] - C[i] &gt;= <span class="hljs-number">0</span>) { <span class="hljs-comment">// 油量足够</span>
    left += G[i] - C[i]; <span class="hljs-comment">// 把油耗算上去</span>
  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// &lt;-- 油量不够</span>
    <span class="hljs-comment">// 尝试新站点出发</span>
    ans = i + <span class="hljs-number">1</span>;
    left = <span class="hljs-number">0</span>;
  }
}

<span class="hljs-keyword">return</span> total &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : ans; <span class="hljs-comment">// &lt;-- 结论1</span>
</code></pre>
<p data-nodeid="95478">但是需要验证找到的 ans 站点出发，可以绕赛道一圈？答案是不需要的，下面我们证明一下这个结论。</p>
<p data-nodeid="95479">假设从 ans=start 站点出发，那么环形区域必然可以分为两半部分，[0, start) 和 [start, N)。由于不能从 index = 0 出发，那么 [0, start) 这个区域油量收益肯定是 sub_sum(G) &lt; sub_sum(C)，即油量收益肯定是负数。</p>
<p data-nodeid="95480"><img src="https://s0.lgstatic.com/i/image6/M00/2D/CE/CioPOWBm8xOAKZD3AAEboP-L1yM535.png" alt="Drawing 22.png" data-nodeid="96920"></p>
<p data-nodeid="95481">由于油的总量是 sum(G) &gt;= sum(C)，那么后半段油的收益 sub_sum(G) - sub_sum(C) &gt; 0 必然成立。并且，我们可以得到：后半段的收益肯定可以平衡掉前半段的负收益。因此，从 start 出发，就必然可以绕着赛道跑一圈。</p>
<p data-nodeid="95482">【<strong data-nodeid="96931">代码</strong>】到此时，我们已经可以写出代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="95483"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] G, <span class="hljs-keyword">int</span>[] C)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = G == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : G.length;
  <span class="hljs-comment">// 找一个子数组和最大的地方</span>
  <span class="hljs-comment">// 那么也是相当于找一个子数组和最小的地方</span>
  <span class="hljs-keyword">long</span> left = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> get = G[i];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cost = C[i];
    total += get - cost;
    <span class="hljs-comment">// 如果我还能开到下一站，好的，那么继续开</span>
    <span class="hljs-keyword">if</span> (left + get - cost &gt;= <span class="hljs-number">0</span>) {
      left += get - cost;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 如果从[ans ...i]这段区间里面的收益为负数</span>
      left = <span class="hljs-number">0</span>;
      ans = i + <span class="hljs-number">1</span>;
    }
  }
  <span class="hljs-keyword">return</span> total &gt;= <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;
}
</code></pre>
<blockquote data-nodeid="95484">
<p data-nodeid="95485">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96935">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96939">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96943">Python</a></p>
</blockquote>
<p data-nodeid="95486"><strong data-nodeid="96948">复杂度分析</strong>：时间复杂度为 O(N)，空间复杂度为 O(1)。</p>
<p data-nodeid="95487">【<strong data-nodeid="96954">小结</strong>】我们经过层层分析，得到最终求解的代码。最后还证明了不需要额外的代码去验证 ans 站点出发的有效性。在这个题中用到的结论 1 是我们分析问题的关键。</p>
<p data-nodeid="95488">不过这个题还有一个比较<strong data-nodeid="96960">有趣的解法</strong>，解题思路是这样的：</p>
<ul data-nodeid="95489">
<li data-nodeid="95490">
<p data-nodeid="95491">当总和小于 0 的时候，肯定没有解；</p>
</li>
<li data-nodeid="95492">
<p data-nodeid="95493">当总和大于等于 0 的时候，总是有解的，那么在选择起点的时候，可以选择一个子数组，这个子数组是数组里面的最大和，然后就以这里作为起点。（可以反证一下，如果从最大子数组和的起点出发都不能绕赛道一圈，那么其他的点就更没戏了）。</p>
</li>
</ul>
<p data-nodeid="95494">不过想要通关这种解法，需要你依次解决以下几道练习题哦。</p>
<p data-nodeid="95495"><strong data-nodeid="96968">练习题 7</strong>：给定一个数组，求这个子数组里面的最大子数组和。</p>
<p data-nodeid="95496">输入：A = [1,-5,3,4]</p>
<p data-nodeid="95497">输出：7</p>
<p data-nodeid="95498">解释：最大子数组和为 [3,4]，形成的和为 7，没有比 7 更大的子数组和了。</p>
<blockquote data-nodeid="95499">
<p data-nodeid="95500">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96982">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96986">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="96990">Python</a></p>
</blockquote>
<p data-nodeid="95501"><strong data-nodeid="96995">练习题 8</strong>：给定一个数组，这个数组首尾成环，求这个环形数组里面的最大子数组和。</p>
<p data-nodeid="95502">输入：A = [2, -2, -2, -2, 2]</p>
<p data-nodeid="95503">输出：4</p>
<p data-nodeid="95504">解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。</p>
<blockquote data-nodeid="95505">
<p data-nodeid="95506">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97009">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97013">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97017">Python</a></p>
</blockquote>
<p data-nodeid="95507"><strong data-nodeid="97026">练习题 9</strong>：同样是例题 4，你能使用我们前面提过的“<strong data-nodeid="97027">从最大子数组和的起点出发</strong>”这种思路进行求解吗？</p>
<blockquote data-nodeid="95508">
<p data-nodeid="95509">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97031">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97035">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97039">Python</a></p>
</blockquote>
<h3 data-nodeid="95510">总结与延伸</h3>
<p data-nodeid="95511">贪心算法是一种思路，没有模板和套路。不过经过今天的学习。可以发现，贪心算法的两个特点中，第一个特点<strong data-nodeid="97050">只选局部最优解</strong>是比较容易做到的。但是难点在于： <strong data-nodeid="97051">次优解不能逆袭</strong>。</p>
<p data-nodeid="95512">往往我们要花非常多的时间证明，才能够保证次优解可以扔掉。这里面还涉及了非常多的数学思维，需要你活学活用。</p>
<p data-nodeid="95513">作为面试官，我给你的建议是：刷贪心题目的时候，<strong data-nodeid="97062">一定要注意推导</strong>！如果你不会证明：“<strong data-nodeid="97063">为什么次优解可以扔掉？</strong>”，但知道如何进行操作，这说明你还没有真正掌握贪心这种思想。</p>
<h3 data-nodeid="95514"><strong data-nodeid="97067">思考题</strong></h3>
<p data-nodeid="95515">最后我再给你留一道思考题：既然可以用练习题 8 思路解决例 4 的问题，那么肯定也可以用例 4 的思路解决练习题 8，你能想一下代码应该怎么写吗？</p>
<p data-nodeid="95516">给定一个数组，这个数组首尾成环，求这个环形子数组里面的最大子数组和。</p>
<p data-nodeid="95517">输入：A = [2, -2, -2, -2, 2]</p>
<p data-nodeid="95518">输出：4</p>
<p data-nodeid="95519">解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。</p>
<blockquote data-nodeid="95520">
<p data-nodeid="95521">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97083">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97087">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="97091">Python</a></p>
</blockquote>
<p data-nodeid="95522" class="">希望你可以自己动一动手，也欢迎在留言区分享你的思路，我们一起讨论。接下来请和我一起踏上更加奇妙的算法旅程，下一讲将介绍 12 |回溯：我把回溯总结成一个公式，回溯题一出就用它。记得按时来探险。</p>

---

### 精选评论

##### **江：
> 问一下那个跑道的题，为什么反证法中说如果不存在一个点可以跑完的话，每一个线段都需要是负数

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 假设：当 sum(G) >= sum(C)，不存在某个点出发，可以绕着赛道跑一圈。若假设成立，那么必然可以将环形跑道切成几段，如下图所示：要注意这个假设。首先，如果不存在一个点可以跑完。那么假设我们从A出发，由于A不能跑完全场，那么必然会在某个点（设为B）累计和成了负数。如果我们再从B出发，同样，会也在某个点（设为C）累计和成为了负数。那么A-B这一段是负数，B-C这一段也是负数。以此类推，必然是每一个小段都会是负数。

##### **兵：
> 例2,如果输入是1,2],[2,3],[3,4这种情况，按照题目意思，输出应该是4({[1,2],[2,3]}、{[1,2],[3,4]},{[2,3],[3,4]}、{[1,2],[2,3],[3,4]})，但是代码跑出来的却是3。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 好像示例是有点模糊，我重新更新了一下题意

##### **兵：
> 老师，maxNum指的是什么？case1和case2的表述看不懂呀。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 我的锅。嗯。这个要注意看图。maxNum指的是绿色部分的“不重合的区间的最大的数目”。newMaxNumber是的是，当你在右边加入一个区间之后，也就是红色部分。那你会你得到一个新的newMaxNum：也就是新的不重合区间的目数。那么，这个新的newMaxNum，可以不包括这个新进来的红色的区间，也可能包含，所以需要分为case 1, case 2

