<p data-nodeid="339093" class="">在电影院，相信你也看到有人持有 VIP 卡，可以直接越过队列进场去看电影。对于这种情况，我们的程序也可以用<strong data-nodeid="339103">优先级队列</strong>（<strong data-nodeid="339104">Priority Queue</strong>）来模拟这个场景。</p>




<p data-nodeid="349606" class="te-preview-highlight">通常而言，<strong data-nodeid="349620">优先级队列都是基于堆</strong>（<strong data-nodeid="349621">Heap</strong>）<strong data-nodeid="349622">这种数据结构来实现的</strong>。因此，我们在正式开始学习优先级队列之前，还需要深入浅出地介绍一下堆及其相关的四种操作。</p>



<p data-nodeid="326938"><img src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB95iADDnqAACK2SKwkGM125.png" alt="Drawing 0.png" data-nodeid="327259"></p>
<h3 data-nodeid="326939">堆</h3>
<p data-nodeid="326940">FIFO 队列能够解决广度遍历、分层遍历类似的题目，FIFO 队列在遍历的时候，有一个有趣的特点：<strong data-nodeid="327266">每一层结点的先后顺序，遍历时就确定下来了</strong>。</p>
<p data-nodeid="326941">如果把这种先后顺序当成优先级，那么这些结点之间的优先级就由遍历时的顺序决定。但是有时候我们遇到的问题，结点之间需要按照<strong data-nodeid="327280">大小进行排序之后</strong>，<strong data-nodeid="327281">再决定优先级</strong>。在这种情况下，FIFO 队列不再适用，就需要用一种新的数据结构——<strong data-nodeid="327282">优先级队列</strong>。</p>
<p data-nodeid="326942"><strong data-nodeid="327287">优先级队列底层依赖的数据结构一般是堆，而堆是面试中经常遇到的考点之一</strong>。因此，在这里我会先介绍堆的实现与要点，再介绍优先级队列的特点以及具体如何运用。</p>
<h4 data-nodeid="326943">堆的分类：大堆与小堆</h4>
<p data-nodeid="326944">通常堆的结构都是表现为一棵树，如果<strong data-nodeid="327298">根比左右子结点都大</strong>，那么称为<strong data-nodeid="327299">大堆</strong>。如下图所示：</p>
<p data-nodeid="326945"><img src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB96aAYBPuAADIgr8zVTQ525.png" alt="Drawing 1.png" data-nodeid="327302"></p>
<p data-nodeid="326946">如果<strong data-nodeid="327314">根比左右子结点都要小</strong>，那么称为**小堆，**如下图所示：</p>
<p data-nodeid="326947"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB966AG3lGAADMrGaqmms247.png" alt="Drawing 2.png" data-nodeid="327317"></p>
<p data-nodeid="326948">通过堆的定义，可以发现<strong data-nodeid="327323">堆的特点：大堆的根是最大值，小堆的根是最小值</strong>。</p>
<p data-nodeid="326949">更有趣的是，每次有元素 push 或者 pop 的时候，调整堆的时间复杂度为 O(lgn)，速度也非常快。因此，<strong data-nodeid="327329">堆经常被用于优先级队列</strong>。接下来，我将以大堆为例，详细介绍堆的表示方式、添加元素、移除元素。</p>
<p data-nodeid="326950"><em data-nodeid="327333">注：后面的堆操作都是基于大堆。</em></p>
<h4 data-nodeid="326951">堆的表示</h4>
<p data-nodeid="326952">大部分时候都是<strong data-nodeid="327340">使用数组</strong>表示一个堆，而不是使用二叉树。这是因为:</p>
<ul data-nodeid="326953">
<li data-nodeid="326954">
<p data-nodeid="326955">数组的内存具有连续性，访问速度更快；</p>
</li>
<li data-nodeid="326956">
<p data-nodeid="326957">堆结构是一棵<strong data-nodeid="327347">完全二叉树</strong>。</p>
</li>
</ul>
<p data-nodeid="326958">如下图所示，堆的规律有如下几点：</p>
<ul data-nodeid="326959">
<li data-nodeid="326960">
<p data-nodeid="326961">i 结点的父结点 par = (i-1)/2</p>
</li>
<li data-nodeid="326962">
<p data-nodeid="326963">i 结点的左子结点 2 * i + 1</p>
</li>
<li data-nodeid="326964">
<p data-nodeid="326965">i 结点的右子结点 2 * i + 2</p>
</li>
</ul>
<p data-nodeid="326966"><img src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB97mANuA0AAEuXuRD7OM444.png" alt="Drawing 3.png" data-nodeid="327358"></p>
<p data-nodeid="326967"><em data-nodeid="327362">注意：这里的下标是从 0 开始的。</em></p>
<p data-nodeid="326968">接下来，我们将通过具体的题目将堆的操作代码<strong data-nodeid="327368">模板化</strong>。</p>
<h4 data-nodeid="326969">堆的操作</h4>
<p data-nodeid="326970">堆的操作实际上只有两种：<strong data-nodeid="327375">下沉和上浮</strong>，如下图所示：</p>
<p data-nodeid="326971"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB98KAGCi1AACNPdvPhX0284.png" alt="Drawing 4.png" data-nodeid="327378"></p>
<p data-nodeid="326972">通过下沉和上浮，又可以分别得到 pop 和 push 操作，接下来我们一起讨论这四种操作的特点。</p>
<p data-nodeid="326973">假设我们已经申请了数组 a[] 和元素 n 表示当前堆中元素的个数，代码如下：</p>
<pre class="lang-java" data-nodeid="326974"><code data-language="java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 表示堆的数组空间, 100作示例大小</span>
<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">// 堆中元素个数</span>
</code></pre>
<p data-nodeid="326975"><em data-nodeid="327387">注：这个数组的大小仅作为示例讲解，你可以根据实际情况调整，我们的重点是把算法讲清楚。</em></p>
<p data-nodeid="326976"><strong data-nodeid="327393">1. 下沉</strong></p>
<p data-nodeid="326977">引起下沉操作的原因：假设 a[i] 比它的子结点要小，那么除 a[i] 以外，其他子树都满足堆的性质。这个时候，就可以通过下沉操作，帮助 a[i] 找到正确的位置。</p>
<p data-nodeid="326978"><em data-nodeid="327410">注意，上述操作的是大堆。</em></p>
<p data-nodeid="326979">为了方便你理解，我制作了下沉过程的动图演示，如下图所示：</p>
<p data-nodeid="326980"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB99OAQTpJAAGapaZWoyM328.gif" alt="1.gif" data-nodeid="327414"></p>
<blockquote data-nodeid="326981">
<p data-nodeid="326982">Step 1. 结点 3 需要下沉。<br>
Step 2. 将要下沉的值存入变量 t 中，腾出空位。<br>
Step 3. 在子结点 8 和 9 中选中较大的结点 9。<br>
Step 4. 9 比 3 大，9 需要上移，腾出空位。<br>
Step 5. 上移之后，再查看子结点 4 与 7，选中较大结点 7。<br>
Step 6. 由于 7 比 3 大，7 需要上移，腾出空位。<br>
Step 7. 将 3 填入最终空出来的空位中。</p>
</blockquote>
<p data-nodeid="326983">首先，写下沉代码时，需要记住一个<strong data-nodeid="327437">贪心原则</strong>：如果子结点大，那么子结点就要上移。实际上，如果我们将移动路径<strong data-nodeid="327438">一维化</strong>，那么这段下沉代码就会变成如下图所示的样子：</p>
<p data-nodeid="326984"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB996AJuAmAACoyw2YoTY998.gif" alt="2.gif" data-nodeid="327441"></p>
<blockquote data-nodeid="326985">
<p data-nodeid="326986">Step 1. 最大堆，结点 3 需要下沉。<br>
Step 2. 用临时变量 t 保存值 3。<br>
Step 3.子结点 9 比 t = 3 大，向前移动。<br>
Step 4.接着子结点 7 比 t = 3 大，向前移动。<br>
Step 5.最终给 3 找取最终的位置。</p>
</blockquote>
<p data-nodeid="326987">可以发现，下沉与经典的<strong data-nodeid="327456">插入排序（递减）非常相似</strong>。只有一点略有不同：插入排序是一维的，只与后继的元素进行比较，而下沉是二维的，需要在两个后继元素中找到最大值与插入值进行比较。</p>
<p data-nodeid="326988">根据这个原则，可以写出<strong data-nodeid="327462">下沉</strong>的代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="326989"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
&nbsp; <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
&nbsp; <span class="hljs-keyword">int</span> t = a[i];
&nbsp; <span class="hljs-comment">// 找到i结点的左子结点</span>
&nbsp; <span class="hljs-keyword">while</span> ((j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) &lt; n) {
    <span class="hljs-comment">// 比插入排序多出来的一步：需要在两个后继中找个最大的出来</span>
&nbsp; &nbsp; <span class="hljs-comment">// j &lt; n - 1判断是否有右子结点</span>
&nbsp; &nbsp; <span class="hljs-comment">// 如果有，并且右子结点更大，那么</span>
&nbsp; &nbsp; <span class="hljs-comment">// j指向右子结点</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; a[j] &lt; a[j + <span class="hljs-number">1</span>]) {
&nbsp; &nbsp; &nbsp; j++;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 如果子结点比t大</span>
&nbsp; &nbsp; <span class="hljs-comment">// 那么t的位置还需要往后排</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (a[j] &gt; t) {
&nbsp; &nbsp; &nbsp; a[i] = a[j];
&nbsp; &nbsp; &nbsp; i = j;
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 找到了t的位置</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时t是大于所有的子结点的</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; }
&nbsp; }
&nbsp; <span class="hljs-comment">// 将t放在找到的位置那里</span>
&nbsp; a[i] = t;
}
</code></pre>
<p data-nodeid="326990"><strong data-nodeid="327467">复杂度分析</strong>：由于堆是一个完全二叉树，所以在下沉的时候，下沉路径就是树的高度。如果堆中有 N 个元素的话，所以时间复杂度为 O(lgN)。</p>
<p data-nodeid="326991"><strong data-nodeid="327473">2. 上浮</strong></p>
<p data-nodeid="326992">上浮操作的条件：假设 a[i] 比它的父结点要大，并且除 a[i] 以外，其他子树都满足大堆的性质。</p>
<p data-nodeid="326993"><em data-nodeid="327486">注意，上述操作的是大堆。</em></p>
<p data-nodeid="326994">为了方便你理解，我同样制作了上浮过程的动图演示，如下图所示：</p>
<p data-nodeid="326995"><img src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB9-6AO_sXAAF4Rim8-h4328.gif" alt="3.gif" data-nodeid="327490"></p>
<blockquote data-nodeid="326996">
<p data-nodeid="326997">Step 1.结点 10 太大，需要上浮。<br>
Step 2.将要上浮的 10 放到临时变量 t 中，腾出空位。<br>
Step 3.找到空位的父结点 8。<br>
Step 4.由于 8 比 t = 10 小，所以 8 往下移，腾出空位。<br>
Step 5.选中空位的父结点 9。<br>
Step 6.由于 9 仍然比 10 小，腾出空位。<br>
Step 7.再也不能找到父结点了，将 10 放到空位中。</p>
</blockquote>
<p data-nodeid="326998">同样，在<strong data-nodeid="327521">上浮</strong>的时候，可以发现<strong data-nodeid="327522">一个原则</strong>：如果父结点比“我”<strong data-nodeid="327523">小</strong>，那么父结点就需要下移。我们将移动路径<strong data-nodeid="327524">一维化</strong>，这段插入代码就会变成如下图所示的样子：</p>
<p data-nodeid="326999"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB9_yAMrYIAACvs1tCxn0334.gif" alt="4.gif" data-nodeid="327527"></p>
<blockquote data-nodeid="327000">
<p data-nodeid="327001">Step 1.最大堆，结点 10 需要上浮。<br>
Step 2.将需要上浮的 10 放到临时变量 t 中，腾出空位。<br>
Step 3.8 比 t 小，移动 8，腾出空位。<br>
Step 4.9 比 t 小，移动 9，腾出空位。<br>
Step 5.不能再移动了，将 t 放到空位中。</p>
</blockquote>
<p data-nodeid="327002">可以发现，上浮与经典的<strong data-nodeid="327546">插入排序（递减的）非常相似</strong>。到这里，结点 a[i] 上浮的代码也比较容易搞定了。</p>
<pre class="lang-java" data-nodeid="327003"><code data-language="java"><span class="hljs-comment">// 上浮</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
&nbsp; <span class="hljs-keyword">int</span> t = a[i];
&nbsp; <span class="hljs-keyword">int</span> par = <span class="hljs-number">0</span>;
&nbsp; <span class="hljs-comment">// 如果还存在父结点</span>
  <span class="hljs-comment">// 由于我们的下标是从0开始</span>
  <span class="hljs-comment">// 0结点没有父结点</span>
&nbsp; <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {
    par = (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 如果父结点比t值小</span>
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (a[par] &lt; t) {
      <span class="hljs-comment">// 那么向下移动父结点的值。</span>
&nbsp; &nbsp; &nbsp; a[i] = a[par];
&nbsp; &nbsp; &nbsp; i = par;
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">break</span>;
&nbsp; &nbsp; }
&nbsp; }
&nbsp; a[i] = t;
}
</code></pre>
<p data-nodeid="327004"><strong data-nodeid="327551">复杂度分析</strong>：由于堆是一个完全二叉树，所以在上浮的时候，上浮路径就是树的高度。如果堆中有 N 个元素的话，所以时间复杂度为 O(lgN)。</p>
<p data-nodeid="327005"><strong data-nodeid="327558">3. push 操作</strong>需要两步来完成：</p>
<p data-nodeid="327006">（1）往堆的尾巴 a[n] 上添加新来的元素</p>
<p data-nodeid="327007">（2）新来元素 a[n] 进行<strong data-nodeid="327573">上浮</strong>的操作</p>
<p data-nodeid="327008">至此，我们可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="327009"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{
&nbsp; <span class="hljs-comment">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>
&nbsp; a[n++] = v;
&nbsp; swim(n - <span class="hljs-number">1</span>);
}
</code></pre>
<p data-nodeid="327010"><strong data-nodeid="327579">复杂度分析</strong>：主要是上浮操作，所以时间复杂度为 O(lgN)。</p>
<p data-nodeid="327011"><strong data-nodeid="327586">4. pop 操作</strong>需要以下 3 步：</p>
<p data-nodeid="327012">（1）取出 a[0] 的值作为返回值</p>
<p data-nodeid="327013">（2）然后将 a[n-1] 存放至 a[0]</p>
<p data-nodeid="327014">（3）将 a[0] 进行<strong data-nodeid="327609">下沉</strong>操作</p>
<p data-nodeid="327015">有了 sink() 函数，操作还是比较简单的，我们可以直接写出代码如下：</p>
<pre class="lang-java" data-nodeid="327016"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
&nbsp; <span class="hljs-keyword">int</span> ret = a[<span class="hljs-number">0</span>];
&nbsp; a[<span class="hljs-number">0</span>] = a[--n];
&nbsp; sink(<span class="hljs-number">0</span>);
&nbsp; <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p data-nodeid="327017"><strong data-nodeid="327615">复杂度分析</strong>：主要是下沉操作，所以时间复杂度为 O(lgN)。</p>
<p data-nodeid="327018">堆的操作都梳理完成之后，这里我们给出完整的代码。虽然是一块比较基础的代码，但是我曾经在<strong data-nodeid="327621">商汤</strong>的面试中就遇到过这么“裸”的面试题：“实现堆的 push 和 pop”。</p>
<pre class="lang-java" data-nodeid="327019"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heap</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 下沉</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> t = a[i];
        <span class="hljs-comment">// 找到i结点的左子结点</span>
        <span class="hljs-keyword">while</span> ((j = (i &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) &lt; n) {
            <span class="hljs-comment">// j &lt; n - 1判断是否有右子结点</span>
            <span class="hljs-comment">// 如果有，并且右子结点更大，那么</span>
            <span class="hljs-comment">// j指向右子结点</span>
            <span class="hljs-keyword">if</span> (j &lt; n - <span class="hljs-number">1</span> &amp;&amp; a[j] &lt; a[j + <span class="hljs-number">1</span>]) {
                j++;
            }
            <span class="hljs-comment">// 如果子结点比t大</span>
            <span class="hljs-comment">// 那么t的位置还需要往后排</span>
            <span class="hljs-keyword">if</span> (a[j] &gt; t) {
                a[i] = a[j];
                i = j;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 找到了t的位置</span>
                <span class="hljs-comment">// 此时t是大于所有的子结点的</span>
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-comment">// 将t放在找到的位置那里</span>
        a[i] = t;
    }
    <span class="hljs-comment">// 上浮</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
        <span class="hljs-keyword">int</span> t = a[i];
        <span class="hljs-keyword">int</span> par = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 如果还存在父结点</span>
        <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (par = (i - <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) != i) {
            <span class="hljs-comment">// 如果父结点比t值小</span>
            <span class="hljs-keyword">if</span> (a[par] &lt; t) {
                a[i] = a[par];
                i = par;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">break</span>;
            }
        }
        a[i] = t;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{
        <span class="hljs-comment">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span>
        a[n++] = v;
        swim(n - <span class="hljs-number">1</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">int</span> ret = a[<span class="hljs-number">0</span>];
        a[<span class="hljs-number">0</span>] = a[--n];
        sink(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> ret;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> n;
    }
}
</code></pre>
<p data-nodeid="327020">讲完了堆的四种操作，我们再来看一下如何把知识运用到题目求解和实际工作中。</p>
<h4 data-nodeid="327021">例 1：最小的 k 个数</h4>
<p data-nodeid="327022">【<strong data-nodeid="327632">题目</strong>】给定一个数组 a[]，返回这个数组中最小的 k 个数。</p>
<p data-nodeid="327023">输入：A = [3,2,1], k = 2</p>
<p data-nodeid="327024">输出：[2, 1]</p>
<p data-nodeid="327025">【<strong data-nodeid="327651">分析</strong>】这是一道来自<strong data-nodeid="327652">阿里</strong>的题目。首先来看，如果是先排序，然后再返回前面的 k 个数。这样操作的复杂度是 O(nlgn)，但面试官可能想要得到复杂度更低的一些算法。</p>
<p data-nodeid="327026">现在问题的特点是，只需要 k 个最小的数就可以了。假设我们已经拿到了前面 [0 ~ i] 个数中最小的 k 个数。那么当第 a[i+1] 进来的时候，应该怎么办呢？</p>
<p data-nodeid="327027">接下来我们按照“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690" data-nodeid="327667">第 01</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690" data-nodeid="327670">讲</a>”介绍的“<strong data-nodeid="327676">四步分析法”</strong> 寻找解题突破口。</p>
<p data-nodeid="327028"><strong data-nodeid="327682">1. 模拟</strong></p>
<p data-nodeid="327029">可以采用“挤出去的办法”：</p>
<ul data-nodeid="327030">
<li data-nodeid="327031">
<p data-nodeid="327032">先把 a[i+1] 加入集合中，此时集合中已经有 k+1 个数了；</p>
</li>
<li data-nodeid="327033">
<p data-nodeid="327034">再把集合 k+1 个数中的<strong data-nodeid="327694">最大的数</strong>扔出去。</p>
</li>
</ul>
<p data-nodeid="327035">此时，存留下来的 k 个数，就是 [0 ~ i + 1] 里面最小的 k 个数了，具体演示如下图所示：</p>
<p data-nodeid="327036"><img src="https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB-CCAHNSQAAiT0tDfClw811.gif" alt="5.gif" data-nodeid="327704"></p>
<blockquote data-nodeid="327037">
<p data-nodeid="327038">Step 1.当 i 指向 8 时，如果我们已经得到了最小的 k = 2 个数的集合。<br>
Step 2.i+1 指向 1 时，需要把 1 加到最小集合中。<br>
Step 3.扔掉最大的元素 3，得到 [0~i+1] 范围里面的最小的 k 个数。</p>
</blockquote>
<p data-nodeid="327039"><strong data-nodeid="327721">2. 规律</strong></p>
<p data-nodeid="327040">由上述分析可以找出以下两个规律：</p>
<p data-nodeid="327041">（1）我们要的是一个集合，这个集合并<strong data-nodeid="327728">不需要有序</strong>，但需要支持 push 功能；</p>
<p data-nodeid="327042">（2）pop 的时候，总是把<strong data-nodeid="327734">最大的元素</strong>扔出去。</p>
<p data-nodeid="327043"><strong data-nodeid="327740">3. 匹配</strong></p>
<p data-nodeid="327044">基于我们发现的两个规律，可以得出，这个时候应该使用<strong data-nodeid="327746">大堆</strong>。因为堆满足：</p>
<p data-nodeid="327045">（1）内部并不是有序的，支持 push 功能；</p>
<p data-nodeid="327046">（2）pop 时，扔掉<strong data-nodeid="327753">堆里最大元素</strong>就可以了。</p>
<p data-nodeid="327047"><strong data-nodeid="327759">4. 边界</strong></p>
<p data-nodeid="327048">数据结构选定后，在面试时，你还需要思考一下问题的边界。给定数组和 k 的情况，应该有以下 7 种：</p>
<p data-nodeid="327049">（1）数组为 null</p>
<p data-nodeid="327050">（2）数组中元素个数小于 k</p>
<p data-nodeid="327051">（3）数组中元素个数等于 k</p>
<p data-nodeid="327052">（4）数组中元素个数大于 k</p>
<p data-nodeid="327053">（5）k &lt; 0</p>
<p data-nodeid="327054">（6）k == 0</p>
<p data-nodeid="327055">（7）k &gt; 0</p>
<p data-nodeid="327056">【<strong data-nodeid="327775">画图</strong>】分析到这里。我们可以利用大堆完成一次模拟了，动图演示如下：</p>
<p data-nodeid="327057">输入：[9, 3, 2, 8, 1, 7, 5, 6, 4], k = 4</p>
<p data-nodeid="327058">输出：[1,2,3,4]</p>
<p data-nodeid="327059"><img src="https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB-DmADf7pACpCmKnHs-c177.gif" alt="6.gif" data-nodeid="327787"></p>
<blockquote data-nodeid="327060">
<p data-nodeid="327061">Step 1.push(9)。<br>
Step 2.push(3)。<br>
Step 3.push(2)。<br>
Step 4.push(8)。<br>
Step 5.push(1)，堆中元素个数 &gt; k，需要执行 pop。<br>
Step 6.pop() 结束。<br>
Step 7.push(7)，堆中元素个数 &gt; k，需要执行 pop。<br>
Step 8.pop 操作结束。<br>
Step 9.push(5)，堆中元素个数 &gt; k，需要执行 pop。<br>
Step 10.pop 操作结束。<br>
Step 11.push(6)，堆中元素个数 &gt; k，需要执行 pop。<br>
Step 12.pop 结束。<br>
Step 13.push(4)，堆中元素个数 &gt; k，需要执行 pop。<br>
Step 14.pop 结束，最终得到最小的 k 个数 [1, 2, 3, 4]。</p>
</blockquote>
<p data-nodeid="327062">【<strong data-nodeid="327824">代码</strong>】接下来，就可以开始写代码了，也是时候亮出你真正的实力了。代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="327063"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">null</span>;
&nbsp; <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;
&nbsp; <span class="hljs-comment">// .. 这里省略了堆的四种操作的代码: 参考前面的实现</span>
&nbsp; <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{
&nbsp; &nbsp; <span class="hljs-comment">// 返回堆中元素的个数</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> n;
&nbsp; }
&nbsp; <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getLeastNumbers(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> k) {
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span> || arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) {
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 初始化堆, 注意大小要为k + 1</span>
&nbsp; &nbsp; a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k + <span class="hljs-number">1</span>];
&nbsp; &nbsp; n = <span class="hljs-number">0</span>;
&nbsp; &nbsp; <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : arr) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 首先将元素压入堆中</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果堆中已经有k个元素</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时压入，会有k+1个元素，</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 所以初始化时，申请数组大小需要为k+1</span>
&nbsp; &nbsp; &nbsp; push(x);
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果堆中元素多于k个，那么扔掉最大的元素</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (size() &gt; k) {
&nbsp; &nbsp; &nbsp; &nbsp; pop();
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 返回最小的k个数</span>
&nbsp; &nbsp; <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];
&nbsp; &nbsp; <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (size() &gt; <span class="hljs-number">0</span>) {
&nbsp; &nbsp; &nbsp; ans[i++] = pop();
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">return</span> ans;
&nbsp; }
}
</code></pre>
<blockquote data-nodeid="327064">
<p data-nodeid="327065">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.java" data-nodeid="327828">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.cpp" data-nodeid="327832">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.py" data-nodeid="327836">Python</a></p>
</blockquote>
<p data-nodeid="327066"><strong data-nodeid="327841">复杂度分析</strong>：时间复杂度，每个元素都需要入堆，而堆 push 的时间复杂度为 O(lgk)。因为我们控制了堆的大小为 k，所以总的时间复杂度为 O(Nlgk)。因为我们使用了 k 个元素的堆，所以空间复杂度为 O(k)。</p>
<p data-nodeid="327067">【<strong data-nodeid="327847">小结</strong>】在这个并不算难的题目里，我们为了深入讲解优先级队列的原理，采用了一种“最费劲”的方式（自己写堆）来操作。</p>
<p data-nodeid="327068">但实际上，<strong data-nodeid="327861">大部分语言都内置了堆的实现</strong>（<strong data-nodeid="327862">优先级队列</strong>）。<strong data-nodeid="327863">当你面试的时候，如果面试官没有明确提出要求你自己写堆，赶紧麻溜地用内置的优先级队列啊</strong>！</p>
<p data-nodeid="327069">接下来，我们一起看看如何用语言内置的优先级队列来解决这个问题。代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="327070"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp;<span class="hljs-title">Solution</span>&nbsp;</span>{
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">public</span>&nbsp;<span class="hljs-keyword">int</span>[]&nbsp;getLeastNumbers(<span class="hljs-keyword">int</span>[]&nbsp;arr,&nbsp;<span class="hljs-keyword">int</span>&nbsp;k)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span>&nbsp;(k&nbsp;&lt;=&nbsp;<span class="hljs-number">0</span>&nbsp;||&nbsp;arr&nbsp;==&nbsp;<span class="hljs-keyword">null</span>&nbsp;||&nbsp;arr.length&nbsp;==&nbsp;<span class="hljs-number">0</span>)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
        <span class="hljs-comment">// 注意大堆的声明</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queue&lt;Integer&gt;&nbsp;Q&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;PriorityQueue&lt;&gt;((v1,&nbsp;v2)&nbsp;-&gt;&nbsp;v2&nbsp;-&nbsp;v1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">int</span>&nbsp;x:&nbsp;arr)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.offer(x);
            <span class="hljs-comment">// 保持堆中元素小于等于k个</span>
            <span class="hljs-comment">// 保证一直拿到的是k个最小的数</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">while</span>&nbsp;(Q.size()&nbsp;&gt;&nbsp;k)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q.poll();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
        <span class="hljs-comment">// 生成返回结果</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>[]&nbsp;ans&nbsp;=&nbsp;<span class="hljs-keyword">new</span>&nbsp;<span class="hljs-keyword">int</span>[k];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">int</span>&nbsp;i&nbsp;=&nbsp;<span class="hljs-number">0</span>;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span>&nbsp;(<span class="hljs-keyword">int</span>&nbsp;x:&nbsp;Q)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[i++]&nbsp;=&nbsp;x;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span>&nbsp;ans;
&nbsp;&nbsp;&nbsp;&nbsp;}
}
</code></pre>
<blockquote data-nodeid="327071">
<p data-nodeid="327072">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.java" data-nodeid="327868">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp" data-nodeid="327872">C++</a>/<a href="https://github.com/JiYou/LaGouAlgo/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.py" data-nodeid="327876">Python</a></p>
</blockquote>
<p data-nodeid="327073"><strong data-nodeid="327881">复杂度分析：</strong> 首先堆的大小为 k，那么每次 push/pop 的复杂度都是 O(lgk)。一共有 n 个元素，所以复杂度为 O(nlgk)。</p>
<p data-nodeid="327074">此外，这道题还有不使用优先级队列，直接可以达到 O(N) 复杂度的算法，你可以尝试思考一下。</p>
<blockquote data-nodeid="327075">
<p data-nodeid="327076">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.java" data-nodeid="327886">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.cpp" data-nodeid="327890">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.py" data-nodeid="327894">Python</a><br>
注：<strong data-nodeid="327901">如果看不懂也没有关系，我们在“第 08 讲”介绍快排时还会进一步讲解</strong>。</p>
</blockquote>
<p data-nodeid="327077">关于解决这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结一下，再来看我给出的思维导图：</p>
<p data-nodeid="327078"><img src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-FeAA31IAADlOdvhaHc020.png" alt="Drawing 11.png" data-nodeid="327905"></p>
<p data-nodeid="327079">例 1 是一道非常经典的题目，如果你掌握了这道题的解题思想，可以举一反三解决更多的题目。这里我给出一些堆的练习题。</p>
<p data-nodeid="327080"><strong data-nodeid="327911">练习题 1</strong>：给定一个数组，求这个数组的前 k 个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数。</p>
<p data-nodeid="327081">输入：A = [1,2,1,1,3,3,2,3] k = 2</p>
<p data-nodeid="327082">输出：[1, 3]</p>
<p data-nodeid="327083"><strong data-nodeid="327935">解释</strong>：每个数字的出现频率从高到低排序&lt;1, 3次&gt;, &lt;3,3次&gt; &lt;2, 2次&gt;，取前 2 个高频数字。所以是 [1, 3]。</p>
<blockquote data-nodeid="327084">
<p data-nodeid="327085">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.java" data-nodeid="327939">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.cpp" data-nodeid="327943">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.py" data-nodeid="327947">Python</a></p>
</blockquote>
<p data-nodeid="327086"><strong data-nodeid="327952">练习题 2</strong>：在练习题1的基础上，给定的是一个单词数组，求这个数组前 k 个高频单词。如果有两个单词出现频率是一样的。那么输出字典序较小的那个单词。</p>
<p data-nodeid="327087">输入：A = ["AA", "BB", "AA", "BB", "CCC", "CCC", "CCC", "AA"] k = 2</p>
<p data-nodeid="327088">输出：["AA", "CCC"]</p>
<p data-nodeid="327089"><strong data-nodeid="328011">解释</strong>：出现次数最多的 2 个单词就是["AA", "CCC"]</p>
<blockquote data-nodeid="327090">
<p data-nodeid="327091">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.java" data-nodeid="328015">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.cpp" data-nodeid="328019">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.py" data-nodeid="328023">Python</a></p>
</blockquote>
<p data-nodeid="327092"><strong data-nodeid="328031">练习题 3</strong>：给定一个点集数组 A[]，求离原点最近的 k 个点。</p>
<p data-nodeid="327093">输入：A = [[0,1], [1,0], [100,1], [1,100]], k = 2</p>
<p data-nodeid="327094">输出：[[0,1], [1,0]]</p>
<p data-nodeid="327095"><strong data-nodeid="328074">解释</strong>：离原点最近的两个点就是 [[0,1], [1,0]]</p>
<blockquote data-nodeid="327096">
<p data-nodeid="327097">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.java" data-nodeid="328078">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.cpp" data-nodeid="328082">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.py" data-nodeid="328086">Python</a></p>
</blockquote>
<p data-nodeid="327098"><strong data-nodeid="328091">练习题 4</strong>：将 k 个有序的链表，合并成一个有序的链表。</p>
<blockquote data-nodeid="327099">
<p data-nodeid="327100">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.java" data-nodeid="328095">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp" data-nodeid="328099">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.py" data-nodeid="328103">Python</a></p>
</blockquote>
<p data-nodeid="327101"><strong data-nodeid="328108">练习题 5</strong>：给定两个有序数组，两个数组中各找一个数，凑成一对，找出相加之和最小的 k 对。</p>
<p data-nodeid="327102">输入：A = [1, 1, 2], B = [1, 2, 3], k = 2</p>
<p data-nodeid="327103">输出：B = [[1, 1], [1, 1]]]</p>
<p data-nodeid="327104"><strong data-nodeid="328137">解释</strong>：A,B 数组中各取一个1出来凑成一对，其和 [1+1=2, 1+1=2]是最小的 2 对。</p>
<blockquote data-nodeid="327105">
<p data-nodeid="327106">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.java" data-nodeid="328141">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.cpp" data-nodeid="328145">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.py" data-nodeid="328149">Python</a></p>
</blockquote>
<h3 data-nodeid="327107">优先级队列</h3>
<p data-nodeid="327108">前面提到，优先级队列主要基于堆来实现，因此，堆具备的特性优先级队列也同样具备。比如：</p>
<ul data-nodeid="327109">
<li data-nodeid="327110">
<p data-nodeid="327111">可以 O(lgn) 的复杂度往优先级队列中<strong data-nodeid="328156">添加元素；</strong></p>
</li>
<li data-nodeid="327112">
<p data-nodeid="327113">可以 O(lgn) 的复杂度从优先级队列<strong data-nodeid="328162">弹出最大/最小元素</strong>。</p>
</li>
</ul>
<p data-nodeid="327114">经过简化，我们可以得到优先级队列的特性，如下图所示：</p>
<p data-nodeid="327115"><img src="https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-GWAals1AACz-cwh5A0701.png" alt="Drawing 12.png" data-nodeid="328166"></p>
<p data-nodeid="327116">不过，如果只是知道这两个特性，你还不能从容地应对面试。接下来，我们一起看一下优先级队列的深度运用。</p>
<h4 data-nodeid="327117">例 2：跳跃游戏</h4>
<p data-nodeid="327118">【<strong data-nodeid="328178">题目</strong>】假设你正在玩跳跃游戏，从<strong data-nodeid="328179">低处往高处跳</strong>的时候，可以有两种方法。</p>
<p data-nodeid="327119">方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。</p>
<p data-nodeid="327120">方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的(一个只能用一次)。</p>
<p data-nodeid="327121">其他无论是<strong data-nodeid="328191">平着跳</strong>，还是<strong data-nodeid="328192">从高处往低处跳</strong>，不需要借助什么就可以完成（在这道题中我们默认无论从多高跳下来，也摔不死）。</p>
<p data-nodeid="327122">给你一个数组，用来表示不同的高度。假设你总是站在 index = 0 的高度开始。那么请问，你最远能跳到哪里?</p>
<p data-nodeid="327123">输入：[3, 1, 6, 20, 10, 20], bricks = 5, landers = 1</p>
<p data-nodeid="327124">输出：4</p>
<p data-nodeid="327125"><strong data-nodeid="328203">解释：</strong></p>
<ul data-nodeid="327126">
<li data-nodeid="327127">
<p data-nodeid="327128">Step 1. 从 3 跳到 1 时，因为是从高往低处跳，直接跳就可以了</p>
</li>
<li data-nodeid="327129">
<p data-nodeid="327130">Step 2. 从 1 到 6 时，用掉 5 个砖块</p>
</li>
<li data-nodeid="327131">
<p data-nodeid="327132">Step 3. 从 6 到 20 时，用掉梯子</p>
</li>
<li data-nodeid="327133">
<p data-nodeid="327134">Step 4. 从 20 到 10 可以直接跳</p>
</li>
<li data-nodeid="327135">
<p data-nodeid="327136">Step 5.到 10 这里就停住了，没有东西可以帮助你跳到 20 了，所以只能跳到下标 index = 4 这里。</p>
</li>
</ul>
<p data-nodeid="327137">【<strong data-nodeid="328226">分析</strong>】这是一道来自<strong data-nodeid="328227">拼多多</strong>的面试题。首先我们想一想<strong data-nodeid="328228">在什么情况下使用梯子</strong>？因为梯子最好用，可以无视高度直接使用。但是这里有一个限制条件，只能在<strong data-nodeid="328229">大高度差</strong>的时候使用梯子。如果是在小高度差的时候使用，那么最终就走不远，比如对于上面给定的例子：</p>
<ul data-nodeid="327138">
<li data-nodeid="327139">
<p data-nodeid="327140">Step 1. 从 3 跳到 1 时，直接跳就可以了；</p>
</li>
<li data-nodeid="327141">
<p data-nodeid="327142">Step 2. 从 1 到 6 时，用掉梯子；</p>
</li>
<li data-nodeid="327143">
<p data-nodeid="327144">Step 3. 从 6 到 20 时，手里的 5 个砖头就不够用了！所以最远只能到下标 index = 2。</p>
</li>
</ul>
<p data-nodeid="327145">因此，我们选择使用<strong data-nodeid="328238">梯子的时候，一定要使用得当</strong>！那么应该如何判断在什么情况下使用梯子呢？</p>
<p data-nodeid="327146">下面可以尝试换种思路，从低往高跳跃的时候，本来是要使用砖块的。但是可以想象成我随身带着一个本子，在上面<strong data-nodeid="328244">记录落差(落差定义为：低往高处跳时的高度差)</strong>。比如从高度 1 跳到高度 6，就在小本子上写 5。而高处往低处跳的时候，不需要记录，因为这不是落差（题目说了高往低处跳可以直接跳，没有必要记录）。</p>
<p data-nodeid="327147">在跳跃的时候，一定要保证小本子上的<strong data-nodeid="328250">落差之和要小于等于砖块数目</strong>。可是当落差大于砖块之和时怎么办呢？</p>
<p data-nodeid="327148">别忘了，我们还有梯子呢。梯子可是万能的（可以把梯子想象成一次性橡皮擦 ）！如果还有梯子，我们只需要从小本子上挑出最大的落差，用“一次性<strong data-nodeid="328256">橡皮擦</strong>”将它从小本上擦掉即可。</p>
<p data-nodeid="327149"><strong data-nodeid="328262">1. 模拟</strong></p>
<p data-nodeid="327150">有了思路之后，我们来执行一次模拟。具体演示如下图所示：</p>
<p data-nodeid="327151"><img src="https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-IeAcgVAABQeZUJ0g7s661.gif" alt="7.gif" data-nodeid="328266"></p>
<blockquote data-nodeid="327152">
<p data-nodeid="327153">Step 1. 首先从高度 3 出发，此时小本子为空 {}。<br>
Step 2. 从高度 3 跳到高度 1（高往低跳，无压力），此时小本子仍然为空 {}。<br>
Step 3. 从 1 跳到高度 6，小本子记录落差 {5} &lt;= 砖头数 5。<br>
Step 4. 从 6 跳到 20, 小本子记录{5, 14}，总和 &gt; 砖头数 5。<br>
Step 5.需要从小本子{5, 14}中选出最大数 14，然后梯子替换掉。<br>
Step 6. 从 20 跳到 10，高到低跳。<br>
Step 7. 要从 10 跳到 20，需要把落差 10 记录到本子上 {5, 10} 。<br>
Step 8. 小本子 {5, 10} 总和 = 15，大于砖头数 5，又没有梯子可以用了。因此只能停在 4 这个位置。</p>
</blockquote>
<p data-nodeid="327154"><strong data-nodeid="328290">2. 规律</strong>：在这里，我们发现小本子有两个有趣的地方：</p>
<p data-nodeid="327155">（1）需要在小本子上记录落差；</p>
<p data-nodeid="327156">（2）需要用梯子来替换最大的落差。</p>
<p data-nodeid="327157">在我们学过的数据结构里面，满足这个 push/pop 特点的，应该就是<strong data-nodeid="328298">优先级队列</strong>啦。</p>
<p data-nodeid="327158"><strong data-nodeid="328305">3. 边界</strong>：注意考虑给定数组为空的情况。</p>
<p data-nodeid="327159">【<strong data-nodeid="328311">代码</strong>】到这里，可以开始写出代码了。具体代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="327160"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>{
        <span class="hljs-comment">// 注意处理非法输入</span>
        <span class="hljs-keyword">if</span> (heights == <span class="hljs-keyword">null</span> || heights.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">// 记录落并的小本子: 最大堆</span>
        Queue&lt;Integer&gt; Q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
        <span class="hljs-keyword">int</span> qSum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> lastPos = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> preHeight = heights[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; heights.length; i++) {
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curHeight = heights[i];
            <span class="hljs-comment">// 如果是从高处往低处跳</span>
            <span class="hljs-keyword">if</span> (preHeight &gt;= curHeight) {
                lastPos = i;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 如果是低处往高处跳</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> delta = curHeight - preHeight;
                <span class="hljs-comment">// 拿到高度的落差</span>
                <span class="hljs-comment">// 写到小本子上</span>
                Q.offer(delta);
                qSum += delta;
                <span class="hljs-comment">// 如果小本子上的总和比砖块多了</span>
                <span class="hljs-comment">// 并且还有梯子</span>
                <span class="hljs-keyword">while</span> (qSum &gt; bricks &amp;&amp; ladders &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-comment">// 需要用梯子把最大的落差给抵消掉</span>
                    qSum -= Q.peek();
                    Q.poll();
                    ladders--;
                }
                <span class="hljs-comment">// 看看经过一番处理之后，还能不能跳到i这个位置</span>
                <span class="hljs-keyword">if</span> (qSum &lt;= bricks) {
                    lastPos = i;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// 如果经过一番处理之后，还是不能跳</span>
                    <span class="hljs-comment">// 看来不能跳到i了</span>
                    <span class="hljs-comment">// 跳出循环!</span>
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-comment">// 更新位置的高度</span>
            preHeight = curHeight;
        }
        <span class="hljs-keyword">return</span> lastPos;
    }
}
</code></pre>
<blockquote data-nodeid="327161">
<p data-nodeid="327162">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.java" data-nodeid="328315">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.cpp" data-nodeid="328319">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.py" data-nodeid="328323">Python</a></p>
</blockquote>
<p data-nodeid="327163"><strong data-nodeid="328328">复杂度分析</strong>：在跳跃的过程中，最差的情况下，我们需要把所有的高度差记录下来。在这种情况下，每个高度差都需要执行 push 操作。那么时间复杂度为 O(NlgN)，空间复杂度为O(N)。</p>
<p data-nodeid="327164">【<strong data-nodeid="328334">小结</strong>】首先我们仔细总结一下这道题目的特点：</p>
<ul data-nodeid="327165">
<li data-nodeid="327166">
<p data-nodeid="327167">需要将<strong data-nodeid="328340">消耗的过程，转换为存储的过程</strong>（记录在小本子上），对应堆的 push；</p>
</li>
<li data-nodeid="327168">
<p data-nodeid="327169">需要优先消除一些元素，对应堆的 pop。</p>
</li>
</ul>
<p data-nodeid="327170">与例 1 关于堆的题目相比，例 2 的求解过程不再那么直白，需要我们深入挖掘题目的特点，才能找到正确的解答方法——使用push 和 pop。</p>
<p data-nodeid="327171">此外，我们还能挖出一些不同的东西来——关于堆中元素需要弹出时的处理方式。在 Top K 问题里，当堆中元素个数超出 k 个时，就要执行 pop 操作。而这道题，将弹出元素的条件变成了堆中的总和不能超出砖块的数目。</p>
<p data-nodeid="327172"><strong data-nodeid="328360">练习题 6</strong>：一只蚂蚁在树下吃果子，第 i 天会掉 落A[i] 个果子，这些果子会在接下来的 B[i] 天（即第 i+B[i] 天）立马坏掉不能吃。给定 A，B 两个数组，蚂蚁一天只能吃一个果子。吃不完了它可以存放起来。请问最多蚂蚁可以吃多少个果子。</p>
<p data-nodeid="327173">输入：A = [3, 1], B = [3, 1]</p>
<p data-nodeid="327174">输出：3</p>
<p data-nodeid="327175"><strong data-nodeid="328374">解释</strong>：我们假设下标从 1 开始：</p>
<p data-nodeid="327176">第 1 天你吃 1 个第 1 天的果子</p>
<p data-nodeid="327177">第 2 天吃 1 个第 1 天的果子，同时把第 2 天的果子存起来。</p>
<p data-nodeid="327178">第 3 天吃 1 个第 1 天的果子，第 2 天的果子只能放 1 天，第 2 天的果子第 3 天坏了。</p>
<p data-nodeid="327179">第 4 天没有果子吃了。</p>
<blockquote data-nodeid="327180">
<p data-nodeid="327181">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.java" data-nodeid="328382">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.cpp" data-nodeid="328386">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.py" data-nodeid="328390">Python</a></p>
</blockquote>
<p data-nodeid="327182">你可以自己尝试总结一下解决这类题目的思路和重点，然后再来参考我给出的思维导图：</p>
<p data-nodeid="327183"><img src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-LyAd-I8AACuBAvv24c185.png" alt="Drawing 14.png" data-nodeid="328394"></p>
<h4 data-nodeid="327184">例 3：汽车加油次数</h4>
<p data-nodeid="327185">【<strong data-nodeid="328417">题目</strong>】一辆汽车携带 startFuel 升汽油从位置 0 出发前往位置 target，按顺序有一系列加油站 stations。第 i 个加油站位于 stations[i][0]，可以加 stations[i][1] 升油（一个加油站只能加一次）。如果想要到达 target，输出最少加油次数。如果不能到达 target，那么返回 -1。</p>
<p data-nodeid="327186"><strong data-nodeid="328422">两个条件</strong>：</p>
<ol data-nodeid="327187">
<li data-nodeid="327188">
<p data-nodeid="327189">假设汽车油箱总是很大；</p>
</li>
<li data-nodeid="327190">
<p data-nodeid="327191">假设行走一单位距离，消耗一升汽油。</p>
</li>
</ol>
<p data-nodeid="327192"><strong data-nodeid="328429">示例</strong>：</p>
<p data-nodeid="327193">输入：target = 100, startFuel = 10, stations = [[10, 60], [20, 30], [30, 30], [60, 40]]</p>
<p data-nodeid="327194">输出：2</p>
<p data-nodeid="327195">【<strong data-nodeid="328454">分析</strong>】首先带着 10 升汽油，可以顺利开到 pos = 10 的加油站，加上 60 升汽油。然后直接开车到 pos = 60 的加油站，加上 40 升汽油就可以顺利到达 target = 100 处。所以最少需要加 2 次油。</p>
<p data-nodeid="327196">在<strong data-nodeid="328466">微软和头条</strong>都有同学遇到过这道题目。仔细读题之后，可以发现，需要加油的情况只有一种：汽<strong data-nodeid="328467">车当前位置 + 车里剩余汽油 &lt; 要到达的下一个目标地点</strong>。这里的下一个目标地点，有可能是 target，也有可能是加油站。</p>
<p data-nodeid="327197">那么问题是，当我们发现汽油不够的时候，应该如何加油呢？题目最终目的是产生尽量少的加油次数，所以每次加油加得越多越好！这就找到了一个解题方向：应该<strong data-nodeid="328473">挑油量最大的加油站</strong>进行加油。</p>
<p data-nodeid="327198">假设有一个巨大无比的副油箱，每次经过加油站的时候，都可以把加油站里面的油放到副油箱里面<strong data-nodeid="328479">存起来</strong>。缺油的时候，就从副油箱里把最大量的汽油加到车里（这里才算加一次油）。</p>
<p data-nodeid="327199"><strong data-nodeid="328485">1. 模拟</strong></p>
<p data-nodeid="327200">接下来我们就利用这个副油箱进行一下模拟，具体演示如下图所示（注意：副油箱里面的汽油不能算在已经加到车的汽油里，你可以认为它还放在后面座位上呢）：</p>
<p data-nodeid="327201"><img src="https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-NWATbp5ABcZWJEFfns318.gif" alt="8.gif" data-nodeid="328489"></p>
<blockquote data-nodeid="327202">
<p data-nodeid="327203">Step 1. 从 0 位置出发，下一站位于 pos = 10，当前汽油可以达到。<br>
Step 2. 开到了pos = 10，将 60 升汽油放到副油箱，此时余下汽油量为 0。<br>
Step 3. 汽油里面的汽油不足开到 pos = 20 加油站，从副油箱中取出最多汽油 60 加上。<strong data-nodeid="328509">第 1 次</strong>加油之后，余下油量变成 60。<br>
Step 4. 开到 pos = 20 处，余下汽油 50, 并且将加油站的 30 升汽油放到副油箱。<br>
Step 5. 开到 pos = 30 处，余下 40 升汽油，并且将加油站的 30 升汽油放到副油箱。<br>
Step 6. 开到加油站 60 处，余下 10 升汽油，并且将加油站的 40 升汽油放到副油箱。<br>
Step 7. 发现无法开到位置 100 处，那么将最多的汽油 40 升加到汽车里，此时余下汽油 50。<br>
最后，成功开到了终点。</p>
</blockquote>
<p data-nodeid="327204"><strong data-nodeid="328515">2. 规律</strong></p>
<p data-nodeid="327205">通过观察副油箱的操作，我们发现它的行为具有两个特点：</p>
<p data-nodeid="327206">（1）每次经过加油站会把汽油<strong data-nodeid="328522">加到</strong>副油箱</p>
<p data-nodeid="327207">（2）缺油的时候，总是把<strong data-nodeid="328528">最大升</strong>的汽油拿出来加上</p>
<p data-nodeid="327208">这两个行为让我们联想到本讲学过的 push/pop 操作。并且每次 pop 的时候，都要弹出最大的元素，这又让我们想起了今天学过的堆（不过这里不再写堆的四种操作了），就用优先级队列吧。因为总是<strong data-nodeid="328534">最大升的汽油优先</strong>。</p>
<p data-nodeid="327209"><strong data-nodeid="328540">3. 边界</strong></p>
<p data-nodeid="327210">在正式写代码前，你还是要考虑到以下 3 种情况：</p>
<p data-nodeid="327211">（1）加油站的位置都小于 target</p>
<p data-nodeid="327212">（2）某些加油站的位置等于 target</p>
<p data-nodeid="327213">（3）有些加油站的位置大于 target</p>
<p data-nodeid="327214">在处理的时候，<strong data-nodeid="328550">可以将 target 也当成一个站。只不过这个站，并不提供汽油</strong>。这样处理起来更容易一些。</p>
<p data-nodeid="327215">【<strong data-nodeid="328556">代码</strong>】通过了前面的分析，此时我们应该撸起袖子开始写代码了，代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="327216"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
&nbsp; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minRefuelStops</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> startFuel, <span class="hljs-keyword">int</span>[][] stations)</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = stations.length;
&nbsp; &nbsp; <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
&nbsp; &nbsp; <span class="hljs-comment">// 当前汽车的状态{位置, 还余下多少汽油}</span>
&nbsp; &nbsp; <span class="hljs-keyword">int</span> curPos = <span class="hljs-number">0</span>;
&nbsp; &nbsp; <span class="hljs-keyword">int</span> fuelLeft = startFuel;
&nbsp; &nbsp; <span class="hljs-comment">// 副油箱</span>
&nbsp; &nbsp; Queue&lt;Integer&gt; Q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((v1, v2) -&gt; v2 - v1);
&nbsp; &nbsp; <span class="hljs-comment">// 从副油箱里面往汽车加油的次数</span>
&nbsp; &nbsp; <span class="hljs-keyword">int</span> addFuelTimes = <span class="hljs-number">0</span>;
&nbsp; &nbsp; <span class="hljs-keyword">while</span> (curPos + fuelLeft &lt; target) {
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 默认期望的下一站，站点设置为target</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 此时能加的汽油为0</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> pos = target;
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">int</span> fuel = <span class="hljs-number">0</span>;
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果有位于target之前的站点, 那么更新</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 加油站的位置，以及能加到副油箱的油量</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (i &lt; N &amp;&amp; stations[i][<span class="hljs-number">0</span>] &lt;= target) {
&nbsp; &nbsp; &nbsp; &nbsp; pos = stations[i][<span class="hljs-number">0</span>];
&nbsp; &nbsp; &nbsp; &nbsp; fuel = stations[i][<span class="hljs-number">1</span>];
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 如果当前汽车的状态，不能到达期望的下一站</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">while</span> (curPos + fuelLeft &lt; pos) {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 拿出副油箱啊</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 惨了，副油箱没有油了，</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (Q.isEmpty()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 从副油箱里面拿出最大的汽油加上去</span>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> curMaxFuel = Q.peek();
&nbsp; &nbsp; &nbsp; &nbsp; Q.poll();
&nbsp; &nbsp; &nbsp; &nbsp; fuelLeft += curMaxFuel;
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 加油次数++</span>
&nbsp; &nbsp; &nbsp; &nbsp; addFuelTimes++;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 好了，现在可以到达期望的下一站了</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 不过需要把消耗的汽油扣掉</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> fuelCost = pos - curPos;
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 更新当前汽车的状态</span>
&nbsp; &nbsp; &nbsp; fuelLeft -= fuelCost;
&nbsp; &nbsp; &nbsp; curPos = pos;
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 这个汽油站里面的汽油加到副油箱</span>
&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">if</span> (fuel &gt; <span class="hljs-number">0</span>) {
&nbsp; &nbsp; &nbsp; &nbsp; Q.offer(fuel);
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; <span class="hljs-comment">// 这个站就过去了</span>
&nbsp; &nbsp; &nbsp; i++;
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-comment">// 能到达target吗？如果能，返回加油次数，不能返回-1</span>
&nbsp; &nbsp; <span class="hljs-keyword">return</span> curPos + fuelLeft &gt;= target ? addFuelTimes : -<span class="hljs-number">1</span>;
&nbsp; }
}
</code></pre>
<blockquote data-nodeid="327217">
<p data-nodeid="327218">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.java" data-nodeid="328560">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.cpp" data-nodeid="328564">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.py" data-nodeid="328568">Python</a></p>
</blockquote>
<p data-nodeid="327219"><strong data-nodeid="328573">复杂度分析</strong>：最差情况下，需要把所有的油都收集起来，此时所有的油都需要有 push 操作，所以时间复杂度为O(NlgN)，而空间复杂度为O(N)。</p>
<p data-nodeid="327220">【<strong data-nodeid="328583">小结</strong>】首先，当你发现这道题属于“<strong data-nodeid="328584">消耗物品</strong>”类题目，并且优先消耗较大的油箱时，脑海中应该联想前面我们讲过的关于堆的总结：</p>
<ul data-nodeid="327221">
<li data-nodeid="327222">
<p data-nodeid="327223">将消耗的过程转换为存储的过程，对应堆的 push 操作；</p>
</li>
<li data-nodeid="327224">
<p data-nodeid="327225">将优先选择大油桶的过程看成堆的 pop 操作。</p>
</li>
</ul>
<p data-nodeid="327226">经过一番分析，我们挖出了这道题背后的考点，以及优先级队列可能存在变化地方：</p>
<ul data-nodeid="327227">
<li data-nodeid="327228">
<p data-nodeid="327229">什么时候执行 push 操作？</p>
</li>
<li data-nodeid="327230">
<p data-nodeid="327231">什么时候执行 pop 操作？</p>
</li>
</ul>
<p data-nodeid="327232"><strong data-nodeid="328600">练习题 7</strong>：在一个网络中有 N 台计算机，编号从 1~N，现在给定一些<strong data-nodeid="328601">有向</strong>边，表示计算机之间网络传输使用的时间（ms），请问，从节点编号为k的计算机发出一个信号，需要多久才能让所有的计算机接收到信号。如果不能让所有人接收到信号，请输出 -1。</p>
<p data-nodeid="327233">输入：N = 2, times = [1, 2, 100], k = 1</p>
<p data-nodeid="327234">输出：100</p>
<p data-nodeid="327235"><strong data-nodeid="328612">解释</strong>：只有两个计算机 1，和计算机 2。从计算机 1 发送信息到计算机 2 需要 100ms。所以输出 100。</p>
<blockquote data-nodeid="327236">
<p data-nodeid="327237">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java" data-nodeid="328616">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp" data-nodeid="328620">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py" data-nodeid="328624">Python</a></p>
</blockquote>
<h3 data-nodeid="327238">总结与延伸</h3>
<p data-nodeid="327239">至此，我们已经学习了堆的特性与实现。在了解了 push/pop 元素的复杂度为 logn 后，我们还需要知道考点可能出现在以下两个地方：</p>
<ol data-nodeid="327240">
<li data-nodeid="327241">
<p data-nodeid="327242">什么时候 push 元素</p>
</li>
<li data-nodeid="327243">
<p data-nodeid="327244">什么时候 pop 元素</p>
</li>
</ol>
<p data-nodeid="327245">这里我做了一个简单的归纳，并且列举了例题中的条件，你能在实战中补充一些其他有趣的条件吗？</p>
<p data-nodeid="327246"><img src="https://s0.lgstatic.com/i/image6/M00/13/4A/Cgp9HWBB-QCAcvk-AADd5wNIZG0008.png" alt="Drawing 16.png" data-nodeid="328632"></p>
<p data-nodeid="327247">优先级队列非常有趣，也非常有用，在后面的<strong data-nodeid="328638">广度优先搜索中，还会重拾这个知识，</strong> 帮助你解决更多的疑难问题。</p>
<h3 data-nodeid="327248">思考题</h3>
<p data-nodeid="327249">最后我再给你留一道<strong data-nodeid="328645">思考题</strong>：</p>
<p data-nodeid="327250">来自 <strong data-nodeid="328651">Google</strong> 的面试题。一个机器每隔一秒钟就会输出一个整数，请你写一个查询接口，输出所有已经得到的整数的中位数。中位数就是排序之后位于中间的数。如果数目为偶数，则是中间两个数的平均值。</p>
<blockquote data-nodeid="327251">
<p data-nodeid="327252">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.java" data-nodeid="328655">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp" data-nodeid="328659">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.py" data-nodeid="328663">Python</a></p>
</blockquote>
<p data-nodeid="327253">你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。后会有期，优先级队列！</p>
<p data-nodeid="327254" class="">下一讲将介绍 04 | 链表：如何利用“假头，新链表，双指针”解决链表题？（上）记得按时来探险。</p>

---

### 精选评论

##### *中：
> 有一说一，感觉好难

##### **成：
> 写的很好理解，就是这一期的动态图实在太快了

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 您建议我们收到了，后面的内容已会降低动图速度哈

##### **5700：
> 感觉梯子的例子使用的数字不太好，让人误以为有砖头时优先使用砖头就好了，如果使用3，11，2,5,7,9 八个砖块，一个梯子这种例子在砖块不够时消除前面最大的需要8个砖块，这样是不是更好😁

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 赞！这个例子不错!

##### **成：
> 很实用，需要多想，多打

##### **用户7186：
> 梯子例题替换最大需要砖块数这里 ，while (qSum  ，while循环 可以换成 if 判断嘛？感觉这里每次都只会执行一次呀。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 可以。用while更保险，习惯了。

##### **林：
> 这节课有点意思。

##### **军：
> 给定一个数组，求这个数组的前 k 个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数. 这道题对应的代码只有“给定一个数组，求这个数组的前 k 个高频元素”逻辑, 没有“如果有两个数出现次数一样，那么优先取较小的那个数”这个的逻辑呢?

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; leetcode原题中是有一个约束的：

题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。

不过你提的这个点很有意思。在面试的时候，如果面试官没有主动说出这个约束，那么需要向面试官问清楚，如果出现这种情况怎么办？

##### **正：
> 老师 你好，练习题 4：将 k 个有序的链表，合并成一个有序的链表。 你的github的答案里面的 y.val 怎么理解比较好

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 我看了一下代码。我觉得你说的应该是c++的代码，如果我说错了，更正一下。c++ priority_queue的，在自定义排序的时候。

会利用x->val 与y->val进行比较。当写成x->val > y->val的时候，会优先将y元素出队。

##### *海：
> 例题2有些疑问点：1. while (qSum  0) {}这个条件判断，如果前面的都是低阶的楼梯，但是叠加起来比bricks大，那么其实此时的台阶还不是最大的却用了梯子；2. 这里是不是少了个用bricks抵消delta的代码if (qSum = bricks) {}

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 1. while qSum > bricks这个循环是说，当走到这里的时候，发现不能往前走了。因为砖头不够用了。于是用梯子去填最大的那个落差。注意，梯子填的是以前的某个位置出现的最大的落差，而不是当前。

2. 不要设置qSum == bricks。梯子是万能的，我们在能用砖头的时候，要尽量用砖头

##### **福：
> 练习一应该改为这样才合理吧。实际测试用例[1,1,1, 2,2, 3,3] -  [1,2]而用github代码是 [1,3]auto cmp = [">const pair">int,int">,const pair">int,int B) {    if(A.second != B.second) {        return B.second ">second;    }    return A.first ">first;};

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; leetcode原题中是有一个约束的：

题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。

不过你提的这个点很有意思。在面试的时候，如果面试官没有主动说出这个约束，那么需要向面试官问清楚，如果出现这种情况怎么办？

##### pmk：
> 老师您好，关于汽车加油次数的题，你的解法我看好像并不是按最少加油次数来算的？如果要解原题应该怎么做？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; while (true) {printf("解法是原题，100%包过");}

##### pmk：
> 老师您好，下层操作里面a[n-1] 存放至 a[0]是什么意思？不应该直接对a[0]直接下沉吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 注意pop操作的顺序：
pop 操作需要以下 3 步：
（1）取出 a[0] 的值作为返回值
（2）然后将 a[n-1] 存放至 a[0]
（3）将 a[0] 进行下沉操作
如果是一个最大堆，那么原来的A[0](晁盖)就是堆中的最大元素，但是此时，最大元素是要被pop出去的(晁盖跪了)。pop出去之后，谁来当老大就是一个问题了。那么操作的时候呢，就是先把A[n-1]扔上来当老大(对的，就是卢俊义要上来当老大，此时已经在A[0]的位置上了)。A[0](卢俊义)一看，唉哟，下面的人个个都是李逵(人才），这个老大不好当。于是往下怂～

##### **方：
> 算法学习---技术宅男 “加油站”

##### **0747：
> 我能想到的方法1 维护一个大顶堆，一个小顶堆。2 树状数组。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 赞，思路正确。我给出的答案就是方法1

##### *飞：
> 练习题7为什么要用堆而不用队列呢，用堆似乎只是保证了计算延迟的时候，计算机编号从小到大

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 练习题7，我重新看了，应该是使用”最小时延“结点优先出队，所以这里应该是命名用优先队列。并且在顺序的比较时，应该按照时延出队。不是按照编号来出队。

”按照编号来出队“当然也不会有什么大问题，只是没有达到最优的效果。

##### **辉：
> 下沉实例代码中的n是什么？好像没有定义直接用了

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; n在前文中定了。
"
假设我们已经申请了数组 a[] 和元素 n 表示当前堆中元素的个数，代码如下：
 
int[] a = new int[100]; // 表示堆的数组空间, 100作示例大小
int n = 0; // 堆中元素个数

"

另外，后面也给出了堆的完整的代码。

##### **亚：
> 德哥，可以把对应的题号给写上吗

