<p data-nodeid="8221" class="">面试的场景与我们之前学习某个知识点的情况不再相同。在学习“一解多题”的时候，由于已经预设了前提，实际上我们是知道某个题会用到什么知识点的。</p>
<p data-nodeid="8222">但是在面试中，当你拿到一个题目，可能一时想不到具体采用哪种解法。所以在本讲，我将带你回到面试场景，教你分析题目的思路。我们的目标就变成<strong data-nodeid="8692">从题目出发，去考虑如何破解一个题</strong>。</p>
<p data-nodeid="8223">本讲将会重点学习：</p>
<ul data-nodeid="8224">
<li data-nodeid="8225">
<p data-nodeid="8226">如何挖掘题目的特点</p>
</li>
<li data-nodeid="8227">
<p data-nodeid="8228">如何利用特点匹配到数据结构和算法知识点</p>
</li>
</ul>
<p data-nodeid="8229">完成这两步动作，需要你熟练地掌握前面“一解多题”模块介绍的数据结构与算法知识点。养兵千日，用在一时，是时候派上用场了。</p>
<h3 data-nodeid="8230">最大矩形</h3>
<p data-nodeid="8231">【<strong data-nodeid="8707">题目</strong>】给定一个数组，里面有<em data-nodeid="8708">n</em>个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p data-nodeid="8232">输入：[2,1,5,6,2,3]</p>
<p data-nodeid="8233">输出：10</p>
<p data-nodeid="8234">解释：柱状图的示例，其中每个柱子的宽度为 1，给定的高度为<code data-backticks="1" data-nodeid="8715">[2,1,5,6,2,3]</code>。</p>
<p data-nodeid="8235"><img src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__gKAfuSVAAJVGh0lZ7k739.png" alt="Drawing 0.png" data-nodeid="8719"></p>
<div data-nodeid="8236"><p style="text-align:center">输入     最大矩形</p></div>
<h3 data-nodeid="8237">暴力算法</h3>
<p data-nodeid="8238">当拿到题目之后，一种最简单、最暴力的算法立马会出现在我们脑海里面。那就是：</p>
<ul data-nodeid="8239">
<li data-nodeid="8240">
<p data-nodeid="8241">分别选定两个柱子，然后计算这两个柱子为边界，构成的最大矩形的面积；</p>
</li>
<li data-nodeid="8242">
<p data-nodeid="8243">取出所有的矩形面积中的最大面积。</p>
</li>
</ul>
<p data-nodeid="8244">那么根据这个思路，可以得到代码如下：</p>
<pre class="lang-java" data-nodeid="8245"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
        <span class="hljs-keyword">int</span> h = Integer.MAX_VALUE;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = l; k &lt;= r; k++) {
            h = Math.min(h, A[k]);
        }
        <span class="hljs-keyword">return</span> h;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
                ans = Math.max(ans,
                   minHeight(A, i, j) * (j - i + <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<p data-nodeid="8246">但是，这个代码的时间复杂度实在太高，达到 O(N<sup>3</sup>)，在面试中并不能给你加分。那么有没有什么更好的办法呢？</p>
<h3 data-nodeid="8247">特点 1：区间</h3>
<p data-nodeid="8248">可以发现，求解的时候，我们非常依赖一个区域里面的最小值：就是 minHeight() 函数。</p>
<p data-nodeid="8249">那么，有没有什么办法，可以<strong data-nodeid="8737">快速地</strong>获取：一个数组区间里面的最小值呢？此时问题破解的关键聚焦到下面这个问题上。</p>
<blockquote data-nodeid="8250">
<p data-nodeid="8251">给定一个数组：如何快速地查询一个区间里面的最小值？</p>
</blockquote>
<p data-nodeid="8252">如果我们能在 O(1) 的时间得到一个区间里面的最小值，那么就可以把暴力算法的时间复杂度优化到 O(N<sup>2</sup>)。</p>
<p data-nodeid="8253">因此，此时我们需要快速匹配到一个算法和数据结构来满足这样的特点。想到这里，你的脑海里面应该浮现如下的场景：</p>
<p data-nodeid="8254"><img src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__hyAKNRHAADJi9Tt1Jc075.png" alt="Drawing 1.png" data-nodeid="8747"></p>
<p data-nodeid="8255">那么，我们需要什么样的数据结构/算法呢？</p>
<ul data-nodeid="8256">
<li data-nodeid="8257">
<p data-nodeid="8258">如果是在面试中，你发现脑海里面空空如也，一点也想不到有什么办法可以处理这个区间查询问题，就需要立马转换思路，尝试寻找别的破题办法。因为很有可能，这里踩了你的知识盲区，要在短时间发现一种算法解决这个问题的可能性还是挺小的。</p>
</li>
<li data-nodeid="8259">
<p data-nodeid="8260">如果是在准备面试阶段，那么你应该立马搜索一下有什么样的数据结构可以满足这样的要求。大概率情况下，这种基础问题已经有很多现成的数据结构来支撑了，所以不需要你再去“挠破脑袋”当发明家了。</p>
</li>
</ul>
<p data-nodeid="8261">就现在而言，我们肯定是处在一个准备面试的阶段。所以，下面我会带你走一遍“搜索”的步骤。</p>
<p data-nodeid="8262">求解区间的最小值/最大值问题，一般有 2 类算法与数据结构：</p>
<ul data-nodeid="8263">
<li data-nodeid="8264">
<p data-nodeid="8265">ST（Sparse Table）算法</p>
</li>
<li data-nodeid="8266">
<p data-nodeid="8267">线段树（Segment Tree）</p>
</li>
</ul>
<p data-nodeid="8268">接下来，我们分别介绍一下这两种算法（说不定哪天你在面试中碰到这个关键问题，就轻而易举答出来了）。</p>
<h4 data-nodeid="8269">ST 算法</h4>
<p data-nodeid="8270">在面试时，我们总是先看到问题，然后希望匹配到一个算法，能够刚好满足我们期望的时间复杂度。那么 ST 算法可以满足我们的要求吗？</p>
<p data-nodeid="10275" class="">先来看一下 <strong data-nodeid="10281">ST 算法的特点</strong>：</p>

<ul data-nodeid="8272">
<li data-nodeid="8273">
<p data-nodeid="8274">ST 算法需要预处理，并且在预处理阶段，时间复杂度为 O(NlgN)，空间复杂度为 O(NlgN)；</p>
</li>
<li data-nodeid="8275">
<p data-nodeid="8276">ST 算法预处理结束之后，在查询阶段，时间复杂度为 O(1)。</p>
</li>
</ul>
<p data-nodeid="8277">如果我们用上 ST 算法，那么时间复杂度可以从 O(N<sup>3</sup>) 变为 O(N<sup>2</sup> + NlgN) = O(N<sup>2</sup>)。这样一来复杂度就下降了一个数量级，还是非常值得一试的。</p>
<p data-nodeid="14390" class="">下面我们讲一下 ST 算法 <strong data-nodeid="14396">2 个核心思想</strong>。</p>

<h5 data-nodeid="8279">1. 一分为二</h5>
<p data-nodeid="30859" class="">任何一个区间都可以分为<strong data-nodeid="30869">两个可能重合的区间</strong>。比如给定的区间为 [start, end]，那么：</p>




<ul data-nodeid="8281">
<li data-nodeid="8282">
<p data-nodeid="8283">这个区间可以分为 [start, end1], [start2, end]，即第一个区间必须以 start 为起点，第二个区间必须以 end 为终点；</p>
</li>
<li data-nodeid="8284">
<p data-nodeid="8285">两个区间<strong data-nodeid="8813">可以重合</strong>；</p>
</li>
<li data-nodeid="8286">
<p data-nodeid="8287">两个区间的长度<strong data-nodeid="8823">必须</strong>是 2<sup>p</sup> 长度（p 是非负整数）。</p>
</li>
</ul>
<p data-nodeid="8288"><img src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__iqAUkNNAABpKQ8hpO8389.png" alt="Drawing 2.png" data-nodeid="8826"></p>
<p data-nodeid="8289">【<strong data-nodeid="8852">例 1</strong>】比如有一个区间 [10, 17]，长度为 8，那么可以拆分为 [10, 13], [14,17] 长度为 2<sup>2</sup> 的两个区间。下图是拆分之后<strong data-nodeid="8853">不存在重合</strong>的情况：</p>
<p data-nodeid="8290"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jGAJ-BPAAB07QZeoiU141.png" alt="Drawing 3.png" data-nodeid="8856"></p>
<p data-nodeid="8291">【<strong data-nodeid="8882">例 2</strong>】比如有一个区间 [10, 18]，长度为 9。那么可以拆分为 [10, 17] 和 [11, 18] 长度为 2<sup>3</sup> 的两个区间。下图是拆分之后存在<strong data-nodeid="8883">部分重合</strong>的情况：</p>
<p data-nodeid="8292"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__jiAOH3WAABwKY4dT9s988.png" alt="Drawing 4.png" data-nodeid="8886"></p>
<p data-nodeid="8293">【<strong data-nodeid="8912">例 3</strong>】比如有一个区间 [10, 10]，长度为 1，那么可以拆分为 [10, 10] 和 [10, 10]，这两个区间完全重合，且长度为 2<sup>0</sup> 的两个区间。这是拆分之后<strong data-nodeid="8913">完全重合</strong>的情况。</p>
<p data-nodeid="8294">基于此，我们可以得到<strong data-nodeid="8919">结论 1</strong>。</p>
<blockquote data-nodeid="8295">
<p data-nodeid="8296">给定一个数组，这个数组里面的任意一个有效区间<strong data-nodeid="8929">总是</strong>可以表达为：可能重叠的两个 2<sup>p</sup> 长度区间。</p>
</blockquote>
<p data-nodeid="8297">那么，假设我们已经得到所有 2<sup>p</sup> 长度的区间的信息。那么“区间 [start, end] 上的最小值：可以先取出两个长度为 2<sup>p</sup> 的子区间的最小值，再从中选择最小的即可。</p>
<pre class="lang-java" data-nodeid="8298"><code data-language="java">区间[start, end]上的最小值 = min(区间[l, l+2&lt;sup&gt;p&lt;/sup&gt;)上的最小值
                         区间[r-2&lt;sup&gt;p&lt;/sup&gt;+1, r]上的最小值)
</code></pre>
<p data-nodeid="8299">基于结论 1，我们可以得到<strong data-nodeid="8948">结论 2</strong>。</p>
<blockquote data-nodeid="8300">
<p data-nodeid="8301">计算顺序：</p>
<ol data-nodeid="8302">
<li data-nodeid="8303">
<p data-nodeid="8304">先计算出长度为 2<sup>0</sup> 的所有区间的最小值；</p>
</li>
<li data-nodeid="8305">
<p data-nodeid="8306">再计算长度为 2<sup>1</sup> 的所有区间的最小值；</p>
</li>
<li data-nodeid="8307">
<p data-nodeid="8308">然后计算长度为 2<sup>2</sup> 的所有区间的最小值；</p>
</li>
<li data-nodeid="8309">
<p data-nodeid="8310">直到长度为 2<sup>x</sup> 的区间的最小值。</p>
</li>
</ol>
<blockquote data-nodeid="8311">
<p data-nodeid="8312">其中 2<sup>x</sup> 刚好大于等于给定的数组长度。</p>
</blockquote>
</blockquote>
<h5 data-nodeid="8313">2. 指数表示法</h5>
<p data-nodeid="8314">当拆分完成之后，原本一个区间的表示是 [start, end]，分为两个长度（len）一样的区间。更进一步，这两个区间可以表示为 &lt;start1, len&gt;, &lt;start2, len&gt;。</p>
<p data-nodeid="34976" class="">例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10, len=8&gt;, &lt;start2=11, len=8&gt;。</p>

<p data-nodeid="8316">例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10, len=4&gt;, &lt;start2=14,len=4&gt;。</p>
<p data-nodeid="8317">重新表示之后，区间 &lt;start, len&gt; 中，由于长度信息 len 总是 2<sup>p</sup>，因此我们可以只记录<strong data-nodeid="9016">指数 p</strong>。</p>
<p data-nodeid="8318">例 1 中 [10, 18] 拆分之后，可以表示为 &lt;start1=10, p=3&gt;, &lt;start2=11, p=3&gt;。</p>
<p data-nodeid="8319">例 2 中 [10, 17] 拆分之后，可以表示为 &lt;start1=10, p=2&gt;, &lt;start2=14,p=2&gt;。</p>
<p data-nodeid="8320">如果我们将区间采用指数 p 表示之后，就只需要使用空间 st[N][log2(N)+1]，也就是空间复杂度为 O(NlgN)。</p>
<p data-nodeid="8321">那么基于以上两个核心思想，我们可以写出 ST 算法的代码了。这里可以分为两步，一步是预处理，另一步是查询。</p>
<p data-nodeid="8322"><strong data-nodeid="9062">预处理构建 st[][] 数组代码如下</strong>：</p>
<pre class="lang-java" data-nodeid="8323"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[][] st)</span> </span>{
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
  <span class="hljs-comment">// 第一步：</span>
  <span class="hljs-comment">//    - 处理长度为1的区间</span>
  <span class="hljs-comment">//      即[i, i + 1)</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// 区间的表示：</span>
  <span class="hljs-comment">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
  <span class="hljs-comment">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
    st[i][<span class="hljs-number">0</span>] = A[i];
  }
  <span class="hljs-comment">// 递推：</span>
  <span class="hljs-comment">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>
  <span class="hljs-comment">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>
  <span class="hljs-comment">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= N; j++) {
    <span class="hljs-comment">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>
    <span class="hljs-comment">// last = i + (1&lt;&lt;j)</span>
    <span class="hljs-comment">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; (i + (<span class="hljs-number">1</span> &lt;&lt; j)) &lt;= N; i++) {
      st[i][j] = Math.min(st[i][j - <span class="hljs-number">1</span>], 
                          st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);
    }
  }
}
</code></pre>
<p data-nodeid="8324"><strong data-nodeid="9066">查询阶段的代码如下：</strong></p>
<pre class="lang-java" data-nodeid="8325"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] st, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span>
</span>{
  <span class="hljs-comment">// 这里我们将区间[l, r]分为两个区间</span>
  <span class="hljs-comment">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>
  <span class="hljs-comment">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>
  <span class="hljs-keyword">int</span> len = r - l + <span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> j = log2(len);
  <span class="hljs-keyword">return</span> Math.min(st[l][j], st[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);
}
</code></pre>
<p data-nodeid="8326">需要注意的是，在查询阶段，如果一个区间的长度本来就是 2<sup>p</sup>，那么就可以拆分成两个完全重合的区间。</p>
<p data-nodeid="8327">得到 ST 算法的代码之后，我们就可以开始解决这道题目了。代码如下：</p>
<pre class="lang-java" data-nodeid="8328"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">log2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>{
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)(Math.log(N) / Math.log(<span class="hljs-number">2</span>));
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] createST(<span class="hljs-keyword">int</span> N) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> powerOf2 = log2(N);
        <span class="hljs-keyword">int</span>[][] st = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N][powerOf2 + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            st[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[powerOf2+<span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">return</span> st;
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span>[][] st)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-comment">// 第一步：</span>
        <span class="hljs-comment">//    - 处理长度为1的区间</span>
        <span class="hljs-comment">//      即[i, i + 1)</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// 区间的表示：</span>
        <span class="hljs-comment">//      [start=i, len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
        <span class="hljs-comment">//      也就是st[i][len=2&lt;sup&gt;0&lt;/sup&gt;]</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            st[i][<span class="hljs-number">0</span>] = A[i];
        }
        <span class="hljs-comment">// 递推：</span>
        <span class="hljs-comment">//      依次处理2&lt;sup&gt;j&lt;/sup&gt;长度。</span>
        <span class="hljs-comment">//      其中2&lt;sup&gt;j&lt;/sup&gt; = 2&lt;sup&gt;(j-1)&lt;/sup&gt; + 2&lt;sup&gt;(j-1)&lt;/sup&gt;</span>
        <span class="hljs-comment">//      注意：这里的长度都是完整的2&lt;sup&gt;j&lt;/sup&gt;的</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; j) &lt;= N; j++) {
            <span class="hljs-comment">// 这里要处理的区间[i, i + (1&lt;&lt;j)]</span>
            <span class="hljs-comment">// last = i + (1&lt;&lt;j)</span>
            <span class="hljs-comment">// 根据左闭右开原则，last是可以取到n的。这点要注意。</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; (i + (<span class="hljs-number">1</span> &lt;&lt; j)) &lt;= N; i++) {
                st[i][j] = Math.min(st[i][j - <span class="hljs-number">1</span>],
                                    st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);
            }
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minHeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] st, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{
        <span class="hljs-comment">// 这里我们将区间[l, r]分为两个区间</span>
        <span class="hljs-comment">// [l, l+log2(len)] =&gt; [l, len=log2(len)]</span>
        <span class="hljs-comment">// [r-log2(len)+1, r] =&gt; [r-log2(len) + 1, len=log2(len)]</span>
        <span class="hljs-keyword">int</span> len = r - l + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> j = log2(len);
        <span class="hljs-keyword">return</span> Math.min(st[l][j], st[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-keyword">int</span>[][] st = createST(N);
        buildST(A, st);
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
                ans = Math.max(ans, 
                  minHeight(st, i, j) * (j - i + <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="8329">
<p data-nodeid="8330">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9076">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9080">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.st.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9084">Python</a></p>
</blockquote>
<p data-nodeid="8331">不过，这种算法的时间复杂度仍然是 O(N<sup>2</sup>)。这里请你思考一下，还有没有更好的办法呢？</p>
<h4 data-nodeid="8332">线段树</h4>
<p data-nodeid="8333">不妨尝试一下线段树。在处理区间信息的时候，线段树是一个非常有用的数据结构。下面我们来了解一下它的特点（可以先不管它长什么样）：</p>
<ul data-nodeid="8334">
<li data-nodeid="8335">
<p data-nodeid="8336">构建线段树，时间复杂度为 O(NlgN)；</p>
</li>
<li data-nodeid="8337">
<p data-nodeid="8338">查询阶段，时间复杂度为 O(lgN)；</p>
</li>
<li data-nodeid="8339">
<p data-nodeid="8340">空间复杂度为 O(4N)。</p>
</li>
</ul>
<h5 data-nodeid="8341">1. 线段树的思想</h5>
<p data-nodeid="8342"><strong data-nodeid="9102">线段树的思想</strong>是用一棵平衡二叉树来表示一个数组区间上的信息：</p>
<ul data-nodeid="8343">
<li data-nodeid="8344">
<p data-nodeid="8345">根结点记录整个数组的信息；</p>
</li>
<li data-nodeid="8346">
<p data-nodeid="8347">左子树记录数组左半部分的信息；</p>
</li>
<li data-nodeid="8348">
<p data-nodeid="8349">右子树记录数组右半部分的信息。</p>
</li>
</ul>
<p data-nodeid="8350"><strong data-nodeid="9113">【例 1】</strong> 假设给定的数组为 A[] = {1, 2, 3, 4}，需要记录的信息为区间里面的最小值。那么线段树构成如下：</p>
<p data-nodeid="8351"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nKANd_2AACTipb_MQs065.png" alt="Drawing 5.png" data-nodeid="9116"></p>
<p data-nodeid="8352">那么查询的时候，就需要从根结点开始往下查。假设我们要基于这棵树查询区间 [1, 3] 的最小值信息。</p>
<ul data-nodeid="8353">
<li data-nodeid="8354">
<p data-nodeid="8355"><strong data-nodeid="9125">第 1 步</strong></p>
</li>
</ul>
<p data-nodeid="8356">首先，我们访问到根结点，可以发现 [0, 3] 区间与 [1, 3] 区间处于相交的情况，因此根结点的信息，对于我们要查询的结果是没有帮助的，所以需要将 [0, 3] 区间拆分为 [0, 1] 和 [2,3] 区间。</p>
<p data-nodeid="8357"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__nyAG63XAACqx6B5uVU521.png" alt="Drawing 6.png" data-nodeid="9149"></p>
<p data-nodeid="8358">这里我们得到<strong data-nodeid="9155">原则 1</strong>：</p>
<blockquote data-nodeid="8359">
<p data-nodeid="8360">区间相交的时候，需要拆分树结点区间，然后分别看左右子树。</p>
</blockquote>
<ul data-nodeid="8361">
<li data-nodeid="8362">
<p data-nodeid="8363"><strong data-nodeid="9160">第 2 步</strong></p>
</li>
</ul>
<p data-nodeid="8364">接下来，我们先看左子树，可以发现区间 [0, 1] 与区间 [1,3] 仍然是处于相交的状态。</p>
<p data-nodeid="8365"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__oKAY7Z0AACvIcu60-4225.png" alt="Drawing 7.png" data-nodeid="9172"></p>
<p data-nodeid="8366">因此还需要再次利用原则 1，分别观察它们的左右子树，如下图所示：</p>
<p data-nodeid="8367"><img src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__oiAT5PpAACwh7u3Cyk265.png" alt="Drawing 8.png" data-nodeid="9176"></p>
<p data-nodeid="8368">我们再接着遍历左右子树的时候，不难发现有以下两种情况:</p>
<p data-nodeid="8369">Case 1. [0,0] 与区间 [1,3] 不相交，无视 [0,0] 区间上的信息；</p>
<p data-nodeid="8370">Case 2. [1,1] 被区间 [1,3] 包含，需要保留这个区间上的信息。</p>
<p data-nodeid="39092" class="">由此，我们就得到<strong data-nodeid="39102">原则 2</strong> 和<strong data-nodeid="39103">原则 3</strong>。</p>

<blockquote data-nodeid="8372">
<p data-nodeid="8373"><strong data-nodeid="9218">原则 2：树结点区间与查询区间不相交时，无视树结点的信息。</strong><br>
<strong data-nodeid="9219">原则 3：树结点区间包含查询区间内部时，保留树结点的信息。</strong></p>
</blockquote>
<ul data-nodeid="8374">
<li data-nodeid="8375">
<p data-nodeid="8376"><strong data-nodeid="9223">第 3 步</strong></p>
</li>
</ul>
<p data-nodeid="8377">最后，看一下右边子树，我们发现 [2, 3] 树结点区间包含查询区间，因此，需要使用原则 3。</p>
<p data-nodeid="8378"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__piAASjRAACwfmU76M4079.png" alt="Drawing 9.png" data-nodeid="9231"></p>
<ul data-nodeid="8379">
<li data-nodeid="8380">
<p data-nodeid="8381"><strong data-nodeid="9235">第 4 步</strong></p>
</li>
</ul>
<p data-nodeid="8382">那么最终，我们只选取两个树结点的信息，如下图所示：</p>
<p data-nodeid="8383"><img src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__p-AaesyAADICuyRzZ8398.png" alt="Drawing 10.png" data-nodeid="9239"></p>
<p data-nodeid="8384">那么我们可以得到区间 [1,3] 上的最小值：</p>
<blockquote data-nodeid="8385">
<p data-nodeid="8386">min([1,1] 区间上的最小值，[2,3] 区间上的最小值) = 2</p>
</blockquote>
<p data-nodeid="8387">经过上面的查询，这里我总结了 3 个原则。</p>
<blockquote data-nodeid="8388">
<p data-nodeid="8389">原则 1：区间相交的时候，需要拆分树结点区间，然后分别看左右子树。<br>
原则 2：树结点区间与查询区间不相交时，无视树结点的信息。<br>
原则 3：树结点区间包含查询区间内部时，保留树结点的信息。</p>
</blockquote>
<p data-nodeid="8390">3 个原则分别代表区间之间的三种关系。你不需要去死记这个关系，只需要注意以下两点：</p>
<ul data-nodeid="8391">
<li data-nodeid="8392">
<p data-nodeid="8393">树中的结点的区间会不停地拆分；</p>
</li>
<li data-nodeid="8394">
<p data-nodeid="8395">查询区间一直固定不变。</p>
</li>
</ul>
<h5 data-nodeid="8396">2. 查询的本质</h5>
<p data-nodeid="8397">似乎让你单纯地记录这个查询流程太枯燥了，因此我们还需要更深入地去想一下线段树查询的本质，理解之后再去记忆就比较简单了。你可以这样想，给定一个二叉树，然后又给了一个查询区间，那么可以把查询的过程表示成 2 步。</p>
<ul data-nodeid="8398">
<li data-nodeid="8399">
<p data-nodeid="8400">第 1 步：裁剪</p>
</li>
</ul>
<p data-nodeid="8401">我们修剪一下这棵二叉树，让所有的叶子结点都在查询区间范围内。</p>
<p data-nodeid="8402"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__q2APtnlAADfBsWCUTs679.png" alt="Drawing 11.png" data-nodeid="9271"></p>
<p data-nodeid="84386">需要注意的是，当区间 [2,3] 已经包含查询区间的时候，其子树上的结点就没有必要保留了。最终，我们将灰色的树结点都去掉，只保留：<br>
1） “包含”查询区间的叶结点；<br>
2）根结点到这些叶结点的<strong data-nodeid="84403">路径</strong>。</p>
<ul data-nodeid="84387">
<li data-nodeid="84388">
<p data-nodeid="84389">第 2 步：收集叶子结点的信息</p>
</li>
</ul>





















<p data-nodeid="8411"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__rWAFHv2AACwSnQB1C4869.png" alt="Drawing 12.png" data-nodeid="9286"></p>
<p data-nodeid="8412">当裁剪完成之后，只需要再查看存留的二叉树的叶结点信息就可以了。</p>
<p data-nodeid="8413">不过我们这里并不真正地去裁剪这棵二叉树，而是在遍历的时候，只提取出相应的信息（区间上的最小值）即可。</p>
<p data-nodeid="8414">下面是一道关于二叉树的裁剪的练习题，希望你可以尝试解决一下。</p>
<p data-nodeid="86457" class=""><strong data-nodeid="86466">练习题 1</strong>： 给你二叉搜索树的根结点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使所有结点的值在 [low, high] 中。修剪树不应该改变保留在树中的元素的相对结构（如果没有被移除，原有的父代子代关系都应当保留）。可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根结点。注意，根结点可能会根据给定的边界发生改变。</p>

<p data-nodeid="8416">输入如下所示的二叉搜索树，并且 low = 1，high = 3。</p>
<p data-nodeid="8417"><img src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__r6AYsviAACOtqFSsXc299.png" alt="Drawing 13.png" data-nodeid="9302"></p>
<p data-nodeid="8418">输出：</p>
<p data-nodeid="8419"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__sWAaVRCAABqvED48GE222.png" alt="Drawing 14.png" data-nodeid="9306"></p>
<blockquote data-nodeid="8420">
<p data-nodeid="8421">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9310">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9314">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9318">Python</a></p>
</blockquote>
<p data-nodeid="8422">完成练习题之后，你可以想一下，线段树查询与练习题 1 的裁剪有什么异同点？可以把你的思考写在留言区，我们一起讨论。</p>
<h5 data-nodeid="8423">3. 线段树的更新</h5>
<p data-nodeid="8424">虽然这道题没有用到<strong data-nodeid="9328">线段树的更新</strong>，但是面试的时候你可能会用到，所以我们还是要讲一下，</p>
<p data-nodeid="8425">当我们要更新某个区间上的值时，需要将线段树路径上所有的点的区间信息都更新掉（更新的时候，采用后续遍历即可），如下图所示：</p>
<p data-nodeid="8426"><img src="https://s0.lgstatic.com/i/image6/M01/3A/90/Cgp9HWB__tGALBeoAADYdvwyPEo939.png" alt="Drawing 15.png" data-nodeid="9332"></p>
<h5 data-nodeid="8427">4. 线段树的存储</h5>
<p data-nodeid="8428">可能现在你准备开始用包含左右指针的二叉树写线段树了，不过还有更高效的方式——用数组表示一棵二叉树。</p>
<p data-nodeid="8429">你可以回忆一下，“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9342">03 | 优先级队列：堆与优先级队列，筛选最优元素</a>”学习堆的时候，我们已经用过一个数组来表示二叉树了，如下图所示：</p>
<p data-nodeid="8430"><img src="https://s0.lgstatic.com/i/image6/M00/3A/90/Cgp9HWB__t2AaDg8AADItUzBiIo402.png" alt="Drawing 16.png" data-nodeid="9346"></p>
<p data-nodeid="94677" class="">这里也可以用数组来表示线段树，主要是因为：</p>


<ul data-nodeid="8432">
<li data-nodeid="8433">
<p data-nodeid="8434">数组具有更好的内存连续性；</p>
</li>
<li data-nodeid="8435">
<p data-nodeid="8436">内存连续性对 CPU 缓存更友好；</p>
</li>
<li data-nodeid="8437">
<p data-nodeid="8438">对 CPU 缓存更友好的数据结构能够运行得更快。</p>
</li>
</ul>
<p data-nodeid="8439">但是，通常我们学习的二叉树表示，会不停地 new TreeNode() 导致内存特别碎片化，因此对 CPU 缓存并不友好，导致运行得变慢。</p>
<p data-nodeid="8440">当给定一个数组的时候，我们需要利用这个树创建一个线段树。根据线段树的定义：</p>
<ul data-nodeid="8441">
<li data-nodeid="8442">
<p data-nodeid="8443">根结点记录整个数组的信息；</p>
</li>
<li data-nodeid="8444">
<p data-nodeid="8445">左子树记录数组左半部分的信息；</p>
</li>
<li data-nodeid="8446">
<p data-nodeid="8447">右子树记录数组右半部分的信息。</p>
</li>
</ul>
<p data-nodeid="8448">这里我们可以肯定的是，根结点的信息，实际上需要依赖左子树的信息，以及右子树的信息才能够生成的。所以，这个二叉树的创建肯定是一个后序遍历。</p>
<p data-nodeid="8449">然后再根据数组表示二叉树的方法，有以下 3 种：</p>
<ul data-nodeid="8450">
<li data-nodeid="8451">
<p data-nodeid="8452">i 结点的父结点 par = (i-1)/2；</p>
</li>
<li data-nodeid="8453">
<p data-nodeid="8454">i 结点的左子结点 2 * i + 1；</p>
</li>
<li data-nodeid="8455">
<p data-nodeid="8456">i 结点的右子结点 2 * i + 2。</p>
</li>
</ul>
<h5 data-nodeid="8457">5. 线段树的模板代码</h5>
<p data-nodeid="8458">此时，我们可以写出线段树的模板代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8459"><code data-language="java"><span class="hljs-comment">// 表示线段树的数组treeArray[]</span>
<span class="hljs-comment">// 数组里面的值表示区间里面的最小值</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] treeArray = <span class="hljs-keyword">null</span>;
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftNodePos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos)</span> </span>{
    <span class="hljs-keyword">return</span> (rootPos &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightNodePos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos)</span> </span>{
    <span class="hljs-keyword">return</span> (rootPos &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>;
}
<span class="hljs-comment">// treeArray[rootPos] 将会记录数组[start, end]</span>
<span class="hljs-comment">// 这个区间上的信息。在本题中，信息为区间上的最小值</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span>[] A, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
    <span class="hljs-comment">// 范围为空</span>
    <span class="hljs-keyword">if</span> (start &gt; end)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">// 如果区间：只有一个数</span>
    <span class="hljs-keyword">if</span> (start == end) {
        treeArray[rootPos] = A[start];
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 否则需要将区间分为两半</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
        buildTree(leftNodePos(rootPos), A, start, mid);
        buildTree(rightNodePos(rootPos), A, mid + <span class="hljs-number">1</span>, end);
        <span class="hljs-comment">// 构建成功之后，需要利用左子树的信息和右子树的信息来</span>
        <span class="hljs-comment">// 来更新 [start, end] rootNode 的信息</span>
        treeArray[rootPos] =
            Math.min(treeArray[leftNodePos(rootPos)], 
                     treeArray[rightNodePos(rootPos)]);
    }
}
<span class="hljs-comment">/**
 * 查询区间[queryStart, queryEnd]这个区间上的最小值信息
 *
 * treeArray[rootPos]表示区间 [start, end]上的最小值。
 * 可以把前面的三个参数看成
 * class TreeNode {
 *      int val;        &lt;-- arg: treeArray[rootPos];
 *      int rangeStart; &lt;-- arg: start
 *      int rangeEnd:   &lt;-- arg: end
 *      TreeNode left;  &lt;-- leftNodePos(rootPos);
 *      TreeNode right: &lt;-- rightNodePos(rootPos);
 * }
 */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">queryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end,
                      <span class="hljs-keyword">int</span> queryStart, <span class="hljs-keyword">int</span> queryEnd)</span> </span>{
    <span class="hljs-comment">// 无效区间，返回最大值</span>
    <span class="hljs-keyword">if</span> (start &gt; end || queryStart &gt; queryEnd) {
        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
    }
    <span class="hljs-comment">// 原则1： 包含于查询区间内部</span>
    <span class="hljs-keyword">if</span> (queryStart &lt;= start &amp;&amp; end &lt;= queryEnd) {
        <span class="hljs-keyword">return</span> treeArray[rootPos];
    }
    <span class="hljs-comment">// 原则2：不相交时，放弃区间信息，这里我们返回最大值</span>
    <span class="hljs-keyword">if</span> (end &lt; queryStart || queryEnd &lt; start) {
        <span class="hljs-keyword">return</span> Integer.MAX_VALUE;
    }
    <span class="hljs-comment">// 原则3：当相交的时候，需要将[start, end]进行拆分</span>
    <span class="hljs-comment">// 由于我们建树的时候，都是平分，所以这里将区间也进行平分</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> Math.min(queryTree(leftNodePos(rootPos),
                               start, mid, queryStart, queryEnd),
                    queryTree(rightNodePos(rootPos),
                               mid + <span class="hljs-number">1</span>, end, queryStart, queryEnd));
}
<span class="hljs-comment">// 当我们要更新数组中A[inx] = value的时候</span>
<span class="hljs-comment">// 线段树中存储的区间的信息，也是需要更新的</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootPos, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end,
                <span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> value)</span> </span>{
    <span class="hljs-comment">// 如果树中的结点不在我们的更新路径上</span>
    <span class="hljs-keyword">if</span> (start &gt; end || idx &lt; start || idx &gt; end) {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 如果已经找到了叶子结点</span>
    <span class="hljs-keyword">if</span> (start == idx &amp;&amp; idx == end) {
        treeArray[rootPos] = value;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// 这里后序遍历</span>
    <span class="hljs-comment">// 如果是非叶子结点，那么</span>
    <span class="hljs-comment">// 先更新左右子结点，再更新根结点</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 更新左子树</span>
    updateTree(leftNodePos(rootPos), start, mid, idx, value);
    <span class="hljs-comment">// 更新右子树</span>
    updateTree(rightNodePos(rootPos), mid + <span class="hljs-number">1</span>, end, idx, value);
    <span class="hljs-comment">// 更新根结点</span>
    treeArray[rootPos] =
        Math.min(treeArray[leftNodePos(rootPos)],
                 treeArray[rightNodePos(rootPos)]);
}
</code></pre>
<blockquote data-nodeid="8460">
<p data-nodeid="8461">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9372">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9376">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9380">Python</a></p>
</blockquote>
<p data-nodeid="8462">那么我们通过使用线段树，就写出求解的代码了，如下所示（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8463"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">// ... 并查集的模板代码....</span>
   <span class="hljs-function"><span class="hljs-keyword">public</span>
    <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
        treeArray = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N &lt;&lt; <span class="hljs-number">2</span>];
        buildTree(<span class="hljs-number">0</span>, heights, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; N; j++) {
                <span class="hljs-comment">// rootPos = 0表示根结点</span>
                <span class="hljs-comment">// [0, N-1]表示根结点代表：[0, N-1]这个区间上的最小值信息</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> minHeight = queryTree(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>, i, j);
                ans = Math.max(ans, minHeight * (j - i + <span class="hljs-number">1</span>));
            }
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="8464">
<p data-nodeid="8465">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9385">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9389">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.segtree.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9393">Python</a></p>
</blockquote>
<p data-nodeid="8466">接下来，我们分析一下时间复杂度，一共会有 N x N 个区间需要查询，每次查询的时间复杂度为 O(lgN)，所以时间复杂度为 O(N<sup>2</sup> lgN)，空间复杂度为 O(N)。</p>
<p data-nodeid="8467">到这里，我们利用一些区间信息查找常用的手段进行了优化：</p>
<ul data-nodeid="8468">
<li data-nodeid="8469">
<p data-nodeid="8470">使用 ST 算法将时间复杂度优化到 O(N<sup>2</sup>)；</p>
</li>
<li data-nodeid="8471">
<p data-nodeid="8472">使用线段树将时间复杂度优化到O(N<sup>2</sup> lgN)。</p>
</li>
</ul>
<p data-nodeid="8473">可是，这两种算法都还是会超时，接下来应该怎么办呢？</p>
<p data-nodeid="8474">其实，真正面试的时候，你应该注意，一开始找到的题目特点是基于区间查询的方式，实际上就把优化的上限限定死了。一共有 N x N 个区间要查，无论查多快，时间复杂度都不会比 O(N x N) 更好。</p>
<p data-nodeid="8475">这就意味着，一开始，我们破题的大方向就是错的。当然，在这里我是发扬了要把一个题的特点深挖到底的精神，在练习的时候可以这么操作。如果是在面试中，还没有走到使用 ST 算法，线段树，就应该尝试寻找题目的其他特点了。</p>
<h3 data-nodeid="8476">特点 2：选与不选</h3>
<p data-nodeid="8477">首先，我们假设问题是有一个最优解的，而这个<strong data-nodeid="9423">最优解</strong>肯定是<strong data-nodeid="9424">原始数组的一个连续子数组</strong>。那么，对于数组中的元素而言，就存在 2 种可能：</p>
<ul data-nodeid="8478">
<li data-nodeid="8479">
<p data-nodeid="8480">被最优解选中</p>
</li>
<li data-nodeid="8481">
<p data-nodeid="8482">没有被最优解选中</p>
</li>
</ul>
<p data-nodeid="8483">但是，如果我们去讨论每个元素的选/不选，时间复杂度就会瞬间爆炸到 O(2<sup>N</sup>)。但是你先别着急放弃这个特点，我们决心把这个特点死磕到底。</p>
<p data-nodeid="8484">接着看题目，由于最大矩形的制约因素是被选中<strong data-nodeid="9441">区域的最小值</strong>制约的。那么当给定一个区域 [start, end] 的时候，对于这个区间里面的最小值而言，只有两种可能。</p>
<p data-nodeid="8485">第一种可能：被最优解选中，此时解为 area = minHeight * (end - start + 1)。</p>
<p data-nodeid="8486">第二种可能：没有被最优解选中，那么可以利用最小值，将区域切分为两半：</p>
<ul data-nodeid="98783">
<li data-nodeid="98784">
<p data-nodeid="98785" class="">计算左边区域的最大矩形的面积；</p>
</li>
<li data-nodeid="98786">
<p data-nodeid="98787">计算右边区域的最大矩形的面积。</p>
</li>
</ul>

<p data-nodeid="8492">然后再取这两种可能的最大矩形面积。</p>
<p data-nodeid="8493">我们发现，利用区间里面的最小值（选/不选），可以将区间切分为更小的区间。</p>
<p data-nodeid="8494"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__vmAdDMGAAX2VnfI0w8074.png" alt="Drawing 17.png" data-nodeid="9452"></p>
<p data-nodeid="8495">此时，我们就可以使用分治算法了。</p>
<h4 data-nodeid="8496">分治算法 1</h4>
<p data-nodeid="8497">根据前面的思路，我们可以写出分治的代码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8498"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">// 这里得到一个区域里面的最大矩形面积</span>
    <span class="hljs-comment">// 这个区间域为[b, e)</span>
    <span class="hljs-comment">// 注意e是取不到的</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRangeMaxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
        <span class="hljs-comment">// 如果为空区间</span>
        <span class="hljs-keyword">if</span> (b &gt;= e) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-comment">// 如果区间中只有一个元素</span>
        <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
            <span class="hljs-keyword">return</span> heights[b];
        }
        <span class="hljs-comment">// 如果有多个元素。那么找到范围里面的最小值</span>
        <span class="hljs-comment">// 如果有多个最小值，那么我们就找离中心最近的那个，尽量把区域进行等分</span>
        <span class="hljs-keyword">int</span> mid = b + ((e-b) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> minIndex = b;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b + <span class="hljs-number">1</span>; i &lt; e; i++) {
            <span class="hljs-keyword">if</span> (heights[i] &lt; heights[minIndex]) {
                minIndex = i;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[minIndex]) {
                <span class="hljs-comment">// 多个最小值，那么谁离mid更近，我们用谁</span>
                <span class="hljs-keyword">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
                    minIndex = i;
                }
            }
        }
        <span class="hljs-comment">// 在使用 最小值 情况下的面积</span>
        <span class="hljs-keyword">int</span> useMinIndexArea = heights[minIndex] * (e - b);
        <span class="hljs-comment">// 不用 minIndex 那么就会把区间分为两部分</span>
        <span class="hljs-keyword">int</span> leftMaxArea = getRangeMaxArea(heights, b, minIndex);
        <span class="hljs-keyword">int</span> rightMaxArea = getRangeMaxArea(heights, minIndex + <span class="hljs-number">1</span>, e);
        <span class="hljs-keyword">return</span> Math.max(useMinIndexArea,
                         Math.max(leftMaxArea, rightMaxArea));
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
        <span class="hljs-keyword">return</span> getRangeMaxArea(heights, <span class="hljs-number">0</span>, N);
    }
}
</code></pre>
<blockquote data-nodeid="8499">
<p data-nodeid="8500">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9459">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9463">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9467">Python</a></p>
</blockquote>
<p data-nodeid="8501"><strong data-nodeid="9476">复杂度分析</strong>：正常情况下，时间复杂度为 O(NlgN)，最差情况下，比如数组是一个已排序的数组，并且里面元素都不相同，那么时间复杂度会变为 O(N<sup>2</sup>)，空间复杂度为 O(lgN)。</p>
<p data-nodeid="8502">【<strong data-nodeid="9488">小结</strong>】这里你可以回想一下我们在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6697&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9486">08 | 排序：如何利用合并与快排的小技巧，解决算法难题？</a>”学习的排序技巧，原来我们学习快速排序的时候，会用“三路切分”将区间分为三部分。而在这里，我们是用最小值将区间切分成两半。</p>
<p data-nodeid="8503">那么有没有办法可以进一步优化呢？我们可以看到，分治的核心代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8504"><code data-language="java"><span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
<span class="hljs-keyword">int</span> minIndex = b;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = b + <span class="hljs-number">1</span>; i &lt; e; i++) {
  <span class="hljs-keyword">if</span> (heights[i] &lt; heights[minIndex]) {
    minIndex = i;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heights[i] == heights[minIndex]) {
    <span class="hljs-comment">// 多个最小值，那么谁离mid更近，我们用谁</span>
    <span class="hljs-keyword">if</span> (Math.abs(mid - i) &lt; Math.abs(mid - minIndex)) {
      minIndex = i;
    }
  }
}
</code></pre>
<p data-nodeid="8505">这段代码本质就是在搜索一个区间里面的最小值。如果你还有印象，寻找一个区间的信息，我们可以得到如下信息：</p>
<ul data-nodeid="8506">
<li data-nodeid="8507">
<p data-nodeid="8508">ST 算法预处理时间复杂度 O(NlgN)，查询区间最小值 O(1)，空间复杂度 O(NlgN)；</p>
</li>
<li data-nodeid="8509">
<p data-nodeid="8510">线段树建树 O(NlgN)，查询区间最小值 O(lgN)，空间复杂度 O(N)。</p>
</li>
</ul>
<p data-nodeid="8511">下面我再给你留两个练习题，请你分别用这两个算法再优化一下分治算法。如果有什么疑问，可以写在留言区，我会逐一为你解答。</p>
<p data-nodeid="8512"><strong data-nodeid="9498">练习题 2</strong>：请使用 ST 算法优化分治算法。并且分析优化之后的时间/空间复杂度。</p>
<blockquote data-nodeid="8513">
<p data-nodeid="8514">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9502">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9506">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.st.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9510">Python</a></p>
</blockquote>
<p data-nodeid="8515"><strong data-nodeid="9515">练习题 3</strong>：请使用线段树算法优化我们的分治算法，并且分析优化之后时间/空间复杂度。</p>
<blockquote data-nodeid="8516">
<p data-nodeid="8517">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9519">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9523">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq.seg.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9527">Python</a></p>
</blockquote>
<h4 data-nodeid="8518">分治算法 2</h4>
<p data-nodeid="8519">在前面的分治算法中，我们在切分数组的时候，采用了一个区域里面的最小值进行切分。在最差情况下（数组元素不同且有序），会得到 O(N<sup>2</sup>) 时间复杂度。</p>
<p data-nodeid="8520">不知道你有没有想起我们切分数组的算法。</p>
<ul data-nodeid="8521">
<li data-nodeid="8522">
<p data-nodeid="8523">合并排序：切分的时候，直接从数组的中间开始切分。时间复杂度最差也为 O(NlgN)。</p>
</li>
<li data-nodeid="8524">
<p data-nodeid="8525">快速排序：切分的时候，采用数组中的随机值进行切分。时间复杂度最差也为O(N<sup>2</sup>)。</p>
</li>
</ul>
<p data-nodeid="8526">于是，我们可以得到一个<strong data-nodeid="9545">结论。</strong></p>
<blockquote data-nodeid="8527">
<p data-nodeid="8528">我们在切分数组的时候：如果采用值进行切分，那么最差情况下的时间复杂度会掉到 O(N<sup>2</sup>)；如果采用中间的下标进行切分，那么时间复杂度为 O(NlgN)。</p>
</blockquote>
<p data-nodeid="8529">就这道题而言，如果我们想把分治算法变成 O(NlgN)，应该怎么办？相信你已经想到了方向，那就是切分的时候，采用下标进行切分。</p>
<p data-nodeid="8530">到这里，我们已经可以写出伪代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8531"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRangeArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
    <span class="hljs-keyword">if</span> (b &gt;= e) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// 如果只有一个元素</span>
    <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
        <span class="hljs-keyword">return</span> heights[b];
    }
    <span class="hljs-comment">// 用数组中间的那个元素将数组分为两半</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>
    <span class="hljs-keyword">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);
    <span class="hljs-keyword">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class="hljs-number">1</span>, e);
    <span class="hljs-comment">// 如果一定要包含heights[mid]</span>
    <span class="hljs-comment">// 求出containsMidIndexArea; &lt;-- 那么这里怎么求?</span>
    <span class="hljs-keyword">return</span> Math.max(containsMidIndexArea,
                    Math.max(leftMaxArea, rightMaxArea));
}
</code></pre>
<p data-nodeid="8532">接下来，我们看一下问题的核心部分，当包含 heights[mid] 的时候，应该如何计算？共有两种情况。</p>
<ul data-nodeid="8533">
<li data-nodeid="8534">
<p data-nodeid="8535">Case 1：其他元素都比 heights[mid] 大，heights[mid] 成了短板。</p>
</li>
<li data-nodeid="8536">
<p data-nodeid="8537">Case 2：存在比 heights[mid] 小的元素，heights[mid] 只是参与一下。</p>
</li>
</ul>
<p data-nodeid="8538">关于这两种情况的处理， 核心代码如下：</p>
<pre class="lang-java" data-nodeid="8539"><code data-language="java"><span class="hljs-keyword">int</span> minHeight = heights[mid];
<span class="hljs-keyword">int</span> containsMidIndexArea = minHeight;
<span class="hljs-keyword">int</span> left = m - <span class="hljs-number">1</span>, right = m + <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span> (left &gt;= b || right &lt; e) {
    <span class="hljs-keyword">if</span> (right &gt;= e || left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
        minHeight = min(minHeight, heights[left]);
        left--;
    } <span class="hljs-keyword">else</span> {
        minHeight = min(minHeight, heights[right]);
        right++;
    }
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmp = minHeight * (right - left - <span class="hljs-number">1</span>);
    containsMidIndexArea = max(containsMidIndexArea, tmp);
}
</code></pre>
<p data-nodeid="8540">那么，到此为止，我们就可以写出完全是 O(NlgN) 的代码了。</p>
<pre class="lang-java" data-nodeid="8541"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxRangeArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> e)</span> </span>{
    <span class="hljs-keyword">if</span> (b &gt;= e) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-comment">// 如果只有一个元素</span>
    <span class="hljs-keyword">if</span> (b + <span class="hljs-number">1</span> == e) {
      <span class="hljs-keyword">return</span> heights[b];
    }
    <span class="hljs-comment">// 用数组中间的那个元素将数组分为两半</span>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = b + ((e - b) &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 不包含中间这个元素的时候，那么就只能在这个元素的左边和右边寻找了</span>
    <span class="hljs-keyword">int</span> leftMaxArea = getMaxRangeArea(heights, b, mid);
    <span class="hljs-keyword">int</span> rightMaxArea = getMaxRangeArea(heights, mid + <span class="hljs-number">1</span>, e);
    <span class="hljs-comment">// 如果一定要包含heights[mid]</span>
    <span class="hljs-comment">// 那么就有两种情况。</span>
    <span class="hljs-keyword">int</span> minHeight = heights[mid];
    <span class="hljs-keyword">int</span> containsMidIndexArea = minHeight;
    <span class="hljs-keyword">int</span> left = mid - <span class="hljs-number">1</span>, right = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (left &gt;= b || right &lt; e) {
      <span class="hljs-keyword">if</span> (right &gt;= e || 
          left &gt;= b &amp;&amp; heights[left] &gt;= heights[right]) {
        minHeight = Math.min(minHeight, heights[left]);
        left--;
      } <span class="hljs-keyword">else</span> {
        minHeight = Math.min(minHeight, heights[right]);
        right++;
      }
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> tmp = minHeight * (right - left - <span class="hljs-number">1</span>);
      containsMidIndexArea = Math.max(containsMidIndexArea, tmp);
    }
    <span class="hljs-keyword">return</span> Math.max(containsMidIndexArea,
                    Math.max(leftMaxArea, rightMaxArea));
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = heights == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : heights.length;
    <span class="hljs-keyword">return</span> getMaxRangeArea(heights, <span class="hljs-number">0</span>, N);
  }
}
</code></pre>
<blockquote data-nodeid="8542">
<p data-nodeid="8543">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9581">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9585">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dq2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9589">Python</a></p>
</blockquote>
<p data-nodeid="8544"><strong data-nodeid="9594">复杂度分析</strong>：时间复杂度 O(NlgN)，空间复杂度 O(1)（不算栈空间）。</p>
<p data-nodeid="8545">【<strong data-nodeid="9600">小结</strong>】在写这个算法的时候，我们需要注意两个地方。</p>
<p data-nodeid="8546"><strong data-nodeid="9613">其一</strong>：在处理 heights[mid] 的时候，将<strong data-nodeid="9614">包含</strong>关系分为以下 2 种：</p>
<ul data-nodeid="8547">
<li data-nodeid="8548">
<p data-nodeid="8549">包含 heights[mid]，并且找到的区域内的元素都比 heights[mid] 大；</p>
</li>
<li data-nodeid="8550">
<p data-nodeid="8551">不包含 heights[mid]，这种情况需要递归处理 [b, mid) 和 [mid + 1, e)。</p>
</li>
</ul>
<p data-nodeid="8552">容易出错的地方在于，包含 heights[mid] 的时候，实际上有两种情况的（前面我们提到的Case 1 和 Case 2）。这里只处理了 Case 1，但是没有处理 Case 2。</p>
<p data-nodeid="8553"><strong data-nodeid="9646">其二</strong>：采用这种分治算法，包含 heights[mid] 的时候，采用了双指针的做法，left 和 right 分别向两边推进。但是你需要格外注意，推进的时候，哪边大，则移动哪边的指针。</p>
<p data-nodeid="8554">你能想想为什么吗？请你完成下面的练习题 4，期待看到你理解与思考。</p>
<p data-nodeid="8555"><strong data-nodeid="9658">练习题 4</strong>：这里的分治算法在往左右两边推进的时候，为什么哪边大就往哪边移动呢？你能再想一下，这与“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6700&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9656">11 | 贪心：这种思想，没有模板，如何才能掌握它？</a>”介绍的贪心算法的例 1 有什么异同吗？</p>
<h3 data-nodeid="8556">特点 3：左右两边较小的数</h3>
<p data-nodeid="8557">构成一个矩形的面积的时候，有宽和高。无论是特点 1，还是特点 2，它们都有一个共同点：先固定矩形的宽，再去选择高。</p>
<p data-nodeid="8558">有没有可能反过来呢？我们先去固定高度，再去决定宽度。当我们选择数组中的元素 heights[i] 作为矩形的高度时。寻找宽度需要满足以下两个条件：</p>
<ul data-nodeid="8559">
<li data-nodeid="8560">
<p data-nodeid="8561">i 元素必须要在这个范围内；</p>
</li>
<li data-nodeid="8562">
<p data-nodeid="8563">这个范围内的元素都必须要大于等于 heights[i]。</p>
</li>
</ul>
<p data-nodeid="8564">那么我们就可以称 heights[i] 决定了这个最大范围的面积。</p>
<h4 data-nodeid="8565">小于我的位置</h4>
<p data-nodeid="8566">那么这也就意味着，我们需要解决如下的问题。</p>
<ul data-nodeid="8567">
<li data-nodeid="8568">
<p data-nodeid="8569">数组中元素右边离我最近且比我小的元素的位置</p>
</li>
</ul>
<blockquote data-nodeid="8570">
<p data-nodeid="8571">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9683">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9687">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9691">Python</a></p>
</blockquote>
<ul data-nodeid="8572">
<li data-nodeid="8573">
<p data-nodeid="8574">数组中元素左边离我最近且比我小的元素的位置</p>
</li>
</ul>
<blockquote data-nodeid="8575">
<p data-nodeid="8576">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9696">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9700">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9704">Python</a></p>
</blockquote>
<p data-nodeid="8577">实际上，这两个问题，我们已经在“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9710">01 | 栈：从简单栈到单调栈，解决经典栈问题</a>”介绍单调栈时学过了。那么你现在解决起来，应该是很容易了吧。本讲不再过多叙述，直接给出如下代码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8578"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeftSmall</span>
</span>{
  <span class="hljs-comment">// 当我们要找左边比我小的元素的时候，需要用递增栈</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findLeftSmall(<span class="hljs-keyword">int</span>[] A)
  {
    <span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">null</span> || A.length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">0</span>];
    }
    <span class="hljs-comment">// 结果数组</span>
    <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
    <span class="hljs-comment">// 注意，栈中的元素记录的是下标</span>
    Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    <span class="hljs-comment">// 注意这里的遍历方向发生了变化，因为我们是要找到左边比我小的元素的位置</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = A.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[i];
      <span class="hljs-comment">// 每个元素都遍历栈中的元素完成消除动作</span>
      <span class="hljs-comment">// 这里是递减栈</span>
      <span class="hljs-comment">// 如果发现进来的元素x与栈中元素相比</span>
      <span class="hljs-comment">// 如果大于栈中的元素，那么要把栈中的元素弹出去</span>
      <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
        <span class="hljs-comment">// 消除的时候，记录一下被谁消除了</span>
        ans[t.peek()] = i;
        <span class="hljs-comment">// 消除时候，值更大的需要从栈中消失</span>
        t.pop();
      }
      <span class="hljs-comment">// 剩下的入栈</span>
      t.push(i);
    }
    <span class="hljs-comment">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>
    <span class="hljs-keyword">while</span> (!t.empty()) {
      ans[t.peek()] = -<span class="hljs-number">1</span>;
      t.pop();
    }
    <span class="hljs-keyword">return</span> ans;
  }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RightSmall</span>
</span>{
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] findRightSmall(<span class="hljs-keyword">int</span>[] A)
  {
    <span class="hljs-comment">// 结果数组</span>
    <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];
    <span class="hljs-comment">// 注意，栈中的元素记录的是下标</span>
    Stack&lt;Integer&gt; t = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.length; i++) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = A[i];
      <span class="hljs-comment">// 每个元素都向左遍历栈中的元素完成消除动作</span>
      <span class="hljs-keyword">while</span> (!t.empty() &amp;&amp; A[t.peek()] &gt; x) {
        <span class="hljs-comment">// 消除的时候，记录一下被谁消除了</span>
        ans[t.peek()] = i;
        <span class="hljs-comment">// 消除时候，值更大的需要从栈中消失</span>
        t.pop();
      }
      <span class="hljs-comment">// 剩下的入栈</span>
      t.push(i);
    }
    <span class="hljs-comment">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span>
    <span class="hljs-keyword">while</span> (!t.empty()) {
      ans[t.peek()] = -<span class="hljs-number">1</span>;
      t.pop();
    }
    <span class="hljs-keyword">return</span> ans;
  }
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
</span>{
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span>
  </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
    <span class="hljs-keyword">int</span>[] leftSmall = LeftSmall.findLeftSmall(A);
    <span class="hljs-keyword">int</span>[] rightSmall = RightSmall.findRightSmall(A);
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = A[i];
      <span class="hljs-comment">// 左边比我小的位置</span>
      <span class="hljs-comment">// 右边比我小的位置</span>
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> leftPos = leftSmall[i];
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rightPos = rightSmall[i] == -<span class="hljs-number">1</span> ? N : rightSmall[i];
      <span class="hljs-comment">// 现在我们确定区间(leftPos, rightPos)</span>
      <span class="hljs-comment">// 注意两边都是开区间。在这个区间里面，所有的数肯定都是 &gt;= A[i]的。</span>
      <span class="hljs-comment">// 那么底部的宽度就是</span>
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = rightPos - leftPos - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> area = height * width;
      ans = Math.max(ans, area);
    }
    <span class="hljs-keyword">return</span> ans;
  }
}
</code></pre>
<blockquote data-nodeid="8579">
<p data-nodeid="8580">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9715">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9719">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9723">python</a></p>
</blockquote>
<p data-nodeid="8581"><strong data-nodeid="9728">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(N)。</p>
<p data-nodeid="8582">【<strong data-nodeid="9740">小结</strong>】如果你看到这里，突然感觉代码都很神奇，充满了魔法，就是时候温习一下“<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="9738">01 | 栈：从简单栈到单调栈，解决经典栈问题</a>”中单调栈的“魔法技能”部分了。通过复习有时候也能唤醒你算法的巨龙哦。</p>
<h4 data-nodeid="8583">单调栈的性质</h4>
<p data-nodeid="8584">我们来看递增栈（不是严格递增），栈中元素存放的是数组 A[] 的下标。如下图所示：</p>
<p data-nodeid="8585"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__xWAW9DWAAFqqPVJeyA651.png" alt="Drawing 18.png" data-nodeid="9748"></p>
<p data-nodeid="8586">说明：在这个图中，左边是栈底，右边是栈增长的方向。栈中不同的矩形表示相应 A[] 数组中下标位置相应值的大小。那么，首先基于递增栈的定义，我们可以知道它有如下<strong data-nodeid="9757">特性</strong>：</p>
<blockquote data-nodeid="8587">
<p data-nodeid="8588">栈中存放的下标，如果 i 在 j 之前入栈，那么必然满足 A[i] &lt;= A[j]。</p>
</blockquote>
<p data-nodeid="119325" class="">“<strong data-nodeid="119335">削</strong>”<strong data-nodeid="119336">的定义</strong>：当需要把一个更小的元素入栈的时候，这个更小的元素就会把栈中大的元素出栈，直到栈为空，或者栈顶元素更小，再入栈。</p>





<p data-nodeid="8590">例如：当栈中已经有 &lt;i, j&gt;，现在需要将 A[k] 入栈，但是 A[i] &lt; A[k] &amp;&amp; A[k] &lt; A[j]。那么 A[k] 就会把 A[j] 削出栈。如下图所示：</p>
<p data-nodeid="8591"><img src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__x2AMAmBAAGTLBc-_M4399.png" alt="Drawing 19.png" data-nodeid="9820"></p>
<p data-nodeid="8592">根据这个特性，我们肯定可以得到 A[i] &lt;= A[k] &lt; A[j]。基于这个特性，还可以得出 3 个有用的性质。</p>
<p data-nodeid="8593"><strong data-nodeid="9841">性质 1</strong></p>
<p data-nodeid="8594">如下图所示：</p>
<p data-nodeid="8595"><img src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yOANThzAAFyvMYvHNg791.png" alt="Drawing 20.png" data-nodeid="9845"></p>
<blockquote data-nodeid="8596">
<p data-nodeid="8597">假设 i, j 这两个下标在单调栈中相邻，那么在原数组 A[] 中， (i, j) 这个开区间里面的数都大于 A[j]。</p>
</blockquote>
<p data-nodeid="8598">这里我们采用反证法来证明这个性质。首先给出反证法的条件：</p>
<ul data-nodeid="8599">
<li data-nodeid="8600">
<p data-nodeid="8601">单调栈中连续存放着下标 i, j（但并不代表下标 i,j 是连续的，也就是说 i + 1 不一定等于j）；</p>
</li>
<li data-nodeid="8602">
<p data-nodeid="8603">假设 A[] 数组在 (i, j) 范围中存在 1 个下标 k，即 i &lt; k &lt; j，并且使得 A[k] &lt; A[j] 成立。</p>
</li>
</ul>
<p data-nodeid="8604">证明：如果 A[k] &lt; A[j]，那么将 A[k] 放入单调队列之后，由于 (k, j) 范围里面的数组都大于 A[j]。那么当 A[j] 入栈之后，应该位于 A[k] 之后。于是栈中会形成 &lt;i, k, j&gt; 三个数。但实际上栈中只存放了 &lt;i, j&gt; 两个数，并且 i &lt; k &lt; j，这里存在矛盾。所以在 (i, j) 这个开区间范围里面的数，都必须大于 A[j]。</p>
<p data-nodeid="8605">之所以这些大于 A[j] 的元素没有出现在栈中，是因为这些元素在 A[j] 入栈时可能都在栈中，但是立马都被 A[j] 削出栈了。</p>
<p data-nodeid="8606"><strong data-nodeid="9929">性质 2</strong></p>
<p data-nodeid="8607"><img src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__yuAfVYwAAFqqPVJeyA829.png" alt="Drawing 21.png" data-nodeid="9932"></p>
<p data-nodeid="8608">然后，基于性质 1，当单调栈中有 &lt;i, j, k&gt;3 个原数组的下标。那么可以得到性质 2：</p>
<blockquote data-nodeid="8609">
<p data-nodeid="8610">当单调栈中有 &lt;i, j, k&gt; 3 个数组下标时，其中 (i, k] 这个范围里面的元素，肯定 &gt;= A[j]。</p>
</blockquote>
<p data-nodeid="8611">证明如下：</p>
<ul data-nodeid="8612">
<li data-nodeid="8613">
<p data-nodeid="8614">根据性质 1，可以得到 (i, j) 里面的元素都大于 A[j]，即 A[(i,j)] &gt; A[j]；</p>
</li>
<li data-nodeid="8615">
<p data-nodeid="8616">根据性质 1，还可以得到 (j, k) 里面的元素都大于 A[k]，即 A[(j,k)] &gt; A[k]；</p>
</li>
<li data-nodeid="8617">
<p data-nodeid="8618">由于 j 在 k 之前入栈，所以可以肯定 A[j] &lt;= A[k]。</p>
</li>
</ul>
<p data-nodeid="8619">综上，A[(j,k)] &gt; A[k] &gt;= A[j]，所以可以得出结论 (i, k] 里面的元素肯定 &gt;= A[j]。</p>
<p data-nodeid="8620"><strong data-nodeid="10005">性质 3</strong></p>
<p data-nodeid="8621">现在我们遇到下面这种场景。在单调栈中，已经存放了原数组的两个下标 &lt;i, j&gt;，其中 j 是栈顶元素，现在要把一个更小的值 A[k] 对应的下标 k 入栈。如下图所示：</p>
<p data-nodeid="8622"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zSAIgpuAAGDndzxWPI670.png" alt="Drawing 22.png" data-nodeid="10015"></p>
<p data-nodeid="8623">此时，根据单调栈的性质，需要将 A[j] 弹出栈（有可能 A[k] 已经削除了栈中的很多元素，现在轮到削除 A[j] 了）。那么此时我们可以得到一个<strong data-nodeid="10033">性质 3</strong>：</p>
<blockquote data-nodeid="8624">
<p data-nodeid="8625">原数组 (j, k) 范围里面的数，都大于 A[j]。</p>
</blockquote>
<p data-nodeid="8626">同样，我们可以采用反证法。先给出反证法的条件：</p>
<ul data-nodeid="8627">
<li data-nodeid="8628">
<p data-nodeid="8629">当 k 要入栈时，单调栈中连续存放着下标 i, j（但并不代表下标 i,j 是连续的，也就是说 i + 1 不一定等于 j）；</p>
</li>
<li data-nodeid="8630">
<p data-nodeid="8631">假设范围 (j, k) 中存在<strong data-nodeid="10046">1 个</strong>下标 x；</p>
</li>
<li data-nodeid="8632">
<p data-nodeid="8633">使得 A[x] &lt;= A[j] 成立。</p>
</li>
</ul>
<p data-nodeid="8634">如果有 j &lt; x &lt; k，并且 A[x] &lt;= A[j] 成立，那么单调栈中现在必然存在 A[x] 元素。但是现在栈中存放着 A[j]，并且没有 A[x] 元素。所以得出矛盾。所以性质 3 成立。</p>
<p data-nodeid="8635">其实性质 2 和性质 3 有个比较好记的地方。如果你将范围 (i,j), (j, k) 看成两个“空档”。那么 A[j] 就好像总是挑着两座大山，如下图所示：</p>
<p data-nodeid="8636"><img src="https://s0.lgstatic.com/i/image6/M00/3A/99/CioPOWB__zuAUKHIAAGwv8-dDjM339.png" alt="Drawing 23.png" data-nodeid="10092"></p>
<p data-nodeid="8637">至于 A[j] 和 A[k] 值的大小，当然是比较容易判断的：</p>
<ul data-nodeid="8638">
<li data-nodeid="8639">
<p data-nodeid="8640">如果栈中 j 在 k 之前（且相邻），那么 A[j] &lt; A[k]；</p>
</li>
<li data-nodeid="8641">
<p data-nodeid="8642">如果 A[k] 要削 A[j] 出栈，那么 A[k] &lt; A[j]。</p>
</li>
</ul>
<p data-nodeid="8643">到这里，我们就可以写出代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="8644"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-comment">// 虽然可以用Stack&lt;Integer&gt;，但是这里我们为了更快地操作，我们用</span>
        <span class="hljs-comment">// 数组模拟栈来运行，因为我们知道最多存放的内容实际上就是N个</span>
        <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// s[top-1]表示栈顶元素</span>
        <span class="hljs-keyword">int</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// 注意，这里我们取到了i == N</span>
        <span class="hljs-comment">// 按理说，不应该取到i == N的。但是这时候，主要是为了处理这种数组</span>
        <span class="hljs-comment">// A = [1, 2, 3]</span>
        <span class="hljs-comment">// 没有任何元素会出栈。</span>
        <span class="hljs-comment">// 那么最后我们用一个0元素，把所有的元素都削出栈。</span>
        <span class="hljs-comment">// 这样代码就可以统一处理掉。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++) {
            <span class="hljs-comment">// 注意：当i == N的时候，x = -1;</span>
            <span class="hljs-comment">// 比数组中的元素都要小。</span>
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x = i == N ? -<span class="hljs-number">1</span> : A[i];
            <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">0</span> &amp;&amp; A[s[top - <span class="hljs-number">1</span>]] &gt; x) {
                <span class="hljs-comment">// 计算以A[s[top]]的元素的高度的矩形。</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> height = A[s[--top]];
                <span class="hljs-comment">// i元素要将index = s[top-1]的元素出栈。</span>
                <span class="hljs-comment">// 那么根据性质2/3：</span>
                <span class="hljs-comment">// 此时A[s[top-1] .... i) 这个区间里面的元素都是</span>
                <span class="hljs-comment">// 大于A[s[top-1]]的</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> rightPos = i;
                <span class="hljs-comment">// 这里需要使用性质1.</span>
                <span class="hljs-comment">// 注意：当栈中一个元素都没有的时候，要取-1</span>
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> leftPos = top &gt; <span class="hljs-number">0</span> ? s[top - <span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> width = rightPos - leftPos - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> area = height * width;
                ans = Math.max(ans, area);
            }
            s[top++] = i;
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="8645">
<p data-nodeid="8646">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10136">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10140">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10144">Python</a></p>
</blockquote>
<p data-nodeid="8647"><strong data-nodeid="10149">复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(N)。</p>
<h4 data-nodeid="8648">DP</h4>
<p data-nodeid="8649">前面我们使用单调栈来求解一个左右两边第一个较小的元素的位置。现在我们重新来考虑一下这个问题。</p>
<p data-nodeid="8650"><strong data-nodeid="10156">题目</strong>：数组中左边离我最近且比我小的元素的位置。</p>
<p data-nodeid="8651"><img src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__0WATqoPAACmXg-WF6E452.png" alt="Drawing 24.png" data-nodeid="10159"></p>
<p data-nodeid="8652" class="">我们在考虑的时候，直接考虑最后一个元素的情况（不知道你是否还记得我们<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10163">DP 的最后一步</a>），也就是求解 A[k+1] 左边第一个比较小元素的位置。假设 [0, k] 这个范围元素的解都放在 dp[] 数组里面。如果我们要求 A[k+1] 左边第一个比较小元素的位置。通常的写法如下：</p>
<pre class="lang-java" data-nodeid="8653"><code data-language="java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> pre = k; pre &gt;= <span class="hljs-number">0</span>; pre--) {
  <span class="hljs-keyword">if</span> (A[pre] &lt; A[k+<span class="hljs-number">1</span>]) {
    dp[k+<span class="hljs-number">1</span>] = pre;
    <span class="hljs-keyword">break</span>;
  }
}
</code></pre>
<p data-nodeid="8654">但是这么写，时间复杂度就变成 O(N)。如果要求解“数组中元素左边离我最近且比我小的元素的位置”，问题就秒变 O(N<sup>2</sup>)。而我们知道，如果使用单调栈，是可以在 O(N) 时间复杂度解决的。</p>
<p data-nodeid="8655">我们立马会发现，求解 A[k+1] 的时候，还没有用上 dp[] 数组。那么我们可以这样操作：</p>
<ul data-nodeid="8656">
<li data-nodeid="8657">
<p data-nodeid="8658">首先 A[k] 与 A[k+1] 比较，如果 A[k] &gt;= A[k+1]，那么直接跳到下标 j = dp[k] 这个位置；</p>
</li>
<li data-nodeid="8659">
<p data-nodeid="8660">重复上述步骤，直到找到一个元素比 A[k+1] 小，或者没有任何元素为止。</p>
</li>
</ul>
<p data-nodeid="8661">通过这样的方式，我们可以快速跳过一些元素，使时间复杂度变为 O(lgN)。于是代码可以长成这样：</p>
<pre class="lang-java" data-nodeid="8662"><code data-language="java"><span class="hljs-keyword">int</span> pre = k + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;
<span class="hljs-keyword">while</span> (pre != -<span class="hljs-number">1</span> &amp;&amp; A[pre] &gt;= A[k+<span class="hljs-number">1</span>]) {
    pre = dp[pre];
}
dp[k+<span class="hljs-number">1</span>] = pre;
</code></pre>
<blockquote data-nodeid="8663">
<p data-nodeid="8664">联想 1：你可以想一下，这和 KMP 算法有没有什么相似的地方？<br>
联想 2：你可以再想一下，这和我们学过的并查集有没有什么相似的地方？</p>
</blockquote>
<p data-nodeid="8665">那么我们的求解最大矩形的代码，就可以利用这个思想，写出代码如下：</p>
<pre class="lang-java" data-nodeid="8666"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] A)</span> </span>{
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = A == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : A.length;
        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">int</span>[] lm = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N]; <span class="hljs-comment">// left min的位置</span>
        <span class="hljs-keyword">int</span>[] rm = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N]; <span class="hljs-comment">// right min的位置</span>
        lm[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; i++) {
            <span class="hljs-keyword">int</span> idx = i - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (idx != -<span class="hljs-number">1</span> &amp;&amp; A[idx] &gt;= A[i]) {
                idx = lm[idx];
            }
            lm[i] = idx;
        }
        rm[N - <span class="hljs-number">1</span>] = N;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = N - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            <span class="hljs-keyword">int</span> idx = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (idx != N &amp;&amp; A[idx] &gt;= A[i]) {
                idx = rm[idx];
            }
            rm[i] = idx;
        }
        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            ans = Math.max(ans, A[i] * (rm[i] - lm[i] - <span class="hljs-number">1</span>));
        }
        <span class="hljs-keyword">return</span> ans;
    }
}
</code></pre>
<blockquote data-nodeid="8667">
<p data-nodeid="8668">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10227">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10231">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.dp.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10235">Python</a></p>
</blockquote>
<p data-nodeid="8669"><strong data-nodeid="10240">复杂度分析</strong>：时间复杂度 O(NlgN)，时间复杂度可以类比并查集的跳跃方式，空间复杂度 O(N)。</p>
<h3 data-nodeid="8670">总结</h3>
<p data-nodeid="8671">在这一讲里面，我们采用的总方针是：</p>
<ul data-nodeid="8672">
<li data-nodeid="8673">
<p data-nodeid="8674">深挖题目的特点；</p>
</li>
<li data-nodeid="8675">
<p data-nodeid="8676">对标数据结构/算法特点；</p>
</li>
<li data-nodeid="8677">
<p data-nodeid="8678">将特点进行结合，创造出新的解法。</p>
</li>
</ul>
<p data-nodeid="8679">我们再将本讲介绍的题目进行一个总结和归纳，如下图所示：</p>
<p data-nodeid="8680"><img src="https://s0.lgstatic.com/i/image6/M00/3A/91/Cgp9HWB__1KAJ88RAAEz0wn26MU790.png" alt="Drawing 25.png" data-nodeid="10249"></p>
<h3 data-nodeid="8681">思考题</h3>
<p data-nodeid="8682">这里我再给你留了一下思考题：给定一个仅包含<code data-backticks="1" data-nodeid="10252">0</code>和<code data-backticks="1" data-nodeid="10254">1</code>、大小为<code data-backticks="1" data-nodeid="10256">rows x cols</code>的二维二进制矩阵，找出只包含<code data-backticks="1" data-nodeid="10258">1</code>的最大矩形，并返回其面积。</p>
<blockquote data-nodeid="8683">
<p data-nodeid="8684">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10263">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10267">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/16.Rectangle/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="10271">Python</a></p>
</blockquote>
<p data-nodeid="127549" class="te-preview-highlight">关于最大矩形这一道题，我们就介绍到这里。如果你发现这个题目还有新的特点，还能匹配到新的算法，那么有可能你还会发现新的解法哦。接下来我们将进入 17 | 深度思考子集：如何掌握 5 种通用解法？记得按时来探险。</p>

---

### 精选评论


