<p data-nodeid="2">这一模块我会带你挖掘题目的特点，再对标不同的数据结构与算法，从而得出不同的解法。虽然我们只介绍一道题，但是解题的方法却有很多种，我会带你尝试从不同的角度去击破一道题。</p>
<p data-nodeid="3">关于字符串查找，可以说是一类非常经典的面试题，它可以考察候选人多方面的技能，比如代码基本功、深度思考能力，以及知识广度等。</p>
<ul data-nodeid="4">
<li data-nodeid="5">
<p data-nodeid="6">代码基本功：需要注意各种空字符串，数组访问越界等边界的处理。</p>
</li>
<li data-nodeid="7">
<p data-nodeid="8">深度思考能力：各种字符串查找的算法代码本身不会太长，但是需要你深入理解其原理才能正确地写代码，并且清晰地讲述思路。</p>
</li>
<li data-nodeid="9">
<p data-nodeid="10">知识广度：字符串查找涉及很多种算法，可以借此了解候选人的知识积累。</p>
</li>
</ul>
<p data-nodeid="11">在本讲，将以一道字符串查找的面试题为引，带你深入探索“一题多解”的思考方式，有利于你掌握快速审题和解题的能力。具体来说，学完本讲你将收获：</p>
<ul data-nodeid="12">
<li data-nodeid="13">
<p data-nodeid="14">暴力搜索算法与本质</p>
</li>
<li data-nodeid="15">
<p data-nodeid="16">KMP 算法的改进与扩展</p>
</li>
<li data-nodeid="17">
<p data-nodeid="18">BM 算法</p>
</li>
<li data-nodeid="19">
<p data-nodeid="20">Sunday 算法</p>
</li>
</ul>
<h3 data-nodeid="21">字符串查找</h3>
<p data-nodeid="22">【<strong data-nodeid="423">题目</strong>】实现 strStr() 函数。给定一个 main 字符串和一个 sub 字符串，在 main 字符串中找出 sub 字符串出现的第一个位置 （从 0 开始）。如果不存在，则返回 -1。</p>
<p data-nodeid="23"><strong data-nodeid="427">示例 1</strong></p>
<p data-nodeid="24">输入: main = "hello", sub = "ll"</p>
<p data-nodeid="25">输出: 2</p>
<p data-nodeid="26"><em data-nodeid="440">注意：有的文章也把 sub 字符串称为 pattern字符串（模式串）。</em></p>
<h3 data-nodeid="27">暴力查找算法</h3>
<p data-nodeid="28">如果你在面试的时候，拿到这道题没有任何思路，可以先选择一个暴力求解的方法。具体思路就是把每一个 main 字符串都当成一个潜在的起始位置，然后依次向后匹配。</p>
<p data-nodeid="29">这里我们用一个例子说明一下暴力查找算法的思路。注意，图中较长的字符串为主串 main，较短的字符串为子串 sub。</p>
<p data-nodeid="9277" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5P6uAddtOAA7mSiBVGWI035.gif" alt="1.gif" data-nodeid="9280"></p>


<p data-nodeid="32">基于这样的思路，我们可以写出代码如下（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="33"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
        <span class="hljs-keyword">if</span> (sub == <span class="hljs-keyword">null</span> || sub.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span> (main == <span class="hljs-keyword">null</span> || main.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">// 采用暴力匹配的方式</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; main.length(); i++) {
            <span class="hljs-keyword">boolean</span> hasFind = <span class="hljs-keyword">true</span>;
            <span class="hljs-comment">// 那么从头开始匹配sub</span>
            <span class="hljs-keyword">for</span>  (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sub.length(); j++) {
                <span class="hljs-keyword">if</span> (i + j &gt;= main.length() ||
                    main.charAt(i+j) != sub.charAt(j)) {
                    <span class="hljs-comment">// 如果无法匹配或者说匹配失败</span>
                    hasFind = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">if</span> (hasFind) {
                <span class="hljs-keyword">return</span> i;
            }
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<blockquote data-nodeid="34">
<p data-nodeid="35">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="452">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="456">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="460">Python</a></p>
</blockquote>
<p data-nodeid="36"><strong data-nodeid="465">复杂度分析</strong>：最坏情况下时间复杂度为O(N×M)，其中 N 为 main 字符串的长度，M 为 sub 字符串的长度。空间复杂度为 O(1)。</p>
<p data-nodeid="37">【<strong data-nodeid="471">分析</strong>】首先我们分析一下这种方法的缺点：时间复杂度高，如果字符较长，不能快速定位。</p>
<p data-nodeid="38">那么这种算法有没有优点呢？实际上还是有的：</p>
<ul data-nodeid="39">
<li data-nodeid="40">
<p data-nodeid="41">实现简单；</p>
</li>
<li data-nodeid="42">
<p data-nodeid="43">不需要额外空间，在字符串较短的情况下，算法的运行速度很快；</p>
</li>
<li data-nodeid="44">
<p data-nodeid="45">大部分时候，我们处理的都是较短的字符串。</p>
</li>
</ul>
<p data-nodeid="46">虽然其他一些算法是线性时间复杂度，但是由于需要开辟额外的内存空间，在一定情况下：</p>
<ul data-nodeid="47">
<li data-nodeid="48">
<p data-nodeid="49">涉及内存申请与释放，内存的申请与释放都会带来较大的时间开销；</p>
</li>
<li data-nodeid="50">
<p data-nodeid="51">可能触发带内存 GC 语言的内存垃圾回收，导致程序运行速度变得更慢。</p>
</li>
</ul>
<p data-nodeid="52">为了避免申请内存，Java 语言内置的 IndexOf 方法的实现就是采用的这种思路。我们在面试的时候，除了要把代码写对，还需要亮出更多手中的“法宝”，向面试官展示出自己的优势。比如：</p>
<ul data-nodeid="53">
<li data-nodeid="54">
<p data-nodeid="55">指出这种算法实现的优点和缺点；</p>
</li>
<li data-nodeid="56">
<p data-nodeid="57">什么情况下用这种算法？什么情况下不应该用？</p>
</li>
</ul>
<p data-nodeid="58">在面试中，如果你仅是把暴力的方法写对，很有可能还是不能通过面试。因为：</p>
<blockquote data-nodeid="59">
<p data-nodeid="60">字符串查找题目，用暴力方法写对的人~~实在太多了= =。</p>
</blockquote>
<h3 data-nodeid="61">KMP 算法</h3>
<p data-nodeid="62">接下来我们讨论 KMP 算法。如果你以前在学习 KMP 算法的过程中，觉得很难，或者说压根看不懂。相信我，这不是你的错。因为学习 KMP 算法需要一些前置知识，在这里，我们就将这些前置知识讲透。</p>
<p data-nodeid="63">只要你跟着我的思路，一步一步思考，学完本讲肯定能看懂 KMP 。</p>
<h4 data-nodeid="64">前缀与前缀集</h4>
<p data-nodeid="65">首先我们要学习的第一个概念是<strong data-nodeid="495">前缀</strong>，一个长度为 N 的字符串 S 的前缀需要满足如下条件：</p>
<ul data-nodeid="66">
<li data-nodeid="67">
<p data-nodeid="68">非空</p>
</li>
<li data-nodeid="69">
<p data-nodeid="70"><strong data-nodeid="500">不是 S 自身</strong></p>
</li>
<li data-nodeid="71">
<p data-nodeid="72">是包含 S[0] 的连续子串</p>
</li>
</ul>
<p data-nodeid="73">比如，给定一个字符串 S = "ABC"，那么所有的前缀有：</p>
<pre class="lang-java" data-nodeid="74"><code data-language="java">{
  <span class="hljs-string">"A"</span>,
  <span class="hljs-string">"AB"</span>,
}
</code></pre>
<p data-nodeid="75">我们把所有前缀放到一个集合中，就构成了字符串的<strong data-nodeid="516">前缀集</strong>。</p>
<h4 data-nodeid="76">后缀与后缀集</h4>
<p data-nodeid="77">第二个概念是<strong data-nodeid="523">后缀</strong>，一个长度为 N 的字符串 S 的后缀需要满足如下条件：</p>
<ul data-nodeid="78">
<li data-nodeid="79">
<p data-nodeid="80">非空</p>
</li>
<li data-nodeid="81">
<p data-nodeid="82">不是 S 自身</p>
</li>
<li data-nodeid="83">
<p data-nodeid="84">是包含最后一个字符 S[N-1] 的连续子串</p>
</li>
</ul>
<p data-nodeid="85">比如，给定一个字符串 S = "ABC"，那么所有的后缀有：</p>
<pre class="lang-java" data-nodeid="86"><code data-language="java">{
  <span class="hljs-string">"C"</span>,
  <span class="hljs-string">"BC"</span>,
}
</code></pre>
<p data-nodeid="87">我们把所有后缀放到一个集合中，就构成了字符串的<strong data-nodeid="541">后缀集</strong>。</p>
<h4 data-nodeid="88">前后缀的最长匹配</h4>
<p data-nodeid="89">给定一个字符串，我们想知道它的前缀集和后缀集里面最长且相同的字符串是什么，比如：</p>
<pre class="lang-java" data-nodeid="90"><code data-language="java">S = <span class="hljs-string">"ababa"</span>;
前缀集 = {
  <span class="hljs-string">"a"</span>,
  <span class="hljs-string">"ab"</span>,
  <span class="hljs-string">"aba"</span>,
  <span class="hljs-string">"abab"</span>,
}
后缀集 = {
  <span class="hljs-string">"a"</span>,
  <span class="hljs-string">"ba"</span>,
  <span class="hljs-string">"aba"</span>,
  <span class="hljs-string">"baba"</span>,
}
</code></pre>
<p data-nodeid="91">那么两个集合的交集就是：</p>
<pre class="lang-java" data-nodeid="92"><code data-language="java">前后缀的交集 = {
  <span class="hljs-string">"a"</span>,
  <span class="hljs-string">"aba"</span>,
}
</code></pre>
<p data-nodeid="93">我们还需要在这个交集里面找到<strong data-nodeid="558">最长的字符串</strong>，就是 "aba"，这里我们称为<strong data-nodeid="559">前后缀的最长匹配</strong>。</p>
<h4 data-nodeid="94">PMT 表（Partial Match Table）</h4>
<p data-nodeid="12985" class="">PMT 表（本质上就是一个数组）中的每一项 PMT[i]，表示的是一个字符串 S[0..i] 的<strong data-nodeid="12999">前后缀的最长匹配</strong>的长度。这里我可以用如下操作表示 PMT 表的含义：</p>

<pre class="lang-java" data-nodeid="96"><code data-language="java">S = <span class="hljs-string">"abababca"</span>; <span class="hljs-comment">// ab重复3次再加上一个ca</span>
PMT[<span class="hljs-number">0</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>]= <span class="hljs-string">"a"</span>) = <span class="hljs-string">""</span> = <span class="hljs-number">0</span>
PMT[<span class="hljs-number">1</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">1</span>]= <span class="hljs-string">"ab"</span>) = <span class="hljs-string">""</span> = <span class="hljs-number">0</span>
PMT[<span class="hljs-number">2</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>]= <span class="hljs-string">"aba"</span>) = <span class="hljs-string">"a"</span> = <span class="hljs-number">1</span>
PMT[<span class="hljs-number">3</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">3</span>]= <span class="hljs-string">"abab"</span>) = <span class="hljs-string">"ab"</span> = <span class="hljs-number">2</span>
PMT[<span class="hljs-number">4</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">4</span>] = <span class="hljs-string">"ababa"</span>) = <span class="hljs-string">"aba"</span> = <span class="hljs-number">3</span>
PMT[<span class="hljs-number">5</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>] = <span class="hljs-string">"ababab"</span>) = <span class="hljs-string">"abab"</span> = <span class="hljs-number">4</span>
PMT[<span class="hljs-number">6</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">6</span>] = <span class="hljs-string">"abababc"</span>) = <span class="hljs-string">""</span> = <span class="hljs-number">0</span>
PMT[<span class="hljs-number">6</span>] = 前后缀的最长匹配(S[<span class="hljs-number">0</span>..<span class="hljs-number">6</span>] = <span class="hljs-string">"abababca"</span>) = <span class="hljs-string">"a"</span> = <span class="hljs-number">1</span>
</code></pre>
<p data-nodeid="97">注意：PMT[i] 求的就是<strong data-nodeid="600">字符串 S[0..i]<strong data-nodeid="599">的前后缀的</strong>最长匹配</strong>。所以，字符串 S = "abababca" 的 PMT 表如下：</p>
<p data-nodeid="16696" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QFiAGzZHAAC2m7Ugm-M073.png" alt="Drawing 1.png" data-nodeid="16699"></p>


<h4 data-nodeid="100">PMT 的用途</h4>
<p data-nodeid="101">现在你已经知道了 PMT 表的定义，以及如何计算 PMT 表。但直接根据定义来计算，复杂度有点高。不过没关系，我们后面马上就会介绍如何高效地计算 PMT 表。</p>
<p data-nodeid="102">在这之前，我先介绍一下 PMT 表的<strong data-nodeid="615">用途。<strong data-nodeid="614">重要的话说三遍</strong>：</strong></p>
<p data-nodeid="103"><strong data-nodeid="620">PMT 表的用途是解开 KMP 算法的关键</strong>！</p>
<p data-nodeid="104"><strong data-nodeid="625">PMT 表的用途是解开 KMP 算法的关键</strong>！</p>
<p data-nodeid="105"><strong data-nodeid="630">PMT 表的用途是解开 KMP 算法的关键</strong>！</p>
<p data-nodeid="106">那么，PMT 表到底能用来做什么呢？我们再来看一下暴力算法中可以优化的地方。比如，要在字符串 main = "ababdababc" 中找到 sub="ababc"。</p>
<p data-nodeid="107">第 1 轮比较时，会在 main[4] 处比较 ('d' != 'c') 失败。如下图所示：</p>
<p data-nodeid="20394" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QGCAL-PeAABRB-3sg1A408.png" alt="Drawing 2.png" data-nodeid="20397"></p>

<p data-nodeid="109">进行第 2 轮比较时，会在 main[1] 处比较 ('b' != 'a') 失败。如下图所示：</p>
<p data-nodeid="24092" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QGaAREh8AABjgONJpHI860.png" alt="Drawing 3.png" data-nodeid="24095"></p>

<p data-nodeid="111">进行第 3 轮比较时，会在 main[4] 处比较 ('d' != 'a') 失败。如下图所示：</p>
<p data-nodeid="27790" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QGuAX8j3AAB17551o7U749.png" alt="Drawing 4.png" data-nodeid="27793"></p>

<p data-nodeid="113">接下来，进行第 4 轮比较时，会在 main[3] 处比较 ('b' != 'a')失败。如下图所示：</p>
<p data-nodeid="31488" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QHGAcpfwAACIBm3EAW8556.png" alt="Drawing 5.png" data-nodeid="31491"></p>

<p data-nodeid="115">进行第 5 轮比较时，会在 main[4] 处比较 ('d' != 'a') 失败。凡是比较失败下标小于 4 的情况，<strong data-nodeid="743">都是无效比较（比如第 2 轮，第 4 轮）</strong>。因为这种比较还没有跑到 main[4] 就挂了（第 2 轮挂在 main[1]，第 4 轮挂在 main[3]）。</p>
<p data-nodeid="35186" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QHaALdrWAACXBtrxa4M862.png" alt="Drawing 6.png" data-nodeid="35189"></p>

<p data-nodeid="117">如果我们只看有效比较（第 1 轮、第 3 轮、第 5 轮），然后分别观察字符串已经匹配的部分，如下所示：</p>
<pre class="lang-java" data-nodeid="118"><code data-language="java">第<span class="hljs-number">1</span>轮匹配成功的部分是: <span class="hljs-string">"abab"</span>
第<span class="hljs-number">3</span>轮匹配成功的部分是：<span class="hljs-string">"ab"</span>
第<span class="hljs-number">5</span>轮匹配成功的部分是: <span class="hljs-string">""</span>
</code></pre>
<p data-nodeid="119">联系前面讲到的<strong data-nodeid="753">前后缀的最长匹配</strong>知识，可以发现：</p>
<pre class="lang-java" data-nodeid="120"><code data-language="java"><span class="hljs-string">"abab"</span>的前后缀最长匹配为<span class="hljs-string">"ab"</span>
<span class="hljs-string">"ab"</span>的前后缀最长匹配为<span class="hljs-string">""</span>
</code></pre>
<p data-nodeid="121">因此，我们可以总结出一个规律：当某个匹配位置失败，进行下一次比较时，取已经匹配成功部分的“前后缀的最长匹配”即可。这样，比较时就能够从第 1 轮，直接跳到第 3 轮，然后再从第 3 轮直接跳到第 5 轮。如下图所示：</p>
<p data-nodeid="38884" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QICAPtTuAACqqyQ-ciM844.png" alt="Drawing 7.png" data-nodeid="38887"></p>

<p data-nodeid="42582">到这里，就可以发现 PMT 表的作用了。我们先给出 sub="ababc" 字符串的 PMT 表，如下所示：</p>
<p data-nodeid="42583" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QIeAV7aKAABL7SL_5OU219.png" alt="Drawing 8.png" data-nodeid="42591"></p>


<pre class="lang-java" data-nodeid="125"><code data-language="java"><span class="hljs-string">"abab"</span>的前后缀最长匹配 = <span class="hljs-string">"ab"</span> = PMT[<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>
<span class="hljs-string">"ab"</span>的前后缀最长匹配 = <span class="hljs-string">""</span> = PMT[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>
</code></pre>
<p data-nodeid="126">结合 PMT 表，还可以发现，当在 sub[j] 位置比较失败，下一个可能成功的比较位置就是 PMT[j-1]。</p>
<p data-nodeid="46286" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QI2AKF-nAADJ-97QTzc223.png" alt="Drawing 9.png" data-nodeid="46289"></p>

<p data-nodeid="128">因此，经过前面的分析，我们总算弄明白了 PMT 表的作用。就是：</p>
<blockquote data-nodeid="129">
<p data-nodeid="130">比较失败的时候，可以利用 PMT 表迅速地转到下一个有可能成功的比较上。<br>
直接跳过一些无效比较。</p>
</blockquote>
<p data-nodeid="131">当我们有 PMT 表的时候，就可以跳过无效比较的代码写出如下代码：</p>
<pre class="lang-java" data-nodeid="132"><code data-language="java">i = <span class="hljs-number">0</span>
j = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; main.length() and j &lt; sub.length():
  <span class="hljs-keyword">if</span> main[i] == sub[j]:
    i++
    j++
  <span class="hljs-keyword">else</span>:
    j = pmt[j-<span class="hljs-number">1</span>] <span class="hljs-comment">// &lt;-- 出错了!</span>
</code></pre>
<p data-nodeid="133">但是这样写，会在 j = pmt[j-1] 这里出错，原因在于 j 是可以取 0 的。并且，当 j = 0 的时候，如果比较失败，应该移动 i。</p>
<p data-nodeid="134">所以正确的代码应该写成如下（是的，还不用关心 pmt 数组怎么算的）：</p>
<pre class="lang-java" data-nodeid="135"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> alen = main.length();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> blen = sub.length();
    <span class="hljs-keyword">int</span>[] PMT = buildPMT(sub);
  
    <span class="hljs-keyword">while</span> (i &lt; alen &amp;&amp; j &lt; blen) {
      <span class="hljs-keyword">if</span> (main.charAt(i) == sub.charAt(j)) {
        <span class="hljs-comment">// 如果匹配成功，那么向前走</span>
        <span class="hljs-comment">// 这里和暴力的方法没有区别</span>
        i++;
        j++;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 如果匹配失败，我们这里要跳过一些无效的比较</span>
        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) {
          <span class="hljs-comment">// 这里需要移动i</span>
          i++;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// 跳过无效的比较!</span>
          j = PMT[j-<span class="hljs-number">1</span>];
        }
      }
    }
  
    <span class="hljs-comment">// 看一下是不是匹配完了</span>
    <span class="hljs-keyword">return</span> j == blen ? i - blen : -<span class="hljs-number">1</span>;
}
</code></pre>
<blockquote data-nodeid="136">
<p data-nodeid="137">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.pmt.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="792">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.pmt.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="796">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.pmt.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="800">Python</a></p>
</blockquote>
<p data-nodeid="138"><strong data-nodeid="805">复杂度分析</strong>：时间复杂度为 O(N + M)，其中 N 表示 main 字符串的长度，而 M 表示 sub 字符串的长度。空间复杂度为 O(M)。</p>
<h4 data-nodeid="139">next 数组怎么来的？</h4>
<p data-nodeid="140">你可能会问：我们学的 KMP 算法里面都是有 next 数组，为什么你这里只有 PMT 数组？</p>
<p data-nodeid="141">其实关键在于这里面有一个优化。因为每次访问 pmt[] 数组的时候，都是用 pmt[j-1]。每次访问的时候，都还需要 j-1，因此多了一个减法。那么有没有办法把这个减法给节省掉？</p>
<p data-nodeid="142">为了节省运算量，我们在 pmt[] 数组的前面插一个数 -1。</p>
<p data-nodeid="49984" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QJqAfjCyAABkH6Y4HOM290.png" alt="Drawing 10.png" data-nodeid="49987"></p>

<p data-nodeid="144">那么就形成了 next 数组。既然有了这样一个数组，比较的代码就可以更改 2 个匹配失败的地方，如下图所示：</p>
<p data-nodeid="61066"><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QKKAetH8AAJlv9cWcGE540.png" alt="Drawing 11.png" data-nodeid="61070"></p>
<p data-nodeid="61067" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QKeAALkDAAJVrPPGvYQ122.png" alt="Drawing 12.png" data-nodeid="61073"></p>





<p data-nodeid="147">更改之后的代码就变成如下的样子（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="148"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> alen = main.length();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> blen = sub.length();
    <span class="hljs-keyword">int</span>[] next = buildNext(sub); <span class="hljs-comment">// &lt;-- pmt[]的前面加一个-1形成next</span>
    <span class="hljs-keyword">while</span> (i &lt; alen &amp;&amp; j &lt; blen) {
        <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == j || main.charAt(i) == sub.charAt(j)) {
            <span class="hljs-comment">// 如果匹配成功，那么向前走</span>
            <span class="hljs-comment">// 这里和暴力的方法没有区别</span>
            i++;
            j++;
        } <span class="hljs-keyword">else</span> {
            j = next[j];
        }
    }
    <span class="hljs-comment">// 看一下是不是匹配完了</span>
    <span class="hljs-keyword">return</span> j == blen ? i - blen : -<span class="hljs-number">1</span>;
}
</code></pre>
<h4 data-nodeid="64768">next 数组的计算</h4>


<p data-nodeid="151">讲完主程序之后，接下来我们应该看一下如何计算 sub 字符串的 next 数组。首先应该考虑整个字符串的<strong data-nodeid="841">最后一步</strong>，也就是找整个字符串的<strong data-nodeid="842">前后缀的最长匹配</strong>。</p>
<p data-nodeid="152">我们分 4 个阶段进行讲解：</p>
<ul data-nodeid="153">
<li data-nodeid="154">
<p data-nodeid="155">暴力方法</p>
</li>
<li data-nodeid="156">
<p data-nodeid="157">跳过无效比较方法 1</p>
</li>
<li data-nodeid="158">
<p data-nodeid="159">跳过无效比较方法2</p>
</li>
<li data-nodeid="160">
<p data-nodeid="161">写代码</p>
</li>
</ul>
<p data-nodeid="162"><strong data-nodeid="851">第一个阶段：暴力方法</strong></p>
<p data-nodeid="163">暴力方法的思路是：不停地移动字符串的前缀，从最长的可能开始暴力比较。那么当字符串为 sub = "ababc" 的时候，匹配过程如下：</p>
<p data-nodeid="68462" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QLOAFbsEAAB2TT7CNTY592.png" alt="Drawing 13.png" data-nodeid="68465"></p>

<p data-nodeid="165">我们很快可以发现，暴力的比较过程，和我们最开始的字符串暴力算法非常类似。</p>
<blockquote data-nodeid="166">
<p data-nodeid="167">优化暴力算法的思路就是跳过一些无效比较。</p>
</blockquote>
<p data-nodeid="168"><strong data-nodeid="865">第二阶段：跳过无效比较方法 1</strong></p>
<p data-nodeid="169">那么这里是否可以跳过一些无效比较呢？（提示，借助 PMT 的思路）</p>
<p data-nodeid="170">很快，我们应该可以发现，在第 2 轮比较的时候，当得到已经匹配的字符串为 "ab" 时，PMT["ab"] = 0。此时，下一轮比较的时候，应该直接从 j = 0 开始。也就是如下图所示的地方：</p>
<p data-nodeid="72158" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QLuAC3ytAACjKtED2X4849.png" alt="Drawing 14.png" data-nodeid="72161"></p>

<p data-nodeid="172">我们可以直接把第 3 轮给跳过。所以当我们计算 PMT["ababc"] 的时候，需要依赖P MT["ab"]。这就形成了一个子问题。</p>
<p data-nodeid="75854" class=""><strong data-nodeid="75858">第三阶段：跳过无效比较方法 2</strong></p>

<p data-nodeid="174">首先我们看一种<strong data-nodeid="905">运气好</strong>的情况：</p>
<p data-nodeid="79547" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QMeAS9AIAABHhoOeG5g985.png" alt="Drawing 15.png" data-nodeid="79550"></p>

<p data-nodeid="176">已知：在左边，我们找到了字符串 "abab" 的<strong data-nodeid="928">前后缀的最长匹配</strong>“ab"（长度为 2）。那么当我们再去求字符串 "ababa" 的前后缀的最长匹配的时候，<strong data-nodeid="929">直接往后延伸一位</strong>就可以了。</p>
<p data-nodeid="177">我们利用反证法进行证明。</p>
<ul data-nodeid="178">
<li data-nodeid="179">
<p data-nodeid="180">条件：字符串 "abab" 的<strong data-nodeid="943">前后缀的最长匹配</strong>"ab"（长度为 2）成立。</p>
</li>
<li data-nodeid="181">
<p data-nodeid="182">并且假设 "ababa"，相比在 "abab" 的基础上直接延伸，还有更长的“前后缀的最长匹配”。</p>
</li>
</ul>
<p data-nodeid="183">观察下图展示的结果，假设框中的区域为相等的部分（不管问号存在的这种情况，并且它们是相等的）。</p>
<p data-nodeid="83239" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QNOAGRW5AAA-7HVC5zI425.png" alt="Drawing 16.png" data-nodeid="83242"></p>

<p data-nodeid="185">但是，如果存在这种更长的情况。导致的结果就是：绿色线框中的内容肯定是相等的。</p>
<p data-nodeid="86931" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QNuAJtqtAABD_6dXDFM955.png" alt="Drawing 17.png" data-nodeid="86934"><br>
如果绿色线框中的内容相等，那么 "abab" 的前后缀的最长匹配长度就是 3。这样与我们给定的条件矛盾。</p>


<p data-nodeid="188">实际上，就算是<strong data-nodeid="975">运气差</strong>的时候，我们也只需要：<strong data-nodeid="976">直接延伸一位就可以了</strong>。这种情况也是可以用完全一样的反证法来证明。那么如下图所示，我们可以把第 1 轮直接跳过。</p>
<p data-nodeid="90629" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QOKATZt1AABfbeG1SPU738.png" alt="Drawing 18.png" data-nodeid="90632"></p>

<p data-nodeid="190"><strong data-nodeid="983">第四阶段：写代码</strong></p>
<p data-nodeid="191">我们发现，实际上最后一步的情况只有两种：</p>
<ul data-nodeid="192">
<li data-nodeid="193">
<p data-nodeid="194">直接延伸一位，并且延伸之后<strong data-nodeid="992">相等</strong>，那么 last_len = 之前匹配的长度 + 1；</p>
</li>
<li data-nodeid="195">
<p data-nodeid="196">直接延伸一位，并且延伸之后<strong data-nodeid="1002">不相等</strong>，那么下一个比较位置就是转到 pmt[j-1]。</p>
</li>
</ul>
<p data-nodeid="197">但是，我们又发现：每次<strong data-nodeid="1008">匹配成功</strong>的时候，有如下图所示的这个规律：</p>
<p data-nodeid="94321" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QOuALm-zAABJXyKtJGY264.png" alt="Drawing 19.png" data-nodeid="94324"></p>

<ul data-nodeid="199">
<li data-nodeid="200">
<p data-nodeid="201">左边，需要记录 PMT["abab"] = 前后缀最长匹配长度 = 2 = j + 1，此时 j = 1；</p>
</li>
<li data-nodeid="202">
<p data-nodeid="203">右边，需要记录 PMT["ababa"] = 前后缀最长匹配长度 = 3 = j + 1，此时 j=2。</p>
</li>
</ul>
<p data-nodeid="204">匹配失败的时候:</p>
<ul data-nodeid="205">
<li data-nodeid="206">
<p data-nodeid="207">1）当 j=0 的时候，j 已经不能再退了，所以需要移动 i；</p>
</li>
<li data-nodeid="208">
<p data-nodeid="209">2）当 j &gt; 0 的时候，我们还可以再往回退，于是设置 j = PMT[j-1]。</p>
</li>
</ul>
<p data-nodeid="210">并且，PMT[x] 里面的所有字符串 x，都是字符串截取了 sub 字符串位置 [0, ..., len(x)-1]。由于这个范围的左端点总是 0，所以我们只需要记录这个范围的右端点就可以了，即用PMT[len(x)-1] 表示 PMT[x]。</p>
<p data-nodeid="211">那么，我们就可以得到如下代码（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="212"><code data-language="java"><span class="hljs-keyword">int</span>[] buildPMT(String sub) {
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = sub == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : sub.length();
  <span class="hljs-keyword">int</span>[] PMT = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];
  <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
  PMT[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span> (i &lt; N) {
    <span class="hljs-keyword">if</span> (sub.charAt(i) == sub.charAt(j)) {
      <span class="hljs-comment">// 当相等的时候，</span>
      i++;
      j++;
      PMT[i - <span class="hljs-number">1</span>] = j;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == j) {
        <span class="hljs-comment">// 如果匹配失败，并且j已经为0</span>
        <span class="hljs-comment">// 那么</span>
        i++;
        PMT[i - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
      } <span class="hljs-keyword">else</span> {
        j = PMT[j - <span class="hljs-number">1</span>];
      }
    }
  }
  <span class="hljs-keyword">return</span> PMT;
}
</code></pre>
<p data-nodeid="213">实际上，这部分代码与我们最开始用 PMT 表来求字符串匹配的代码非常像。访问所有 pmt[] 数组里面的元素的时候，都是用 pmt[i-1] 和 pmt[j-1]。每次访问都需要做 1 次减法，当时我们采用的优化方法是：引入 next 数组。那么同样的，这里也可以引入 next 数组。</p>
<p data-nodeid="214">最终求解 next 数组的代码就可以表示如下：</p>
<pre class="lang-java" data-nodeid="215"><code data-language="java"><span class="hljs-keyword">int</span>[] buildNext(String sub) {
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = sub == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : sub.length();
    <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span>;
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (i &lt; N) {
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || sub.charAt(i) == sub.charAt(j)) {
            i++;
            j++;
            next[i] = j;
        } <span class="hljs-keyword">else</span> {
            j = next[j];
        }
    }
    <span class="hljs-keyword">return</span> next;
}
</code></pre>
<p data-nodeid="216">注意：由于 next 数组是在 pmt 数组的前面插入了一个 -1。所以，申请数组长度的时候，是字符串的长度 +1。注意写代码的时候不要写错！</p>
<p data-nodeid="217"><strong data-nodeid="1076">练习题 1</strong>：求解一个字符串的 pmt[] 数组，本质上是一个动态规划，你能用我们《<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6703&amp;fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1074">14 | DP：我是怎么治好“DP 头痛症”的？</a>》介绍的动态规划 6 步分析法进行求解吗？</p>
<blockquote data-nodeid="218">
<p data-nodeid="219">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/pmt.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1080">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/pmt.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1084">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/pmt.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1088">Python</a></p>
</blockquote>
<p data-nodeid="220"><strong data-nodeid="1107">练习题 2</strong>：当我们求解了 pmt[] 数组，由于访问 pmt 数组的时候，都是 pmt[i-1] 或 pmt[j-1]，为了优化掉这个减法，你可以把求解 pmt[] 数组的代码，转成输出 next 数组的代码吗？</p>
<blockquote data-nodeid="221">
<p data-nodeid="222">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/next.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1111">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/next.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1115">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/next.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1119">Python</a></p>
</blockquote>
<p data-nodeid="223"><strong data-nodeid="1124">练习题 3</strong>：给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。</p>
<p data-nodeid="224">输入："abab"</p>
<p data-nodeid="225">输出：True</p>
<p data-nodeid="226">解释：可由子字符串 "ab" 重复两次构成。</p>
<blockquote data-nodeid="227">
<p data-nodeid="228">方法 1 PMT：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1138">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1142">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1146">Python</a><br>
方法 2 Next：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.next.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1151">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.next.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1155">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.next.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1159">Python</a><br>
方法 3 同余：<a href="http:////github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.mod.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1164">Java</a>/<a href="http:////github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.mod.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1168">C++</a>/<a href="http:////github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.mod.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1172">Python</a></p>
</blockquote>
<h4 data-nodeid="229">完整的 KMP 代码</h4>
<p data-nodeid="230">到此为止，我们已经可以给出完整的 KMP 代码了，如下所示（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="231"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-comment">// 在学习PMT的</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] buildNext(String sub) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = sub == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : sub.length();
        <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span>;
        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; N) {
            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || sub.charAt(i) == sub.charAt(j)) {
                i++;
                j++;
                next[i] = j;
            } <span class="hljs-keyword">else</span> {
                j = next[j];
            }
        }
        <span class="hljs-keyword">return</span> next;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> alen = main.length();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> blen = sub.length();
        <span class="hljs-keyword">int</span>[] next = buildNext(sub);
        <span class="hljs-keyword">while</span> (i &lt; alen &amp;&amp; j &lt; blen) {
            <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == j || main.charAt(i) == sub.charAt(j)) {
                <span class="hljs-comment">// 如果匹配成功，那么向前走</span>
                <span class="hljs-comment">// 这里和暴力的方法没有区别</span>
                i++;
                j++;
            } <span class="hljs-keyword">else</span> {
                j = next[j];
            }
        }
        <span class="hljs-comment">// 看一下是不是匹配完了</span>
        <span class="hljs-keyword">return</span> j == blen ? i - blen : -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<blockquote data-nodeid="232">
<p data-nodeid="233">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1178">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1182">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1186">Python</a></p>
</blockquote>
<h4 data-nodeid="234">复杂度分析</h4>
<p data-nodeid="235">这里稍微唠叨一下 KMP 的时间复杂度。在比较成功的情况下，i 和 j 都会前进。在比较失败的时候，j 会往回跑（j back），如下图所示：</p>
<p data-nodeid="98013" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QP2ATikgAAH2l05J4wU268.png" alt="Drawing 20.png" data-nodeid="98016"></p>

<p data-nodeid="237">这里我们需要给出两个定义：</p>
<ul data-nodeid="238">
<li data-nodeid="239">
<p data-nodeid="240">匹配失败时，当 i 停住不动的时候，称为一个<strong data-nodeid="1197">失配点；</strong></p>
</li>
<li data-nodeid="241">
<p data-nodeid="242">当遇到一个失配点时，j 会往回跑，那么会有不同的往回跑的步数。</p>
</li>
</ul>
<p data-nodeid="243">那么时间复杂度可以写成如下：O(N + sum(每个失配点 x 每个失配点j往回跑的次数))。那么最差情况如下图所示：</p>
<p data-nodeid="101705" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QQWAZrkbAAEDgTWXTyg728.png" alt="Drawing 21.png" data-nodeid="101708"></p>

<p data-nodeid="245">此时失配点只有 N / M 个，每次失配之后，j 要往回跑 M 次。所以最差情况下时间复杂度为 O(N + M)，而空间复杂度为 O(M)。</p>
<h4 data-nodeid="246">KMP 的优化</h4>
<p data-nodeid="247">相信你已经理解了前面介绍的 PMT 对暴力算法进行优化的原理，其核心就是跳过无效地比较。那么，我们再看一下，是不是可以在 KMP 的基础上跳过更多的无效比较呢？</p>
<p data-nodeid="248">假设有如下比较失败的情况：</p>
<p data-nodeid="105397" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QQyAQ3jiAACDRobq3aA249.png" alt="Drawing 22.png" data-nodeid="105400"></p>

<p data-nodeid="250">我们已经跳过了比较失败的情况，不过可以发现，每次回退，其实都是反复地用 'b' 和' c' 字符进行比较。实际这里上可以进行如下优化：</p>
<p data-nodeid="109089" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QRaAYmd1AAB7MCW-NSg749.png" alt="Drawing 23.png" data-nodeid="109092"></p>

<p data-nodeid="252">总结一下，当发现回退之后的字符仍然是相等的时候，我们就再回退一次。由于这部分代码只涉及求解 next 数组，所以我把这部分代码也给你写出来：</p>
<pre class="lang-java" data-nodeid="253"><code data-language="java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] buildNext(String sub) {
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = sub == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : sub.length();
        <span class="hljs-keyword">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = -<span class="hljs-number">1</span>;
        next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (i &lt; N) {
            <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || sub.charAt(i) == sub.charAt(j)) {
                i++;
                j++;
                <span class="hljs-keyword">if</span> (i &lt; sub.length() &amp;&amp; 
                    j &lt; sub.length() &amp;&amp;
                    sub.charAt(i) == sub.charAt(j)) {
                    next[i] = next[j];    
                } <span class="hljs-keyword">else</span> {
                    next[i] = j;
                }
            } <span class="hljs-keyword">else</span> {
                j = next[j];
            }
        }
        <span class="hljs-keyword">return</span> next;
    }
</code></pre>
<blockquote data-nodeid="254">
<p data-nodeid="255">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1226">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1230">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.kmp2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1234">Python</a></p>
</blockquote>
<h3 data-nodeid="256">BM 算法</h3>
<p data-nodeid="257">虽然 KMP 算法能够取得线性时间复杂度。不过，当你打开任何一个文档编辑器的时候，大部分编辑器的搜索算法并不是基于 KMP 算法来实现的。这里主要有两个原因：</p>
<ul data-nodeid="258">
<li data-nodeid="259">
<p data-nodeid="260">KMP 算法需要在 main 字符串从头搜索到结尾；</p>
</li>
<li data-nodeid="261">
<p data-nodeid="262">KMP 算法在跳过一些<strong data-nodeid="1243">坏字符</strong>的时候，会出现不停回退的情况。</p>
</li>
</ul>
<p data-nodeid="263">比如，当你利用 KMP 算法进行搜索的时候，会有如下情况：</p>
<p data-nodeid="112781" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/73/CioPOWB5QR6AZkqYAACDRobq3aA070.png" alt="Drawing 24.png" data-nodeid="112784"></p>

<p data-nodeid="265">实际上，我们肉眼可见的是，<strong data-nodeid="1261">字符 'c' 并不出现在 sub 字符串</strong>，所以我们没有必要一直回退。一种更好的办法是：将 sub 字符串推到 'c' 字符的后面。</p>
<p data-nodeid="116473" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QSaAFuqPAABMef1SYNI911.png" alt="Drawing 25.png" data-nodeid="116476"></p>

<p data-nodeid="267">如果你能想到这个思路，不妨再更进一步思考一下。既然字符串比较的时候，右边失效就直接前移了，那么我们直接从右往左边比较，不是来得更直接吗？</p>
<p data-nodeid="268">于是，基于下面这两个思路你就可以得到答案。</p>
<ul data-nodeid="269">
<li data-nodeid="270">
<p data-nodeid="271"><strong data-nodeid="1276">坏字符：<strong data-nodeid="1275">在 main 字符串与 sub</strong>比较失败的字符</strong>；</p>
</li>
<li data-nodeid="272">
<p data-nodeid="273">从右向左比较。</p>
</li>
</ul>
<p data-nodeid="274">有人发明了 BM（Boyer-Moore）算法，还在字符串查找上留下了大名。你先别后悔晚生了那么多年，我们一起再把这个算法讲透。</p>
<h4 data-nodeid="275">概念</h4>
<p data-nodeid="276">我会采用 Moore 举的例子一步一步展开介绍。两个字符串为：main = "HERE IS A SIMPLE EXAMPLE", sub = "EXAMPLE"。</p>
<h5 data-nodeid="134924" class="">1. 第 1 步</h5>





<p data-nodeid="138604" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QTuAAxHVAABGdtl_7Ic614.png" alt="Drawing 26.png" data-nodeid="138607"></p>

<p data-nodeid="281">首先比较 'S' != 'E'，那么需要把 sub 字符串移动到 'S' 的后面。因为 'S' 从来没有出现在 sub 字符串，所以 'S' 就是一个<strong data-nodeid="1323">坏字符</strong>。</p>
<p data-nodeid="282">注意：<strong data-nodeid="1333">坏字符</strong>指的是<strong data-nodeid="1334">匹配失败</strong>的 main 字符串中对应的那个字符，而不是说没有在 sub 字符串里面出现的字符。</p>
<h5 data-nodeid="157005" class="">2. 第 2 步</h5>





<p data-nodeid="160675" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QUuAbJcCAABGmQa8J_A368.png" alt="Drawing 27.png" data-nodeid="160678"></p>

<p data-nodeid="287">'P' != 'E'，此时 'P' 是一个坏字符，但是出现在 sub 中。那么我们移动 sub 字符串，让两个字符串在 'P' 字符这里对齐，移动的距离为 2。</p>
<p data-nodeid="288">由第 1 步和第 2 步，可以得到一个“<strong data-nodeid="1365">坏字符</strong>”规则：</p>
<blockquote data-nodeid="289">
<p data-nodeid="290">当匹配失败的时候，移动距离 = 坏字符的位置 - sub 中的上一次出现位置。</p>
</blockquote>
<p data-nodeid="291">注意：这里“坏字符的位置”指的是坏字符在匹配失败的时候，在 sub 字符串中的下标。举 2 个例子：</p>
<p data-nodeid="292">例 1：在第 1 步比较失败之后，我们移动 7 步。如下图所示：</p>
<p data-nodeid="164347" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QVOAAH-hAABWb2U0530631.png" alt="Drawing 28.png" data-nodeid="164350"></p>

<p data-nodeid="294">例 2：在第 2 步比较失败之后，我们移动 4 步。如下图所示：</p>
<p data-nodeid="168019" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QVmAaw64AABgRFsWqnk546.png" alt="Drawing 29.png" data-nodeid="168022"></p>

<p data-nodeid="296">当 'P' != 'E' 时，坏字符对应 sub 中的比较位置为 6，而在 sub[6] 之前出现的 'P' 字符下标为 4，所以移动距离为 6 - 4 = 2。</p>
<h5 data-nodeid="171691" class="">3. 第 3 步</h5>

<p data-nodeid="175357" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QWaAId0BAABGNnt_aAw360.png" alt="Drawing 30.png" data-nodeid="175360"></p>

<p data-nodeid="301">移动之后，我们依然从尾部开始比较。一直向前移动，如下图所示：</p>
<p data-nodeid="179025" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QXCAayNtAARqUBiF940832.gif" alt="2.gif" data-nodeid="179028"></p>


<p data-nodeid="304">由于我们是从后往前进行比较，比较成功的字符串都是位于 sub 字符串的尾部（即后缀），所以可以把这些<strong data-nodeid="1409">比较成功的后缀子串称为好后缀（good suffix）</strong>。</p>
<p data-nodeid="305">因此，"E", "LE", "PLE", "MPLE" 都是好后缀。</p>
<h5 data-nodeid="197336" class="">4. 第 4 步</h5>





<p data-nodeid="200988" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QX-AM9tFAABGlFYAmqg000.png" alt="Drawing 32.png" data-nodeid="200991"></p>

<p data-nodeid="310">到此时，'I' 就是一个坏字符，因为比较失败了。此时正在比较 sub[2]，而 sub[0,1] 之前都没有 'I' 字符，所以移动距离为 2 - (-1) = 3。</p>
<p data-nodeid="311">那么问题是，有没有更好的移动办法？ 这个移动办法其实就在第 5 步。</p>
<h5 data-nodeid="204642" class="">5. 第 5 步</h5>

<p data-nodeid="315">我先介绍一下思路：在前面的“坏字符规则”里介绍了当<strong data-nodeid="1458">单个</strong>字符匹配失败的时候的移动距离。那么有没有可能把一些 sub 字符串连续的字符，当成一个整体处理呢？</p>
<p data-nodeid="316">如果你想到了这一点，就得到了 BM 算法的精髓：**好后缀规则。**这个规则还有以下 3 种情况。</p>
<p data-nodeid="317">1）如果我们将<strong data-nodeid="1469">已匹配连续的字符串看成一个“整体”</strong>，这些整体也出现在 sub 字符串里面，就可以重新进行对齐。如下所示：</p>
<p data-nodeid="208290" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QYmARtNHAAGCi8OvLlY072.png" alt="Drawing 33.png" data-nodeid="208293"></p>

<p data-nodeid="319">2）如果已匹配字符串的“好后缀”<strong data-nodeid="1478">出现在 sub 的头部</strong>，那么只需要重新对齐就可以了。</p>
<p data-nodeid="211940" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QZ2AJntAAAGM1re0xjY259.png" alt="Drawing 34.png" data-nodeid="211943"></p>

<p data-nodeid="321">3） 如果 1）2）都不满足，那么直接跳过这段已匹配字符串。</p>
<p data-nodeid="215590" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QaWACK40AAFjz2byyDg692.png" alt="Drawing 35.png" data-nodeid="215593"></p>

<p data-nodeid="323">这里我需要特别地说明一下：</p>
<ul data-nodeid="324">
<li data-nodeid="325">
<p data-nodeid="326">处理的时候，必须从 1）、2）、3）依次处理；</p>
</li>
<li data-nodeid="327">
<p data-nodeid="328">情况 1）只需要出现在 sub 子串中，而情况 2）中的“好后缀”必须要是 sub 字符串的前缀；</p>
</li>
<li data-nodeid="329">
<p data-nodeid="330">在处理情况 2）的时候，如果有很多个好后缀串，我们总是让“好后缀”更长的优先。</p>
</li>
</ul>
<p data-nodeid="331">再回到例子中，看一下应该如何移动：</p>
<p data-nodeid="219240" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QayADbP-AABsnb2-qKk052.png" alt="Drawing 36.png" data-nodeid="219243"></p>

<p data-nodeid="333">首先根据<strong data-nodeid="1513">坏字符规则</strong>，因为 'I' != 'A'，可以得到移动步数为 2 - (-1) = 3。根据**好后缀规则，**我们再分别看 1）、2）、3）这三种情况：</p>
<p data-nodeid="334">1）已匹配的字符串为 MPLE，这个字符串没有在 sub 字符串的<strong data-nodeid="1519">更左边</strong>出现过，所以情况 1）不满足；</p>
<p data-nodeid="335">2）MPLE 的好后缀有 {"PLE", "LE", "E"}，其中只有 "E" 是 sub 字符串的前缀，所以需要移动 6 步将 "E" 对齐；</p>
<p data-nodeid="336">3）匹配到了 2），所以 3）不需要处理。</p>
<p data-nodeid="337">我们发现，在第 5 步，当使用“好后缀规则”的时候，能够移动更远的距离。所以我们最终选择这个更长的移动距离。</p>
<p data-nodeid="338">当然，选择“坏字符规则”与“好后缀规则”的时候，谁移动的距离更大，我们就用谁。</p>
<h5 data-nodeid="237481" class="">6. 第 6 步</h5>





<p data-nodeid="342">第 6 步在第 5 步的基础上，只能使用坏字符规则。</p>
<p data-nodeid="241119" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QbyARSHQAABGLfmtWkE937.png" alt="Drawing 37.png" data-nodeid="241122"></p>

<p data-nodeid="344"><strong data-nodeid="1556">因为没有好后缀可供使用。向后移动 6 - 4 = 2 位</strong>。</p>
<h5 data-nodeid="259310" class="">7. 第 7 步</h5>





<p data-nodeid="262938" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QdGAM3DwAABGM2GWvYg665.png" alt="Drawing 38.png" data-nodeid="262941"></p>

<p data-nodeid="349">匹配成功！不过，我们在进行编辑器中的文本搜索时，实际上还会继续往后面搜索。</p>
<h4 data-nodeid="350">suffix 和 prefix</h4>
<p data-nodeid="351">前面我们介绍了关于坏字符的移动距离的计算，下面再看一下“好后缀规则”下的移动距离。这里需要引入两个数组，suffix 和 prefix。我们先看 suffix。</p>
<p data-nodeid="352">对于 sub = "ABCABCABC" 而言，suffix[4] 表示的含义如下图所示：</p>
<p data-nodeid="266568" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QdqALgv7AAGpVfCu-Kc071.png" alt="Drawing 39.png" data-nodeid="266571"></p>

<p data-nodeid="354">suffix[] 数组下标 i 表示长度为 i 的后缀串。suffix[i] 存放的值，表示在其<strong data-nodeid="1599">左边</strong>出现<strong data-nodeid="1600">相同</strong>字符串的<strong data-nodeid="1601">最大起始</strong>位置。比如：</p>
<ul data-nodeid="355">
<li data-nodeid="356">
<p data-nodeid="357">sub = "ABCABCABC" 时，对于子串 "CABC" 而言，suffix[4 = len("CABC")] = 2，还有一个同样的子串 "CBAC" 出现在 sub 字符串的下标 2 处；</p>
</li>
<li data-nodeid="358">
<p data-nodeid="359">sub = "BBB" 时，当子串为 "B" 时，suffix[1 = len("B")] = 1，对于后缀来说，有两个地方出现了这个子串，即 sub[0] 和 sub[1]，这里我们需要取<strong data-nodeid="1652">最大的起始位置</strong>1。</p>
</li>
</ul>
<p data-nodeid="360">而 prefix[i] 数组则表示长度为 i 的后缀串是不是 sub 的前缀。</p>
<h4 data-nodeid="270198">算法实现</h4>


<p data-nodeid="363">【<strong data-nodeid="1664">代码</strong>】根据前面的分析，我们可以写出代码如下（代码并不长，只是我加了很多注释）：</p>
<pre class="lang-java" data-nodeid="364"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] bad = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];
  <span class="hljs-comment">// suffix 后缀在sub字符串中的最右的起始位置：需要在其自身的左边。</span>
  <span class="hljs-comment">// prefix[i]数组则表示长度为i的后缀串是不是sub的前缀。</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] suffix = <span class="hljs-keyword">null</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] prefix = <span class="hljs-keyword">null</span>;
  <span class="hljs-comment">/**
   * 记录每个字符在sub字符串中的出现的最右端的下标位置
   * 如果没有出现，那么设置为-1
   * 用于坏字符规则
   * <span class="hljs-doctag">@param</span> sub
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBadCharPos</span><span class="hljs-params">(String sub)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">256</span>; j++) {
      bad[j] = -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sub.length(); j++) {
      bad[(<span class="hljs-keyword">int</span>)sub.charAt(j)] = j;
    }
  }
  <span class="hljs-comment">/**
   * 这个函数负责生成suffix和prefix
   * 这段代码需要仔细读注释
   * <span class="hljs-doctag">@param</span> sub 要在main字符串中查找的字符串sub
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSuffixPrefix</span><span class="hljs-params">(String sub)</span> </span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = sub.length();
    <span class="hljs-comment">// 初始化</span>
    <span class="hljs-comment">// 设置所有的 prefix[] = false</span>
    <span class="hljs-comment">// 设置所有的 suffix[] = -1</span>
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) {
      prefix[i] = <span class="hljs-keyword">false</span>;
      suffix[i] = -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) {
      j = i;
      len = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 两个字符串：</span>
      <span class="hljs-comment">// 前缀字符串是P = sub[0...j]</span>
      <span class="hljs-comment">// 后缀字符串是S = t[(n-j-1)...n-1];</span>
      <span class="hljs-comment">// 当然，P和S是一样长的!</span>
      <span class="hljs-comment">// 比较顺序:</span>
      <span class="hljs-comment">// 在比较前缀字符串P和后缀字符串S的时候</span>
      <span class="hljs-comment">// 是从: `后面` 开始向前比较的</span>
      <span class="hljs-comment">// HINT:</span>
      <span class="hljs-comment">// 我们当然没有必要取出P和S</span>
      <span class="hljs-comment">// 在比较的时候，j--可以保证从后往前匹配</span>
      <span class="hljs-comment">// len++表示已经匹配的长度</span>
      <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; sub.charAt(j) == sub.charAt(n - <span class="hljs-number">1</span> - len)) {
        len++;
        <span class="hljs-comment">// 这段代码非常有意思。</span>
        <span class="hljs-comment">// 我们要考虑以下场景才容易看懂：</span>
        <span class="hljs-comment">// 假设字符串sub = "ABABABAB";</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// * i = 1:</span>
        <span class="hljs-comment">//      前缀字符串P = "AB" = sub[0,1];</span>
        <span class="hljs-comment">//      后缀字符串S = "AB" = sub[6,7];</span>
        <span class="hljs-comment">//   &gt; j = 1:</span>
        <span class="hljs-comment">//     P[j=1] = 'B' == S[7] = 'B' 成立</span>
        <span class="hljs-comment">//     所以suffix[1=len('B')] = 1</span>
        <span class="hljs-comment">//     表示后缀串“B”在sub字符串左边的开始位置在1</span>
        <span class="hljs-comment">//   &gt; j = 0:</span>
        <span class="hljs-comment">//     P[j=0] = 'A' == S[6] = 'A' 成立</span>
        <span class="hljs-comment">//     所以suffix[2=len('AB')] = 0</span>
        <span class="hljs-comment">//     表示后缀串"AB"在sub字符串左边的开始位置在0</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// 接下来我们看当处理到i = 5的时候发生什么?</span>
        <span class="hljs-comment">//</span>
        <span class="hljs-comment">// * i = 5</span>
        <span class="hljs-comment">//      前缀字符串P = "ABABAB" = sub[0...5];</span>
        <span class="hljs-comment">//      后缀字符串S = "ABABAB" = sub[2...7];</span>
        <span class="hljs-comment">//   &gt; j = 5</span>
        <span class="hljs-comment">//     P[j=5] = 'B' == Sub[7] = 'B' 成立</span>
        <span class="hljs-comment">//     所以suffix[1=len('B')] = j = 5</span>
        <span class="hljs-comment">//     表示后缀串“B”在sub字符串左边的开始位置在5</span>
        <span class="hljs-comment">//   &gt; j = 4</span>
        <span class="hljs-comment">//     P[j=4] = 'A' == Sub[6] = 'A'成立</span>
        <span class="hljs-comment">//     所以suffix[2=len('AB')] = j = 4</span>
        <span class="hljs-comment">//     表示后缀串“AB”在sub字符串左边的开始位置在4</span>
        <span class="hljs-comment">// 到这里，我们发现</span>
        <span class="hljs-comment">// 通过这一行代码，我们可以找到每个后缀串在sub里面“最右边”的起始位置。</span>
        <span class="hljs-comment">// 注意：这里的最右边当然不能是后缀串本身，需要在后缀串的左边!</span>
        suffix[len] = j;
        j--;
      }
      <span class="hljs-comment">// 如果P字符串和S字符串完全一样</span>
      <span class="hljs-comment">// 那么说明，后缀字符串S能够匹配前缀</span>
      <span class="hljs-comment">// 这里要进行标记</span>
      <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> == j) {
        prefix[len] = <span class="hljs-keyword">true</span>;
      }
    }
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> j
   *   sub字符串和main字符串从后往前匹配的时候，在sub[j]位置与main匹配失败
   *   也就是说: sub[j+1,...,n)都和main字符串匹配成功了，是一个好后缀
   * <span class="hljs-doctag">@param</span> n sub字符串的长度
   * <span class="hljs-doctag">@return</span> 依次使用1), 2), 3)返回相应的值
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">moveBySuffixPrefix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> n)</span> </span>{
    <span class="hljs-comment">// 因为已经匹配的位置是sub[j+1,n)</span>
    <span class="hljs-comment">// len表示已经匹配的字符串的长度</span>
    <span class="hljs-keyword">int</span> len = n - (j + <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 使用规则 1)</span>
    <span class="hljs-keyword">if</span> (suffix[len] != -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span> - suffix[len];
    }
    <span class="hljs-comment">// 使用规则 2)</span>
    <span class="hljs-comment">// 这里也可以从r = j + 1开始。但是如果j+1是有效的。那么</span>
    <span class="hljs-comment">// 前面的suffix[len] != -1就会处理掉。</span>
    <span class="hljs-comment">// 所以这里没有必要再看j + 1</span>
    <span class="hljs-comment">// 直接找到一个可以匹配的后缀子串与前缀子串匹配的位置就可以了。</span>
    <span class="hljs-comment">// r表示在sub字符串中的下标，那么n - r就表示相应的后缀串</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = j + <span class="hljs-number">2</span>; r &lt;= n - <span class="hljs-number">1</span>; r++) {
      <span class="hljs-keyword">if</span> (prefix[n - r]) {
        <span class="hljs-keyword">return</span> r;
      }
    }
    <span class="hljs-comment">// 使用规则3)</span>
    <span class="hljs-keyword">return</span> n;
  }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
    <span class="hljs-keyword">if</span> (sub == <span class="hljs-keyword">null</span> || sub.length() == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span> (main == <span class="hljs-keyword">null</span> || main.length() == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
     buildBadCharPos(sub);
     <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mainLen = main.length();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> subLen = sub.length();
     suffix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[subLen];
    prefix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[subLen];
     buildSuffixPrefix(sux);
     <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt;= mainLen - subLen) {
      <span class="hljs-keyword">for</span> (j = subLen - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) {
        <span class="hljs-keyword">if</span> (main.charAt(i + j) != sub.charAt(j)) {
          <span class="hljs-keyword">break</span>;
        }
      }
      <span class="hljs-keyword">if</span> (j &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">return</span> i;
      }
      <span class="hljs-keyword">int</span> badMoveLength = j - bad[(<span class="hljs-keyword">int</span>)main.charAt(i + j)];
      <span class="hljs-keyword">int</span> goodSuffixMoveLength = <span class="hljs-number">0</span>;
      <span class="hljs-comment">// 有后缀串的时候，我们才去使用</span>
      <span class="hljs-comment">// 好后缀规则</span>
      <span class="hljs-comment">// 因为是在sub[j]匹配失败</span>
      <span class="hljs-comment">// 所以当j &gt;= subLen - 1的时候</span>
      <span class="hljs-comment">// 是没有后缀串的!</span>
      <span class="hljs-comment">// 当然也没有好后缀串了</span>
      <span class="hljs-keyword">if</span> (j &lt; subLen - <span class="hljs-number">1</span>) {
        <span class="hljs-function">goodSuffixMoveLength 
             <span class="hljs-title">moveBySuffixPrefix</span><span class="hljs-params">(j, subLex)</span></span>;
      }
      i += Math.max(badMoveLength, goodSuffixMoveLength);
    }
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }
</code></pre>
<blockquote data-nodeid="365">
<p data-nodeid="366">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.bm.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1668">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.bm.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1672">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.bm.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1676">Python</a></p>
</blockquote>
<p data-nodeid="367"><strong data-nodeid="1685">复杂度分析</strong>：时间复杂度，由于需要预处理 sub 字符串得到 suffix 和 prefix，这里的复杂度为 O(M<sup>2</sup>)。最差情况下，时间复杂度会下降到 O(N×M)。空间复杂度为 O(M)。不过对于无周期的模式串，大部分时间复杂度为 O(N)。其中 N 表示 main  字符串的长度，M 表示 sub 字符串的长度。</p>
<p data-nodeid="368">【<strong data-nodeid="1695">小结</strong>】这里我们引入了 BM 算法的一些概念，以及如何从右向左查找的时候进行优化。虽然 BM 算法最差情况下时间复杂度会掉到 O(N×M)，不过再加入一些优化，还是可以将这个算法更改为 O(N) 的线性算法。优化的具体细节，你可以阅读<a href="http://www-igm.univ-mlv.fr/~lecroq/string/node15.html#SECTION00150?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1693">Turbo-BM 算法</a>。</p>
<h3 data-nodeid="369">Sunday 算法</h3>
<p data-nodeid="370">Sunday 算法应该是除了暴力算法中最好懂的字符串匹配算法了（不过它在最差情况下是时间复杂度是 O(N×M)，看来跑得快的算法都需要“挠头发”）。</p>
<h4 data-nodeid="371">思路与步骤</h4>
<p data-nodeid="372">我们直接做个让你一看就懂的演示。首先假定字符串为 main = "substring searching" 中查找 sub = "search"。下图中 m 表示的是 sub 字符串的长度。</p>
<p data-nodeid="273824" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/6B/Cgp9HWB5QeyALQzIAAD1qwlBJsQ639.png" alt="Drawing 40.png" data-nodeid="273827"></p>

<p data-nodeid="374">匹配失败的时候，直接看 main 字符串<strong data-nodeid="1735">对齐之后，<strong data-nodeid="1734">紧接着的那个字符。比如当 'u' != 'e' 的时候，立马去看字符 'i'，我们称为</strong>Target Char</strong>。</p>
<p data-nodeid="375">由于 sub 中不存在字符 i，所以会移动 7 步（下面我们讲这个步数的计算）。</p>
<p data-nodeid="277452" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QfyANDuBAADvdZ_1hE0462.png" alt="Drawing 41.png" data-nodeid="277455"></p>

<p data-nodeid="377">再接着比较 'n' != 's'，那么会去看<strong data-nodeid="1763">Target Char</strong>字符 'r'，而 'r' 字符在 search 中的位置为 3。</p>
<p data-nodeid="281080" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QgOAAU_dAACZ8A8Y2do628.png" alt="Drawing 42.png" data-nodeid="281083"></p>

<p data-nodeid="379">经过再次移动，匹配成功。</p>
<h4 data-nodeid="380">移动规则</h4>
<p data-nodeid="381">匹配失败时，只需要向前移动 i + = sub.length() - lastPos[Target Char]。这里 lastPos[] 数组记录的是 sub 字符串中每个字符在 sub 最右边的位置。如果字符没有在 sub 中出现，则标记为 -1。</p>
<p data-nodeid="382">【<strong data-nodeid="1782">代码</strong>】至此，我们就可以写出如下代码了（解析在注释里）：</p>
<pre class="lang-java" data-nodeid="383"><code data-language="java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(String main, String sub)</span> </span>{
        <span class="hljs-keyword">if</span> (sub == <span class="hljs-keyword">null</span> || sub.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span> (main == <span class="hljs-keyword">null</span> || main.length() == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
  
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mainLen = main.length();
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> subLen = sub.length();
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;
  
        <span class="hljs-comment">// pos数组记录sub中每个字符在sub最右边的位置。</span>
        <span class="hljs-comment">// 如果不存在，用-1表示。</span>
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; pos.length; j++) {
            pos[j] = -<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; subLen; j++) {
            pos[(<span class="hljs-keyword">int</span>)sub.charAt(j)] = j;
        }
   
        <span class="hljs-keyword">while</span> (i &lt;= mainLen - subLen) {
            j = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">while</span> (main.charAt(i + j) == sub.charAt(j)) {
                j++;
                <span class="hljs-keyword">if</span> (j &gt;= subLen) {
                    <span class="hljs-keyword">return</span> i;
                }
            }
            
            <span class="hljs-comment">// 如果Target Char不在main的范围里面了</span>
            <span class="hljs-keyword">if</span> (i + subLen &gt;= mainLen) {
                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> targetChar = (<span class="hljs-keyword">int</span>)main.charAt(i + subLen);
            i += subLen - pos[targetChar];
        }
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
}
</code></pre>
<blockquote data-nodeid="384">
<p data-nodeid="385">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.sunday.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1786">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.sunday.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1790">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/28.%E5%AE%9E%E7%8E%B0-str-str.sunday.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1794">Python</a></p>
</blockquote>
<p data-nodeid="386"><strong data-nodeid="1799">复杂度分析</strong>：时间复杂度为 O(N×M)，其中 N 为 main 字符串的长度，M 为 sub 字符串的长度。空间复杂度为 O(256)。</p>
<p data-nodeid="387">【<strong data-nodeid="1805">小结</strong>】除了暴力算法，Sunday 算法应该是最好写的算法了。不过实现代码的时候，你仍需要注意两个地方：</p>
<ul data-nodeid="388">
<li data-nodeid="389">
<p data-nodeid="390">主循环中 while (i &lt;= mainLen - subLen)，如果取 i &lt; mainLen - subLen，那么无法处理  strStr("a", "a") 这种查找；</p>
</li>
<li data-nodeid="391">
<p data-nodeid="392">在取 target char 的时候，需要注意判断是不是越界。</p>
</li>
</ul>
<h3 data-nodeid="393">总结</h3>
<p data-nodeid="284708">为了方便你复习，我把本讲重点介绍的知识点整理在一张思维导图里：</p>
<p data-nodeid="284709" class=""><img src="https://s0.lgstatic.com/i/image6/M00/38/74/CioPOWB5QgyABaGxAAFjfJB6Wpo335.png" alt="Drawing 43.png" data-nodeid="284713"></p>


<p data-nodeid="396">学完本讲，我希望你可以思考一下，是哪些基础知识点导致你对算法没有清晰地理解。然后对照着上图，进行重点突破。</p>
<p data-nodeid="397">比如，你发现看不懂 KMP 算法的时候，可以查一下，是不是 PMT 的用途没有看懂？看不懂 BM 算法的时候，是不是因为没有弄明白坏字符规则与好后缀规则。</p>
<h3 data-nodeid="398">思考题</h3>
<p data-nodeid="399">最后我还给你留了一个思考题。</p>
<p data-nodeid="288338" class="te-preview-highlight">思考题：给定一个字符串 <em data-nodeid="288345"><strong data-nodeid="288344">s</strong></em>，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。</p>

<p data-nodeid="401">输入：s = "aacecaaa"</p>
<p data-nodeid="402">输出："aaacecaaa"</p>
<blockquote data-nodeid="403">
<p data-nodeid="404">代码 :<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.java?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1847">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.cpp?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1851">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/15.StrStr/214.%E6%9C%80%E7%9F%AD%E5%9B%9E%E6%96%87%E4%B8%B2.py?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="1855">Python</a></p>
</blockquote>
<p data-nodeid="405">我们的字符串查找算法就讲到这里了，接下来我们将要介绍 16 |如何利用 DP 与单调队列寻找最大矩形？让我们继续前进。</p>

---

### 精选评论

##### **辉：
> 从这句话开始看不懂了：凡是比较失败下标小于 4 的情况，都是无效比较（比如第 2 轮，第 4 轮）。因为这种比较还没有跑到 main[4] 就挂了（第 2 轮挂在 main[1]，第 4 轮挂在 main[3]）。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 首先暴力法实际上是把所有可能的情况都进行了比较。KMP在暴力法的基础上进行的优化是：我把情况分为两部分，一部分有效比较；另外一部分是无效比较。那么如何区分有效比较与无效比较。这里的原则是。如果main[i]与sub[j]在这里匹配失败。那么暴力法重新匹配的时候，如果在main[k] = sub[l]比较失败，并且k < i。那么这种比较就是无效比较。因为k < i。这种比较是!!绝对不可能!!产生匹配成功的情况的，因此，也称之为无效比较。这种无效比较是可以直接跳过的！如何跳过这些无效比较，也就是KMP算法要解决的问题。

##### **岳：
> 虽然看了一遍没有看懂，但还是觉得写的真好呀

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 小伙伴具体哪里没听懂可以留言提问哦，老师会帮你解答哈，加油～

##### **彬：
> 赞

##### **威：
> 太强了，老师的算法能力很厉害

