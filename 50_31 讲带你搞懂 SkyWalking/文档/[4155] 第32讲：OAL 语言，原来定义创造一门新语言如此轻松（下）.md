<p data-nodeid="45396">了解了 OAL 语言的基础语法以及 official_analysis.oal 文件中典型的 OAL 语句之后，我们来看 official_analysis.oal 文件是如何被解析的。</p>



<p data-nodeid="46178">在generate-tool-grammar 模块中会使 antlr4-maven-plugin 这个 Maven 插件处理 OALParser.g4 以及 OALLexer.g4 文件，得到相应的辅助类，如下图所示，这与前文 Antlr4 示例相同：</p>
<p data-nodeid="46179" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETYeADqgoAAE8NIoy0_c302.png" alt="Drawing 0.png" data-nodeid="46183"></p>


<p data-nodeid="44380">generate-tool 模块会使用上述辅助类识别 official_analysis.oal 文件并最终转换成 OALScripts 对象，相关的代码片段如下：</p>
<pre class="lang-java" data-nodeid="46576"><code data-language="java"><span class="hljs-comment">// 构造 official_analysis.oal 文件的完整路径</span>
String scriptFilePath = StringUtil.join(File.separatorChar,
    modulePath, <span class="hljs-string">"src"</span>, <span class="hljs-string">"main"</span>, <span class="hljs-string">"resources"</span>, <span class="hljs-string">"official_analysis.oal"</span>);
<span class="hljs-comment">// 创建 ScriptParser实例</span>
ScriptParser scriptParser =  
      ScriptParser.createFromFile(scriptFilePath);
<span class="hljs-comment">// 调用 parse()方法识别 official_analysis.oal文件</span>
OALScripts oalScripts = scriptParser.parse(); 
</code></pre>

<p data-nodeid="47375" class="">在 ScriptParser.parse() 方法中可以看到，generate-tool 模块与前文示例一样，也是使用 Listener 模式遍历生成的抽象语法树（AST）。最后生成的 OALScripts 对象底层封装了一个 List<code data-backticks="1" data-nodeid="47377">&lt;AnalysisResult&gt;</code>，每个 AnalysisResult 对应一条 OAL 语句。</p>

<p data-nodeid="48155">下面以 instance_jvm_old_gc_time 这条 OAL 语句生成的 AST 为例介绍 OALListener 中各个回调方法的执行流程，下图是该语句生成的简化版 AST，其中的红色箭头标记了 ParseTreeWalker 遍历各个节点的路径：</p>
<p data-nodeid="48156" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETZ2APvsSAAMOZtTc1cI758.png" alt="Drawing 1.png" data-nodeid="48168"></p>



<p data-nodeid="44384">另外，上图还按序标记了在对应节点上触发的 OALListener 方法，下面是这些方法的具体功能：</p>
<p data-nodeid="44385">(1).enterAggregationStatement() 方法：创建该语句对应的 AnalysisResult 对象。</p>
<p data-nodeid="44386">(2).exitVariable() 方法：填充 AnalysisResult 的 varName、metricsName、tableName 三个字段，会对大小写以及下划线进行处理。</p>
<p data-nodeid="44387">(3).enterSource() 方法：填充 AnalysisResult 的 sourceName、sourceScopeId 两个字段。</p>
<p data-nodeid="44388">(4).enterSourceAttribute() 方法：填充 AnalysisResult 的 sourceAttribute 字段。</p>
<p data-nodeid="44389">(5).enterFilterStatement() 方法：创建 ConditionExpression 对象。</p>
<p data-nodeid="44390">(6)~(8) 三个方法分别填充 ConditionExpression 对象中的三个字段。</p>
<p data-nodeid="44391">(9).exitFilterStatement() 方法：将 ConditionExpression 添加到 AnalysisResult 中的 filterExpressionsParserResult 集合。</p>
<p data-nodeid="44392">(10).enterFunctionName() 方法：填充 AnalysisResult 的 aggregationFunctionName 字段。</p>
<p data-nodeid="48945">到此为止，该 AnalysisResult 填充的字段如下图所示：</p>
<p data-nodeid="48946" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETaeAbBI9AAK4QkZfEcY292.png" alt="Drawing 2.png" data-nodeid="48950"></p>


<p data-nodeid="44395">(11).exitAggregationStatement() 方法：这里使用 DeepAnalysis 分析前 10 步从 OAL 语句获取到的信息，从而完整填充整个 AnalysisResult 对象。</p>
<ul data-nodeid="49725">
<li data-nodeid="49726">
<p data-nodeid="49727">在 DeepAnalysis 中首先会根据 aggregationFunctionName 确定当前指标的类型并填充 metricsClassName 字段。示例中的 longAvg 会查找到 LongAvgMetrics 类，如下图所示：</p>
</li>
</ul>
<p data-nodeid="49728" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETbGAKMAIAAEGRmp6VX8630.png" alt="Drawing 3.png" data-nodeid="49732"></p>


<ul data-nodeid="44400">
<li data-nodeid="44401">
<p data-nodeid="44402">接下来会查找 LongAvgMetrics 类中 @Entrance 注解标注的入口方法，即 combine() 方法，创建相应的 EntryMethod 对象填充到 entryMethod 字段中。这里生成的 EntryMethod 对象不仅包含入口方法的名称，还会根据入口方法参数上的注解生成相应的参数表达式。</p>
</li>
</ul>
<p data-nodeid="44403">依然以 LongAvgMetrics 为例，combine() 方法的定义如下：</p>
<pre class="lang-java" data-nodeid="50125"><code data-language="java"><span class="hljs-meta">@Entrance</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-meta">@SourceFrom</span> <span class="hljs-keyword">long</span> summation, <span class="hljs-meta">@ConstOne</span> <span class="hljs-keyword">int</span> count)</span> </span>{
    <span class="hljs-keyword">this</span>.summation += summation;
    <span class="hljs-keyword">this</span>.count += count;
}
</code></pre>

<p data-nodeid="50518">之前我们只关心了方法内的具体逻辑，没有关注方法以及参数上的注解。@Entrance 注解标识了该方法为入口方法，@SourceFrom 标识了该参数来自 OAL 语句前面指定的 source.sourceAttribute，即 ServiceInstanceJVMGC.time，@ ConstOne 标识该参数固定为 1。</p>
<p data-nodeid="50519">查找 @Entrance 标注的方法的逻辑比较简单，就是遍历 LongAvgMetrics 以及父类所有方法即可。这里来看处理 @SourceFrom 以及 @ConstOne 注解的相关代码如下：</p>

<pre class="lang-java" data-nodeid="50914"><code data-language="java">EntryMethod entryMethod = <span class="hljs-keyword">new</span> EntryMethod();
result.setEntryMethod(entryMethod);&nbsp;
<span class="hljs-comment">// @Entrance注解标注的入口方法名</span>
entryMethod.setMethodName(entranceMethod.getName());

<span class="hljs-comment">// 根据入口方法的参数设置参数代码</span>
<span class="hljs-keyword">for</span> (Parameter parameter : entranceMethod.getParameters()) {
&nbsp; &nbsp; Annotation[] parameterAnnotations = parameter.getAnnotations();
&nbsp; &nbsp; Annotation annotation = parameterAnnotations[<span class="hljs-number">0</span>];
&nbsp; &nbsp; <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> SourceFrom) {
&nbsp; &nbsp; &nbsp; &nbsp; entryMethod.addArg(<span class="hljs-string">"source."</span> + ClassMethodUtil
             .toGetMethod(result.getSourceAttribute()) + <span class="hljs-string">"()"</span>);
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (annotation <span class="hljs-keyword">instanceof</span> ConstOne) {
&nbsp; &nbsp; &nbsp; &nbsp; entryMethod.addArg(<span class="hljs-string">"1"</span>);
&nbsp; &nbsp; }&nbsp;
&nbsp; &nbsp; <span class="hljs-comment">// 还有针对其他注解的处理，例如 @Expression、@ExpressionArg0等，不再展开</span>
}
</code></pre>

<p data-nodeid="51693">最终创建的 EntryMethod 对象如下图所示：</p>
<p data-nodeid="51694" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETcGAFSJfAAD90Ejj-vM209.png" alt="Drawing 4.png" data-nodeid="51698"></p>


<ul data-nodeid="52475">
<li data-nodeid="52476">
<p data-nodeid="52477">扫描 LongAvgMetrics 中的全部字段，将所有 @Column 注解标注的字段封装成 DataColumn 对象记录到 persistentFields 集合中。</p>
</li>
<li data-nodeid="52478">
<p data-nodeid="52479">根据 sourceName 字段的值从 generator-scope-meta.yml 文件中查找该 source 默认新增的字段，如下图所示，InstanceJvmOldGcTimeMetrics 需要新增 entityId、serviceId 两个字段，这也与我们之前的分析相同。这些新增字段会记录到 fieldsFromSource 集合中。</p>
</li>
</ul>
<p data-nodeid="52480" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/1A/CgqCHl8ETciAVpVKAAEuRAJmdIU888.png" alt="Drawing 5.png" data-nodeid="52485"></p>


<p data-nodeid="44414">到此为止，instance_jvm_old_gc_time 这条 OAL 语句对应的 AnalysisResult 对象填充完毕。在第 11 步 exitAggregationStatement() 方法的最后，会将该 AnalysisResult 对象记录到 OALScripts.metricsStmts 集合中，作为后续 FreeMarker 填充模板的数据。</p>
<h3 data-nodeid="54438" class="">MetricsImplementor 模板</h3>





<p data-nodeid="44416">在完成 official_analysis.oal 文件中全部 OAL 语句的处理之后，会将 OALScripts 对象传入到 FileGenerator 中完成 Java 代码生成。在 FileGenerator 的构造方法中会初始化 Configuration 对象，与前面介绍的 FreeMarker 示例相同。</p>
<p data-nodeid="44417">在 FileGenerator.generate() 方法中会遍历全部 AnalysisResult 对象，为每个 AnalysisResult 对象生成相应的 Metrics 类以及 Dispatcher 类。创建 Metrics 类时使用的是 MetricsImplementor.ftl 模板文件，相关代码如下：</p>
<pre class="lang-java" data-nodeid="54816"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateMetricsImplementor</span><span class="hljs-params">(AnalysisResult result,Writer output)</span> </span>{
   configuration.getTemplate(<span class="hljs-string">"MetricsImplementor.ftl"</span>)
        .process(result, output);
}
</code></pre>

<p data-nodeid="44419">在 MetricsImplementor.ftl 这个模板文件中，我们重点关注一下字段生成的逻辑以及 id() 方法的逻辑，具体如下所示：</p>
<pre class="lang-dart" data-nodeid="57832"><code data-language="dart">&lt;!-- 直接获取 AnalysisResult中相应的字段值，生成的<span class="hljs-meta">@Stream</span>注解--&gt;
<span class="hljs-meta">@Stream</span>(name = <span class="hljs-string">"<span class="hljs-subst">${tableName}</span>"</span>, 
        scopeId = ${sourceScopeId}, 
        builder = ${metricsName}Metrics.Builder.<span class="hljs-keyword">class</span>, 
        processor = MetricsStreamProcessor.<span class="hljs-keyword">class</span>)
&lt;!-- 填充类名以及父类名称 --&gt;        
public <span class="hljs-keyword">class</span> ${metricsName}Metrics <span class="hljs-keyword">extends</span> ${metricsClassName} 
    <span class="hljs-keyword">implements</span> WithMetadata {
&lt;!-- 遍历 AnalysisResult中的 fieldsFromSource集合，生成相应的字段 --&gt;
&lt;#list fieldsFromSource <span class="hljs-keyword">as</span> sourceField&gt;
    &lt;!-- 设置 <span class="hljs-meta">@Column</span>注解的名称 --&gt;
    <span class="hljs-meta">@Setter</span> <span class="hljs-meta">@Getter</span> <span class="hljs-meta">@Column</span>(columnName = <span class="hljs-string">"<span class="hljs-subst">${sourceField.columnName}</span>"</span>) 
    &lt;!-- 根据配置是否添加 <span class="hljs-meta">@IDColumn</span>注解 --&gt;
    &lt;#<span class="hljs-keyword">if</span> sourceField.isID()&gt;<span class="hljs-meta">@IDColumn</span>&lt;/#<span class="hljs-keyword">if</span>&gt;   
    private ${sourceField.typeName} ${sourceField.fieldName};
&lt;/#list&gt;

    <span class="hljs-meta">@Override</span> public <span class="hljs-built_in">String</span> id() {
        <span class="hljs-built_in">String</span> splitJointId = <span class="hljs-built_in">String</span>.valueOf(getTimeBucket());
&lt;!-- 遍历 AnalysisResult中的 fieldsFromSource集合 --&gt;
&lt;#list fieldsFromSource <span class="hljs-keyword">as</span> sourceField&gt;
    &lt;#<span class="hljs-keyword">if</span> sourceField.isID()&gt; &lt;!-- 根据ID配置决定是否参与构造Document Id--&gt;
        &lt;#<span class="hljs-keyword">if</span> sourceField.getTypeName() == <span class="hljs-string">"java.lang.String"</span>&gt;
            splitJointId += Const.ID_SPLIT + ${sourceField.fieldName};
        &lt;#<span class="hljs-keyword">else</span>&gt;
            splitJointId += Const.ID_SPLIT +
                  <span class="hljs-built_in">String</span>.valueOf(${sourceField.fieldName});
        &lt;/#<span class="hljs-keyword">if</span>&gt;
    &lt;/#<span class="hljs-keyword">if</span>&gt;
&lt;/#list&gt;
        <span class="hljs-keyword">return</span> splitJointId;
    }
    &lt;!-- 省略后续其他方法 --&gt;
}
</code></pre>








<p data-nodeid="44421">Metrics 类其他方法的生成方式与 id() 方法类似，只是使用的 AnalysisResult 字段不同。你可以将 MetricsImplementor.ftl 模板与 InstanceJvmOldGcTimeMetrics.java 进行比较，更便于理解。</p>
<h3 data-nodeid="59729" class="">DispatcherTemplate 模板</h3>





<p data-nodeid="60443">在前文介绍 Dispatcher 的时候提到，不同 Dispatcher 实现会对关联的 Source 进行分析并转换成 Metrics 传入到 MetricsStreamProcessor 进行后续的流处理。例如，ServiceInstanceJVMGCDispatcher 会将一个 ServiceInstanceJVMGC 对象转换成下图展示的四个 Metrics 对象：</p>
<p data-nodeid="60444" class=""><img src="https://s0.lgstatic.com/i/image/M00/2E/0E/Ciqc1F8ETfCABEkKAAEpESqaVTE235.png" alt="Drawing 6.png" data-nodeid="60448"></p>


<p data-nodeid="44425">相应的，FileGenerator 生成 Dispatcher 实现类的代码之前，会将由同一个 Source 衍生出来的 Metrics 封装到一个 DispatcherContext 对象， DispatcherContext 的核心字段如下：</p>
<pre class="lang-java" data-nodeid="60809"><code data-language="java"><span class="hljs-keyword">private</span> String source; <span class="hljs-comment">// Source 名称</span>
<span class="hljs-keyword">private</span> String packageName; <span class="hljs-comment">// Dispatcher所在包名</span>
<span class="hljs-comment">// 该 Source所有衍生 Metrics对应的 AnalysisResult对象集合</span>
<span class="hljs-keyword">private</span> List&lt;AnalysisResult&gt; metrics = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(); 
</code></pre>

<p data-nodeid="44427">生成 Dispatcher 实现类使用的是 DispatcherTemplate.ftl 模板文件，填充的数据来自 DispatcherContext，入口是 FileGenerator.generateDispatcher() 方法：</p>
<pre class="lang-java" data-nodeid="61170"><code data-language="java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generateDispatcher</span><span class="hljs-params">(AnalysisResult result, Writer output)</span> </span>{
    String scopeName = result.getSourceName(); 
    <span class="hljs-comment">// 根据 Source名称查找相应的 DispatcherContext</span>
    DispatcherContext context =  
         allDispatcherContext.getAllContext().get(scopeName);
    <span class="hljs-comment">// 生成 Dispatcher实现类的代码并写入到指定文件中</span>
    configuration.getTemplate(<span class="hljs-string">"DispatcherTemplate.ftl"</span>)
           .process(context, output);
}
</code></pre>

<p data-nodeid="44429">接下来看 DispatcherTemplate.ftl 的实现，它会遍历 DispatcherContext.metrics 集合为每个 Metrics 生成相应的 do*() 方法，核心实现如下：</p>
<pre class="lang-java" data-nodeid="61531"><code data-language="java">&lt;#list metrics as metrics&gt; &lt;!-- 遍历 DispatcherContext.metrics 集合 --&gt;
    &lt;!--&nbsp;填充 do*()方法签名 --&gt;
    &lt;!-- 示例中对应 doInstanceJvmOldGcTime(ServiceInstanceJVMGC)方法 --&gt;
    private void do${metrics.metricsName}(${source} source) {
        &lt;!--&nbsp;创建相应的Metrics实例 --&gt;
        ${metrics.metricsName}Metrics metrics = 
              new ${metrics.metricsName}Metrics();
    &lt;#if metrics.filterExpressions??&gt;
        &lt;!--根据 OAL语句中 filter表达式生成对source过滤的代码(略)&nbsp;--&gt;
    &lt;/#if&gt;
        &lt;!-- 下面开始填充 Metrics对象 --&gt;
        metrics.setTimeBucket(source.getTimeBucket());
    &lt;#list metrics.fieldsFromSource as field&gt;
        metrics.${field.fieldSetter}(source.${field.fieldGetter}());
    &lt;/#list&gt;
        &lt;!-- 根据 AnalysisResult.entryMethod 生成调用入口方法的代码 --&gt;
        &lt;!-- doInstanceJvmOldGcTime() 方法中调用的是 combine() 方法 --&gt;
        metrics.${metrics.entryMethod.methodName}(
          &lt;!-- 生成入口方法的参数 --&gt;
           &lt;#list metrics.entryMethod.argsExpressions as arg&gt;
             ${arg}&lt;#if arg_has_next&gt;, &lt;/#if&gt;&lt;/#list&gt;
         );
        MetricsStreamProcessor.getInstance().in(metrics);
    }
&lt;/#list&gt;
</code></pre>

<p data-nodeid="44431">为了更好地理解 FreeMarker 填充数据的逻辑，你可以将 DispatcherTemplate.ftl 模板生成 do*() 方法的逻辑与生成后的 ServiceInstanceJVMGCDispatcher.doInstanceJvmOldGcTime() 方法进行比较。</p>
<h3 data-nodeid="62975" class="">内置&nbsp;oal 引擎</h3>




<p data-nodeid="44433">从&nbsp;6.3 版本的开始，SkyWalking&nbsp;将 OAL&nbsp;引擎内置到&nbsp;OAP&nbsp;Server 中，在&nbsp;OAP Server 启动时会动态生成 Metrics&nbsp;类实现以及相应 Dispatcher 实现，我们可以在 CoreModuleProvider.prepare() 方法中看到下面这段代码（6.3 版本之后的代码）：</p>
<pre class="lang-java te-preview-highlight" data-nodeid="63331"><code data-language="java">oalEngine = OALEngineLoader.get();
oalEngine.setStreamListener(streamAnnotationListener);
oalEngine.setDispatcherListener(receiver.getDispatcherManager());
oalEngine.start(getClass().getClassLoader());
</code></pre>

<p data-nodeid="44435">在 oalEngine.start() 方法中会解析 official_analysis.oal 文件得到 OALScripts 对象，然后使用 Javassist 和 FreeMarker 生成的 Metrics 和 Dispatcher 实现类，最后直接通过传入的 ClassLoader 加载到 JVM。<br>
6.3 版本中生成代码的核心实现与 6.2 版本中生成代码的核心实现基本类似，只有下面的微小区别：</p>
<ul data-nodeid="44436">
<li data-nodeid="44437">
<p data-nodeid="44438">6.3 版本之后的 OAL 语法略有改动，但改动很小，并不影响理解。</p>
</li>
<li data-nodeid="44439">
<p data-nodeid="44440">6.3 版本之后在运行时生成代码，而 6.2 版本是在编译期生成。</p>
</li>
<li data-nodeid="44441">
<p data-nodeid="44442">6.3 版本之后生成代码时使用了 Javassist 和 FreeMarker，6.2 版本只使用了 FreeMarker。</p>
</li>
<li data-nodeid="44443">
<p data-nodeid="44444">6.3 版本之后生成的代码默认不会保存到磁盘中，我们可以在环境变量中设置 SW_OAL_ENGINE_DEBUG=Y 参数保存运行时生成的 Java 文件。如果你感兴趣可以对比 6.2 和 6.3 生成的 Java 代码，会发现两者区别不大。</p>
</li>
</ul>

---

### 精选评论

##### **斌：
> 花了大半年时间，今天终于撸完了这个专栏，作者 牛逼！！

