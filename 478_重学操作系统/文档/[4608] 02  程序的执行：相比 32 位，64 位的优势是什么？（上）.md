<p data-nodeid="8755" class="">本节课给你讲学习操作系统之前的一个前置知识：程序是如何执行的？</p>
<p data-nodeid="8756"><strong data-nodeid="8892">我们先来看一道常规的面试题：相比 32 位，64 位的优势是什么</strong>？</p>
<p data-nodeid="8757">面试官考察这种类型的问题，主要是想看求职者是否有扎实的计算机基础，同时想知道求职者在工作中是否充满好奇，会主动学习、寻根问底，毕竟 32、64 位是经常出现在程序员视野的词汇，常见的东西都弄明白了，那说明这个人学习能力强。</p>
<p data-nodeid="8758">其实 ，面试官在这里给你挖了一个陷阱，因为他没有说清楚 32、64 位指的是操作系统、是软件、还是 CPU？</p>
<ul data-nodeid="8759">
<li data-nodeid="8760">
<p data-nodeid="8761">如果是软件，那么我们的数据库有 32 位和 64 位版本；</p>
</li>
<li data-nodeid="8762">
<p data-nodeid="8763">如果是操作系统，那么在阿里云上选择 Centos 和 Debian 版本的时候，也会有 32/64 版本；</p>
</li>
<li data-nodeid="8764">
<p data-nodeid="8765">如果是 CPU，那么有 32 位 CPU，也有 64 位 CPU。</p>
</li>
</ul>
<p data-nodeid="8766">接下来请你带着问题开始今天的课程学习，本课时的重点是带你学懂程序执行的原理。</p>
<h3 data-nodeid="8767">图灵机的构造</h3>
<p data-nodeid="8768">想要学懂程序执行的原理，就要从图灵机说起了。它在计算机科学方面有两个巨大的贡献：</p>
<p data-nodeid="8769">第一，它清楚地定义了计算机能力的边界，也就是可计算理论；</p>
<p data-nodeid="8770">第二，它定义了计算机由哪些部分组成，程序又是如何执行的。</p>
<p data-nodeid="8771"><img src="https://s0.lgstatic.com/i/image/M00/4C/BE/Ciqc1F9YkgKAMPJ6ABSBvBPOVvk790.png" alt="Drawing 0.png" data-nodeid="8905"></p>
<p data-nodeid="8772">我们先来看一看图灵机的内部构造：</p>
<ol data-nodeid="8773">
<li data-nodeid="8774">
<p data-nodeid="8775">图灵机拥有一条无限长的纸带，纸带上是一个格子挨着一个格子，格子中可以写字符，你可以把纸带看作内存，而这些字符可以看作是内存中的数据或者程序。</p>
</li>
<li data-nodeid="8776">
<p data-nodeid="8777">图灵机有一个读写头，读写头可以读取任意格子上的字符，也可以改写任意格子的字符。</p>
</li>
<li data-nodeid="8778">
<p data-nodeid="8779">读写头上面的盒子里是一些精密的零件，包括图灵机的存储、控制单元和运算单元。</p>
</li>
</ol>
<h3 data-nodeid="8780">图灵机如何执行程序</h3>
<p data-nodeid="8781">下面我们来举一个例子，让大家弄清楚图灵机是如何工作的，比如我们要计算 11 + 15 的值，具体的运算步骤如下：</p>
<ul data-nodeid="8782">
<li data-nodeid="8783">
<p data-nodeid="8784">首先，我们将“11、15、+” 分别写入纸带上的 3 个格子（现在纸带上的字符串是11、15、 +)，然后将读写头先停在 11 对应的格子上。</p>
</li>
</ul>
<p data-nodeid="8785"><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/Ciqc1F9YoK6AM2frAAAtDcKchOk422.png" alt="1.png" data-nodeid="8915"></p>
<ul data-nodeid="8786">
<li data-nodeid="8787">
<p data-nodeid="8788">接下来，图灵机通过读写头读入 11 到它的存储设备中（这个存储设备也叫作图灵机的状态）。图灵机没有说读写头为什么可以识别纸带上的字符，而是假定读写头可以做到这点。</p>
</li>
</ul>
<p data-nodeid="8789"><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/Ciqc1F9YoLWAYNkqAABb6DZsrMk959.png" alt="2.png" data-nodeid="8919"></p>
<ul data-nodeid="8790">
<li data-nodeid="8791">
<p data-nodeid="8792">然后读写头向右移动一个格，用同样的方法将 15 读入图灵机的状态中。现在图灵机的状态中有两个连续的数字，11 和 15。</p>
</li>
</ul>
<p data-nodeid="8793"><img src="https://s0.lgstatic.com/i/image/M00/4C/D6/CgqCHl9YoL2AYCJbAABc5X0-CI4938.png" alt="3.png" data-nodeid="8923"></p>
<ul data-nodeid="8794">
<li data-nodeid="8795">
<p data-nodeid="8796">接下来重复上面的过程，会读到一个+号。下面我详细说一下这个运算流程：</p>
<ul data-nodeid="8797">
<li data-nodeid="8798">
<p data-nodeid="8799">读写头读到一个 + 号 ；</p>
</li>
<li data-nodeid="8800">
<p data-nodeid="8801">然后将 + 号传输给控制单元 ；</p>
</li>
<li data-nodeid="8802">
<p data-nodeid="8803">控制单元发现是一个 + 号，所以没有存入状态中。因为 + 号是一个我们预设的控制符（指令），它的作用是加和目前状态。因此，控制单元识别出是控制符，并通知运算单元工作；</p>
</li>
<li data-nodeid="8804">
<p data-nodeid="8805">运算单元从状态中读入 11、15 并进行计算，将结果 26 存储到状态；</p>
</li>
<li data-nodeid="8806">
<p data-nodeid="8807">运算单元将结果回传给控制单元；</p>
</li>
<li data-nodeid="8808">
<p data-nodeid="8809">控制单元将结果传输给读写头。</p>
</li>
</ul>
</li>
</ul>
<p data-nodeid="8810"><img src="https://s0.lgstatic.com/i/image/M00/4C/CB/Ciqc1F9YoMSAa9_WAADEZsnCSoU226.png" alt="4.png" data-nodeid="8933"></p>
<ul data-nodeid="8811">
<li data-nodeid="8812">
<p data-nodeid="8813">读写头向右移动，将结果 26 写入纸带。</p>
</li>
</ul>
<p data-nodeid="8814"><img src="https://s0.lgstatic.com/i/image/M00/4C/D6/CgqCHl9YoMqAB2JiAAA2igzBi94334.png" alt="5.png" data-nodeid="8937"></p>
<p data-nodeid="8815">这样，我们就通过图灵机计算出了 11+15 的值。不知道你有没有发现，图灵机构造的这一台机器，主要功能就是读写纸带然后计算；纸带中有数据、也有控制字符（也就是指令），这个设计和我们今天的计算机是一样的。</p>
<p data-nodeid="8816">图灵通过数学证明了，一个问题如果可以拆解成图灵机的可执行步骤，那问题就是可计算的。另一方面，图灵机定义了计算机的组成以及工作原理，但是没有给出具体的实现。</p>
<h3 data-nodeid="8817">冯诺依曼模型</h3>
<p data-nodeid="8818"><img src="https://s0.lgstatic.com/i/image/M00/4E/A2/CgqCHl9e5VaANB2BAAEVncqxxwI213.png" alt="1.png" data-nodeid="8943"></p>
<p data-nodeid="8819">具体的实现是 1945 年冯诺依曼和其他几位科学家在著名的 101 页报告中提出的。报告遵循了图灵机的设计，并提出用电子元件构造计算机，约定了用二进制进行计算和存储，并且将计算机结构分成以下 5 个部分：</p>
<ol data-nodeid="8820">
<li data-nodeid="8821">
<p data-nodeid="8822">输入设备；</p>
</li>
<li data-nodeid="8823">
<p data-nodeid="8824">输出设备；</p>
</li>
<li data-nodeid="8825">
<p data-nodeid="8826">内存；</p>
</li>
<li data-nodeid="8827">
<p data-nodeid="8828">中央处理器；</p>
</li>
<li data-nodeid="8829">
<p data-nodeid="8830">总线。</p>
</li>
</ol>
<p data-nodeid="8831">这个模型也被称为冯诺依曼模型，下面我们具体来看看这 5 部分的作用。</p>
<h4 data-nodeid="8832">内存</h4>
<p data-nodeid="8833">在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。存储的数据单位是一个二进制位，英文是 bit。最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>
<p data-nodeid="8834">我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</p>
<h4 data-nodeid="8835">CPU</h4>
<p data-nodeid="8836">冯诺依曼模型中 CPU 负责控制和计算。为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>
<ul data-nodeid="8837">
<li data-nodeid="8838">
<p data-nodeid="8839">如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</p>
</li>
<li data-nodeid="8840">
<p data-nodeid="8841">如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</p>
</li>
</ul>
<p data-nodeid="8842">这里的 32 和 64，称作 CPU 的位宽。</p>
<p data-nodeid="8843">为什么 CPU 要这样设计呢？ 因为一个 byte 最大的表示范围就是 0~255。比如要计算 20000*50，就超出了byte 最大的表示范围了。因此，CPU 需要支持多个 byte 一起计算。当然，CPU 位数越大，可以计算的数值就越大。但是在现实生活中不一定需要计算这么大的数值。比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p>
<p data-nodeid="8844"><strong data-nodeid="8967">控制单元和逻辑运算单元</strong></p>
<p data-nodeid="8845">CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。具体的工作原理我们在指令部分给大家分析。</p>
<p data-nodeid="8846"><strong data-nodeid="8972">寄存器</strong></p>
<p data-nodeid="8847">CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。这种存储就是寄存器。寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p>
<ul data-nodeid="8848">
<li data-nodeid="8849">
<p data-nodeid="8850">寄存器中有一部分是可供用户编程用的，比如用来存加和指令的两个参数，是<strong data-nodeid="8979">通用寄存器</strong>。</p>
</li>
<li data-nodeid="8851">
<p data-nodeid="8852">还有一部分寄存器有特殊的用途，叫作<strong data-nodeid="8985">特殊寄存器</strong>。比如程序指针，就是一个特殊寄存器。它存储了 CPU 要执行的下一条指令所在的内存地址。注意，程序指针不是存储了下一条要执行的指令，此时指令还在内存中，程序指针只是存储了下一条指令的地址。</p>
</li>
<li data-nodeid="8853">
<p data-nodeid="8854">下一条要执行的指令，会从内存读入到另一个特殊的寄存器中，这个寄存器叫作<strong data-nodeid="8991">指令寄存器</strong>。指令被执行完成之前，指令都存储在这里。</p>
</li>
</ul>
<h4 data-nodeid="8855">总线</h4>
<p data-nodeid="8856">CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。总线分成 3 种：</p>
<ul data-nodeid="8857">
<li data-nodeid="8858">
<p data-nodeid="8859">一种是<strong data-nodeid="8999">地址总线</strong>，专门用来指定 CPU 将要操作的内存地址。</p>
</li>
<li data-nodeid="8860">
<p data-nodeid="8861">还有一种是<strong data-nodeid="9005">数据总线</strong>，用来读写内存中的数据。</p>
</li>
</ul>
<p data-nodeid="8862">当 CPU 需要读写内存的时候，先要通过地址总线来指定内存地址，再通过数据总线来传输数据。</p>
<ul data-nodeid="8863">
<li data-nodeid="8864">
<p data-nodeid="8865">最后一种总线叫作<strong data-nodeid="9012">控制总线</strong>，用来发送和接收关键信号，比如后面我们会学到的中断信号，还有设备复位、就绪等信号，都是通过控制总线传输。同样的，CPU 需要对这些信号进行响应，这也需要控制总线。</p>
</li>
</ul>
<h4 data-nodeid="8866">输入、输出设备</h4>
<p data-nodeid="8867">输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p>
<p data-nodeid="8868">到这里，相信你已经对冯诺依曼模型的构造有了一定的了解。这里我再强调几个问题：</p>
<h5 data-nodeid="8869">1. 线路位宽问题</h5>
<p data-nodeid="8870">第一个问题是，你可能会好奇数据如何通过线路传递。其实是通过操作电压，低电压是 0，高电压是 1。</p>
<p data-nodeid="8871">如果只有一条线路，每次只能传递 1 个信号，因为你必须在 0,1 中选一个。比如你构造高高低低这样的信号，其实就是 1100，相当于你传了一个数字 10 过去。大家注意，这种传递是相当慢的，因为你需要传递 4 次。</p>
<p data-nodeid="8872">这种一个 bit 一个 bit 发送的方式，我们叫作串行。如果希望每次多传一些数据，就需要增加线路，也就是需要并行。</p>
<p data-nodeid="8873">如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；如果有 10 条地址总线，一次就可以表示 2<sup>10</sup> 种情况，也就是可以操作 1024 个内存地址；如果你希望操作 4G 的内存，那么就需要 32 条线，因为 2<sup>32</sup> 是 4G。</p>
<p data-nodeid="8874">到这里，你可能会问，那我串行发送行不行？当然也不是不行，只是速度会很慢，因为每多增加一条线路速度就会翻倍。</p>
<h5 data-nodeid="8875">2. 64 位和 32 位的计算</h5>
<p data-nodeid="8876">第二个问题是，CPU 的位宽会对计算造成什么影响？</p>
<p data-nodeid="8877">我们来看一个具体场景：要用 32 位宽的 CPU，加和两个 64 位的数字。</p>
<p data-nodeid="8878">32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。</p>
<p data-nodeid="9060" class="">因此必须把两个 64 位数字拆成 2 个 32 位数字来计算，这样就需要一个算法，比如用像小时候做加法竖式一样，先加和两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位。</p>

<p data-nodeid="8880">而 64 位的 CPU 就可以一次读入 64 位的数字，同时 64 位的 CPU 内部的逻辑计算单元，也支持 64 位的数字进行计算。但是你千万不要仅仅因为位宽的区别，就认为 64 位 CPU 性能比 32 位高很多。</p>
<p data-nodeid="8881">要知道大部分应用不需要计算超过 32 位的数字，比如你做一个电商网站，用户的金额通常是 10 万以下的，而 32 位有符号整数，最大可以到 20 亿。所以这样的计算在 32 位还是 64 位中没有什么区别。</p>
<p data-nodeid="8882" class="">还有一点要注意，32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。比如说你有一条 40 位的地址总线（其实就是 40 条线），32 位的 CPU 没有办法一次给 40 个信号，因为它最多只有 32 位的寄存器。因此 32 位宽的 CPU 最多操作 2<sup>32</sup> 个内存地址，也就是 4G 内存地址。</p>
<h3 data-nodeid="8883">总结</h3>
<p data-nodeid="8884">关于计算机组成和指令部分，我们就先学到这里。这节课我们通过图灵机和冯诺依曼模型学习了计算机的组成、CPU 的工作原理等。此外，我们还顺带讨论了 32 位和 64 位的区别，现在，<strong data-nodeid="9052">你可以回答 64 位和 32 位比较有哪些优势了吗</strong>？</p>
<p data-nodeid="8885">请你先自己思考这个问题的答案，再来 <strong data-nodeid="9058">03 课时</strong>查看详细的分析过程。</p>
<p data-nodeid="8886" class="">你可以把你的思考、思路或者课后总结写在留言区，这样可以帮助你产生更多的思考，也是构建知识体系的一部分。经过长期的积累，相信你会得到意想不到的收获。如果你觉得今天的内容对你有所启发，欢迎分享给身边的朋友。期待看到你的思考！</p>

---

### 精选评论

##### **郁：
> 老师以后再出个编译原理和网络的课吧，这样就把计算机基础知识架构都重学一遍

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 林老师的《计算机网络》课程后面也会在拉勾教育上线，同学可以关注一下哦

##### **睿：
> 酣畅淋漓啊 老师以后再出个计算机网络的课吧

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 老师已经在准备咯～

##### **邪：
> 还有一个问题：计算机为什么用二进制

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 说说我自己的见解，因为电平高、低刚好是1,0； 所以就成了2进制。

##### **辉：
> 1. 线路位宽问题 中 1100 应该是等于 12

##### **曦：
> 分享下总结https://github.com/SedationH/web-roam/blob/master/08OS/02%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.md

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 给你点赞～

##### *方：
> 1. 图灵机的两大贡献：1) 清晰的定义了计算机的边界(可计算理论) 2) 定义了计算机的组成部分，以及程序如何运行2. 冯诺依曼模型对图灵机进行具体的实现。包括CPU，内存，总线，I/O设备3. 在冯模型中内存程序内存线性排列并存储。存储单位为bit，最小的存储单元为8个bit(1 byte)。在内存中任何位置的读写速度相同。内存地址从0开始，下一个地址为1，一直到 (内存的字节数 - 1)4. CPU负责控制和运算，32和64位指的是CPU一次可运算的位(bit)数。32位(4 byte); 64位(8 byte)5. CPU中包括运算单元，控制单元和寄存器。寄存器又分为1)通用寄存器，用于用户编程使用。2) 特殊寄存器，用于存储下一个要执行的指令的内存地址 3) 读取到的指令会放到指令寄存器。CPU从寄存器的读取速度远远高于从内存读取6. 总线用于冯模型中，各个设备之间的通信。分为1)内存总线，用于操作内存地址 2)数据总线，用于读取内存数据 3)控制总线，用于传输关键信号，如中断，复位，就绪等7. I/O设备，用于计算机与外界交互8. 数据是通过高低电压传输(高1,低0)，并行传递信号可提升传输效率。线路位宽限制了每次并行传输的最大信号量。如果是32位地址总线则可以操作2^32位内存(4G)9. 32位宽CPU操作64位数据时，需要分为两次32位操作。32位操作系统无法控制高于32位的总线。64位相对于32位的优势：因为一次性并行传输的信号量以及CPU的处理能力从2^32 变成了 2^64，因此可以操作的数据量和内存地址范围都变成了32位的2次幂

##### **兴：
> 32位的cpu没法控制超过32位的地址总线，真的是这样吗？x86cpu运行在实模式时，寄存器只能使用低16位，但是可以使用20位的地址总线，使得可以使用1m的物理内存。我理解的有问题吗？希望老师指出

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这里我说的不好， 之后改一下。你说的没错，寄存器只有16位也可以操作20位地址。 比如一个1位的CPU也可以接1000根引脚连到1000位的总线上，只不过需要1000次操作才能把数据写到总线上。如果寄存器只有16位要操作20位地址，那么就需要分步骤操作。类似后面讲虚拟内存的方法。

##### **曦：
> 修：感觉这里是在强调一次读入，32位CPU不是不能计算64位的数据（通过一些算法）FORM：因为 32 位宽的 CPU 中没有 64 位的寄存器，所以就算地址总线、数据总线都超过 32 位，读入的数据也只能是 32 位。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 对，一次读入，谢谢反馈。

##### *剑：
> CPU计算层面的话，64位CPU在计算大数据的时候比32位更高效，但是这种场景不多然后是通信层面，64位可以操作更大的内存，以及和内存之间进行更高速的通信，因为支持的地址总线更大

##### **涛：
> 32位的最大正整数应该是二进制的三十二个一转换为十进制，也就是4294967295。

##### *浩：
> 听完一遍还没什么感觉，还是得会看

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 可以结合网络搜索补充自己的知识储备，课后可以利用文字版反复理解，学习效果会更好 。

##### rick：
> 1. 可以寻址更大范围的内存2. 算数逻辑单元单次可以运算的数据范围更大

##### *尚：
> 除数值计算外，64位可以有更大的寻址空间。所以给32位cpu装8g内存意义不大，但64位就可以为程序分配更多的内存，以增加运行效率

##### **龙：
> 64位的cpu可以一次计算更大的数；64位的总线可以一次传输更多的控制指令，从而缩短一段指令的执行时间

##### *松：
> 老师讲的真的很有逻辑，感谢！

##### *冲：
> 32位和64位的区别，就是CPU数据总线或者寄存器的宽度，一次能处理多大的数据。使用64位CPU，处理较大的定点数时就不用分两次处理了。32位和64位操作系统，则对应着不同位宽的CPU，64位的CPU可以兼容两种，而32位的CPU只能支持32位操作系统。相应的，32位CPU支持的地址空间小一些，只有4GB，而64位的CPU地址总线宽度一般为48位，对应着256TB的内存。

##### **用户2229：
> 老师最近遇到一个很疑惑的问题，c++写一个程序需要处理大文件，发布为32位程序处理数据近2G文件就蹦了，发布为64位处理几十G都没问题，32位、64位程序跟32位、64系统系统区别是什么，为什么程序差别也那么大

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 32位程序用的是32位指令啊，，，内存太大就寻址不了了。

##### **贵：
> 总线分为地址总线，数据总线和控制总线。地址总线作用寻址，数据总线作用传输数据，控制总线的作用主控制，如接收输入输出设备的信号

##### *珣：
> 1100这个二进制数怎么是10呢，应该是12吧

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 对，，是12。

##### **宇：
> 在超过20亿大小的数据计算，64位会比32位更快；另外64位cpu可以比32位操作更大内存空间

##### 邵：
> 64位的cpu可以寻址更多的内存；但32位的cpu最多只能寻址到4GB，就算你装了8GB内存条

##### *磊：
> 如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址；这个地方有点不明白，串行一次传1bit，也就是传0或1，怎么操纵两个内存地址呢？求解

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 0是一个内存地址， 1是一个。

##### *宇：
> 64位相比32位优势1. 计算大数据的在CPU指令层面来说，应该使用更少的指令。也减少了寄存器读写数据的次数，理论上会更快。2. 64位CPU可以操作币32位CPU多出2^32的内存地址，所以64位CPU更适合大内存的机器

##### *文：
> 处理64位的数字时，需要分多次读入，会有并发问题

##### *超：
> 32位的cpu有32个寄存器。也就是有32个地址总线去操作内存。。。每个总线是0 1.。。。所以一共能操作 2*32.。。。。。我太笨了。。

##### **宏：
> 1.位宽更大，支持可操作的内存更多2.支持更高的并行，在处理大量级的数据，64位会更快

##### **帅：
> 不错，感谢老师

##### *滕：
> cpu 通过地址总线获取到内存中的指令地址，并保存在特殊寄存器上，这种理解不知对否

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 32位程序用的是32位指令啊，，，内存太大就寻址不了了。

##### hbcjos：
> 364位相对32位的优势：64位CPU在通过数据总线取数据时比32位CPU拥有更大的取数范围，从而避免了将大数拆成小数然后做计算的耗时操作64位地址总线能操作更多的内存空间，可以管理更多的计算机空间

##### **士星矢：
> 32位，位宽范围为2^32 =4G,64位位宽范围位2^64，所以，64位系统运行速度更快。32位，总线是32根，64位系统是64根，所以，64位系统处理能力更强。

##### **7892：
> 你可以回答 64 位和 32 位比较有哪些优势了吗？在超过32位的字符操作时，64位的CPU是有优势的。同时，64位的CPU能够操作更多的内存。

##### **青：
> 32位 cpu可以表示4个字节的数字，64位cpu可以表示8个字节数字，因此，能够一次运行计算的范围不同，64位cpu的范围更大，相比数字精度更大。比如，int需要32位，long需要64位。

##### **个咪的汪：
> 64 位比32位的优势是一次性处理的数据更多，速度也更快，效率高

##### **小永：
> 内存中的数据是以二进制的方式存储，也就是bit,一个字节(byte)占8个bit;

##### *程：
> 计算超过 32 位的数据时， 64 位 CPU 所需的步骤更少。32 位字节能表示2^32 种情况，每一个数字代表一个内存 byte 的门牌号的话，一共能表示 2^32 byte 大小的内存，也就是 4G 。

##### **金：
> 32位宽的cpu配上32位宽的数据总线,控制总线,地址总线;由于此时CPU内的计算逻辑单元也是32位的,所有单次只能传输和计算32位宽的数据,即最多操作2^32次方个内存地址;64位则在计算和传输位宽在32位-64位之间的数据可以速度翻倍

##### **亮：
> 受每次计算byte数的限制，32位在计算64位时，需要拆分转换。但在实际生活应用中，32位可以适用绝大多数的场景，在计算不超过32位的情况下，64位和32位宽的CPU性能差别不大。

##### *旭：
> 明白了串行和并行的区别

##### **伟：
> 讲师回复：0,1二选1，所以能描述两个地址。但是每次只能传递一个bit（因为2选一）。如果发送两次，就可以描述4个地址，但是只能传2个bit。。。。。。这什么意思啊？？？？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 如果要描述4个位置，需要2个bit，分别是00, 01, 10, 11。如果线路每次只能传1个bit，就需要传2次。

##### **8901：
> 假设用32位处理程序刚刚好，如果改为用64位会比32位多消耗cpu、内存吧？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 也不会多消耗，而是没有明显的优势。

##### **用户2508：
> 老师，我是不是可以理解，数据总线和地址总线的个数应该是保持一致的，因为32位的cpu一次最多只能发出32位的信号出来，通过地址总线传输到32个不同的地址上面去。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 地址总线条数可以少一些，毕竟你不会真的用完64位描述地址。

##### **军：
> 想请教下怎么判断CPU是32位宽还是64位宽呢？是再CPU设计时寄存器的位数吗？还是根据什么

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 通用一些系统调用可以看到。

##### **雅：
> 打卡

##### AlbertLiu：
> 图灵机读到数值 直接到状态里，没有经过控制单元吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 经过控制单元的。但是图灵机上时间已经没有意义了。

##### **霞：
> 一个byte的表示范围难道不是 -128~127嘛，为啥是0~255什么意思

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 无符号是0-255；如果有符号就是你说的。但无论怎么算，就只能表达255个数字。

##### *冲：
> 老师看我理解的对不对，32位操作系统可以装64位软件，只是运行的时候，软件会比较慢，因为32位同时控制不了那么多的总线。

##### **慧：
> 还是不懂

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 同学可以结合文字内容反复学习，如果对课程中的哪块知识有疑问也可以留言提问哈

##### **鸣：
> 了解，终于明白了为啥32位电脑最多只能装4G内存了，原来是由CPU的位宽决定的。32的位宽最多同时操作2^32个内存地址。那是不是可以这样理解，8G的内存条装到32位的计算机里，是可以用的，只是利用率只有50%？

##### **科：
> 文章中有一处错误，64位的数字在32位的cpu上被拆成2个32位的数字进行计算，而不是4个32位数字进行计算。实践中32位的更有意义，64位的有点浪费

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 同学很细心，是4个。 我已经修正了。

##### **豪：
> 64位支持更多内存，买买买😊

##### Benson：
> 32位cpu最多只能用4G内存，多了也用不上

##### **龙：
> “32 位宽的 CPU 没办法控制超过 32 位的地址总线、数据总线工作。”这句话是不是有问题。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 感谢反馈，我们换一种说法，已在正课中更新。优化为：
32 位宽的 CPU 控制 40 位宽的地址总线、数据总线工作会非常麻烦，需要双方制定协议。 因此通常 32 位宽 CPU 最多操作 32 位宽的地址总线和数据总线。

##### *强：
> 老师，问一下，“如果只有 1 条地址总线，那每次只能表示 0-1 两种情况，所以只能操作 2 个内存地址”，不是每次只能发送一个信号嘛？为什么会表示0-1两种情况，有点不明白，谢老师解答。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 0,1二选1，所以能描述两个地址。 但是每次只能传递一个bit（因为2选一）。如果发送两次，就可以描述4个地址，但是只能传2个bit。

##### **用户0385：
> 打卡

##### **宝：
> 打卡

##### **用户1605：
> 64 位 CPU 需要有对应的寄存器，数据总线，地址总线等支持；并且上层应用同时需要支持 64 位地址的运算。反观 32 位宽的 CPU 能够满足日常大部分场景，并且有丰富的应用场景以及生态支撑。

##### *豆：
> 打卡学习

##### *格：
> 微机原理

##### **鑫：
> 程序计算读取数据大小限制

##### **威：
> 打卡

##### **用户6516：
> 沙发

