<p data-nodeid="21012" class="">我记得自己在面试中遇到过这样一个问题：“<strong data-nodeid="21100">可不可以计算一个人程序写得好不好</strong>？”</p>
<p data-nodeid="21013">当时我也没有想明白“<strong data-nodeid="21106">计算</strong>”这个词是什么意思。但事后分析来看，“计算”不就是写程序吗？</p>
<p data-nodeid="21014">其实简单理解这个问题就是“<strong data-nodeid="21112">可不可以用机器来判断人的程序写得好不好</strong>？”如果从这个角度考虑，我是可以和面试官论述一番的。</p>
<p data-nodeid="21015">后面我查阅了资料，历史上有一个对计算机领域影响颇深的可计算理论，面试官说的“计算”应该就来源于这里。其实继续深挖还能找出很多涉及计算机本源的有趣的知识，比如图灵机、冯诺依曼模型；再比如说 CPU 的构成、程序如何执行、缓存的分级、总线的作用等。</p>
<p data-nodeid="21016">上面提到的这些内容其实都属于操作系统的前置课程，我会利用第一章 4 个课时和大家探讨一下计算机组成原理，然后我们再正式进入操作系统的学习。其实学习就是这样，追溯源头，回到本质，才能挖掘兴趣、激发思考，否则就变成了死记硬背。接下来我们将从计算能源的角度入手，来展开今天的课程学习。</p>
<h3 data-nodeid="21017">芯片：计算能源</h3>
<p data-nodeid="21018">我们知道第一次工业革命出现了蒸汽机，能源是煤炭。第二次工业革命出现了发电机，能源是电。20 世纪四五十年代，又发生了第三次科技革命，革命产物是计算机。而第四次科技革命，就发生在当下，出现了人工智能，能源是数据。</p>
<p data-nodeid="21019">说到这里，你可能会有个疑问：第三次科技革命的能源是什么呢？</p>
<p data-nodeid="21020">你的第一反应可能是电，但是细想又觉得不对。前两次工业革命都有带来能源变革，为什么第三次科技革命就没有了能源变革？其实，第三次科技革命的能源是一种数字能量，本质是计算。</p>
<p data-nodeid="21021">下面我们来看一看这种数字能量是如何产生的。电能供给给芯片，芯片中的一种电子元件晶振（也就是石英晶体）通电后产生震荡，震荡会产生频率稳定的脉冲信号。通常这是一种高频的脉冲信号，每秒可达百万次。然后，我们通过谐振效应发放这个信号，形成方波。再通过电子元件调整这种脉冲的频率，把脉冲信号转换为我们需要的频率，这就形成了驱动芯片工作的时钟信号。这种信号的频率，我们也称作芯片的时钟频率。最后，时钟信号驱动着芯片工作，就像人体的脉搏一样，每一次脉冲到来，都让芯片的状态发生一次变化，用这种方法，最终存储器中的指令被一行行执行。指令被执行，其实就是数据被计算，这就是我说的计算能量。</p>
<p data-nodeid="21022">芯片普及后，不仅给计算机和手机提供支持，它们还被安装到了航天设备、能源设备、医疗设备及通信设备中，甚至小到电灯、微波炉、咖啡机、热水器里面都有了芯片。有了芯片，设备通电后才可以计算，有了计算，这些设备才能够实现更加复杂而精确的功能。</p>
<h3 data-nodeid="21023">摩尔定律：计算能力的发展</h3>
<p data-nodeid="21024">值得一提的是，历史上是先有计算机，后有的芯片。世界上第一个芯片，也被称作集成电路， 1958 年由美国德州仪器公司的工程师杰克·基尔比发明。而世界上第一台通用计算机 ENIAC 则是在 1946 年诞生于美国陆军弹道研究实验室。</p>
<p data-nodeid="21025">看到这里你可能会有疑问，为什么是先发明计算机再发明芯片呢？</p>
<p data-nodeid="21026">其实，这个道理就好比很多程序员先实现产品功能，再考虑封装和复用。ENIAC 中负责计算的模块和后来的芯片原理是一样的，都是利用电路实现逻辑运算。只不过在 20 世纪 40 年代人们还没有将这种能力抽象成一个独立的产品，而且也没有办法解决电路体积的问题，ENIAC的体积看上去就像一所学校那么大。</p>
<p data-nodeid="21027">芯片的计算能力来源于芯片内部的集成电路，集成电路大大减小了电路的体积，所有的元件都是用同一块半导体材料制作而成，也就是把所有的电路都集成到了一个单一的硅片上。为了提高计算性能，集成电路越来越复杂，里面的电子元件也越来越多。从最早拥有 100 个左右晶体管的小型集成电路，发展到 21 世纪初，拥有上亿电子元件的巨大规模集成电路。</p>
<p data-nodeid="21028">芯片的发展，带来了计算能力的飞跃，ENIAC 只能每秒计算 5000 次加法和 400 次乘法，到 1978 年 8086 芯片已经可以每秒计算百万次了。而今天随便一个芯片不但可以轻轻松松每秒计算数亿次，而且不只有一个核心，是多个核心都能达到这一量级的计算能力。</p>
<p data-nodeid="21029">在当时那个年代，Intel 的创始人之一摩尔就观察到了这个现象，并提出了摩尔定律：当价格不变时，集成电路中可容纳的晶体管数目约每隔 18～24 个月就会增加一倍，性能也将提升一倍。这一定律揭示了信息技术发展的速度，但到今天，摩尔定律失效了。因为随着芯片越来越小，在尺寸和散热等方面已经挑战了人类的极限，芯片中无法再放入更多的电子元件了。</p>
<p data-nodeid="21030">但是计算能力又开始以另一种方式发展，比如一个普普通通的 NVIDA 显卡中就拥有了几百个核心，这样就可以进行大量的并发计算；另外，一个分布式的大数据集群，里面就可能有上千个核心。</p>
<p data-nodeid="21031">展望未来，计算能力还有更多的增长点，不仅有可以无限提高计算能力的量子计算机，还有利用光学元件替代晶体元件的光电集成电路。</p>
<h3 data-nodeid="21032">可计算理论：图灵机</h3>
<p data-nodeid="21033">当然，在科学家们尝试发明计算机和芯片之前，他们必须回答一个问题，那就是计算或者程序可以用来做什么？比如：计算可不可以用来做饭？换一个更专业的说法，做饭可不可以被计算？</p>
<p data-nodeid="21034">生活在数字时代的我们，用着导航、玩着游戏，本能地知道很多问题是可以被计算的，但是生活在 20 世纪初的科学家们，需要在没有计算机和芯片的时代就想清楚这些问题，并不是一件容易的事情。</p>
<h4 data-nodeid="21035">公理化体系和不完备性定理</h4>
<p data-nodeid="21036">最早在 19 世纪初，德国著名数学家希尔伯特提出：这个世界可以建立一套完善的公理体系，由少数几个公理出发，推导出所有的定理和推论。这样就可以逐渐通过这种方法将世界上的万事万物都统一到一个体系中。</p>
<p data-nodeid="21037">当然，这只是一个非常美好的设想，如果万事万物都可以用形式化（简单理解就是程序化规范化）的手段统一到一套体系中，也就意味着计算能力将被无限扩展，只要给定足够的时间和空间，计算机就可以完成任何工作。</p>
<p data-nodeid="21038">但在不久后，美籍数学家哥德尔就提出了哥德尔不完备性定理，内容是：即便在完善的公理体系中仍然可以找到不能被证明也不能被证伪的命题。</p>
<p data-nodeid="21039">这让我联想到，一说谎，鼻子就会变长的匹诺曹。如果他说“我说谎了”，那么他的鼻子应该变长还是变短呢？对于人类而言，这个问题可以理解，但是对于计算机来说这个问题是不可以被计算的。</p>
<p data-nodeid="21040">正是因为世界上存在着大量的这种“公说公有理，婆说婆有理”的问题，才让大家认识到计算不能解决所有问题，所以：<strong data-nodeid="21142">计算机能力也是有边界的。哥德尔的不完备性定理，让大家看到了世界上还有大量不可计算的问题。</strong></p>
<h4 data-nodeid="21041">图灵机和可计算理论</h4>
<p data-nodeid="21042">于是人们意识到了需要一个理论，专门回答这样的问题：<strong data-nodeid="21149">哪些问题可以被计算，哪些不可以被计算</strong>，这就是可计算性理论，该理论是计算机科学的理论基础之一。</p>
<p data-nodeid="21043">1936 年，被誉为人工智能之父的阿兰·图灵提出了图灵机，它是一种不断执行指令的抽象计算机。之所以说抽象，是因为图灵并没有真的造出这台机器，而是把它当成理论去和大家探讨可计算问题。</p>
<p data-nodeid="21044">图灵发现如果一个问题是可计算的，那么它的解决方案就必须可以被具化成一条条的指令，也就是可以使用图灵机处理。因此，不能使用图灵机处理的问题，都是不可计算的问题。</p>
<p data-nodeid="21045">比如一个马达的控制程序是可计算的，因为控制过程是可以被抽象成一条条指令的（即可以写程序实现）。比如程序可以先读入传感器的数据，然后根据数据计算出下面要进行加速还是减速。</p>
<h4 data-nodeid="21046">不可计算问题</h4>
<p data-nodeid="21047">但当图灵机遇到“素数是不是有无穷多个？”这样的问题时，事情就变得复杂了。虽然，我们可以通过有限的步骤计算出下一个素数。比如可以每次尝试一个更大的数字，然后通过一系列计算过程判断该数字是不是素数，直到找到一个更大的素数。古希腊数学家埃拉托斯特尼就发明了筛选出给定范围内所有素数的方法。</p>
<p data-nodeid="21048"><img src="https://s0.lgstatic.com/i/image/M00/4B/7A/Ciqc1F9V0I2ARHpdAAJnCCDKvK8570.gif" alt="Sieve_of_Eratosthenes_animation.gif" data-nodeid="21163"></p>
<p data-nodeid="21049">如上图所示，我们利用埃拉托斯特尼筛法找到的素数越来越多。但是，我们还是不能回答“素数是不是有无穷多个”这样的问题。因为要回答这样的问题，我们会不停地寻找下一个素数。如果素数是无穷的，那么我们的计算就是无穷无尽的，所以这样的问题不可计算。</p>
<h4 data-nodeid="21050">停机问题</h4>
<p data-nodeid="21051">我们也无法实现用一个通用程序去判断另一个程序是否会停止。比如你用运行这段程序来检查一个程序是否会停止时，你会发现不能因为这个程序执行了 1 天，就判定它不会停止，也不能因为这个程序执行了 10 年，从而得出它不会停止的结论。这个问题放到图灵机领域，叫作停机问题，我们无法给出一个判断图灵机是否会停机的通用方法，因此停机问题是一个经典的不可计算问题。</p>
<h3 data-nodeid="21052">计算能力的边界在哪里？</h3>
<p data-nodeid="21053">我们可以把世界上想解决的事情都称作问题，解决问题往往需要消耗芯片的计算能力，这通常称作时间开销，另外解决问题还需要消耗内存，称作空间开销。</p>
<h4 data-nodeid="21054">问题的分类</h4>
<p data-nodeid="21055">世界上有一类问题，无论我们消耗多少时间和空间也无法解决，这类问题就包括“停机问题”，称作不可计算问题，我们无法用计算机精确地解决这类问题。世界上不可计算问题多，还是可计算问题多，也是一个不可计算问题，但直觉告诉我们一定是不可计算问题更多。</p>
<p data-nodeid="21056">另外在可计算的问题中，有困难问题，也有简单问题，我们通常用复杂度来衡量，比如：</p>
<ul data-nodeid="21057">
<li data-nodeid="21058">
<p data-nodeid="21059">“求数组第 10 个元素”，计算这种问题，时间开销、空间开销都不会随着问题规模增长，我们记为 O(1)；</p>
</li>
<li data-nodeid="21060">
<p data-nodeid="21061">“求数组中的最大值”，计算这种问题，时间开销会随着数组规模线性增大，记作 O(N)，N 是问题的规模；</p>
</li>
<li data-nodeid="21062">
<p data-nodeid="21063">还有像“求一个n*n矩阵的和”，如果n是规模，那么时间开销会随着问题规模的平方增长，我们称作 O(N<sup>2</sup>)；</p>
</li>
<li data-nodeid="21064">
<p data-nodeid="21065">当然也有更加复杂的数学模型，比如说O(N<sup>3</sup>)、O(N<sup>4</sup>)、O(N<sup>100</sup>)等。</p>
</li>
</ul>
<h4 data-nodeid="21066">P 问题 vs NP 问题</h4>
<p data-nodeid="21067">按照摩尔定律所说，人类的计算能力每 18～24 个月翻一倍，我们的计算能力在呈指数形式上升。因此，在所有可以计算的问题中，像 O(N<sup>1000</sup>)的问题，虽然现在的计算能力不够，但是相信在遥远的未来，我们会拥有能力解决。这种我们有能力解决的问题，统称为多项式时间（ Polynomial time）问题。我们今天能解决的问题，都是多项式时间的问题，下面记为 P 类型的问题。</p>
<p data-nodeid="21068"><img src="https://s0.lgstatic.com/i/image/M00/4B/7D/Ciqc1F9V1E6AIXioAADZGoACu0o689.png" alt="11.png" data-nodeid="21202"></p>
<p data-nodeid="21069">另外，还有一类问题复杂度本身也是指数形式的问题，比如 O(2<sup>N</sup>)的问题。这类型的问题随着规模 N 上升，时间开销的增长速度和人类计算能力增长速度持平甚至更快。因此虽然这类问题可以计算，但是当 N 较大时，因为计算能力不足，最终结果依然无法被解决。</p>
<p data-nodeid="21070">由此可见，不是所有可以计算的问题都可以被解决，问题如果不能在多项式时间内找到答案，我们记为 NP 问题。</p>
<p data-nodeid="21071">有一部分 NP 问题可以被转化为 P 问题，比如斐波那契数列求第 N 项，可以用缓存、动态规划等方式转化为 O(N) 的问题。但还有更多的 NP 问题，比如一个集合，找出和为零的子集，就没能找到一个合适的转换方法。其实说这么多，就是想告诉大家：如今还有很多问题无法解决，它的数量远远大于我们可以解决的问题，科学家、工程师们也只能望洋兴叹了。</p>
<h4 data-nodeid="21072">人工智能</h4>
<p data-nodeid="21073">此外，包括停机问题、包括 NP 问题在内的很多问题，虽然不能解决，但可以努力让计算机的解决方案超过人类的水平，这就是人工智能。</p>
<p data-nodeid="21074">比如下围棋，围棋盘是 19*19 的，共有 361！种情况，如果遍历 361！种情况，并进行打分，共有 10 的 170 次方种可能，因此，我们的计算能力是远远不足的。但是如果使用人工智能方法对可能出现的部分情况进行概率判断，在不追求绝对精确的情况下，人工智能就可以超过人类选手。</p>
<p data-nodeid="21075">AlphaGo 战胜李世石就是利用了基于概率的不完全解法，这种解法已经可以超过部分人类职业选手了，也就是说计算机的解法已经超过了人类。当然，人类的强项在于理解和分析，人有两种思维，归纳和假设，这两种思维都是计算机无法计算的。机器用概率理解围棋，局部来说机器下得更好，但是人可以制造机器，因此，人的感悟更有意义，谈不上孰优孰劣。</p>
<p data-nodeid="21683" class="">针对这种解决问题的方法，20 世纪中人工智能之父图灵，提出图灵测试，就是在一次人机对话中，随机抽样一部分的实验者和机器对话，如果这部分实验者有较大的百分比判断对面是人而不是机器，那这台机器就通过了图灵测试。在围棋领域，可以说，AI 通过了图灵测试。但围棋的 AI 不能下象棋，这也是 AI 的一个劣势。所以广义的 AI 还没有出现，现在出现的是在某个专业领域的 AI。</p>


<h3 data-nodeid="21077">总结</h3>
<p data-nodeid="21078">下面我们进行总结。本课时是一个理解操作系统知识必不可少的计算机原理引导课。</p>
<ul data-nodeid="21079">
<li data-nodeid="21080">
<p data-nodeid="21081">我们学习了芯片，芯片将电能转化为计算能量，计算能量推动程序执行；</p>
</li>
<li data-nodeid="21082">
<p data-nodeid="21083">接着提到了摩尔定律，了解到我们的计算能力仍在飞速发展；</p>
</li>
<li data-nodeid="21084">
<p data-nodeid="21085">还花了篇幅讲了图灵机，从而进一步认识了人工智能之父阿兰·图灵，图灵机具体的设计和构造，这将在<strong data-nodeid="21226">02 课时程序的执行</strong>部分进一步讨论。</p>
</li>
<li data-nodeid="21086">
<p data-nodeid="21087">最后普及了图灵测试和人工智能的基本概念，带你了解了计算机的能力边界。</p>
</li>
</ul>
<p data-nodeid="21088">下面我们回到最初的问题：“可不可以计算一个人程序写得好不好？”</p>
<p data-nodeid="21089">这个问题可以这样来思考，如果把问题降级，变成：“可不可以计算一个人写的程序会不会停机？”</p>
<p data-nodeid="21090">这个问题就如同停机问题，无法计算，因此这是一个不可计算的问题。但是我们通过设立规则，比如检查缩进、检查函数的复用情况、检查类的命名情况，给写程序的人更好的建议。另外，我们也可以通过 AI 技术，让机器在“程序写得好不好”这个问题的判定能力上，达到人类的水平，通过图灵测试。</p>
<p data-nodeid="21091" class="">综上，从绝对的对错角度去看，这是一个不可计算问题，因为它没有办法被完全解决；但是从图灵测试层面来看，虽然目前无法解决这个问题，但是我们有理由相信，在未来，计算机对这个问题的解决方案，是可以超过人类的。</p>
<h3 data-nodeid="21092">思考题</h3>
<p data-nodeid="21093">最后再给你留一道查资料的思考题：可不可以构造一段程序证明停机问题无解？如果可以，请用自己熟悉的语言写出这段程序。</p>
<p data-nodeid="21094" class="">可以把你的答案、思路或者课后总结写在留言区，这样帮助你产生更多的思考，也是构建知识体系的一部分。经过长期的积累，相信你会得到意想不到的收获。如果你觉得今天的内容对你有所启发，欢迎分享给身边的朋友。期待看到你的思考！</p>

---

### 精选评论

##### *乐：
> 跪求老师出一门计算机网络

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 哈哈哈   可以期待一下哦。林䭽老师的《计算机网络》专栏4月19日在拉勾教育上线～

##### *杨：
> '''背景假设和思路：	N台机器共同保证一个机器X的正常运行，用X1监视X的运行	情况，如果X停机，可以被X1瞬间重启，使X继续正常运行。思路：	由于X1也有可能停机，此时要用X2监视X1，以此类推，Xn	监视Xn-1，但最终的Xn是没有机器监视的，因此X到Xn都	停机的概率大于0，因此多机方案无法解决机器X停机的问题'''# 假设单机停机概率为0.01shutdownLikelihoodPerPC = 0.01# 机器数量为无穷大的整数,此处忽略整数存储限制numberOfPC = sys.maxint# 只要有一台机器不停机，就可以保证目标机器不停机，此处忽略浮点数存储限制shutdownLikelihoodTotalPC = 1 - shutdownLikelihoodPerPC ^ numberOfPC# 如果目标机不停机概率为1if shutdownLikelihoodTotalPC == 1:	print("停机问题有解")else:	print("停机问题无解")

##### *莹：
> 如果能写一个程序证明停机问题无解。这个反命题就是停机问题有解。所以也不能写程序证明停机问题无解。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 哈哈，我觉得我可以在答案中把你的答案贴下。

##### **圆：
> ```javascript//假设存在程序isHalt可以判断程序f对输入input是否停机，当输入input时，f停机返回0；当输入input时，f不停机返回1function isHalt(f, input){}//设定test方法与isHalt结果返回相反function test(f){	if(isHalt(f, f) === 1){//当停机时，test方法终止		return;	}else{//当不停机时，test方法死循环		while(1){}	}}isHalt(test, test)停机时，test(test)进入死循环，与定义的test方法相矛盾（看test代码会直接return）isHalt(test, test)不停机时，test(test)停机，与定义的test方法相矛盾（看test代码会进入死循环）```

##### **8755：
> 这个串讲回顾了好多已经忘记的东西😂

##### **宇：
> 打卡

##### **建：
> 以前在大学觉得学《操作系统》没用，工作后才发现是最重要的

##### **先：
> 信息技术革命的核心：计算能力和通信能力！我觉得当下的AI，本质还是计算能力和通信能力的提升推动的。有能力计算更多的、传输更多的数据，让更大的数据更高效的流动和应用起来。

##### *方：
> 1. 写一个函数来判断程序是否可计算。boolean calculable(AnyFunction program)，这个函数的返回值为true or false。2. 写另外一个函数来制造矛盾。boolean test(AnyFunction program) { if(calculable(program)) { while(true); } else { return true; }} 3. 我们只需要让test函数测试自己，即test(test)，就可以制造出矛盾。因为当我们假设calculate(test)返回值为true(即可计算)，那么test(test)将进入死循环，也就是不可计算; 如果假设calculate(test)返回值为false(即不可计算)，那么test(test)，返回true也就是可以计算。综上，calculable函数返回值不管是true还是false，在验证test(test)的时候，都会产生矛盾。

##### *熠：
> 可以，语速，语调，知识难易程度都还不错！！

##### *勇：
> 信息量有点多😂，我要多看几遍

##### **用户9307：
> 原命题：如果停机问题无解，则能写一个程序证明。逆否命题：如果能写一个程序证明，则停机问题有解。原命题和逆否命题真假性相同。现在可知逆否命题是假，所以原命题也是假，所以不能写一个程序证明。

##### *雪：
> 停机问题无解的最简单的证明方法之一就是构造法。假设程序A能够对任意给定程序判断是否停机。构造程序B，以程序A的输出作为输入。如果程序A的输出是“停机”，那么程序B进入死循环。如果程序A的输出是“不停机”，那么程序B立刻结束。我们把程序B输入程序A。如果A的输出是“停机”，那么B进入死循环，A的输出是错的。如果A的输出是“不停机”，那么B立刻结束，A的输出还是错的。所以A无法判断B是否停机，这和假设矛盾，所以不存在一个程序A能够对任意给定程序判断是否停机。

##### **7139：
> 构建自己的知识体系真的必备的 我以前就没有这个意识

##### **曦：
> https://github.com/SedationH/web-roam/tree/master/08OS// 整体为反证法/** * halt表示等等 函数返回 * 先假设这样能够判断停机问题的程序存在 * 函数返回true表示program在输入input的时候能够停止，是会停机的 * 函数返回false表示program在输入input的时候不能停止，不会停机  */function isHalt(program, input) {  // need to implement}function loop() {  while (true) { }}// 演示下isHalt的使用function foo(input) {  if (input === 0) return  else loop()}isHalt(foo, 0) === trueisHalt(foo, 1) === false// 举反例function hack(program) {  // 如果会停止，我就让他loop，故意制造矛盾  if (isHalt(program, program)) loop()  // 不会停止我就让他返回  else return}// 这里就产生了矛盾if (isHalt(hack, hack) === true) {  // 那么hack函数内部在执行判断的时候  isHalt(hack, hack) === false} else {  isHalt(hack, hack) === true}

##### **0250：
> #/bin/bashwhile truedoecho “被依赖的东西无法被计算”done😂

##### **虎：
> 打卡

##### **强：
> 太长见识了，山腰的我，突然被高手带上了山顶，这也好，那也新奇。老师甚至可以出一个《计算的过去与未来》专栏

##### **禛：
> 受益匪浅,

##### **彪：
> 666

##### **用户6062：
> 编写代码： if(停机){ 打印日志 }，手动停机，因为停机日志无法打印，故停机无法被证明

##### **一：
> 说好的林䭽老师的《计算机网络》专栏出了吗？

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 《计算机网络》4月19日和大家见面。小伙伴可以期待一下哦

##### **文：
> 读史明智

##### Getas：
> 证明停机问题无解等价于没有程序可以判断是否停机。程序是无穷的，所以证明停机问题无解的程序的计算是无穷无尽的。所以不可以写一段程序证明停机问题无解。

##### *先：
> 打卡打卡

##### *潇：
> 我感觉上面有个评论写的有点问题，能写一个程序证明停机问题无解，的反命题是停机问题有解？？不应该是这个吗？： 不能写一个程序证明开机问题有解。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 开机问题是什么？

##### *美：
> 首先，怎么才算停机，这个就不好由当时机器来判断，引入其他监控，监控他的是不是也会停机，无限循环，是一个不可计算的，假设他又是可以计算的一个问题，那么，时间，空间维度，有个恒久的东西来判定计算机什么时候停机了，这就违背了宇宙没有永恒存在的这个理论，所以反证法证明计算机停机是不可计算的

##### **桥：
> 从芯片的发展，计算机的诞生，从不完备理论到图灵机，不可计算问题，P与NP，AI, 概率论，旁证博引，融汇贯通，有大师课的感觉了

##### *雷：
> if(停机){ 输出结果}

##### **龙：
> 假设，停机是可计算的。那么，总归要拿到计算结果。1分钟，1个小时，1天，1月……如果停机时间遥遥无期，该计算也就没了意义

##### **安：
> 打卡

##### **辉：
> 死循环是么老师？for(;;){}

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 类似，你看下后面加餐 | 练习题详解（一）中的题目解读。

##### *兴：
> 打卡

##### **琳：
> 中文屋的问题呢？怎么能判断机器是智能的呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 强AI现在没出现，现在出现的是某个局部的AI。比如就下棋而言，不允许交谈和其他，你是判断不出对面是机器还是人的。

##### dnvce：
> 打卡

##### **斌：
> 打卡第二天

##### **洁：
> 打卡

##### **彬：
> 一周两篇，我将会有5天的时间在寂寞中度过，555。

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 小编偷偷告诉你，本周加更一篇哦，一三五都会更新！！

