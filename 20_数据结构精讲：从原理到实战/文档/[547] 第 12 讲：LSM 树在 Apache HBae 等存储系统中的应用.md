<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">你好，我是你的数据结构课老师蔡元楠，欢迎进入第 12 课时的内容“LSM 树在 Apache HBase 等存储系统中的应用”。</span><br></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在上一讲中，我们一起学习了平衡树和&nbsp;Log-Structured&nbsp;结构的基本概念，那么今天我们就来延续上一讲的问题，继续探讨如何优化&nbsp;Log-Structured&nbsp;结构，以及通过结合平衡树之后才产生的另外一种数据结构——LSM&nbsp;树。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">首先我们一起来回顾一下在上一讲中所遗留的问题。在通过&nbsp;Log-Structured&nbsp;结构设计视频网站浏览次数的功能后，底层的数据结构就如下图所示：</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/Cgq2xl4o-DqAQElxAAE4TpDNdTY041.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">这种方法存在的一个问题，就是当我们不断地添加新数据进去之后，所占用的空间会越来越大，而且遍历整个数据结构的时间也随之越来越长。这时候，我们就可以通过一种叫&nbsp;Compaction&nbsp;的方法，把数据合并，Compaction&nbsp;方法其实也是很多&nbsp;NoSQL&nbsp;架构中的一个重要优化过程。下面我就来详细讲讲整个流程。</span></p>
<h3 style="text-align: justify; white-space: normal;"><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">Log-Structured&nbsp;结构的优化</span></p></h3>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">首先，可以定义一个大小为&nbsp;N&nbsp;的固定数组，我们称它为&nbsp;Segment，一个&nbsp;Segment&nbsp;最多可以存储&nbsp;N&nbsp;个数据，当有第&nbsp;N+1&nbsp;个数据需要写入&nbsp;Log-Structured&nbsp;结构的时候，我们会创建一个新的&nbsp;Segment，然后将&nbsp;N+1&nbsp;个数据写入到新的&nbsp;Segment&nbsp;中。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">以下图为示，我们定义一个&nbsp;Segment&nbsp;的大小为&nbsp;16，当&nbsp;Segment 1&nbsp;写满了&nbsp;16&nbsp;个数据之后，会将新的数据写入到&nbsp;Segment 2&nbsp;里。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/CgpOIF4o-DuAfdPWAAIDOYAAm9U804.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">说到这里，我们的&nbsp;Log-Structured&nbsp;结构还是一直在往内存里添加数据，并没有解决最终会消耗完内存的问题。这时候就到&nbsp;Compaction&nbsp;大显身手的时候了，在当&nbsp;Segment&nbsp;到达一定数量的时候，Compaction&nbsp;会通过后台的线程，把不同的&nbsp;Segments&nbsp;合并在一起，我们以下图为例来说明一下。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">假设我们定义当&nbsp;Segment&nbsp;的数量到达两个的时候，后台线程就会执行&nbsp;Compaction&nbsp;来合并结果。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/Cgq2xl4o-DuAOfSTAAHIkRBDV0E283.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">执行完&nbsp;Compaction&nbsp;之后，内部的数据结构图如下图所示：</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/CgpOIF4o-DuAJLesAAJKZsBH2zU484.png"><span style="font-size: 11pt; text-align: justify;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">刚开始的时候，对于视频浏览次数的统计是通过读取&nbsp;Segment 1&nbsp;和&nbsp;Segment 2&nbsp;来完成的，在&nbsp;Compaction&nbsp;完成了之后，对于结果的读取就可以从&nbsp;Compacted Segment&nbsp;里面读取了。因为这时候所有的结果已经存放在&nbsp;Compacted Segment&nbsp;里面了，所以就可以删除&nbsp;Segment 1&nbsp;和&nbsp;Segment 2&nbsp;来腾出内存空间了。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">整个&nbsp;Compaction&nbsp;的过程会不断地递归进行下去，当&nbsp;Compacted Segment&nbsp;满了以后，后台线程又可以对&nbsp;Compacted Segment&nbsp;进行&nbsp;Compaction&nbsp;操作，再次合并所有结果。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">你会发现，当采用了这种优化之后，写操作还是可以十分高效地进行下去，同时也不会占用大量的内存空间。</span></p>
<h3 style="text-align: justify; white-space: normal;"><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">SSTable&nbsp;和&nbsp;LSM&nbsp;树</span></p></h3>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">上面所讲到的&nbsp;Log-Structured&nbsp;结构的这种&nbsp;Compaction&nbsp;优化，其实是&nbsp;LSM&nbsp;树的一个基础，在学习&nbsp;LSM&nbsp;树之前，我们先来了解一个新的数据结构，即&nbsp;<strong>SSTable</strong>。SSTable（Sorted String Table）数据结构是在&nbsp;Log-Structured&nbsp;结构的基础上，多加了一条规则，就是所有保存在&nbsp;Log-Structured&nbsp;结构里的数据都是键值对，并且键必须是字符串，在经过了&nbsp;Compaction&nbsp;操作之后，所有的&nbsp;Compacted Segment&nbsp;里保存的键值对都必须按照字符排序。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">我们假设现在想利用&nbsp;Log-Structured&nbsp;结构来保存一本书里的词频，为了方便说明，把&nbsp;Segment&nbsp;的大小设为&nbsp;4。在刚开始的时候，这个&nbsp;Log-Structured&nbsp;结构的内存图如下图所示：</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/Cgq2xl4o-DyAHTqbAAD5MzXtGgg203.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在经过了&nbsp;Compaction&nbsp;操作之后，内存图会变成如下图所示：</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/CgpOIF4o-DyAGUkIAAII08Em_5k103.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">可以看到，所有的&nbsp;Compacted Segment&nbsp;都是按照字符串排序的。当我们要查找一个单词出现的次数时，可以去遍历所有的&nbsp;Compacted Segment，来看看这个单词的词频，当然了，因为所有数据都是按照字符串排好序的，如果当遍历到的字符串已经大于我们要找的字符串时，就表示并没有出现过这个单词。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">这时候你可能会有一个疑问，Log-Structured&nbsp;结构是指不停地将新数据加入到&nbsp;Segment&nbsp;的结尾，像这种&nbsp;Compaction&nbsp;的时候将字符串排序应该怎么做呢？此时我们就需要上一讲中所讲到的平衡树了。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">我们先来复习一下二叉查找树里的一个特性：二叉查找树的任意一个节点都比它的左子树所有节点大，同时比右子树所有节点小，说到这里你是不是有点恍然大悟了。如果我们将所有&nbsp;Log-Structured&nbsp;结构里的数据都保存在一个二叉查找树里，当写入数据时其实是按照任意顺序写入的，而当读取数据时是按照二叉查找树的中序遍历来访问数据的，其实就相当于按字符串顺序读取了。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在业界上，我们为了维护数据结构读取的高效，一般都会维护一个平衡树，比如，在上一讲中说到的红黑树或者&nbsp;AVL&nbsp;树。而这样一个平衡树在&nbsp;Log-Structured&nbsp;结构里通常被称为&nbsp;<strong>memtable</strong>。而上面所讲到的概念，通过内部维护平衡树来进行&nbsp;Log-Structured&nbsp;结构的&nbsp;Compaction&nbsp;优化，这样一种数据结构被称为是&nbsp;<strong>LSM</strong><strong>&nbsp;</strong><strong>树</strong>（Log-Structured Merge-Tree），它是由&nbsp;Patrick O'Neil&nbsp;等人在&nbsp;1996&nbsp;年所提出的。</span></p>
<h3 style="text-align: justify; white-space: normal;"><p style="line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">LSM&nbsp;树的应用</span></p></h3>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在数据库里面，有一项功能叫做&nbsp;Range Query，用于查询在一个下界和上界之间的数据，比如，查找时间戳在&nbsp;A&nbsp;到&nbsp;B&nbsp;之内的所有数据。许多著名的数据库系统，像是&nbsp;HBase、SQLite&nbsp;和&nbsp;MongoDB，它们的底层索引因为采用了&nbsp;LSM&nbsp;树，所以可以很快地定位到一个范围。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">比如，如果内存里保存有以下的&nbsp;Compacted Segments：</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/62/BC/Cgq2xl4o-DyAAMmjAAFJNdxBZus633.png"></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">如果我们的查询是需要找出所有从&nbsp;Home&nbsp;到&nbsp;No&nbsp;的数据，那我们就知道，可以从&nbsp;Compacted Segment 2 到 Compacted Segment 3&nbsp;里面去寻找这些数据了。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">同样的，采用&nbsp;Lucene&nbsp;作为后台索引引擎的开源搜索框架，像&nbsp;ElasticSearch&nbsp;和&nbsp;Solr，底层其实运用了&nbsp;LSM&nbsp;树。因为搜索引擎的特殊性，有可能会遇到一些情况，那就是：所搜索的词并不在保存的数据里，而想要知道一个数据是否存在&nbsp;Segment&nbsp;里面，必须遍历一次整个&nbsp;Segment，时间开销还并不是最优化的，所以这两个搜索引擎除了采用&nbsp;LSM&nbsp;树之外，还会利用另外一个在第&nbsp;07&nbsp;讲中所提到的&nbsp;Bloom Filter&nbsp;这个数据结构，它可以用来判断一个词是否一定不在保存的数据里面。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-align: justify; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">OK，这节课就讲到这里啦，下一课时我将分享“用图来表达更为复杂的数据关系”，记得按时来听课哈。</span></p>

---

### 精选评论

##### **是当不了文艺女青年…：
> 提问：“如果我们将所有 Log-Structured 结构里的数据都保存在一个二叉查找树里，当写入数据时其实是按照任意顺序写入的，而当读取数据时是按照二叉查找树的中序遍历来访问数据的，其实就相当于按字符串顺序读取了”这句话里面，指的是写入之后的compaction的时候，存成了二叉树吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个问题问得很好啊！其实每次在将数据写入二叉查找树的时候就已经可以同时做compaction这个步骤了。因为在二叉查找树的插入操作中，每次我们遍历节点的时候，可以对比一下当前节点是否是要插入的数据key相同，如果相同的话就可以合并在一起。

##### **敏：
> 就这些很基础的数据结构，和很朴素的算法，就能创造出这么实用牛逼的工具，我是真的佩服的五体投地

