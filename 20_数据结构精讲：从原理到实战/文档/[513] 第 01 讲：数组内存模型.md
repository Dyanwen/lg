<p style="white-space: normal; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(73, 73, 73); text-align: justify;">你好，我是你的数据结构课老师蔡元楠，欢迎进入第 01 课时的内容“数组内存模型”。</span><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在计算机里，所有的数据结构本质上其实都可以归为两类：数组和链表。对于链表，我将会在第03 与第 04 讲中着重讲解。今天我将要和你一起探索数据结构中最基本的知识点——数组（Array）。</span></p> 
<h3 style="white-space: normal;"><p style="line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">数组的内存模型</span></p></h3> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>1.一维数组</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">还记得在学某种编程语言时，写的第一个程序是“Hello World”吗？在学数据结构时，数组也是第一个要接触的知识点，那什么是数组呢？在计算机科学中，数组可以被定义为是<strong>一组被保存在连续存储空间中，并且具有相同类型的数据元素集合。</strong>而数组中的每一个元素都可以通过自身的索引（Index）来进行访问。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">那么下面就以 Java 语言中的一个例子来说明一下<strong>数组的内存模型</strong>，当定义了一个拥有 5 个元素的 int 数组后，来看看内存长什么样子。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<pre>int[]&nbsp;data&nbsp;=&nbsp;new&nbsp;int[5];</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">通过上面这段声明，计算机会在内存中分配一段<strong>连续的内存空间</strong>给这个 data 数组。现在假设在一个 32 位的机器上运行这段程序，Java 的 int 类型数据占据了 4 个字节的空间，同时也假设计算机分配的地址是从 0x80000000 开始的，整个 data 数组在计算机内存中分配的模型如下图所示。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329g2AIhWoAAFlTMFBxyw356.png" style="width: 449px; height: 160px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">这种分配连续空间的内存模型同时也揭示了数组在数据结构中的另外一个特性，即随机访问（Random Access）。随机访问这个概念在计算机科学中被定义为：</span><strong style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">可以用同等的时间访问到一组数据中的任意一个元素</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">。这个特性除了和连续的内存空间模型有关以外，其实也和数组如何通过索引访问到特定的元素有关。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">刚接触计算机时的你，不知是否会有这样的一个疑惑：为什么在访问数组中的第一个元素时，程序一般都是表达成以下这样的：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<pre>data[0]</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">也就是说，数组的第一个元素是通过索引“0”来进行访问的，第二个元素是通过索引“1”来进行访问的，……，这种<strong>从</strong><strong>&nbsp;</strong><strong>0</strong><strong>&nbsp;</strong><strong>开始进行索引的编码方式被称为是“Zero-based Indexing”</strong>。当然了，在计算机世界中也存在着其他的索引编码方式，像 Visual Basic 中的某些函数索引是采用 1-based Indexing 的，也就是说第一个元素是通过“1”来获取的，但这并不在我们这一讲的讨论范围内，大家可自行查询资料了解详情。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">我们回到数组中第一个元素通过索引“0”来进行访问的问题上来，之所以采取这样的索引方式，原因在于，获取数组元素的方式是按照以下的公式进行获取的：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p> 
<pre>base_address&nbsp;+&nbsp;index（索引）×&nbsp;data_size（数据类型大小）</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>索引</strong>在这里可以看作是一个偏移量（Offset），还是以上面的例子来进行说明。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329g2AIhWoAAFlTMFBxyw356.png" style="width: 449px; height: 160px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">data 这个数组被分配到的起始地址是 0x80000000，是因为 int 类型数据占据了 4 个字节的空间，如果我们要访问第 5 个元素 data[4] 的时候，按照上面的公式，只需要取得 0x80000000 + 4&nbsp;</span><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify; color: rgb(34, 34, 34);">× 4 =&nbsp;</span><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">0x80000010 这个地址的内容就可以了。</span><strong style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">随机访问的背后原理其实也就是利用了这个公式达到了同等的时间访问到一组数据中的任意元素</strong><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>2.二维数组</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">上面所提到的数组是属于一维数组的范畴，我们平时可能还会听到一维数组的其他叫法，例如，<strong>向量（Vector）</strong>或者<strong>表（Table）</strong>。因为在数学上，二维数组可以很好地用来表达<strong>矩阵（Matrix）</strong>这个概念，所以很多时候我们又会将矩阵或者二维数组这种称呼交替使用。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">如果我们按照下面的方式来声明一个二维数组：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p> 
<pre>int[][]&nbsp;data&nbsp;=&nbsp;new&nbsp;int[2][3];</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在面试中，如果我们知道了数组的起始地址，在基于上面的二维数组声明的前提下，data[0][1] 这个元素的内存地址是多少呢？标准的答案其实应该是“无法确定”。什么？标准答案是无法确定，别着急，因为这个问题的答案其实和二维数组在内存中的寻址方式有关。而这其实涉及到计算机内存到底是以<strong>行优先（Row-Major Order）</strong>还是以<strong>列优先（Column-Major Order）</strong>存储的。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">假设现在有一个二维数组，如下图所示：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329g2APk5pAAB2ugtuaDk157.png" style="width: 196px; height: 138px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">下面我们来一起看看行优先或列优先的内存模型会造成什么样的区别。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">（1）行优先</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">行优先的内存模型保证了每一行的每个相邻元素都保存在了相邻的连续内存空间中，对于上面的例子，这个二维数组的内存模型如下图所示，假设起始地址是 0x80000000：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/05/Cgq2xl329g6ATN9WAADD1_gRTG8279.png" style="width: 430px; height: 151px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">可以看到，在二维数组的每一行中，每个相邻元素都保存在了相邻的连续内存里。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在以行优先存储的内存模型中，假设我们要访问 data[i][j] 里的元素，获取数组元素的方式是按照以下的公式进行获取的：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p> 
<pre>base_address&nbsp;+&nbsp;data_size&nbsp;×&nbsp;(i&nbsp;×&nbsp;number_of_column&nbsp;+&nbsp;j)</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">回到一开始的问题里，当我们访问 data[0][1] 这个值时，可以套用上面的公式，其得到的值，就是我们要找的 0x80000004 地址的值，也是就 2。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p> 
<pre>0x80000000&nbsp;+&nbsp;4&nbsp;×&nbsp;(0&nbsp;×&nbsp;3&nbsp;+&nbsp;1)&nbsp;=&nbsp;0x80000004</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329g6AdyS1AAET8uQRA84189.png" style="width: 414px; height: 184px;">&nbsp; &nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">（2）列优先</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">列优先的内存模型保证了每一列的每个相邻元素都保存在了相邻的连续内存中，对于上面的例子，这个二维数组的内存模型如下图所示，我们同样假设起始地址是 0x80000000：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image6/M00/48/16/CioPOWDTIM2AEkzBAAA_9amcdj8615.png" style="text-align: left; color: rgb(51, 51, 51); max-width: 100%;"><span style="font-size: 11pt;">&nbsp; &nbsp; &nbsp;&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">可以看到，在二维数组的每一列中，每个相邻元素都保存在了相邻的连续内存里。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在以列优先存储的内存模型中，假设我们要访问 data[i][j] 里的元素，获取数组元素的方式是按照以下的公式进行获取的：</span></p> 
<pre>base_address&nbsp;+&nbsp;data_size&nbsp;×&nbsp;(i&nbsp;+&nbsp;number_of_row&nbsp;×&nbsp;j)</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">当我们访问 data[0][1] 这个值时，可以套用上面的公式，其得到的值，就是我们要找的 0x80000008 地址的值，同样也是 2。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p> 
<pre>0x80000000&nbsp;+&nbsp;4&nbsp;×&nbsp;(0&nbsp;+&nbsp;2×1)&nbsp;=&nbsp;0x80000008</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329g-ABI2RAAEUG5XyUrM082.png" style="width: 464px; height: 188px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">所以回到一开始的那个面试问题里，行优先还是列优先存储方式会造成 data[0][1] 元素的内存地址不一样。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>3.多维数组</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong><br></strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">多维数组其实本质上和前面介绍的一维数组和二维数组是一样的。如果我们按照下面的方式来声明一个三维数组：</span></p> 
<pre>int[][][]&nbsp;data&nbsp;=&nbsp;new&nbsp;int[2][3][4];</pre> 
<p style="white-space: normal;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(73, 73, 73); text-align: justify;">则可以把这个声明想象成声明了两个 int[3][4] 这样的二维数组，对于多维数组则可以以此类推。下面我将把行优先和列优先的内存寻址计算方式列出来，若感兴趣的话可以将上面所举的二维数组例子套入公式，自行验证一下。</span><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">假设我们声明了一个 data[S1][S2][S3].....[Sn] 的多维数组，如果我要访问 data[D1][D2][D3].....[Dn] 的元素，内存寻址计算方式将按照如下方式寻址：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>行优先</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong><br></strong></span></p> 
<pre>base_address&nbsp;+&nbsp;data_size&nbsp;×&nbsp;(Dn&nbsp;+&nbsp;Sn&nbsp;×&nbsp;(Dn-1&nbsp;+&nbsp;Sn-1&nbsp;×&nbsp;(Dn-2&nbsp;+&nbsp;Sn-2&nbsp;×&nbsp;(...&nbsp;+&nbsp;S2&nbsp;×&nbsp;D1)...)))</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>列优先</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><strong><br></strong></p> 
<pre>base_address&nbsp;+&nbsp;data_size&nbsp;×&nbsp;(D1&nbsp;+&nbsp;(S1&nbsp;×&nbsp;(D2&nbsp;+&nbsp;S2&nbsp;×&nbsp;(D3&nbsp;+&nbsp;S3&nbsp;×&nbsp;(...&nbsp;+&nbsp;Sn-1&nbsp;×&nbsp;Dn)...)))</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">虽然行优先或是列优先这种内存模型对于我们工程师来说是透明的，但是如果我们掌握好了哪种高级语言是采用哪种内存模型的话，这就对于我们来说是很有用的。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">我们都知道，CPU 在读取内存数据的时候，通常会有一个 CPU 缓存策略。也就是说，在 CPU 读取程序指定地址的数值时，<strong>CPU</strong><strong>&nbsp;</strong><strong>会把和它地址相邻的一些数据也一并读取并放到更高一级的缓存中</strong>，比如 L1 或者 L2 缓存。当数据存放在这种缓存上的时候，读取的速度有可能会比直接从内存上读取的速度快 10 倍以上。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: justify; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">如果知道了数据存放的内存模型是行优先的话，在设计数据结构的时候，会更倾向于读取每一行上的数据，因为每一行的数据在内存中都是保存在相邻位置的，它们更有可能被一起读取到 CPU 缓存中；反之，我们更倾向于读取每一列上的数据。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">那高级语言中有哪些是行优先又有哪些是列优先呢？我们常用的 C/C++ 和 Objective-C 都是行优先的内存模型，而 Fortran 或者 Matlab 则是列优先的内存模型。</span></p> 
<h3 style="white-space: normal;"><p style="line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><strong>“高效”的访问与“低效”的插入删除</strong></span></p></h3> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">从前面的数组内存模型的学习中，我们知道了访问一个数组中的元素采用的是随机访问的方式，只需要按照上面讲到的寻址方式来获取相应位置的数值便可，所以<strong>访问数组元素的时间复杂度是</strong><strong>&nbsp;O</strong><strong>(1)</strong>。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">对于保存<strong>基本类型（Primitive Type）</strong>的数组来说，它们的内存大小在一开始就已经确定好了，我们称它为<strong>静态数组（Static Array）</strong>。静态数组的大小是无法改变的，所以我们无法对这种数组进行插入或者删除操作。但是在使用高级语言的时候，比如 Java，我们知道 Java 中的 ArrayList 这种 Collection 是提供了像 add 和 remove 这样的 API 来进行插入和删除操作，这样的数组可以称之为<strong>动态数组（Dynamic Array）</strong>。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">我们来一起看看 add 和 remove 函数在 Java Openjdk-jdk11 中的源码，一起分析它们的时间复杂度。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在 Java Collection 中，底层的数据结构其实还是使用了数组，一般在初始化的时候会分配一个比我们在初始化时设定好的大小更大的空间，以方便以后进行增加元素的操作。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">假设所有的元素都保存在 elementData[] 这个数组中，add 函数的主要时间复杂度来自于以下源码片段。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>1.add(int index, E element) 函数源码</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">首先来看看 add(int index, E element) 这个函数的源码。&nbsp;<a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/ArrayList.java#L511" target="_self">(点击这里查看源代码</a>)</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<pre>public&nbsp;void&nbsp;add(int&nbsp;index,&nbsp;E&nbsp;element)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(elementData,&nbsp;index,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elementData,&nbsp;index&nbsp;+&nbsp;1,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;-&nbsp;index);
&nbsp;&nbsp;&nbsp;&nbsp;elementData[index]&nbsp;=&nbsp;element;
&nbsp;&nbsp;&nbsp;&nbsp;...
}</pre> 
<p style="white-space: normal;"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">可以看到，add 函数调用了一个 System.arraycopy 的函数进行内存操作，s 在这里代表了 ArrayList 的 size。当我们调用 add 函数的时候，函数在实现的过程中到底发生了什么呢？我们来看一个例子。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">假设 elementData 里面存放着以下元素：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/05/Cgq2xl329g-Adz0uAACwgSFkMho326.png" style="width: 360px; height: 90px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">如果我们调用了 add(1, 4) 函数，也就是在 index 为 1 的地方插入 4 这个元素，在 add 的函数中则会执行 System.arraycopy(elementData, 1, elementData, 2, 6 - 1) 语句，它的意思是将从 elementData 数组 index 为 1 的地址开始，复制往后的 5 个元素到 elementData 数组 index 为 2 的地址位置，如下图所示：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329hCAeNOkAAEvRtO2Pnc799.png" style="width: 360px; height: 89px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">红色的部分代表着执行完 System.arraycopy 函数的结果，最后执行 elementData[1] = 4; 这条语句：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/05/Cgq2xl329hCAAKY6AAEkcmvJCew309.png" style="width: 360px; height: 85px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">因为这里涉及到了每个元素的复制，平均下来的时间复杂度相当于 O(n)。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><strong>2.remove(int index) 函数源码</strong></span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">同理，我们来看看 remove(int index) 这个函数的源码。（<a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/ArrayList.java#L534" target="_self">点击这里查看源代码</a>）</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; padding: 0px; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><span style="color: rgb(215, 58, 73); font-size: 9pt; font-family: &quot;Microsoft YaHei&quot;, sans-serif;"></span></p> 
<pre>public&nbsp;void&nbsp;remove(int&nbsp;index)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;fastRemove(es,&nbsp;index);
&nbsp;&nbsp;&nbsp;&nbsp;...
}
&nbsp;
private&nbsp;void&nbsp;fastRemove(Object[]&nbsp;es,&nbsp;int&nbsp;i)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;...
&nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(es,&nbsp;i&nbsp;+&nbsp;1,&nbsp;es,&nbsp;i,&nbsp;newSize&nbsp;-&nbsp;i);
&nbsp;&nbsp;&nbsp;&nbsp;...
}</pre> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">这里的 newSize 是指原来 elementData 的 size - 1，当我们调用 remove(1) 会发生什么呢？我们还是以下面的例子来解释。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/04/CgpOIF329hCAByRzAACwgSFkMho165.png" style="width: 360px; height: 91px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);"><br></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">如果我们调用了 remove(1) 函数，也就是删除在 index 为 1 这个地方的元素，在 remove 的函数中则会执行 System.arraycopy(elementData, 1 + 1, elementData, 1, 2) 语句，它的意思是将从 elementData 数组 index 为 2 的地址开始，复制后面的 2 个元素到 elementData 数组 index 为 1 的地址位置，如下图所示：</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; text-align: center; line-height: 16.866666793823242px; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp; &nbsp; &nbsp; &nbsp;<img src="https://s0.lgstatic.com/i/image3/M01/58/05/Cgq2xl329hCAIGqNAAEIP9vnEWM398.png" style="width: 360px; height: 88px;">&nbsp;&nbsp; &nbsp; &nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; line-height: 1.7; font-size: 11pt; color: rgb(73, 73, 73);">&nbsp;</p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">因为这里同样涉及到了每个元素的复制，平均下来时间复杂度相当于 O(n)。</span></p> 
<h3 style="white-space: normal;"><p style="line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">小结</span></p></h3> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">今天我们一起探讨了数组这个数据结构的内存模型，知道了读取数组的时间复杂度为 O(1)，也一起通过分析 Java Openjdk-jdk11，知道了插入和删除数组元素的时间复杂度为 O(n)。</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p> 
<p style="margin-top: 0pt; margin-bottom: 0pt; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">OK，这节课就讲到这里啦，下一课时我将分享“位图数组在 Redis 中的应用”，记得按时来听课哈。</span></p>

---

### 精选评论

##### *碧：
> 特意买下这门课，想评论一下也是一个原因。我比较同意*卢同学的观点。Java的外数组就是存了内数组的首地址。"The language supports arrays of arrays, rather than multidimensional arrays." --&nbsp;Java Language Specification<div>我觉得这个T.J. Crowder在StackOverflow的回答最清楚直白：<a href="https://stackoverflow.com/questions/6630990/java-a-two-dimensional-array-is-stored-in-column-major-or-row-major-order" style="font-size: 0.427rem; background-color: rgb(255, 255, 255);">https://stackoverflow.com/questions/6630990/java-a-two-dimensional-array-is-stored-in-column-major-or-row-major-order</a></div>

##### **生：
> java是列优先还是行优先？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; ava的情况比较特殊，它既不是行优先也不是列优先，一般在Java声明了一个二维数组，实际上内存并不是连续分配的，而是保存了多个不同的一维数组的首地址

##### *卢：
> 对于Java的二维数组，本质上还是一维的，每一位中存储的是另外一个一维数组的地址。上述对于Java多维数组描述错误！

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; “对于Java的二维数组，本质上还是一维的”这个描述是对的。“每一位中存储的是另外一个一维数组的地址”这个不太恰当，本质上不会存数组的地址

##### **松：
> 棒 高屋建瓴

##### *磊：
> 对于java的多维数组，是不是在数组对象的对象头中保存了多个一维数组的首地址

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 理解得十分正确，以二维数组为例，数组对象从起始地址开始都保存着每个元素里一维数组的起始地址。如果是三位数组的话，数组对象从起始地址开始都保存着每个元素里二维数组的起始地址，这样递归回去。

##### **3517：
> 不明白，行优先的话，寻找data[0][1].为什么不是i*2而是i*3? 请老师看见后能解惑。。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 感谢这位同学的提问！首先我们要搞清楚行优先的内存模型，也就是每一行的每个相邻元素都保存在了相邻的连续内存空间中。在文章中，我们以一个两行三列的数组data[2][3]作为例子来讲解，所以这个数组在内存中是以data[0][0]，data[0][1]，data[0][2]，data[1][0]，data[1][1]，data[1][2]这样来排列的。内存寻址公式base_address + data_size × (i × number_of_column + j)里，i × number_of_column表示要跳过的每一行的数组元素个数。我们换一个例子会好理解一点，如果要寻址data[1][1]元素的话，就表示我们要找第二行的第二个元素。按照base_address + data_size × (i × number_of_column + j)，这个元素的地址就在base_address + data_size × (1 × 3 + 1)，也就是跳过了4个元素从而定位到第5个元素data[1][1]。

##### **建：
> 多维数组本质上都是一维的

