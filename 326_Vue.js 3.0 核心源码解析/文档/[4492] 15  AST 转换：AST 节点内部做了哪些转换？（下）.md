<p data-nodeid="24415">上一节课，我们已经知道了 transform 的核心流程主要有四步：创建 transform 上下文、遍历 AST 节点、静态提升以及创建根代码生成节点。这节课我们接着分析遍历 AST 节点中的 Text 节点的转换函数。</p>



<h3 data-nodeid="23713">遍历 AST 节点</h3>
<h4 data-nodeid="23714">Text 节点转换函数</h4>
<p data-nodeid="23715">接下来，我们来看一下 Text 节点转换函数的实现：</p>
<pre class="lang-java" data-nodeid="26268"><code data-language="java"><span class="hljs-keyword">const</span> transformText = (node, context) =&gt; {
  <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">0</span> <span class="hljs-comment">/* ROOT */</span> ||
    node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> ||
    node.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span> ||
    node.type === <span class="hljs-number">10</span> <span class="hljs-comment">/* IF_BRANCH */</span>) {
    <span class="hljs-comment">// 在节点退出时执行转换，保证所有表达式都已经被处理</span>
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">const</span> children = node.children
      let currentContainer = undefined
      let hasText = <span class="hljs-keyword">false</span>
      <span class="hljs-comment">// 将相邻文本节点合并</span>
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        <span class="hljs-keyword">const</span> child = children[i]
        <span class="hljs-keyword">if</span> (isText(child)) {
          hasText = <span class="hljs-function"><span class="hljs-keyword">true</span>
          <span class="hljs-title">for</span> <span class="hljs-params">(let j = i + <span class="hljs-number">1</span>; j &lt; children.length; j++)</span> </span>{
            <span class="hljs-keyword">const</span> next = children[j]
            <span class="hljs-keyword">if</span> (isText(next)) {
              <span class="hljs-keyword">if</span> (!currentContainer) {
                <span class="hljs-comment">// 创建复合表达式节点</span>
                currentContainer = children[i] = {
                  type: <span class="hljs-number">8</span> <span class="hljs-comment">/* COMPOUND_EXPRESSION */</span>,
                  loc: child.loc,
                  children: [child]
                }
              }
              currentContainer.children.push(` + `, next)
              children.splice(j, <span class="hljs-number">1</span>)
              j--
            }
            <span class="hljs-keyword">else</span> {
              currentContainer = undefined
              <span class="hljs-keyword">break</span>
            }
          }
        }
      }
      <span class="hljs-keyword">if</span> (!hasText ||
        <span class="hljs-comment">// 如果是一个带有单个文本子元素的纯元素节点，什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</span>
        (children.length === <span class="hljs-number">1</span> &amp;&amp;
          (node.type === <span class="hljs-number">0</span> <span class="hljs-comment">/* ROOT */</span> ||
            (node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> &amp;&amp;
              node.tagType === <span class="hljs-number">0</span> <span class="hljs-comment">/* ELEMENT */</span>)))) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-comment">// 为子文本节点创建一个调用函数表达式的代码生成节点</span>
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
        <span class="hljs-keyword">const</span> child = children[i]
        <span class="hljs-keyword">if</span> (isText(child) || child.type === <span class="hljs-number">8</span> <span class="hljs-comment">/* COMPOUND_EXPRESSION */</span>) {
          <span class="hljs-keyword">const</span> callArgs = []
          <span class="hljs-comment">// 为 createTextVNode 添加执行参数</span>
          <span class="hljs-keyword">if</span> (child.type !== <span class="hljs-number">2</span> <span class="hljs-comment">/* TEXT */</span> || child.content !== <span class="hljs-string">' '</span>) {
            callArgs.push(child)
          }
          <span class="hljs-comment">// 标记动态文本</span>
          <span class="hljs-keyword">if</span> (!context.ssr &amp;&amp; child.type !== <span class="hljs-number">2</span> <span class="hljs-comment">/* TEXT */</span>) {
            callArgs.push(`${<span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>} <span class="hljs-comment">/* ${PatchFlagNames[1 /* TEXT */</span>]} */`)
          }
          children[i] = {
            type: <span class="hljs-number">12</span> <span class="hljs-comment">/* TEXT_CALL */</span>,
            content: child,
            loc: child.loc,
            codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
          }
        }
      }
    }
  }
}
</code></pre>




<p data-nodeid="23717">transformText 函数只处理根节点、元素节点、 v-for 以及 v-if 分支相关的节点，它也会返回一个退出函数，因为 transformText 要保证所有表达式节点都已经被处理才执行转换逻辑。</p>
<p data-nodeid="23718">transformText 主要的目的就是合并一些相邻的文本节点，然后为内部每一个文本节点创建一个代码生成节点。</p>
<p data-nodeid="23719">在内部，静态文本节点和动态插值节点都被看作是一个文本节点，所以函数首先遍历节点的子节点，然后把子节点中的相邻文本节点合并成一个。</p>
<p data-nodeid="23720">比如示例中的文本节点：<code data-backticks="1" data-nodeid="23820">&lt;p&gt;hello {{ msg + test }}&lt;/p&gt;</code>。</p>
<p data-nodeid="23721">在转换之前，p 节点对应的 children 数组有两个元素，第一个是纯文本节点，第二个是一个插值节点，这个数组也是前面提到的表达式节点转换后的结果：</p>
<pre class="lang-java" data-nodeid="26731"><code data-language="java">[
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"hello "</span>,
  },
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">"content"</span>: {
      <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
      <span class="hljs-string">"children"</span>: [
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
          <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
          <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.msg"</span>,
          <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
        },
        <span class="hljs-string">" + "</span>,
        {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
          <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
          <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.test"</span>,
          <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
        }
      ],
      <span class="hljs-string">"identifiers"</span>: []
    }
  }
]
</code></pre>

<p data-nodeid="23723">转换后，这两个文本节点被合并成一个复合表达式节点，结果如下：</p>
<pre class="lang-java" data-nodeid="27194"><code data-language="java">[
  {
    <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
    <span class="hljs-string">"children"</span>: [
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">2</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"hello "</span>,
      },
      <span class="hljs-string">" + "</span>,
      {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">5</span>,
        <span class="hljs-string">"content"</span>: {
          <span class="hljs-string">"type"</span>: <span class="hljs-number">8</span>,
          <span class="hljs-string">"children"</span>: [
            {
              <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
              <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
              <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.msg"</span>,
              <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
            },
            <span class="hljs-string">" + "</span>,
            {
              <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
              <span class="hljs-string">"isConstant"</span>: <span class="hljs-keyword">false</span>,
              <span class="hljs-string">"content"</span>: <span class="hljs-string">"_ctx.test"</span>,
              <span class="hljs-string">"isStatic"</span>: <span class="hljs-keyword">false</span>
            }
          ],
          <span class="hljs-string">"identifiers"</span>: []
        }
      }
    ]
  }
]
</code></pre>

<p data-nodeid="23725">合并完子文本节点后，接着判断如果是一个只带有单个文本子元素的纯元素节点，则什么都不需要转换，因为这种情况在运行时可以直接设置元素的 textContent 来更新文本。</p>
<p data-nodeid="23726">最后就是去处理节点包含文本子节点且多个子节点的情况，举个例子：</p>
<pre class="lang-js" data-nodeid="28120"><code data-language="js">&lt;p&gt;
  hello {{ msg + test }}
  &lt;a href=<span class="hljs-string">"foo"</span>/&gt;
  hi
&lt;/p&gt;
</code></pre>


<p data-nodeid="23728">上述 p 标签的子节点经过前面的文本合并流程后，还有 3 个子节点。针对这种情况，我们可以遍历子节点，找到所有的文本节点或者是复合表达式节点，然后为这些子节点通过 createCallExpression 创建一个调用函数表达式的代码生成节点。</p>
<p data-nodeid="23729">我们来看 createCallExpression 的实现：</p>
<pre class="lang-java" data-nodeid="28583"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createCallExpression</span><span class="hljs-params">(callee, args = [], loc = locStub)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">14</span> <span class="hljs-comment">/* JS_CALL_EXPRESSION */</span>,
    loc,
    callee,
    arguments: args
  }
}
</code></pre>

<p data-nodeid="23731">createCallExpression 的实现很简单，就是返回一个类型为 JS_CALL_EXPRESSION 的对象，它包含了执行的函数名和参数。</p>
<p data-nodeid="23732">这里，针对我们创建的函数表达式所生成的节点，它对应的函数名是 createTextVNode，参数 callArgs 是子节点本身 child，如果是动态插值节点，那么参数还会多一个 TEXT 的 patchFlag。</p>
<h4 data-nodeid="23733">v-if 节点转换函数</h4>
<p data-nodeid="23734">接下来，我们来看一下 v-if 节点转换函数的实现：</p>
<pre class="lang-java" data-nodeid="29046"><code data-language="java"><span class="hljs-keyword">const</span> transformIf = createStructuralDirectiveTransform(/^(<span class="hljs-keyword">if</span>|<span class="hljs-keyword">else</span>|<span class="hljs-keyword">else</span>-<span class="hljs-keyword">if</span>)$/, (node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    }
  })
})
</code></pre>

<p data-nodeid="23736">在分析函数的实现前，我们先来看一下 v-if 节点转换的目的，为了方便你的理解，我还是通过示例来说明：</p>
<pre class="lang-js" data-nodeid="30898"><code data-language="js">&lt;hello v-<span class="hljs-keyword">if</span>=<span class="hljs-string">"flag"</span>&gt;&lt;/hello&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>hello {{ msg + test }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
</code></pre>


<p data-nodeid="23738">在 parse 阶段，这个模板解析生成的 AST 节点如下：</p>
<pre class="lang-js" data-nodeid="29972"><code data-language="js">[
  {
    <span class="hljs-string">"children"</span>: [],
    <span class="hljs-string">"codegenNode"</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-string">"isSelfClosing"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"ns"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"props"</span>: [{
      <span class="hljs-string">"type"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"if"</span>,
      <span class="hljs-string">"exp"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-number">4</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"flag"</span>,
        <span class="hljs-string">"isConstant"</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-string">"isStatic"</span>: <span class="hljs-literal">false</span>
      },
      <span class="hljs-string">"arg"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"modifiers"</span>: []
    }],
    <span class="hljs-string">"tag"</span>: <span class="hljs-string">"hello"</span>,
    <span class="hljs-string">"tagType"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"type"</span>: <span class="hljs-number">1</span>
  },
  {
    <span class="hljs-string">"children"</span>: [
      <span class="hljs-comment">// 子节点</span>
    ],
    <span class="hljs-string">"codegenNode"</span>: <span class="hljs-literal">undefined</span>,
    <span class="hljs-string">"isSelfClosing"</span>: <span class="hljs-literal">false</span>,
    <span class="hljs-string">"ns"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"props"</span>: [{ 
      <span class="hljs-string">"type"</span>: <span class="hljs-number">7</span>,
      <span class="hljs-string">"name"</span>: <span class="hljs-string">"else"</span>,
      <span class="hljs-string">"exp"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"arg"</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-string">"modifiers"</span>: []
    }],
    <span class="hljs-string">"tag"</span>: <span class="hljs-string">"div"</span>,
    <span class="hljs-string">"tagType"</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">"type"</span>: <span class="hljs-number">1</span>
  }
]
</code></pre>


<p data-nodeid="23740">v-if 指令用于条件性地渲染一块内容，显然上述 AST 节点对于最终去生成条件的代码而言，是不够语义化的，于是我们需要对它们做一层转换，使其成为语义化强的代码生成节点。</p>
<p data-nodeid="23741">现在我们回过头看 transformIf 的实现，它是通过 createStructuralDirectiveTransform 函数创建的一个结构化指令的转换函数，在 Vue.js 中，v-if、v-else-if、v-else 和 v-for 这些都属于结构化指令，因为它们能影响代码的组织结构。</p>
<p data-nodeid="23742">我们来看一下 createStructuralDirectiveTransform 的实现：</p>
<pre class="lang-java" data-nodeid="31361"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createStructuralDirectiveTransform</span><span class="hljs-params">(name, fn)</span> </span>{
  <span class="hljs-keyword">const</span> matches = isString(name)
    ? (n) =&gt; n === name
    : (n) =&gt; name.test(n)
  <span class="hljs-keyword">return</span> (node, context) =&gt; {
    <span class="hljs-comment">// 只处理元素节点</span>
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-keyword">const</span> { props } = node
      <span class="hljs-comment">// 结构化指令的转换与插槽无关，插槽相关处理逻辑在 vSlot.ts 中</span>
      <span class="hljs-keyword">if</span> (node.tagType === <span class="hljs-number">3</span> <span class="hljs-comment">/* TEMPLATE */</span> &amp;&amp; props.some(isVSlot)) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-keyword">const</span> exitFns = []
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; props.length; i++) {
        <span class="hljs-keyword">const</span> prop = props[i]
        <span class="hljs-keyword">if</span> (prop.type === <span class="hljs-number">7</span> <span class="hljs-comment">/* DIRECTIVE */</span> &amp;&amp; matches(prop.name)) {
          <span class="hljs-comment">// 删除结构指令以避免无限递归</span>
          props.splice(i, <span class="hljs-number">1</span>)
          i--
          <span class="hljs-keyword">const</span> onExit = fn(node, prop, context)
          <span class="hljs-keyword">if</span> (onExit)
            exitFns.push(onExit)
        }
      }
      <span class="hljs-keyword">return</span> exitFns
    }
  }
}
</code></pre>

<p data-nodeid="23744">可以看到，createStructuralDirectiveTransform 接受 2 个参数，第一个 name 是指令的名称，第二个 fn 是构造转换退出函数的方法。</p>
<p data-nodeid="23745">createStructuralDirectiveTransform 最后会返回一个函数，在我们的场景下，这个函数就是 transformIf 转换函数。</p>
<p data-nodeid="23746">我们进一步看这个函数的实现，它只处理元素节点，这个很好理解，因为只有元素节点才会有 v-if 指令，接着会解析这个节点的 props 属性，如果发现 props 包含 if 属性，也就是节点拥有 v-if 指令，那么先从 props 删除这个结构化指令防止无限递归，然后执行 fn 获取对应的退出函数，最后将这个退出函数返回。</p>
<p data-nodeid="23747">接着我们来看 fn 的实现，在我们这个场景下 fn 对应的是前面传入的匿名函数：</p>
<pre class="lang-java" data-nodeid="31824"><code data-language="java">(node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-keyword">return</span> () =&gt; {
       <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    }
  })
}
</code></pre>

<p data-nodeid="23749">可以看出，这个匿名函数内部执行了 processIf 函数，它会先对 v-if 和它的相邻节点做转换，然后返回一个退出函数，在它们的子节点都转换完毕后执行。</p>
<p data-nodeid="23750">我们来看 processIf 函数的实现：</p>
<pre class="lang-java" data-nodeid="32287"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">processIf</span><span class="hljs-params">(node, dir, context, processCodegen)</span> </span>{
  <span class="hljs-keyword">if</span> (dir.name === <span class="hljs-string">'if'</span>) {
    <span class="hljs-comment">// 创建分支节点</span>
    <span class="hljs-keyword">const</span> branch = createIfBranch(node, dir)
    <span class="hljs-comment">// 创建 IF 节点，替换当前节点</span>
    <span class="hljs-keyword">const</span> ifNode = {
      type: <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>,
      loc: node.loc,
      branches: [branch]
    }
    context.replaceNode(ifNode)
    <span class="hljs-keyword">if</span> (processCodegen) {
      <span class="hljs-keyword">return</span> processCodegen(ifNode, branch, <span class="hljs-keyword">true</span>)
    }
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span>
  }
}
</code></pre>

<p data-nodeid="23752">processIf 主要就是用来处理 v-if 节点以及 v-if 的相邻节点，比如 v-else-if 和 v-else，并且它们会走不同的处理逻辑。</p>
<p data-nodeid="23753">我们先来看 v-if 的处理逻辑。首先，它会执行 createIfBranch 去创建一个分支节点：</p>
<pre class="lang-java" data-nodeid="32750"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createIfBranch</span><span class="hljs-params">(node, dir)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">10</span> <span class="hljs-comment">/* IF_BRANCH */</span>,
    loc: node.loc,
    condition: dir.name === <span class="hljs-string">'else'</span> ? undefined : dir.exp,
    children: node.tagType === <span class="hljs-number">3</span> <span class="hljs-comment">/* TEMPLATE */</span> ? node.children : [node]
  }
}
</code></pre>

<p data-nodeid="23755">这个分支节点很好理解，因为 v-if 节点内部的子节点可以属于一个分支，v-else-if 和 v-else 节点内部的子节点也都可以属于一个分支，而最终页面渲染执行哪个分支，这取决于哪个分支节点的 condition 为 true。</p>
<p data-nodeid="23756">所以分支节点返回的对象，就包含了 condition 条件，以及它的子节点 children。注意，<strong data-nodeid="23859">如果节点 node 不是 template</strong>，<strong data-nodeid="23860">那么 children 指向的就是这个单个 node 构造的数组</strong>。</p>
<p data-nodeid="23757">接下来它会创建 IF 节点替换当前节点，IF 节点拥有 branches 属性，包含我们前面创建的分支节点，显然，相对于原节点，IF 节点的语义化更强，更利于后续生成条件表达式代码。</p>
<p data-nodeid="23758">最后它会执行 processCodegen 创建退出函数。我们先不着急去分析退出函数的创建过程，先把 v-if 相邻节点的处理逻辑分析完：</p>
<pre class="lang-java" data-nodeid="33213"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">processIf</span><span class="hljs-params">(node, dir, context, processCodegen)</span> </span>{
  <span class="hljs-keyword">if</span> (dir.name === <span class="hljs-string">'if'</span>) {
    <span class="hljs-comment">// 处理 v-if 节点</span>
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 处理 v-if 相邻节点，比如 v-else-if 和 v-else</span>
    <span class="hljs-keyword">const</span> siblings = context.parent.children
    let i = siblings.indexOf(node)
    <span class="hljs-keyword">while</span> (i-- &gt;= -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">const</span> sibling = siblings[i]
      <span class="hljs-keyword">if</span> (sibling &amp;&amp; sibling.type === <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>) {
        <span class="hljs-comment">// 把节点移动到 IF 节点的 branches 中</span>
        context.removeNode()
        <span class="hljs-keyword">const</span> branch = createIfBranch(node, dir)
        sibling.branches.push(branch)
        <span class="hljs-keyword">const</span> onExit = processCodegen &amp;&amp; processCodegen(sibling, branch, <span class="hljs-keyword">false</span>)
        <span class="hljs-comment">// 因为分支已被删除，所以它的子节点需要在这里遍历</span>
        traverseNode(branch, context)
        <span class="hljs-comment">// 执行退出函数</span>
        <span class="hljs-keyword">if</span> (onExit)
          onExit()
        <span class="hljs-comment">// 恢复 currentNode 为 null，因为它已经被移除</span>
        context.currentNode = <span class="hljs-keyword">null</span>
      }
      <span class="hljs-keyword">else</span> {
        context.onError(createCompilerError(<span class="hljs-number">28</span> <span class="hljs-comment">/* X_V_ELSE_NO_ADJACENT_IF */</span>, node.loc))
      }
      <span class="hljs-keyword">break</span>
    }
  }
}
</code></pre>

<p data-nodeid="23760">这段处理逻辑就是从当前节点往前面的兄弟节点遍历，找到 v-if 节点后，把当前节点删除，然后根据当前节点创建一个分支节点，把这个分支节点添加到前面创建的 IF 节点的 branches 中。此外，由于这个节点已经删除，那么需要在这里把这个节点的子节点通过 traverseNode 遍历一遍。</p>
<p data-nodeid="23761">这么处理下来，就相当于完善了 IF 节点的信息了，IF 节点的 branches 就包含了所有分支节点了。</p>
<p data-nodeid="23762">那么至此，进入 v-if、v-else-if、v-else 这些节点的转换逻辑我们就分析完毕了，即最终创建了一个 IF 节点，它包含了所有的分支节点。</p>
<p data-nodeid="23763">接下来，我们再来分析这个退出函数的逻辑：</p>
<pre class="lang-java" data-nodeid="33676"><code data-language="java">(node, dir, context) =&gt; {
  <span class="hljs-keyword">return</span> processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; {
    <span class="hljs-comment">// 退出回调函数，当所有子节点转换完成执行</span>
    <span class="hljs-keyword">return</span> () =&gt; {
      <span class="hljs-keyword">if</span> (isRoot) {
        <span class="hljs-comment">// v-if 节点的退出函数</span>
        <span class="hljs-comment">// 创建 IF 节点的 codegenNode</span>
        ifNode.codegenNode = createCodegenNodeForBranch(branch, <span class="hljs-number">0</span>, context)
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// v-else-if、v-else 节点的退出函数</span>
        <span class="hljs-comment">// 将此分支的 codegenNode 附加到 上一个条件节点的 codegenNode 的 alternate 中</span>
        let parentCondition = ifNode.<span class="hljs-function">codegenNode
        <span class="hljs-title">while</span> <span class="hljs-params">(parentCondition.alternate.type ===
        <span class="hljs-number">19</span> <span class="hljs-comment">/* JS_CONDITIONAL_EXPRESSION */</span>)</span> </span>{
          parentCondition = parentCondition.alternate
        }
        <span class="hljs-comment">// 更新候选节点</span>
        parentCondition.alternate = createCodegenNodeForBranch(branch, ifNode.branches.length - <span class="hljs-number">1</span>, context)
      }
    }
  })
}
</code></pre>

<p data-nodeid="23765">可以看到，当 v-if 节点执行退出函数时，会通过 createCodegenNodeForBranch 创建 IF 分支节点的 codegenNode，我们来看一下它的实现：</p>
<pre class="lang-java" data-nodeid="34139"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createCodegenNodeForBranch</span><span class="hljs-params">(branch, index, context)</span> </span>{
  <span class="hljs-keyword">if</span> (branch.condition) {
    <span class="hljs-keyword">return</span> createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, index, context),
      createCallExpression(context.helper(CREATE_COMMENT), [
        (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) ? <span class="hljs-string">'"v-if"'</span> : <span class="hljs-string">'""'</span>,
        <span class="hljs-string">'true'</span>
      ]))
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> createChildrenCodegenNode(branch, index, context)
  }
}
</code></pre>

<p data-nodeid="23767">当分支节点存在 condition 的时候，比如 v-if、和 v-else-if，它通过 createConditionalExpression 返回一个条件表达式节点：</p>
<pre class="lang-java" data-nodeid="34602"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createConditionalExpression</span><span class="hljs-params">(test, consequent, alternate, newline = <span class="hljs-keyword">true</span>)</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">19</span> <span class="hljs-comment">/* JS_CONDITIONAL_EXPRESSION */</span>,
    test,
    consequent,
    alternate,
    newline,
    loc: locStub
  }
}
</code></pre>

<p data-nodeid="23769">其中 consequent 在这里是 IF 主 branch 的子节点对应的代码生成节点，alternate 是后补 branch 子节点对应的代码生成节点。</p>
<p data-nodeid="23770">接着，我们来看一下 createChildrenCodegenNode 的实现：</p>
<pre class="lang-java" data-nodeid="35065"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createChildrenCodegenNode</span><span class="hljs-params">(branch, index, context)</span> </span>{
  <span class="hljs-keyword">const</span> { helper } = context
  <span class="hljs-comment">// 根据 index 创建 key 属性</span>
  <span class="hljs-keyword">const</span> keyProperty = createObjectProperty(`key`, createSimpleExpression(index + <span class="hljs-string">''</span>, <span class="hljs-keyword">false</span>))
  <span class="hljs-keyword">const</span> { children } = branch
  <span class="hljs-keyword">const</span> firstChild = children[<span class="hljs-number">0</span>]
  <span class="hljs-keyword">const</span> needFragmentWrapper = children.length !== <span class="hljs-number">1</span> || firstChild.type !== <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>
  <span class="hljs-keyword">if</span> (needFragmentWrapper) {
    <span class="hljs-keyword">if</span> (children.length === <span class="hljs-number">1</span> &amp;&amp; firstChild.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span>) {
      <span class="hljs-keyword">const</span> vnodeCall = firstChild.<span class="hljs-function">codegenNode
      <span class="hljs-title">injectProp</span><span class="hljs-params">(vnodeCall, keyProperty, context)</span>
      return vnodeCall
    }
    <span class="hljs-keyword">else</span> </span>{
      <span class="hljs-keyword">return</span> createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, `${<span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>} <span class="hljs-comment">/* ${PatchFlagNames[64 /* STABLE_FRAGMENT */</span>]} */`, undefined, undefined, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, branch.loc)
    }
  } 
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">const</span> vnodeCall = firstChild
      .codegenNode;
    <span class="hljs-comment">// 把 createVNode 改变为 createBlock</span>
    <span class="hljs-keyword">if</span> (vnodeCall.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span> &amp;&amp;
      <span class="hljs-comment">// 组件节点的 children 会被视为插槽，不需要添加 block</span>
      (firstChild.tagType !== <span class="hljs-number">1</span> <span class="hljs-comment">/* COMPONENT */</span> ||
        vnodeCall.tag === TELEPORT)) {
      vnodeCall.isBlock = <span class="hljs-keyword">true</span>
      <span class="hljs-comment">// 创建 block 的辅助代码</span>
      helper(OPEN_BLOCK)
      helper(CREATE_BLOCK)
    }
    <span class="hljs-comment">// 给 branch 注入 key 属性</span>
    injectProp(vnodeCall, keyProperty, context)
    <span class="hljs-keyword">return</span> vnodeCall
  }
}
</code></pre>

<p data-nodeid="23772">createChildrenCodegenNode 主要就是判断每个分支子节点是不是一个 vnodeCall，如果这个子节点不是组件节点的话，则把它转变成一个 BlockCall，也就是让 v-if 的每一个分支都可以创建一个 Block。</p>
<p data-nodeid="23773">这个行为是很好理解的，因为 v-if 是条件渲染的，我们知道在某些条件下某些分支是不会渲染的，那么它内部的动态节点就不能添加到外部的 Block 中的，所以它就需要单独创建一个 Block 来维护分支内部的动态节点，这样也就构成了 Block tree。</p>
<p data-nodeid="23774">为了直观让你感受 v-if 节点最终转换的结果，我们来看前面示例转换后的结果，最终转换生成的 IF 节点对象大致如下：</p>
<pre class="lang-json" data-nodeid="23775"><code data-language="json">{
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">9</span>,
  <span class="hljs-attr">"branches"</span>: [{
     <span class="hljs-attr">"type"</span>: <span class="hljs-number">10</span>,
     <span class="hljs-attr">"children"</span>: [{
        <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tagType"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"hello"</span>
     }],
     <span class="hljs-attr">"condition"</span>: {
       <span class="hljs-attr">"type"</span>: <span class="hljs-number">4</span>,
       <span class="hljs-attr">"content"</span>: <span class="hljs-string">"_ctx.flag"</span>
     }
  },{
     <span class="hljs-attr">"type"</span>: <span class="hljs-number">10</span>,
     <span class="hljs-attr">"children"</span>: [{
        <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">"tagType"</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"hello"</span>
     }],
     <span class="hljs-attr">"condition"</span>: {
       <span class="hljs-attr">"type"</span>: <span class="hljs-number">4</span>,
       <span class="hljs-attr">"content"</span>: <span class="hljs-string">"_ctx.flag"</span>
     }
  }],
  <span class="hljs-attr">"codegenNode"</span>: {
    <span class="hljs-attr">"type"</span>: <span class="hljs-number">19</span>,
    <span class="hljs-attr">"consequent"</span>: {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">13</span>,
      <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"_component_hello"</span>,
      <span class="hljs-attr">"children"</span>: undefined,
      <span class="hljs-attr">"directives"</span>: undefined,
      <span class="hljs-attr">"dynamicProps"</span>: undefined,
      <span class="hljs-attr">"isBlock"</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">"patchFlag"</span>: undefined
    },
    <span class="hljs-attr">"alternate"</span>: {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">13</span>,
      <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"_component_hello"</span>,
      <span class="hljs-attr">"children"</span>: [
        <span class="hljs-comment">// 子节点</span>
      ],
      <span class="hljs-attr">"directives"</span>: undefined,
      <span class="hljs-attr">"dynamicProps"</span>: undefined,
      <span class="hljs-attr">"isBlock"</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">"patchFlag"</span>: undefined
    }
  }
}
</code></pre>
<p data-nodeid="23776">可以看到，相比原节点，转换后的 IF 节点无论是在语义化还是在信息上，都更加丰富，我们可以依据它在代码生成阶段生成所需的代码。</p>
<h3 data-nodeid="23777">静态提升</h3>
<p data-nodeid="23778">节点转换完毕后，接下来会判断编译配置中是否配置了 hoistStatic，如果是就会执行 hoistStatic 做静态提升：</p>
<pre class="lang-java" data-nodeid="35528"><code data-language="java"><span class="hljs-keyword">if</span> (options.hoistStatic) {
  hoistStatic(root, context)
}
</code></pre>

<p data-nodeid="23780">静态提升也是 Vue.js 3.0 在编译阶段设计了一个优化策略，为了便于你理解，我先举个简单的例子：</p>
<pre class="lang-js" data-nodeid="36454"><code data-language="js">&lt;p&gt;&gt;hello {{ msg + test }}&lt;/p&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>static<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
</code></pre>


<p data-nodeid="23782">我们为它配置了 hoistStatic，经过编译后，它的代码就变成了这样：</p>
<pre class="lang-java" data-nodeid="36917"><code data-language="java"><span class="hljs-keyword">import</span> { toDisplayString as _toDisplayString, createVNode as _createVNode, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from <span class="hljs-string">"vue"</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"static"</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-keyword">const</span> _hoisted_2 = <span class="hljs-comment">/*#__PURE__*/</span>_createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"static"</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)
<span class="hljs-function">export function <span class="hljs-title">render</span><span class="hljs-params">(_ctx, _cache)</span> </span>{
  <span class="hljs-keyword">return</span> (_openBlock(), _createBlock(_Fragment, <span class="hljs-keyword">null</span>, [
    _createVNode(<span class="hljs-string">"p"</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"hello "</span> + _toDisplayString(_ctx.msg + _ctx.test), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>),
    _hoisted_1,
    _hoisted_2
  ], <span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>))
}
</code></pre>

<p data-nodeid="23784">这里，我们先忽略 openBlock、Fragment ，我会在代码生成章节详细说明，重点看一下 _hoisted_1 和 _hoisted_2 这两个变量，它们分别对应模板中两个静态 p 标签生成的 vnode，可以发现它的创建是在 render 函数外部执行的。<br>
这样做的好处是，不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，直接用之前在内存中创建好的 vnode 即可。</p>
<p data-nodeid="23785">那么为什么叫静态提升呢？</p>
<p data-nodeid="23786">因为这些静态节点不依赖动态数据，一旦创建了就不会改变，所以只有静态节点才能被提升到外部创建。</p>
<p data-nodeid="23787">了解以上背景知识后，我们接下来看一下静态提升的实现：</p>
<pre class="lang-java" data-nodeid="37380"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">hoistStatic</span><span class="hljs-params">(root, context)</span> </span>{
  walk(root, context, <span class="hljs-keyword">new</span> Map(),
    <span class="hljs-comment">// Root node is unfortunately non-hoistable due to potential parent fallthrough attributes.</span>
    isSingleElementRoot(root, root.children[<span class="hljs-number">0</span>]));
}
<span class="hljs-function">function <span class="hljs-title">walk</span><span class="hljs-params">(node, context, resultCache, doNotHoistNode = <span class="hljs-keyword">false</span>)</span> </span>{
  let hasHoistedNode = <span class="hljs-keyword">false</span>
  <span class="hljs-comment">// 是否包含运行时常量</span>
  let hasRuntimeConstant = <span class="hljs-keyword">false</span>
  <span class="hljs-keyword">const</span> { children } = <span class="hljs-function">node
  <span class="hljs-title">for</span> <span class="hljs-params">(let i = <span class="hljs-number">0</span>; i &lt; children.length; i++)</span> </span>{
    <span class="hljs-keyword">const</span> child = children[i]
    <span class="hljs-comment">// 只有普通元素和文本节点才能被静态提升</span>
    <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span> &amp;&amp;
      child.tagType === <span class="hljs-number">0</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-function">let staticType
      <span class="hljs-title">if</span> <span class="hljs-params">(!doNotHoistNode &amp;&amp;
        // 获取静态节点的类型，如果是元素，则递归检查它的子节点
        (staticType = getStaticType(child, resultCache)</span>) &gt; 0) </span>{
        <span class="hljs-keyword">if</span> (staticType === <span class="hljs-number">2</span> <span class="hljs-comment">/* HAS_RUNTIME_CONSTANT */</span>) {
          hasRuntimeConstant = <span class="hljs-keyword">true</span>
        }
        <span class="hljs-comment">// 更新 patchFlag</span>
        child.codegenNode.patchFlag =
          -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span> + ((process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) ? ` <span class="hljs-comment">/* HOISTED */</span>` : ``)
        <span class="hljs-comment">// 更新节点的 codegenNode</span>
        child.codegenNode = context.hoist(child.codegenNode)
        hasHoistedNode = <span class="hljs-keyword">true</span>
        <span class="hljs-keyword">continue</span>
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 节点可能会包含一些动态子节点，但它的静态属性还是可以被静态提升</span>
        <span class="hljs-keyword">const</span> codegenNode = child.<span class="hljs-function">codegenNode
        <span class="hljs-title">if</span> <span class="hljs-params">(codegenNode.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span>)</span> </span>{
          <span class="hljs-keyword">const</span> flag = getPatchFlag(codegenNode)
          <span class="hljs-keyword">if</span> ((!flag ||
            flag === <span class="hljs-number">512</span> <span class="hljs-comment">/* NEED_PATCH */</span> ||
            flag === <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>) &amp;&amp;
            !hasDynamicKeyOrRef(child) &amp;&amp;
            !hasCachedProps()) {
            <span class="hljs-keyword">const</span> props = getNodeProps(child)
            <span class="hljs-keyword">if</span> (props) {
              codegenNode.props = context.hoist(props)
            }
          }
        }
      }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">12</span> <span class="hljs-comment">/* TEXT_CALL */</span>) {
      <span class="hljs-comment">// 文本节点也可以静态提升</span>
      <span class="hljs-keyword">const</span> staticType = getStaticType(child.content, resultCache)
      <span class="hljs-keyword">if</span> (staticType &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (staticType === <span class="hljs-number">2</span> <span class="hljs-comment">/* HAS_RUNTIME_CONSTANT */</span>) {
          hasRuntimeConstant = <span class="hljs-keyword">true</span>
        }
        child.codegenNode = context.hoist(child.codegenNode)
        hasHoistedNode = <span class="hljs-keyword">true</span>
      }
    }
    <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">1</span> <span class="hljs-comment">/* ELEMENT */</span>) {
      <span class="hljs-comment">// 递归遍历子节点</span>
      walk(child, context, resultCache)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">11</span> <span class="hljs-comment">/* FOR */</span>) {
      walk(child, context, resultCache, child.children.length === <span class="hljs-number">1</span>)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.type === <span class="hljs-number">9</span> <span class="hljs-comment">/* IF */</span>) {
      <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; child.branches.length; i++) {
        walk(child.branches[i], context, resultCache, child.branches[i].children.length === <span class="hljs-number">1</span>)
      }
    }
  }
  <span class="hljs-keyword">if</span> (!hasRuntimeConstant &amp;&amp; hasHoistedNode &amp;&amp; context.transformHoist) {
    <span class="hljs-comment">// 如果编译配置了 transformHoist，则执行</span>
    context.transformHoist(children, context, node)
  }
}
</code></pre>

<p data-nodeid="23789">可以看到，hoistStatic 主要就是从根节点开始，通过递归的方式去遍历节点，只有普通元素和文本节点才能被静态提升，所以针对这些节点，这里通过 getStaticType 去获取静态类型，如果节点是一个元素类型，getStaticType 内部还会递归判断它的子节点的静态类型。</p>
<p data-nodeid="23790">虽然有的节点包含一些动态子节点，但它本身的静态属性还是可以被静态提升的。</p>
<p data-nodeid="23791">注意，<strong data-nodeid="23912">如果 getStaticType 返回的 staticType 的值是 2</strong>，<strong data-nodeid="23913">则表明它是一个运行时常量</strong>，<strong data-nodeid="23914">由于它的值在运行时才能被确定</strong>，<strong data-nodeid="23915">所以是不能静态提升的</strong>。</p>
<p data-nodeid="23792">如果节点满足可以被静态提升的条件，节点对应的 codegenNode 会通过执行 context.hoist 修改为一个简单表达式节点：</p>
<pre class="lang-java" data-nodeid="37843"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">hoist</span><span class="hljs-params">(exp)</span> </span>{
  context.hoists.push(exp);
  <span class="hljs-keyword">const</span> identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, <span class="hljs-keyword">false</span>, exp.loc, <span class="hljs-keyword">true</span>)
  identifier.hoisted = exp
  <span class="hljs-keyword">return</span> identifier
}
child.codegenNode = context.hoist(child.codegenNode)
</code></pre>

<p data-nodeid="23794">改动后的 codegenNode 会在生成代码阶段帮助我们生成静态提升的相关代码。</p>
<h3 data-nodeid="23795">createRootCodegen</h3>
<p data-nodeid="23796">完成静态提升后，我们来到了 AST 转换的最后一步，即<strong data-nodeid="23924">创建根节点的代码生成节点</strong>。我们先来看一下 createRootCodegen 的实现：</p>
<pre class="lang-java" data-nodeid="38306"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createRootCodegen</span><span class="hljs-params">(root, context)</span> </span>{
  <span class="hljs-keyword">const</span> { helper } = context;
  <span class="hljs-keyword">const</span> { children } = root;
  <span class="hljs-keyword">const</span> child = children[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">if</span> (children.length === <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果子节点是单个元素节点，则将其转换成一个 block</span>
    <span class="hljs-keyword">if</span> (isSingleElementRoot(root, child) &amp;&amp; child.codegenNode) {
      <span class="hljs-keyword">const</span> codegenNode = child.codegenNode;
      <span class="hljs-keyword">if</span> (codegenNode.type === <span class="hljs-number">13</span> <span class="hljs-comment">/* VNODE_CALL */</span>) {
        codegenNode.isBlock = <span class="hljs-keyword">true</span>;
        helper(OPEN_BLOCK);
        helper(CREATE_BLOCK);
      }
      root.codegenNode = codegenNode;
    }
    <span class="hljs-keyword">else</span> {
      root.codegenNode = child;
    }
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (children.length &gt; <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// 如果子节点是多个节点，则返回一个 fragement 的代码生成节点</span>
    root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, `${<span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>} <span class="hljs-comment">/* ${PatchFlagNames[64 /* STABLE_FRAGMENT */</span>]} */`, undefined, undefined, <span class="hljs-keyword">true</span>);
  }
}
</code></pre>

<p data-nodeid="23798">createRootCodegen 做的事情很简单，就是为 root 这个虚拟的 AST 根节点创建一个代码生成节点，如果 root 的子节点 children 是单个元素节点，则将其转换成一个 Block，把这个 child 的 codegenNode 赋值给 root 的 codegenNode。</p>
<p data-nodeid="39721" class="">如果 root 的子节点 children 是多个节点，则返回一个 fragement 的代码生成节点，并赋值给 root 的 codegenNode。</p>
<p data-nodeid="39722">这里，创建 codegenNode 就是为了后续生成代码时使用。</p>
<p data-nodeid="39723">createRootCodegen 完成之后，接着把 transform 上下文在转换 AST 节点过程中创建的一些变量赋值给 root 节点对应的属性，在这里可以看一下这些属性：</p>
<pre class="lang-yaml" data-nodeid="50376"><code data-language="yaml"><span class="hljs-string">root.helpers</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.helpers</span>]
<span class="hljs-string">root.components</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.components</span>]
<span class="hljs-string">root.directives</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.directives</span>]
<span class="hljs-string">root.imports</span> <span class="hljs-string">=</span> [<span class="hljs-string">...context.imports</span>]
<span class="hljs-string">root.hoists</span> <span class="hljs-string">=</span> <span class="hljs-string">context.hoists</span>
<span class="hljs-string">root.temps</span> <span class="hljs-string">=</span> <span class="hljs-string">context.temps</span>
<span class="hljs-string">root.cached</span> <span class="hljs-string">=</span> <span class="hljs-string">context.cached</span>
</code></pre>
























<pre data-nodeid="39233"><code></code></pre>





<p data-nodeid="23803">这样后续在代码生成节点时，就可以通过 root 这个根节点访问到这些变量了。</p>
<h3 data-nodeid="23804">总结</h3>
<p data-nodeid="23805">好的，到这里我们这一节的学习就结束啦，通过这节课的学习，你应该对 AST 节点内部做了哪些转换有所了解。</p>
<p data-nodeid="23806">如果说 parse 阶段是一个词法分析过程，构造基础的 AST 节点对象，那么 transform 节点就是语法分析阶段，把 AST 节点做一层转换，构造出语义化更强，信息更加丰富的 codegenCode，它在后续的代码生成阶段起着非常重要的作用。</p>
<p data-nodeid="23807">最后，给你留一道思考题目，我们已经知道静态提升的好处是，针对静态节点不用每次在 render 阶段都执行一次 createVNode 创建 vnode 对象，但它有没有成本呢？为什么？欢迎你在留言区与我分享。</p>
<blockquote data-nodeid="23808">
<p data-nodeid="23809">本节课的相关代码在源代码中的位置如下：<br>
packages/compiler-core/src/ast.ts<br>
packages/compiler-core/src/transform.ts<br>
packages/compiler-core/src/transforms/transformText.ts<br>
packages/compiler-core/src/transforms/vIf.ts<br>
packages/compiler-core/src/transforms/hoistStatic.ts</p>
</blockquote>

---

### 精选评论

##### **分：
> 空间(内存)换时间(性能)

##### *策：
> 会出现大量的dom节点出现在在内存中，但是没有在页面上的情况，占用缓存，而且编译变慢了

