<p data-nodeid="208752" class="">Vue.js 3.0 允许我们在编写组件的时候添加一个 setup 启动函数，它是 Composition API 逻辑组织的入口，本节课我们就来分析一下这个函数。</p>
<p data-nodeid="208753">我们先通过一段代码认识它，在这里编写一个 button 组件：</p>
<pre class="lang-js" data-nodeid="208754"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>
    Count is: {{ state.count }}, double is: {{ state.double }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> { reactive, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  setup() {
    <span class="hljs-keyword">const</span> state = reactive({
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">double</span>: computed(<span class="hljs-function">() =&gt;</span> state.count * <span class="hljs-number">2</span>)
    })
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>{
      state.count++
    }
    <span class="hljs-keyword">return</span> {
      state,
      increment
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208755">可以看到，这段代码和 Vue.js 2.x 组件的写法相比，多了一个 setup 启动函数，另外组件中也没有定义 props、data、computed 这些 options。</p>
<p data-nodeid="208756">在 setup 函数内部，定义了一个响应式对象 state，它是通过 reactive API 创建的。state 对象有 count 和 double 两个属性，其中 count 对应一个数字属性的值；而double 通过 computed API 创建，对应一个计算属性的值。reactive API 和 computed API 不是我们关注的重点，在后续响应式章节我会详细介绍。</p>
<p data-nodeid="208757">这里需要注意的是，<strong data-nodeid="208881">模板中引用到的变量 state 和 increment 包含在 setup 函数的返回对象中，那么它们是如何建立联系的呢？</strong></p>
<p data-nodeid="208758">我们先来回想一下 Vue.js 2.x 编写组件的时候，会在 props、data、methods、computed 等 options 中定义一些变量。在组件初始化阶段，Vue.js 内部会处理这些 options，即把定义的变量添加到了组件实例上。等模板编译成 render 函数的时候，内部通过 with(this){} 的语法去访问在组件实例中的变量。</p>
<p data-nodeid="208759">那么到了 Vue.js 3.0，既支持组件定义 setup 函数，而且在模板 render 的时候，又可以访问到 setup 函数返回的值，这是如何实现的？我们来一探究竟。</p>
<h3 data-nodeid="208760">创建和设置组件实例</h3>
<p data-nodeid="208761">首先，我们来回顾一下组件的渲染流程：创建 vnode 、渲染 vnode 和生成 DOM。</p>
<p data-nodeid="208762"><img src="https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZpKAVYWOAABLt08AfuQ883.png" alt="4.png" data-nodeid="208888"></p>
<p data-nodeid="208763">其中渲染 vnode 的过程主要就是在挂载组件：</p>
<pre class="lang-java" data-nodeid="208764"><code data-language="java"><span class="hljs-keyword">const</span> mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; {
  <span class="hljs-comment">// 创建组件实例</span>
  <span class="hljs-keyword">const</span> instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))
  <span class="hljs-comment">// 设置组件实例</span>
  setupComponent(instance)
  <span class="hljs-comment">// 设置并运行带副作用的渲染函数</span>
  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)
}
</code></pre>
<p data-nodeid="208765">可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。前两个流程就跟我们今天提到的问题息息相关，所以这一节课我们将重点分析它们。</p>
<p data-nodeid="208766">先看<strong data-nodeid="208896">创建组件实例</strong>的流程，我们要关注 createComponentInstance 方法的实现：</p>
<pre class="lang-java" data-nodeid="208767"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">createComponentInstance</span> <span class="hljs-params">(vnode, parent, suspense)</span> </span>{
  <span class="hljs-comment">// 继承父组件实例上的 appContext，如果是根组件，则直接从根 vnode 中取。</span>
  <span class="hljs-keyword">const</span> appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  <span class="hljs-keyword">const</span> instance = {
    <span class="hljs-comment">// 组件唯一 id</span>
    uid: uid++,
    <span class="hljs-comment">// 组件 vnode</span>
    vnode,
    <span class="hljs-comment">// 父组件实例</span>
    parent,
    <span class="hljs-comment">// app 上下文</span>
    appContext,
    <span class="hljs-comment">// vnode 节点类型</span>
    type: vnode.type,
    <span class="hljs-comment">// 根组件实例</span>
    root: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 新的组件 vnode</span>
    next: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 子节点 vnode</span>
    subTree: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 带副作用更新函数</span>
    update: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 渲染函数</span>
    render: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 渲染上下文代理</span>
    proxy: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 带有 with 区块的渲染上下文代理</span>
    withProxy: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 响应式相关对象</span>
    effects: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 依赖注入相关</span>
    provides: parent ? parent.provides : Object.create(appContext.provides),
    <span class="hljs-comment">// 渲染代理的属性访问缓存</span>
    accessCache: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 渲染缓存</span>
    renderCache: [],
    <span class="hljs-comment">// 渲染上下文</span>
    ctx: EMPTY_OBJ,
    <span class="hljs-comment">// data 数据</span>
    data: EMPTY_OBJ,
    <span class="hljs-comment">// props 数据</span>
    props: EMPTY_OBJ,
    <span class="hljs-comment">// 普通属性</span>
    attrs: EMPTY_OBJ,
    <span class="hljs-comment">// 插槽相关</span>
    slots: EMPTY_OBJ,
    <span class="hljs-comment">// 组件或者 DOM 的 ref 引用</span>
    refs: EMPTY_OBJ,
    <span class="hljs-comment">// setup 函数返回的响应式结果</span>
    setupState: EMPTY_OBJ,
    <span class="hljs-comment">// setup 函数上下文数据</span>
    setupContext: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 注册的组件</span>
    components: Object.create(appContext.components),
    <span class="hljs-comment">// 注册的指令</span>
    directives: Object.create(appContext.directives),
    <span class="hljs-comment">// suspense 相关</span>
    suspense,
    <span class="hljs-comment">// suspense 异步依赖</span>
    asyncDep: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// suspense 异步依赖是否都已处理</span>
    asyncResolved: <span class="hljs-keyword">false</span>,
    <span class="hljs-comment">// 是否挂载</span>
    isMounted: <span class="hljs-keyword">false</span>,
    <span class="hljs-comment">// 是否卸载</span>
    isUnmounted: <span class="hljs-keyword">false</span>,
    <span class="hljs-comment">// 是否激活</span>
    isDeactivated: <span class="hljs-keyword">false</span>,
    <span class="hljs-comment">// 生命周期，before create</span>
    bc: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，created</span>
    c: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，before mount</span>
    bm: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，mounted</span>
    m: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，before update</span>
    bu: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，updated</span>
    u: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，unmounted</span>
    um: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期，before unmount</span>
    bum: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期, deactivated</span>
    da: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期 activated</span>
    a: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期 render triggered</span>
    rtg: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期 render tracked</span>
    rtc: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 生命周期 error captured</span>
    ec: <span class="hljs-keyword">null</span>,
    <span class="hljs-comment">// 派发事件方法</span>
    emit: <span class="hljs-keyword">null</span>
  }
  <span class="hljs-comment">// 初始化渲染上下文</span>
  instance.ctx = { _: instance }
  <span class="hljs-comment">// 初始化根组件指针</span>
  instance.root = parent ? parent.root : instance
  <span class="hljs-comment">// 初始化派发事件方法</span>
  instance.emit = emit.bind(<span class="hljs-keyword">null</span>, instance)
  <span class="hljs-keyword">return</span> instance
}
</code></pre>
<p data-nodeid="208768">从上述代码中可以看到，组件实例 instance 上定义了很多属性，你千万不要被这茫茫多的属性吓到，因为其中一些属性是为了实现某个场景或者某个功能所定义的，你只需要通过我在代码中的注释大概知道它们是做什么的即可。</p>
<p data-nodeid="208769">Vue.js 2.x 使用 new Vue 来初始化一个组件的实例，到了 Vue.js 3.0，我们直接通过创建对象去创建组件的实例。这两种方式并无本质的区别，都是引用一个对象，在整个组件的生命周期中去维护组件的状态数据和上下文环境。</p>
<p data-nodeid="208770">创建好 instance 实例后，接下来就是设置它的一些属性。目前已完成了组件的上下文、根组件指针以及派发事件方法的设置。我们在后面会继续分析更多 instance 实例属性的设置逻辑。</p>
<p data-nodeid="208771">接着是<strong data-nodeid="208905">组件实例的设置流程</strong>，对 setup 函数的处理就在这里完成，我们来看一下 setupComponent 方法的实现：</p>
<pre class="lang-java" data-nodeid="208772"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">setupComponent</span> <span class="hljs-params">(instance, isSSR = <span class="hljs-keyword">false</span>)</span> </span>{
  <span class="hljs-keyword">const</span> { props, children, shapeFlag } = instance.vnode
  <span class="hljs-comment">// 判断是否是一个有状态的组件</span>
  <span class="hljs-keyword">const</span> isStateful = shapeFlag &amp; <span class="hljs-number">4</span>
  <span class="hljs-comment">// 初始化 props</span>
  initProps(instance, props, isStateful, isSSR)
  <span class="hljs-comment">// 初始化 插槽</span>
  initSlots(instance, children)
  <span class="hljs-comment">// 设置有状态的组件实例</span>
  <span class="hljs-keyword">const</span> setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined
  <span class="hljs-keyword">return</span> setupResult
}
</code></pre>
<p data-nodeid="208773">可以看到，我们从组件 vnode 中获取了 props、children、shapeFlag 等属性，然后分别对 props 和插槽进行初始化，这两部分逻辑在后续的章节再详细分析。根据 shapeFlag 的值，我们可以判断这是不是一个有状态组件，如果是则要进一步去设置有状态组件的实例。</p>
<p data-nodeid="208774">接下来我们要关注到 setupStatefulComponent 函数，它主要做了三件事：创建渲染上下文代理、判断处理 setup 函数和完成组件实例设置。它代码如下所示：</p>
<pre class="lang-java" data-nodeid="208775"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">setupStatefulComponent</span> <span class="hljs-params">(instance, isSSR)</span> </span>{
  <span class="hljs-keyword">const</span> Component = instance.type
  <span class="hljs-comment">// 创建渲染代理的属性访问缓存</span>
  instance.accessCache = {}
  <span class="hljs-comment">// 创建渲染上下文代理</span>
  instance.proxy = <span class="hljs-keyword">new</span> Proxy(instance.ctx, PublicInstanceProxyHandlers)
  <span class="hljs-comment">// 判断处理 setup 函数</span>
  <span class="hljs-keyword">const</span> { setup } = <span class="hljs-function">Component
  <span class="hljs-title">if</span> <span class="hljs-params">(setup)</span> </span>{
    <span class="hljs-comment">// 如果 setup 函数带参数，则创建一个 setupContext</span>
    <span class="hljs-keyword">const</span> setupContext = (instance.setupContext =
      setup.length &gt; <span class="hljs-number">1</span> ? createSetupContext(instance) : <span class="hljs-keyword">null</span>)
    <span class="hljs-comment">// 执行 setup 函数，获取结果</span>
    <span class="hljs-keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="hljs-number">0</span> <span class="hljs-comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])
    <span class="hljs-comment">// 处理 setup 执行结果</span>
    handleSetupResult(instance, setupResult)
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 完成组件实例设置</span>
    finishComponentSetup(instance)
  }
}
</code></pre>
<h3 data-nodeid="208776">创建渲染上下文代理</h3>
<p data-nodeid="208777">首先是创建渲染上下文代理的流程，它主要对 instance.ctx 做了代理。在分析实现前，我们需要思考一个问题，这里为什么需要代理呢？</p>
<p data-nodeid="208778">其实在 Vue.js 2.x 中，也有类似的数据代理逻辑，比如 props 求值后的数据，实际上存储在 this._props 上，而 data 中定义的数据存储在 this._data 上。举个例子：</p>
<pre class="lang-js" data-nodeid="208779"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  data() {
    <span class="hljs-attr">msg</span>: <span class="hljs-number">1</span>
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208780">在初始化组件的时候，data 中定义的 msg 在组件内部是存储在 this._data 上的，而模板渲染的时候访问 this.msg，实际上访问的是 this._data.msg，这是因为 Vue.js 2.x 在初始化 data 的时候，做了一层 proxy 代理。</p>
<p data-nodeid="208781">到了 Vue.js 3.0，为了方便维护，我们把组件中不同状态的数据存储到不同的属性中，比如存储到 setupState、ctx、data、props 中。我们在执行组件渲染函数的时候，为了方便用户使用，会直接访问渲染上下文 instance.ctx 中的属性，所以我们也要做一层 proxy，对渲染上下文 instance.ctx 属性的访问和修改，代理到对 setupState、ctx、data、props 中的数据的访问和修改。</p>
<p data-nodeid="208782">明确了代理的需求后，我们接下来就要分析 proxy 的几个方法： get、set 和 has。</p>
<p data-nodeid="208783">当我们<strong data-nodeid="208931">访问 instance.ctx 渲染上下文中的属性</strong>时，就会<strong data-nodeid="208932">进入 get 函数</strong>。我们来看一下它的实现：</p>
<pre class="lang-java" data-nodeid="208784"><code data-language="java"><span class="hljs-keyword">const</span> PublicInstanceProxyHandlers = {
  get ({ _: instance }, key) {
    <span class="hljs-keyword">const</span> { ctx, setupState, data, props, accessCache, type, appContext } = <span class="hljs-function">instance
    <span class="hljs-title">if</span> <span class="hljs-params">(key[<span class="hljs-number">0</span>] !== <span class="hljs-string">'$'</span>)</span> </span>{
      <span class="hljs-comment">// setupState / data / props / ctx</span>
      <span class="hljs-comment">// 渲染代理的属性访问缓存中</span>
      <span class="hljs-keyword">const</span> n = accessCache[key]
      <span class="hljs-keyword">if</span> (n !== undefined) {
        <span class="hljs-comment">// 从缓存中取</span>
        <span class="hljs-keyword">switch</span> (n) {
          <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">/* SETUP */</span>
            <span class="hljs-keyword">return</span> setupState[key]
          <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> :<span class="hljs-comment">/* DATA */</span>
            <span class="hljs-keyword">return</span> data[key]
          <span class="hljs-keyword">case</span> <span class="hljs-number">3</span> :<span class="hljs-comment">/* CONTEXT */</span>
            <span class="hljs-keyword">return</span> ctx[key]
          <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">/* PROPS */</span>
            <span class="hljs-keyword">return</span> props[key]
        }
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) {
        accessCache[key] = <span class="hljs-number">0</span>
        <span class="hljs-comment">// 从 setupState 中取数据</span>
        <span class="hljs-keyword">return</span> setupState[key]
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {
        accessCache[key] = <span class="hljs-number">1</span>
        <span class="hljs-comment">// 从 data 中取数据</span>
        <span class="hljs-keyword">return</span> data[key]
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
        type.props &amp;&amp;
        hasOwn(normalizePropsOptions(type.props)[<span class="hljs-number">0</span>], key)) {
        accessCache[key] = <span class="hljs-number">2</span>
        <span class="hljs-comment">// 从 props 中取数据</span>
        <span class="hljs-keyword">return</span> props[key]
      }
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {
        accessCache[key] = <span class="hljs-number">3</span>
        <span class="hljs-comment">// 从 ctx 中取数据</span>
        <span class="hljs-keyword">return</span> ctx[key]
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 都取不到</span>
        accessCache[key] = <span class="hljs-number">4</span>
      }
    }
    <span class="hljs-keyword">const</span> publicGetter = publicPropertiesMap[key]
    let cssModule, globalProperties
    <span class="hljs-comment">// 公开的 $xxx 属性或方法</span>
    <span class="hljs-keyword">if</span> (publicGetter) {
      <span class="hljs-keyword">return</span> publicGetter(instance)
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      <span class="hljs-comment">// css 模块，通过 vue-loader 编译的时候注入</span>
      (cssModule = type.__cssModules) &amp;&amp;
      (cssModule = cssModule[key])) {
      <span class="hljs-keyword">return</span> cssModule
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) {
      <span class="hljs-comment">// 用户自定义的属性，也用 `$` 开头</span>
      accessCache[key] = <span class="hljs-number">3</span>
      <span class="hljs-keyword">return</span> ctx[key]
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
      <span class="hljs-comment">// 全局定义的属性</span>
      ((globalProperties = appContext.config.globalProperties),
        hasOwn(globalProperties, key))) {
      <span class="hljs-keyword">return</span> globalProperties[key]
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &amp;&amp;
      currentRenderingInstance &amp;&amp; key.indexOf(<span class="hljs-string">'__v'</span>) !== <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; key[<span class="hljs-number">0</span>] === <span class="hljs-string">'$'</span> &amp;&amp; hasOwn(data, key)) {
        <span class="hljs-comment">// 如果在 data 中定义的数据以 $ 开头，会报警告，因为 $ 是保留字符，不会做代理</span>
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved ` +
          `character and is not proxied on the render context.`)
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 在模板中使用的变量如果没有定义，报警告</span>
        warn(`Property ${JSON.stringify(key)} was accessed during render ` +
          `but is not defined on instance.`)
      }
    }
  }
}
</code></pre>
<p data-nodeid="208785">可以看到，函数首先判断 key 不以 $ 开头的情况，这部分数据可能是 setupState、data、props、ctx 中的一种，其中 data、props 我们已经很熟悉了；setupState 就是 setup 函数返回的数据，稍后我们会详细说；ctx 包括了计算属性、组件方法和用户自定义的一些数据。</p>
<p data-nodeid="208786">如果 key 不以 $ 开头，那么就依次判断 setupState、data、props、ctx 中是否包含这个 key，如果包含就返回对应值。<strong data-nodeid="208943">注意这个判断顺序很重要</strong>，<strong data-nodeid="208944">在 key 相同时它会决定数据获取的优先级</strong>，举个例子：</p>
<pre class="lang-js" data-nodeid="208787"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{msg}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    data() {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">'msg from data'</span>
      }
    },
    setup() {
      <span class="hljs-keyword">const</span> msg = ref(<span class="hljs-string">'msg from setup'</span>)
      <span class="hljs-keyword">return</span> {
        msg
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208788">我们在 data 和 setup 中都定义了 msg 变量，但最终输出到界面上的是"msg from setup"，这是因为 setupState 的判断优先级要高于 data。</p>
<p data-nodeid="208789">再回到 get 函数中，我们可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存，它具体是干什么的呢？组件在渲染时会经常访问数据进而触发 get 函数，这其中最昂贵的部分就是多次调用 hasOwn 去判断 key 在不在某个类型的数据中，但是在普通对象上执行简单的属性访问相对要快得多。所以在第一次获取 key 对应的数据后，我们利用 accessCache[key] 去缓存数据，下一次再次根据 key 查找数据，我们就可以直接通过 accessCache[key] 获取对应的值，就不需要依次调用 hasOwn 去判断了。这也是一个性能优化的小技巧。</p>
<p data-nodeid="208790">如果 key 以 $ 开头，那么接下来又会有一系列的判断，首先判断是不是 Vue.js 内部公开的 $xxx 属性或方法（比如 $parent）；然后判断是不是 vue-loader 编译注入的 css 模块内部的 key；接着判断是不是用户自定义以 $ 开头的 key；最后判断是不是全局属性。如果都不满足，就剩两种情况了，即在非生产环境下就会报两种类型的警告，第一种是在 data 中定义的数据以 $ 开头的警告，因为 $ 是保留字符，不会做代理；第二种是在模板中使用的变量没有定义的警告。</p>
<p data-nodeid="208791">接下来是 set 代理过程，当我们<strong data-nodeid="208969">修改 instance.ctx 渲染上下文中的属性</strong>的时候，就会<strong data-nodeid="208970">进入 set 函数</strong>。我们来看一下 set 函数的实现：</p>
<pre class="lang-java" data-nodeid="208792"><code data-language="java"><span class="hljs-keyword">const</span> PublicInstanceProxyHandlers = {
  set ({ _: instance }, key, value) {
    <span class="hljs-keyword">const</span> { data, setupState, ctx } = <span class="hljs-function">instance
    <span class="hljs-title">if</span> <span class="hljs-params">(setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)</span>) </span>{
      <span class="hljs-comment">// 给 setupState 赋值</span>
      setupState[key] = value
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) {
      <span class="hljs-comment">// 给 data 赋值</span>
      data[key] = value
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key in instance.props) {
      <span class="hljs-comment">// 不能直接给 props 赋值</span>
      (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &amp;&amp;
      warn(`Attempting to mutate prop <span class="hljs-string">"${key}"</span>. Props are readonly.`, instance)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">if</span> (key[<span class="hljs-number">0</span>] === <span class="hljs-string">'$'</span> &amp;&amp; key.slice(<span class="hljs-number">1</span>) in instance) {
      <span class="hljs-comment">// 不能给 Vue 内部以 $ 开头的保留属性赋值</span>
      (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &amp;&amp;
      warn(`Attempting to mutate <span class="hljs-keyword">public</span> property <span class="hljs-string">"${key}"</span>. ` +
        `Properties starting with $ are reserved and readonly.`, instance)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 用户自定义数据赋值</span>
      ctx[key] = value
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>
  }
}
</code></pre>
<p data-nodeid="208793">结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。</p>
<p data-nodeid="208794">我们对之前的例子做点修改，添加一个方法：</p>
<pre class="lang-js" data-nodeid="208795"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"random"</span>&gt;</span>Random msg<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    data() {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">msg</span>: <span class="hljs-string">'msg from data'</span>
      }
    },
    setup() {
      <span class="hljs-keyword">const</span> msg = ref(<span class="hljs-string">'msg from setup'</span>)
      <span class="hljs-keyword">return</span> {
        msg
      }
    },
    <span class="hljs-attr">methods</span>: {
      random() {
        <span class="hljs-built_in">this</span>.msg = <span class="hljs-built_in">Math</span>.random()
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208796">我们点击按钮会执行 random 函数，这里的 this 指向的就是 instance.ctx，我们修改 this.msg 会触发 set 函数，所以最终修改的是 setupState 中的 msg 对应的值。</p>
<p data-nodeid="208797">注意，如果我们直接对 props 中的数据赋值，在非生产环境中会收到一条警告，这是因为直接修改 props 不符合数据单向流动的设计思想；如果对 Vue.js 内部以 $ 开头的保留属性赋值，同样也会收到一条警告。</p>
<p data-nodeid="208798">如果是用户自定义的数据，比如在 created 生命周期内定义的数据，它仅用于组件上下文的共享，如下所示：</p>
<pre class="lang-java" data-nodeid="208799"><code data-language="java">export <span class="hljs-keyword">default</span> {
  created() {
    <span class="hljs-keyword">this</span>.userMsg = <span class="hljs-string">'msg from user'</span>
  }
}
</code></pre>
<p data-nodeid="208800">当执行 this.userMsg 赋值的时候，会触发 set 函数，最终 userMsg 会被保留到 ctx 中。</p>
<p data-nodeid="208801">最后是 has 代理过程，当我们<strong data-nodeid="208990">判断属性是否存在于 instance.ctx 渲染上下文中</strong>时，就<strong data-nodeid="208991">会进入 has 函数</strong>，这个在平时项目中用的比较少，同样来举个例子，当执行 created 钩子函数中的 'msg' in this 时，就会触发 has 函数。</p>
<pre class="lang-java" data-nodeid="208802"><code data-language="java">export <span class="hljs-keyword">default</span> {
  created () {
    console.log(<span class="hljs-string">'msg'</span> in <span class="hljs-keyword">this</span>)
  }
}
</code></pre>
<p data-nodeid="208803">下面我们来看一下 has 函数的实现：</p>
<pre class="lang-java" data-nodeid="208804"><code data-language="java"><span class="hljs-keyword">const</span> PublicInstanceProxyHandlers = {
  has
    ({ _: { data, setupState, accessCache, ctx, type, appContext } }, key) {
    <span class="hljs-comment">// 依次判断</span>
    <span class="hljs-keyword">return</span> (accessCache[key] !== undefined ||
      (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) ||
      (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) ||
      (type.props &amp;&amp; hasOwn(normalizePropsOptions(type.props)[<span class="hljs-number">0</span>], key)) ||
      hasOwn(ctx, key) ||
      hasOwn(publicPropertiesMap, key) ||
      hasOwn(appContext.config.globalProperties, key))
  }
}
</code></pre>
<p data-nodeid="208805">这个函数的实现很简单，依次判断 key 是否存在于 accessCache、data、setupState、props 、用户数据、公开属性以及全局属性中，然后返回结果。</p>
<p data-nodeid="208806">至此，我们就搞清楚了创建上下文代理的过程，让我们回到 setupStatefulComponent 函数中，接下来分析第二个流程——判断处理 setup 函数。</p>
<h3 data-nodeid="208807">判断处理 setup 函数</h3>
<p data-nodeid="208808">我们看一下整个逻辑涉及的代码：</p>
<pre class="lang-java" data-nodeid="208809"><code data-language="java"><span class="hljs-comment">// 判断处理 setup 函数</span>
<span class="hljs-keyword">const</span> { setup } = <span class="hljs-function">Component
<span class="hljs-title">if</span> <span class="hljs-params">(setup)</span> </span>{
  <span class="hljs-comment">// 如果 setup 函数带参数，则创建一个 setupContext</span>
  <span class="hljs-keyword">const</span> setupContext = (instance.setupContext =
    setup.length &gt; <span class="hljs-number">1</span> ? createSetupContext(instance) : <span class="hljs-keyword">null</span>)
  <span class="hljs-comment">// 执行 setup 函数获取结果</span>
  <span class="hljs-keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="hljs-number">0</span> <span class="hljs-comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])
  <span class="hljs-comment">// 处理 setup 执行结果</span>
  handleSetupResult(instance, setupResult)
}
</code></pre>
<p data-nodeid="208810">如果我们在组件中定义了 setup 函数，接下来就是处理 setup 函数的流程，主要是三个步骤：创建 setup 函数上下文、执行 setup 函数并获取结果和处理 setup 函数的执行结果。接下来我们就逐个来分析。</p>
<p data-nodeid="208811">首先<strong data-nodeid="209011">判断 setup 函数的参数长度</strong>，<strong data-nodeid="209012">如果大于 1</strong>，<strong data-nodeid="209013">则创建 setupContext 上下文</strong>。</p>
<pre class="lang-java" data-nodeid="208812"><code data-language="java"><span class="hljs-keyword">const</span> setupContext = (instance.setupContext =
    setup.length &gt; <span class="hljs-number">1</span> ? createSetupContext(instance) : <span class="hljs-keyword">null</span>)
</code></pre>
<p data-nodeid="208813">举个例子，我们有个 HelloWorld 子组件，如下：</p>
<pre class="lang-js" data-nodeid="208814"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ msg }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"onClick"</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">msg</span>: <span class="hljs-built_in">String</span>
    },
    setup (props, { emit }) {
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span> (<span class="hljs-params"></span>) </span>{
        emit(<span class="hljs-string">'toggle'</span>)
      }
      <span class="hljs-keyword">return</span> {
        onClick
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208815">我们在父组件引用这个组件：</p>
<pre class="lang-js" data-nodeid="208816"><code data-language="js">&lt;template&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> @<span class="hljs-attr">toggle</span>=<span class="hljs-string">"toggle"</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">HelloWorld</span>&gt;</span></span>
&lt;/template&gt;
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">import</span> HelloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/HelloWorld"</span>;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">components</span>: { HelloWorld },
    setup () {
      <span class="hljs-keyword">const</span> msg = ref(<span class="hljs-string">'Hello World'</span>)
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggle</span> (<span class="hljs-params"></span>) </span>{
        msg.value = msg.value === <span class="hljs-string">'Hello World'</span> ? <span class="hljs-string">'Hello Vue'</span> : <span class="hljs-string">'Hello World'</span>
      }
      <span class="hljs-keyword">return</span> {
        toggle,
        msg
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p data-nodeid="208817">可以看到，HelloWorld 子组件的 setup 函数接收两个参数，第一个参数 props 对应父组件传入的 props 数据，第二个参数 emit 是一个对象，实际上就是 setupContext。</p>
<p data-nodeid="208818">下面我们来看一下用 createSetupContext 函数来创建 setupContext：</p>
<pre class="lang-plain" data-nodeid="208819"><code data-language="plain">function createSetupContext (instance) {
  return {
    attrs: instance.attrs,
    slots: instance.slots,
    emit: instance.emit
  }
}
</code></pre>
<p data-nodeid="208820">这里返回了一个对象，包括 attrs、slots 和 emit 三个属性。setupContext 让我们在 setup 函数内部可以获取到组件的属性、插槽以及派发事件的方法 emit。</p>
<p data-nodeid="208821">可以预见的是，这个 setupContext 对应的就是 setup 函数第二个参数，我们接下来看一下 setup 函数具体是如何执行的。</p>
<p data-nodeid="208822">我们通过下面这行代码来<strong data-nodeid="209025">执行 setup 函数并获取结果</strong>：</p>
<pre class="lang-java" data-nodeid="208823"><code data-language="java"><span class="hljs-keyword">const</span> setupResult = callWithErrorHandling(setup, instance, <span class="hljs-number">0</span> <span class="hljs-comment">/* SETUP_FUNCTION */</span>, [instance.props, setupContext])
</code></pre>
<p data-nodeid="208824">我们具体来看一下 callWithErrorHandling 函数的实现：</p>
<pre class="lang-java" data-nodeid="208825"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">callWithErrorHandling</span> <span class="hljs-params">(fn, instance, type, args)</span> </span>{
  let res
  <span class="hljs-keyword">try</span> {
    res = args ? fn(...args) : fn()
  }
  <span class="hljs-keyword">catch</span> (err) {
    handleError(err, instance, type)
  }
  <span class="hljs-keyword">return</span> res
}
</code></pre>
<p data-nodeid="208826">可以看到，它其实就是对 fn 做的一层包装，内部还是执行了 fn，并在有参数的时候传入参数，所以 setup 的第一个参数是 instance.props，第二个参数是 setupContext。函数执行过程中如果有 JavaScript 执行错误就会捕获错误，并执行 handleError 函数来处理。</p>
<p data-nodeid="208827">执行 setup 函数并拿到了返回的结果，那么接下来就要<strong data-nodeid="209033">用 handleSetupResult 函数来处理结果</strong>。</p>
<pre class="lang-java" data-nodeid="208828"><code data-language="java">handleSetupResult(instance, setupResult)
</code></pre>
<p data-nodeid="208829">我们详细看一下 handleSetupResult 函数的实现：</p>
<pre class="lang-java" data-nodeid="208830"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">handleSetupResult</span><span class="hljs-params">(instance, setupResult)</span> </span>{
  <span class="hljs-keyword">if</span> (isFunction(setupResult)) {
    <span class="hljs-comment">// setup 返回渲染函数</span>
    instance.render = setupResult
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(setupResult)) {
    <span class="hljs-comment">// 把 setup 返回结果变成响应式</span>
    instance.setupState = reactive(setupResult)
  }
  finishComponentSetup(instance)
}
</code></pre>
<p data-nodeid="208831">可以看到，当 setupResult 是一个对象的时候，我们把它变成了响应式并赋值给 instance.setupState，这样在模板渲染的时候，依据前面的代理规则，instance.ctx 就可以从 instance.setupState 上获取到对应的数据，这就在 setup 函数与模板渲染间建立了联系。</p>
<p data-nodeid="208832">另外 setup 不仅仅支持返回一个对象，也可以返回一个函数作为组件的渲染函数。我们可以改写前面的示例，来看一下这时的情况：</p>
<pre class="lang-js" data-nodeid="208833"><code data-language="js">&lt;script&gt;
  <span class="hljs-keyword">import</span> { h } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">props</span>: {
      <span class="hljs-attr">msg</span>: <span class="hljs-built_in">String</span>
    },
    setup (props, { emit }) {
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onClick</span> (<span class="hljs-params"></span>) </span>{
        emit(<span class="hljs-string">'toggle'</span>)
      }
      <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> [
          h(<span class="hljs-string">'p'</span>, <span class="hljs-literal">null</span>, ctx.msg),
          h(<span class="hljs-string">'button'</span>, { <span class="hljs-attr">onClick</span>: onClick }, <span class="hljs-string">'Toggle'</span>)
        ]
      }
    }
  }
&lt;/script&gt;
</code></pre>
<p data-nodeid="208834">这里，我们删除了 HelloWorld 子组件的 template 部分，并把 setup 函数的返回结果改成了函数，也就是说它会作为组件的渲染函数，一切运行正常。</p>
<p data-nodeid="208835">在 handleSetupResult 的最后，会执行 finishComponentSetup 函数完成组件实例的设置，其实这个函数和 setup 函数的执行结果已经没什么关系了，提取到外面放在 handleSetupResult 函数后面执行更合理一些。</p>
<p data-nodeid="208836">另外当组件没有定义的 setup 的时候，也会执行 finishComponentSetup 函数去完成组件实例的设置。</p>
<h3 data-nodeid="208837">完成组件实例设置</h3>
<p data-nodeid="208838">接下来我们来看一下 finishComponentSetup 函数的实现：</p>
<pre class="lang-java" data-nodeid="208839"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">finishComponentSetup</span> <span class="hljs-params">(instance)</span> </span>{
  <span class="hljs-keyword">const</span> Component = instance.type
  <span class="hljs-comment">// 对模板或者渲染函数的标准化</span>
  <span class="hljs-keyword">if</span> (!instance.render) {
    <span class="hljs-keyword">if</span> (compile &amp;&amp; Component.template &amp;&amp; !Component.render) {
      <span class="hljs-comment">// 运行时编译</span>
      Component.render = compile(Component.template, {
        isCustomElement: instance.appContext.config.isCustomElement || NO
      })
      Component.render._rc = <span class="hljs-keyword">true</span>
    }
    <span class="hljs-keyword">if</span> ((process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &amp;&amp; !Component.render) {
      <span class="hljs-keyword">if</span> (!compile &amp;&amp; Component.template) {
        <span class="hljs-comment">// 只编写了 template 但使用了 runtime-only 的版本</span>
        warn(`Component provided template option but ` +
          `runtime compilation is not supported in <span class="hljs-keyword">this</span> build of Vue.` +
          (` Configure your bundler to alias <span class="hljs-string">"vue"</span> to <span class="hljs-string">"vue/dist/vue.esm-bundler.js"</span>.`
          ) <span class="hljs-comment">/* should not happen */</span>)
      }
      <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 既没有写 render 函数，也没有写 template 模板</span>
        warn(`Component is missing template or render function.`)
      }
    }
    <span class="hljs-comment">// 组件对象的 render 函数赋值给 instance</span>
    instance.render = (Component.render || NOOP)
    <span class="hljs-keyword">if</span> (instance.render._rc) {
      <span class="hljs-comment">// 对于使用 with 块的运行时编译的渲染函数，使用新的渲染上下文的代理</span>
      instance.withProxy = <span class="hljs-keyword">new</span> Proxy(instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers)
    }
  }
  <span class="hljs-comment">// 兼容 Vue.js 2.x Options API</span>
  {
    currentInstance = <span class="hljs-function">instance
    <span class="hljs-title">applyOptions</span><span class="hljs-params">(instance, Component)</span>
    currentInstance </span>= <span class="hljs-keyword">null</span>
  }
}
</code></pre>
<p data-nodeid="208840">函数主要做了两件事情：<strong data-nodeid="209047">标准化模板或者渲染函数和兼容 Options API</strong>。接下来我们详细分析这两个流程。</p>
<h4 data-nodeid="208841">标准化模板或者渲染函数</h4>
<p data-nodeid="208842">在分析这个过程之前，我们需要了解一些背景知识。组件最终通过运行 render 函数生成子树 vnode，但是我们很少直接去编写 render 函数，通常会使用两种方式开发组件。</p>
<p data-nodeid="208843"><strong data-nodeid="209054">第一种是使用 SFC（Single File Components）单文件的开发方式来开发组件</strong>，即通过编写组件的 template 模板去描述一个组件的 DOM 结构。我们知道 .vue 类型的文件无法在 Web 端直接加载，因此在 webpack 的编译阶段，它会通过 vue-loader 编译生成组件相关的 JavaScript 和 CSS，并把 template 部分转换成 render 函数添加到组件对象的属性中。</p>
<p data-nodeid="208844"><strong data-nodeid="209063">另外一种开发方式</strong>是不借助 webpack 编译，<strong data-nodeid="209064">直接引入 Vue.js</strong>，开箱即用，我们直接在组件对象 template 属性中编写组件的模板，然后在运行阶段编译生成 render 函数，这种方式通常用于有一定历史包袱的古老项目。</p>
<p data-nodeid="208845">因此 Vue.js 在 Web 端有两个版本：runtime-only 和 runtime-compiled。我们更推荐用 runtime-only 版本的 Vue.js，因为相对而言它体积更小，而且在运行时不用编译，不仅耗时更少而且性能更优秀。遇到一些不得已的情况比如上述提到的古老项目，我们也可以选择 runtime-compiled 版本。</p>
<p data-nodeid="208846">runtime-only 和 runtime-compiled 的主要区别在于是否注册了这个 compile 方法。</p>
<p data-nodeid="208847">在 Vue.js 3.0 中，compile 方法是通过外部注册的：</p>
<pre class="lang-java" data-nodeid="208848"><code data-language="java">let compile;
<span class="hljs-function">function <span class="hljs-title">registerRuntimeCompiler</span><span class="hljs-params">(_compile)</span> </span>{
    compile = _compile;
}
</code></pre>
<p data-nodeid="208849">回到标准化模板或者渲染函数逻辑，我们先看 instance.render 是否存在，如果不存在则开始标准化流程，这里主要需要处理以下三种情况。</p>
<ol data-nodeid="208850">
<li data-nodeid="208851">
<p data-nodeid="208852"><strong data-nodeid="209077">compile 和组件 template 属性存在</strong>，<strong data-nodeid="209078">render 方法不存在的情况</strong>。此时， runtime-compiled 版本会在 JavaScript 运行时进行模板编译，生成 render 函数。</p>
</li>
<li data-nodeid="208853">
<p data-nodeid="208854"><strong data-nodeid="209083">compile 和 render 方法不存在，组件 template 属性存在的情况</strong>。此时由于没有 compile，这里用的是 runtime-only 的版本，因此要报一个警告来告诉用户，想要运行时编译得使用 runtime-compiled 版本的 Vue.js。</p>
</li>
<li data-nodeid="208855">
<p data-nodeid="208856"><strong data-nodeid="209088">组件既没有写 render 函数，也没有写 template 模板</strong>，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板。</p>
</li>
</ol>
<p data-nodeid="208857">处理完以上情况后，就要把组件的 render 函数赋值给 instance.render。到了组件渲染的时候，就可以运行 instance.render 函数生成组件的子树 vnode 了。</p>
<p data-nodeid="208858">另外对于使用 with 块运行时编译的渲染函数，渲染上下文的代理是 RuntimeCompiledPublicInstanceProxyHandlers，它是在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展，主要对 has 函数的实现做了优化：</p>
<pre class="lang-java" data-nodeid="208859"><code data-language="java"><span class="hljs-keyword">const</span> RuntimeCompiledPublicInstanceProxyHandlers = {
  ...PublicInstanceProxyHandlers,
  get(target, key) {
    <span class="hljs-keyword">if</span> (key === Symbol.unscopables) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">return</span> PublicInstanceProxyHandlers.get(target, key, target)
  },
  has(_, key) {
    <span class="hljs-comment">// 如果 key 以 _ 开头或者 key 在全局变量白名单内，则 has 为 false</span>
    <span class="hljs-keyword">const</span> has = key[<span class="hljs-number">0</span>] !== <span class="hljs-string">'_'</span> &amp;&amp; !isGloballyWhitelisted(key)
    <span class="hljs-keyword">if</span> ((process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &amp;&amp; !has &amp;&amp; PublicInstanceProxyHandlers.has(_, key)) {
      warn(`Property ${JSON.stringify(key)} should not start with _ which is a reserved prefix <span class="hljs-keyword">for</span> Vue internals.`)
    }
    <span class="hljs-keyword">return</span> has
  }
}
</code></pre>
<p data-nodeid="208860">这里如果 key 以 _ 开头，或者 key 在全局变量的白名单内，则 has 为 false，此时则直接命中警告，不用再进行之前那一系列的判断了。</p>
<p data-nodeid="208861">了解完标准化模板或者渲染函数流程，我们来看完成组件实例设置的最后一个流程——兼容 Vue.js 2.x 的 Options API。</p>
<h4 data-nodeid="208862">Options API：兼容 Vue.js 2.x</h4>
<p data-nodeid="208863">我们知道 Vue.js 2.x 是通过组件对象的方式去描述一个组件，之前我们也说过，Vue.js 3.0 仍然支持 Vue.js 2.x Options API 的写法，这主要就是通过 applyOptions方法实现的。</p>
<pre class="lang-java" data-nodeid="208864"><code data-language="java"><span class="hljs-function">function <span class="hljs-title">applyOptions</span><span class="hljs-params">(instance, options, deferredData = [], deferredWatch = [], asMixin = <span class="hljs-keyword">false</span>)</span> </span>{
  <span class="hljs-keyword">const</span> {
    <span class="hljs-comment">// 组合</span>
    mixins, extends: extendsOptions,
    <span class="hljs-comment">// 数组状态</span>
    props: propsOptions, data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions,
    <span class="hljs-comment">// 组件和指令</span>
    components, directives,
    <span class="hljs-comment">// 生命周期</span>
    beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeUnmount, unmounted, renderTracked, renderTriggered, errorCaptured } = options;

  <span class="hljs-comment">// instance.proxy 作为 this</span>
  <span class="hljs-keyword">const</span> publicThis = instance.proxy;
  <span class="hljs-keyword">const</span> ctx = instance.ctx;

  <span class="hljs-comment">// 处理全局 mixin</span>
  <span class="hljs-comment">// 处理 extend</span>
  <span class="hljs-comment">// 处理本地 mixins</span>
  <span class="hljs-comment">// props 已经在外面处理过了</span>
  <span class="hljs-comment">// 处理 inject</span>
  <span class="hljs-comment">// 处理 方法</span>
  <span class="hljs-comment">// 处理 data</span>
  <span class="hljs-comment">// 处理计算属性</span>
  <span class="hljs-comment">// 处理 watch</span>
  <span class="hljs-comment">// 处理 provide</span>
  <span class="hljs-comment">// 处理组件</span>
  <span class="hljs-comment">// 处理指令</span>
  <span class="hljs-comment">// 处理生命周期 option</span>
}
</code></pre>
<p data-nodeid="208865">由于 applyOptions 的代码特别长，所以这里我用注释列出了它主要做的事情，感兴趣的同学可以去翻阅它的源码。</p>
<h3 data-nodeid="208866">总结</h3>
<p data-nodeid="208867">这节课我们主要分析了组件的初始化流程，主要包括创建组件实例和设置组件实例。通过进一步细节的深入，我们也了解了渲染上下文的代理过程；了解了 Composition API 中的 setup 启动函数执行的时机，以及如何建立 setup 返回结果和模板渲染之间的联系；了解了组件定义的模板或者渲染函数的标准化过程；了解了如何兼容 Vue.js 2.x 的 Options API。</p>
<p data-nodeid="208868">我们通过一张图再直观感受一下 Vue.js 3.0 组件的初始化流程：</p>
<p data-nodeid="208869"><img src="https://s0.lgstatic.com/i/image/M00/35/74/Ciqc1F8VZvaAYCgKAAHVSzimXjw614.png" alt="3.png" data-nodeid="209103"></p>
<p data-nodeid="208870">最后，给你留一道思考题目，在执行 setup 函数并获取结果的时候，我们使用 callWithErrorHandling 把 setup 包装了一层，它有哪些好处？欢迎你在留言区与我分享。</p>
<blockquote data-nodeid="208871">
<p data-nodeid="208872" class="te-preview-highlight"><strong data-nodeid="209116">本节课的相关代码在源代码中的位置如下：</strong><br>
packages/runtime-core/src/renderer.ts<br>
packages/runtime-core/src/component.ts<br>
packages/runtime-core/src/componentProxy.ts<br>
packages/runtime-core/src/errorHandling.ts</p>
</blockquote>

---

### 精选评论

##### **莹：
> 如果setup返回对象和data重名，我这边测试时会用data中的值来渲染，但是文中的源码确实先执行的setupContext中查找，3.0.1版本

##### **国：
> callWithErrorHandling 把 setup 包装了一层，实际上就是让setup支持可选的参数来进行执行，另外如果发生错误的情况下也可以进行及时捕获并处理错误

##### ssh：
> get的时候回利用accessCache查找缓存，但是set的时候不会，这是为什么呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 因为这个 accessCache 缓存的是 key 对应的数据存储的类型，而不是具体存储的值，数据还是存储在 setupState、ctx、data、props 这些对象中

##### s(t)：
> 在set里面判断accessCache[key]是对应的什么类型(比如setupState)，再setupState[key]=value为什么不行呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 理论上来说，set 的时候判断 accessCache 应该也是可以的

