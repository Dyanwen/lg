<p data-nodeid="981" class="">上一节我们讨论了“自动化测试框架设计原则”，通过学习你应该对自动化测试框架的设计有了一定了解。</p>
<p data-nodeid="982">今天我们来聊聊，“分层测试”的概念、发展和误区，以及其实施原则。</p>
<h3 data-nodeid="983">“分层测试”是什么？</h3>
<p data-nodeid="984">“分层测试”其实并不是一个专业名称，它只是国内互联网从业者约定俗成的一个叫法。它来自专业名称“Test Pyramid”，也就是我们常说的“测试金字塔”，是 Martin Fowler 在 2012 年提出的一个概念。</p>
<p data-nodeid="985"><img src="https://s0.lgstatic.com/i/image/M00/53/0B/Ciqc1F9oGwuAf7eEAADRNGd88dM364.png" alt="Lark20200921-111541.png" data-nodeid="1081"></p>
<div data-nodeid="986"><p style="text-align:center">测试金字塔图 1</p></div>
<p data-nodeid="987">“测试金字塔”将软件测试分为不同的粒度，强调了<strong data-nodeid="1087">不同粒度的自动化测试在整个自动化测试中的占比应该不同</strong>，旨在指导我们如何使用不同类型的自动化测试来实现软件测试价值的最大化。</p>
<p data-nodeid="988">它有如下原则：</p>
<ul data-nodeid="989">
<li data-nodeid="990">
<p data-nodeid="991">分粒度来写自动化测试；</p>
</li>
<li data-nodeid="992">
<p data-nodeid="993">越是高层次，自动化测试的占比应该越少。</p>
</li>
</ul>
<p data-nodeid="994">如测试金字塔图1 所示，越是底层的测试，比如单元测试（Unit Test），测试耗费的时间就越少，花费的成本就越小，越往上层，测试所需的时间就越多，成本就越高，在“测试金字塔”模型中，UI 测试是性价比最低的一个测试类型。所以，我们说“测试金字塔”模型揭露了测试速度、测试成本和自动化测试类型三者之间的关系。</p>
<p data-nodeid="995">它最开始只有 Unit、Service 和 UI 这三个粒度，这三个粒度像是把自动化测试分为了三个不同层次，所以行业内我们将它叫作 “分层测试”。</p>
<p data-nodeid="996">那么，"测试金字塔"的每一层各有什么含义呢？</p>
<ul data-nodeid="997">
<li data-nodeid="998">
<p data-nodeid="999"><strong data-nodeid="1103">Unit 层（单元测试层）</strong><br>
单元测试层位于“测试金字塔”的最底层。主要关注函数，类级别的测试；单元测试之间相互没有依赖，是独立的，可重复执行的；单元测试的执行时间最短，成本最低；在实践中，大约有 70% 的测试用例都是单元测试。</p>
</li>
<li data-nodeid="1000">
<p data-nodeid="1001"><strong data-nodeid="1109">Service 层（服务层）</strong><br>
服务层位于“测试金字塔”的中间层。主要关注模块本身，模块与模块集成的接口， 子系统本身， 各个子系统之间的测试；Server 层的测试可涉及框架、数据库、第三方服务等；在实践中，大约有 20% 的测试用例是测试。</p>
</li>
<li data-nodeid="1002">
<p data-nodeid="1003"><strong data-nodeid="1115">UI 层</strong><br>
UI 层位于“测试金字塔”的最上层。 关注从用户角度看， 整个系统的表现和交互；UI 层的测试通常通过操作页面对象来执行；耗时最长，成本最高。在实践中，UI 层的测试大约占比 10% 左右。</p>
</li>
</ul>
<h3 data-nodeid="1004">“分层测试”的发展</h3>
<p data-nodeid="4450" class="te-preview-highlight">在实践中，“测试金字塔”逐渐更加细化，形成了如下的样子：<br>
<img src="https://s0.lgstatic.com/i/image/M00/6F/CA/Ciqc1F-3MASAcurLAADEq8NbZZM937.png" alt="middle_img_68fc11b1-aa06-4aca-8a41-c55969c3006g.png" data-nodeid="4459"></p>






<div data-nodeid="2963"><p style="text-align:center">测试金字塔图 2</p></div>
<p data-nodeid="2964">测试金字图1 中，原本的 Service 层进一步细分为组件测试（Component Test）、集成测试（Integration Test）和 API 接口测试（API Testing）。</p>








<p data-nodeid="1009">而原本顶部的 UI 层，则被 E2E（End To End）测试取代，E2E 测试和 UI 测试的区别是：UI 测试的重点在于产品或系统的 UI 部分；E2E 则更关注整个产品或者系统的行为是否正确，显然 E2E 能更加准确地描述测试活动的重心。</p>
<p data-nodeid="1010">此外，还在顶部另加了一个 Exploratory Test（探索性测试）。探索性测试不是随机测试，探索性测试一般会设定一个测试目标，然后根据测试执行者对系统的了解，从某一个点出发，围绕着测试目标，同时进行测试用例的设计和执行工作，当前探索性测试一般采用手工测试的方式来进行。</p>
<p data-nodeid="1011">至此，测试的“分层”已经很详细了，那每一层具体测试哪些内容，由哪些人负责执行呢？</p>
<ul data-nodeid="1012">
<li data-nodeid="1013">
<p data-nodeid="1014"><strong data-nodeid="1129">Unit（单元测试）层：</strong> 由于测试的都是具体的方法和类。所以一般由开发自测。</p>
</li>
<li data-nodeid="1015">
<p data-nodeid="1016"><strong data-nodeid="1134">Component Test（组件测试）：</strong> 这部分是 Unit 层的组装，多个 unit 组成一个 Component。对于一个组件来说，其输入可能是独立的，那么可由测试人员测试，也可能依赖别的组件提供，这时通常需要开发来提供 Mock。</p>
</li>
<li data-nodeid="1017">
<p data-nodeid="1018"><strong data-nodeid="1139">Integration Test（集成测试）：</strong> 把多个 Component（组件）形成一个子系统或者系统，集成测试分自顶向下集成和自底向上集成，集成测试一般由测试人员来完成。</p>
</li>
<li data-nodeid="1019">
<p data-nodeid="1020"><strong data-nodeid="1144">API Test（接口测试）：</strong> API 通常是指两个子系统直接通过 API 进行通信（当然不同模块间的通信也会通过 API 来进行），接口测试一般由测试人员来完成。</p>
</li>
<li data-nodeid="1021">
<p data-nodeid="1022"><strong data-nodeid="1149">E2E 测试：</strong> 关注系统的交互和 UI 的展现，通常由测试人员完成。</p>
</li>
<li data-nodeid="1023">
<p data-nodeid="1024"><strong data-nodeid="1154">探索性测试：</strong> 由测试人员手工完成。</p>
</li>
</ul>
<p data-nodeid="1025">总而言之，“测试金字塔”模型指导我们在进行测试时， 应该投入大量精力到运行速度更快，成本更低的 Unit 测试（单元测试）中；应该投入一部分精力到 Server 测试中（即组件测试和API测试）；在测试速度更慢，成本更高的 UI 层面的测试里，我们只需投入最小精力即可。</p>
<h3 data-nodeid="1026">“分层测试”的误区</h3>
<p data-nodeid="1027">“测试金字塔模型”（以下称“分层测试”）是“银弹”吗？是不是无论什么系统，都可以采用分层测试？分层测试又有哪些误区呢？</p>
<h4 data-nodeid="1028">误区 1：分层测试一定是顺序的。</h4>
<p data-nodeid="1029">很多同学在分层实践中都会陷入这个误区，特别是对分层测试不了解的同学，看着分层测试的图就想当然认为分层测试是有顺序的。即测试首先从单元测试开始，等所有的单元测试都做完后，才会开始 Service 层的测试（组件测试、集成测试和 API 测试），而 E2E 测试一定是在最后执行。</p>
<p data-nodeid="1030"><strong data-nodeid="1163">实际上，分层测试并没有规定每一层测试的先后顺序，在实践中，每一层的测试是没有执行先后顺序的，是可以同时运行的。</strong></p>
<h4 data-nodeid="1031">误区 2：不能跨层执行测试。</h4>
<p data-nodeid="1032">有的同学认为，既然分层分得这么清晰，是不是意味着不能在这一层执行其他层的测试呢？</p>
<blockquote data-nodeid="1033">
<p data-nodeid="1034">比如不能在 Service 层进行 E2E 测试，同样也不能在 E2E 层调用 API。</p>
</blockquote>
<p data-nodeid="1035">这是不对的。</p>
<p data-nodeid="1036">分层测试并没有这样的限制。实际上跨层测试是很经常的事情，比如我们在 E2E 测试时调用接口来迅速构造数据，或者使用 Mock 绕过某些非目标测试场景。</p>
<p data-nodeid="1037">还有，特别针对前端的验证来说，比如针对 UI 的验证，可以下沉到 Component 层（组件层）来尽早验证。举例来说，假设你的前端项目采用了 React、Vue、Spa 等 Web 技术，那么，利用这些框架提供的工具在 Component 层（组件层）针对 UI 进行测试是非常普遍的。</p>
<h4 data-nodeid="1038">误区 3：分层后，单元测试越多越好，UI 测试越少越好。</h4>
<p data-nodeid="1039">答案也对也不对。对，是因为理论上越底层的测试发现问题的成本越低，我们应该多做单元测试；不对，是因为现实往往比理论更复杂。</p>
<p data-nodeid="1040">举例来说，假设你的应用是一个跟第三方系统集成的项目（比如对接第三方支付接口）。那么因为第三方接口已经完成，在这个项目中，单元测试已经不用做，且不在你的掌握范围内。这时测试应该把关注点放在 E2E 层，以穷举业务场景的方式，来尽可能多地进行测试，以满足需求。</p>
<p data-nodeid="1041">所以你需要根据项目，合理选择需要实施哪种层次的测试，这才是正确做法。</p>
<h3 data-nodeid="1042">“分层测试”的最佳实施原则</h3>
<p data-nodeid="1043">“分层测试”讲了这么多，有没有好的实践供参考呢？当然有啦，以下就是我总结的分层测试实施原则。</p>
<h4 data-nodeid="1044">1. 不要重复测试</h4>
<p data-nodeid="1045">重复测试是指，同样一个检查点，在 Unit 层有测试用例，在 Service 层也有测试用例，在 E2E 测试里也有覆盖。</p>
<p data-nodeid="1046">在实践中，太多人尝试在每一层里尽可能穷尽所有功能的测试验证。这是不对的，理想的情况是，每一个层次的测试用例集合起来，正好是最小的，能覆盖所有需求的测试集。</p>
<p data-nodeid="1047">重复测试坏处在于，如果有改动，那么就要改动 3 次，并且还增加了脚本维护时间，测试成本非常高。</p>
<h4 data-nodeid="1048">2. 测试尽量下沉</h4>
<p data-nodeid="1049">测试尽量下沉，是指能在单元测试层覆盖的，尽量在单元测试层覆盖。测试下沉的好处是如果你的测试“失败”了，你清楚地知道哪行代码有问题；而如果 E2E 测试失败了，你要花费更多精力才能找到出错的代码行。</p>
<p data-nodeid="1050">测试下沉并不意味着测试脚本写完就算了，它是一个动态的过程。举例来说，假设你发现某一条 E2E 测试发现了一个功能性 Bug，这意味着你的单元测试某处缺失。这时，你需要把针对这个 Bug 的检查下沉到单元测试层，并且删除掉 E2E 层的测试。</p>
<p data-nodeid="1051">总之，你需要多写单元测试。</p>
<h4 data-nodeid="1052">3. 根据业务特性，测试合理分层</h4>
<p data-nodeid="1053">测试合理分层有两个含义。</p>
<p data-nodeid="1054"><strong data-nodeid="1195">第一个就是合理选择分层模型。</strong></p>
<p data-nodeid="1055">比如如果是前端占比比较多的测试，你可能选择“奖杯模型”；如果是针对微服务的测试，你可能选择“纺锤模型”。</p>
<p data-nodeid="1056"><strong data-nodeid="1200">第二个是合理选择在哪一层编写你的测试用例。</strong></p>
<p data-nodeid="1057">假设你需要做一个用户交易历史分页展示的功能，你在单元测试时发现了一个边界值的问题——数据量大到分页超过 1000 页时，程序会出错。</p>
<p data-nodeid="1058">从用户的操作习惯看，数据量根本达不到 1000 页，那么你永远走不到 E2E 层这一步，此时你的测试应该放在单元测试层。</p>
<p data-nodeid="1059">相反，假设如果你的业务流程限定死了，这个分页不可能达到 1000 页，那么这个单元测试就存在“过量测试”的问题，应该从单元测试层移除，转而在 E2E 层根据业务逻辑编写测试用例。</p>
<h3 data-nodeid="1060">课外小知识</h3>
<p data-nodeid="1061">除文中介绍的“测试金字塔”模型之外，“测试金字塔”模型针对不同的系统还有不同的演化。</p>
<p data-nodeid="1062">针对只有前端的项目，“测试金字塔”可能只包含 Unit 单元测试和 UI 测试 / E2E 测试，也可以加入对静态资源（Static files）的检查和集成测试（Integration Test），从而演变成奖杯模型（Testing Trophy）。</p>
<p data-nodeid="1063"><img src="https://s0.lgstatic.com/i/image/M00/50/1A/Ciqc1F9h1zGAE4WdAAKOCpCAbNo838.png" alt="Drawing 2.png" data-nodeid="1209"></p>
<div data-nodeid="1064"><p style="text-align:center">奖杯模型（Testing Trophy）</p></div>
<p data-nodeid="1065">针对微服务项目，还可以演变成一个仅仅关注集成测试的“纺锤模型”。</p>
<p data-nodeid="1066"><img src="https://s0.lgstatic.com/i/image/M00/50/F5/Ciqc1F9kKceAH2RCAAKIDtnMDvI800.png" alt="image (1).png" data-nodeid="1213"></p>
<div data-nodeid="1067"><p style="text-align:center">纺锤模型</p></div>
<p data-nodeid="1068">这些演化的模型，感兴趣的同学可以自行去搜索了解。</p>
<h3 data-nodeid="1069">小结</h3>
<p data-nodeid="1070">最后，总结一下本节课的重点内容，本课时我们详细介绍了“分层测试”，也就是“测试金字塔”模型的概念、发展和误区，以及其实施原则。</p>
<p data-nodeid="1071">“分层测试”是一个很好的自动化测试理论，当前大家形成的“多做单元测试，少做 UI 测试”的共识，就是基于“分层测试”的理论指导。但是在实际应用中，我们也需要根据实际情况去选择合适的分层模型。</p>
<p data-nodeid="1072">毕竟，一切测试都是基于风险的，生搬硬套“分层测试”并不能保证你的项目一定会成功。正如我们刚刚提及适用于微服务项目的纺锤模型，在测试时就需要多关注集成测试，而不必要把单元测试的比重放很高。</p>
<hr data-nodeid="1073">
<p data-nodeid="1074" class=""><a href="https://shenceyun.lagou.com/t/eka" data-nodeid="1221">“测试开发工程师名企直推营” 入口，免费领取 50G 资料包</a></p>

---

### 精选评论

##### **剑：
> 蔡老师，有个问题，希望能给予解惑。由于单元测试基本都是开发做的，那我们测试人员去写接口测试或者E2E测试的时候怎么能知道这条用例重复没重复呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 1.跟开发负责人对齐，定期review。2.每个story开发和测试覆盖的内容要同步到团队。我知道考虑到KPI或者其它因素（开发测试分别汇报给不同的领导等），如果不太现实，测试可只看测试这边的。记住标准就行：分层是为了建设测试执行时间提高效率而不是重复建设。

##### **玲：
> 老师，能再给解释一下具体e2e测试是怎么回事吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; End To End测试。你可以理解为UI端的功能测试。他跟UI测试的区别在于他强调整个流程下（用户角度）的被测系统的功能和逻辑正确性。一般而言，他要求背后的系统，服务都是真实的。而UI测试更多的是关注UI层面本身的逻辑，而不关心其背后系统及服务是否是真实的，即你可以完全Mock掉后端的服务，仅仅来测UI本身的逻辑。

##### **鲁：
> 关于不要重复测试这块，想不到具体的场景。比如打开一个我的订单页面，检查页面正常打开，在API层做接口自动化检查，在UI层做元素显示检查，个人认为这两种不重复，如何理解老师提到的同一个检查点不要重复测试呢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你在页面层做的打开订单页面，会调用到后面的那个API层的接口对不？ 如果是的话，那么你页面层其实已经测试到这个操作了。这样，你API层可以把UI层已经覆盖到的这一条用例去掉。

##### **凯：
> 满满的干货，蔡老师棒棒哒~😁

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 谢谢同学的认可，等到进入 07 课时时，我们就会开启实战部分了~敬请期待吧~

##### **帅：
> 老师，想问一下集成测试和组件测试具体是做什么呢？查资料说集成测试大概是说A程序员写好的API和B程序员的API集成到一起去就叫集成。在针对集成测试和组件测试实施过程中与接口测试（校验接口的各种传参与结果）的工作内容有什么区别呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 集成测试，是Integration Test,组件测试，是Components Test。换成英文可能就更加容易理解。集成测试的范围更广。组件测试更多的关注点在于组件自身。不一定会关注软件系统这个整体。但是集成测试，可以包括组件测试，也可以包括子系统与子系统之间集成的测试。在现在，已经很少见有人去分别他们的定义了，区别这个意义也不大。 在多年以前，集成测试提出主要是描述组件与组件组装方式，例如从上到下的集成，以及自低向上的集成。在现代的开发语境里，集成可以是组件的集成，也可以是API 的集成，也可以是方法的集成。而组件，特别是微服务后，一个微服务也可以成为一个组件(而在以前，它可能是个系统)，个人觉得不必再去区分。

##### **梅：
> 老师，端到端的测试和系统测试有什么区别？端到端测试发现问题是否说明系统测试不充分呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 端到端测试和系统测试这两个概念，可以查下维基百科的定义。我谈下自己的理解，系统测试是根据PRD为基础进行的，但是端到端是基于用户需求的。PRD不一定能正确反映出用户需求。再有就是端到端主要从用户角度出发，包括功能，及非功能的验证。而系统测试没有要求一定从用户角度出发。在实际测试中，系统测试的时候节点在集成测试完成后。而端到端测试一般是验收测试阶段进行。

##### **莹：
> 对于业务而言，可能存在多重类型的组合，可是在单元测试时，都被拆解了理论上是单元测试有触及，接口和UI就不需要测试可是否还可能存在其他的出错的情况，如果是为了确保不要有遗漏，选择在接口和UI上保险加一层覆盖到的话，是交叉的，部分接口覆盖，部分UI覆盖，或者是单一类型都覆盖，方便统一呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 从实际操作来看，一定是重合的，然后通过一定阶段的运行，特别稳定的用例，我们就可以选择只保留最底层了拉。
总而言之，这里是回答一个问题： ”你的自动化测试用例，加的时候都很爽快，那么你敢不敢删？有没有信心删？“

##### **莹：
> 我们属于重前端测试，对于正常流程的处理，开发基本都能实现，但是一到异常流程，就总是出现遗漏可进行需求评审时，业务复杂的话，连产品人员自己也没有想清楚这个场景的逻辑。最后拖到手工测出来，这种也算是边界异常的，到底是应该开发考虑还是需求考虑呢？或者说需求文档对这些的限制，可能达到很明确吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 产品和BA受制于对技术的深入理解，他们一般是无法考虑这么周全的。更何况，需求出来时，需求能不能做，如何做还不知道，所以这个对异常的考虑，我认为应是QA和开发的责任。
所以QA要追着开发问这个需求他们要如何实现？分为哪些步骤？代码逻辑是什么？然后在这个基础上，QA根据自己的理解想，这样实现，会不会导致XYZ问题？
QA在这里的作用越大，产品和开发就越愿意在更早阶段involve QA进来，这是个良性循环。

##### **波：
> 🌝🌝没有几个测试可以做到单元测试。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 的确很少

##### **辉：
> 为什么看不见文中的插图图片，是我手机问题吗？

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 同学，我们这边用几个手机都看过了，没有问题哦~图都能看到，请同学刷新再看看

