<p data-nodeid="8384" class="">你好，我是蔡超，欢迎来到第 24 课时。通过前面章节的学习，我们已经掌握了测试框架的方方面面，今天我们来讲解测试框架的另外一个重要组成部分 —— 测试报告。</p>
<p data-nodeid="8385">测试报告在测试框架中的重要性不言而喻，有了测试报告，我们不仅可以在单次测试运行后，根据测试结果直观地对软件质量有个大致的评估，还可以汇总历次测试运行的情况，得出如下信息。</p>
<ul data-nodeid="8386">
<li data-nodeid="8387">
<p data-nodeid="8388">随着版本的历次变更，质量是变好了还是变坏了？</p>
</li>
<li data-nodeid="8389">
<p data-nodeid="8390">同一个模块下的测试用例， 在不同版本下执行，需要修改测试用例的频率是多少？</p>
</li>
</ul>
<blockquote data-nodeid="8391">
<p data-nodeid="8392">通过此指标可以看出这个模块更新，或者被其他模块影响的频率高低。</p>
</blockquote>
<ul data-nodeid="8393">
<li data-nodeid="8394">
<p data-nodeid="8395">哪条测试用例永远成功？考虑是不是测试检查点写得不足，如果不是，考虑是否可以删除掉这条用例。</p>
</li>
<li data-nodeid="8396">
<p data-nodeid="8397">哪条测试用例永远失败，或者大概率失败？</p>
</li>
</ul>
<blockquote data-nodeid="8398">
<p data-nodeid="8399">首先检查测试脚本是否存在问题。如果没有问题，检查这个测试用例对应哪个功能点？失败的原因是什么？</p>
</blockquote>
<p data-nodeid="8400">既然测试报告能告诉我们这么多信息，那么测试报告应该如何开发呢？测试报告又应该包括哪些内容呢？这一讲的大致内容如下图所示，可供你参考。<br>
<img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_EytCAMU4XAALj-7uE8Bw866.png" alt="图片.png" data-nodeid="8654"></p>
<h3 data-nodeid="8401">测试报告应该包括哪些内容？</h3>
<p data-nodeid="8402">在我看来，测试报告至少需要包括项目总览和执行情况分析这两方面的信息。</p>
<h4 data-nodeid="8403">1. 项目总览</h4>
<ul data-nodeid="8404">
<li data-nodeid="8405">
<p data-nodeid="8406">本次测试执行了多长时间？</p>
</li>
<li data-nodeid="8407">
<p data-nodeid="8408">总共执行了多少测试用例？</p>
</li>
<li data-nodeid="8409">
<p data-nodeid="8410">有多少测试用例执行成功？</p>
</li>
<li data-nodeid="8411">
<p data-nodeid="8412">有多少测试用例执行失败？</p>
</li>
<li data-nodeid="8413">
<p data-nodeid="8414">有多少测试用例是非正常失败的？</p>
</li>
</ul>
<blockquote data-nodeid="8415">
<p data-nodeid="8416">不是由于断言失败，而是由于环境不稳定，运行中突发错误而导致的失败。</p>
</blockquote>
<ul data-nodeid="8417">
<li data-nodeid="8418">
<p data-nodeid="8419">每条测试用例执行了多长时间？</p>
</li>
<li data-nodeid="8420">
<p data-nodeid="8421">本次测试在哪个环境运行？是开发环境、集成测试环境还是生产环境？</p>
</li>
<li data-nodeid="8422">
<p data-nodeid="8423">本次测试运行在哪个操作系统上？</p>
</li>
</ul>
<h4 data-nodeid="8424">2. 执行情况分析</h4>
<p data-nodeid="8425">针对每一次测试运行，测试报告应该提供最基本的测试分析，包括：</p>
<ul data-nodeid="8426">
<li data-nodeid="8427">
<p data-nodeid="8428">按照测试失败划分的测试分析图</p>
</li>
<li data-nodeid="8429">
<p data-nodeid="8430">按模块划分的测试分析图</p>
</li>
<li data-nodeid="8431">
<p data-nodeid="8432">按照测试用例重要程度、优先级划分的测试分析图</p>
</li>
<li data-nodeid="8433">
<p data-nodeid="8434">按照测试执行时间划分的测试分析图</p>
</li>
</ul>
<p data-nodeid="8435">这些不同维度的分析图，可用从各个层面来反映软件的质量情况。</p>
<p data-nodeid="8436">所以，依托测试报告进行分析和总结，我们能够有理有据，以数字形式直观反映项目暴露出的质量问题，从而催促各个相关方后续改进。</p>
<p data-nodeid="8437">在当前市面上所有第三方或者自研的测试报告系统中，<strong data-nodeid="8684">Allure</strong> 是最全面，且支持的测试框架最多的一个测试报告系统。它是开源的测试报告框架，它旨在创建让团队每一个人都清楚明了的测试报告。下面我将以 Allure 报告为例，详细讲解测试报告的开发使用。</p>
<h3 data-nodeid="8438">Allure 报告生成的原理</h3>
<p data-nodeid="8439">Allure 报告是基于标准的 xUnit 结果输出，再添加补充数据而生成的，其报告的生成基于如下两个步骤。</p>
<ul data-nodeid="8440">
<li data-nodeid="8441">
<p data-nodeid="8442">在测试执行期间，一个名为 <strong data-nodeid="8692">Adapter</strong> 的小型 library 被连接到测试框架中，并将所有测试执行的信息保存到 XML 文件中。对于大多数编程语言下的流行测试框架（例如 python 语言中的 pytest，Java 中的 jUnit 等），Allure 都默认为其提供了 Adapter。</p>
</li>
<li data-nodeid="8443">
<p data-nodeid="8444">获取 XML 文件后，Allure 会<strong data-nodeid="8698">将这些 XML 文件转换为 HTML 报告</strong>。这一步骤可以通过持续集成系统的 Allure 插件，或者命令行命令实现。</p>
</li>
</ul>
<h3 data-nodeid="8445">Allure 报告特点</h3>
<p data-nodeid="8446">Allure 报告之所以受到开发、测试，甚至管理人员的推崇，是因为它有如下明显的特点。</p>
<ul data-nodeid="8447">
<li data-nodeid="8448">
<p data-nodeid="8449">从开发/质量保证的角度看，Allure 报告可以<strong data-nodeid="8706">缩短常见缺陷的生命周期</strong>。</p>
</li>
</ul>
<p data-nodeid="8450">可以将测试失败划分为 bug 和损坏的（Broken）测试，还可以配置日志、步骤、固定装置、附件、时间、历史记录，以及与 TMS 的集成和 Bug 跟踪系统，方便将 Task 与负责 Task 开发人员和测试人员绑定，从而使开发和测试人员第一时间掌握所有信息。</p>
<ul data-nodeid="8451">
<li data-nodeid="8452">
<p data-nodeid="8453">从管理者的角度看，Allure 提供了一个清晰的“全局”视野。</p>
</li>
</ul>
<p data-nodeid="8454">包括本次测试涵盖了哪些功能，Bug 在哪个 case 用例中被发现，以及整体测试用例、单条测试用例的执行时间等信息。</p>
<h3 data-nodeid="8455">Allure 测试报告一览</h3>
<p data-nodeid="8456">Allure 测试报告除了涵盖测试运行的全面信息外，还提供各种维度的分析图，包括如下几个部分。</p>
<ul data-nodeid="8457">
<li data-nodeid="8458">
<p data-nodeid="8459"><strong data-nodeid="8715">项目总览（OverView）</strong></p>
</li>
</ul>
<p data-nodeid="8460">项目总览显示了总体测试运行的一系列统计信息。</p>
<p data-nodeid="8461"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_EywGASEwDAAHKaRT1ypk100.png" alt="图片1.png" data-nodeid="8719"></p>
<ul data-nodeid="8462">
<li data-nodeid="8463">
<p data-nodeid="8464"><strong data-nodeid="8723">按缺陷种类分析（Categories）</strong></p>
</li>
</ul>
<p data-nodeid="8465">缺陷种类分析显示了所有不同原因引起的失败，并分类展示。</p>
<p data-nodeid="8466"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_EywmANf7zAANMZsUM5TA694.png" alt="图片2.png" data-nodeid="8727"></p>
<ul data-nodeid="8467">
<li data-nodeid="8468">
<p data-nodeid="8469"><strong data-nodeid="8731">按测试套件分析（Suites）</strong></p>
</li>
</ul>
<p data-nodeid="8470">测试套件分析显示了按照套件和类划分的所有的测试执行情况。</p>
<p data-nodeid="8471"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_EyxKAO_77AANWLzqSMlI490.png" alt="图片3.png" data-nodeid="8735"></p>
<ul data-nodeid="8472">
<li data-nodeid="8473">
<p data-nodeid="8474"><strong data-nodeid="8739">图表模块（Graphs）</strong></p>
</li>
</ul>
<p data-nodeid="8475">图表模块，包括按照不同维度分析的各种图表（例如测试状态表分析，测试用例等级分析表，测试执行时间分析表等等）。</p>
<p data-nodeid="8476"><img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_EyxqAOAI5AAFGT4Lob0E476.png" alt="图片4.png" data-nodeid="8743"></p>
<ul data-nodeid="8477">
<li data-nodeid="8478">
<p data-nodeid="8479"><strong data-nodeid="8747">按执行时间分析（Timeline）</strong></p>
</li>
</ul>
<p data-nodeid="8480">按执行时间分析模块，详细列出了各个测试用例的执行时间，你可以筛选出那些运行时间最长的测试用例进行优化。</p>
<p data-nodeid="8481"><img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_EyyGAXE03AADRzNiqu0U526.png" alt="图片5.png" data-nodeid="8751"></p>
<ul data-nodeid="8482">
<li data-nodeid="8483">
<p data-nodeid="8484"><strong data-nodeid="8755">针对 BDD 驱动的测试用例进行分析（Behaviors）</strong></p>
</li>
</ul>
<p data-nodeid="8485">这里主要是根据 Epic、Feature 和 Story 标签对测试结果进行分组。</p>
<p data-nodeid="8486"><img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_EyymAIOWAAAMXxTLD16w983.png" alt="图片6.png" data-nodeid="8759"></p>
<ul data-nodeid="8487">
<li data-nodeid="8488">
<p data-nodeid="8489"><strong data-nodeid="8763">按照 Package 进行分析（Packages）</strong></p>
</li>
</ul>
<p data-nodeid="8490">Package 模块列出了按照 Package 维度进行分析的详细图表。</p>
<p data-nodeid="8491"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_EyzCANxDXAAOfMQG3Dvg894.png" alt="图片7.png" data-nodeid="8767"></p>
<p data-nodeid="8492">了解了 Allure 测试报告的模块划分，我们来看下，如何配置使得这些模块反映测试的执行情况。</p>
<h3 data-nodeid="8493">Allure 测试报告开发配置指南</h3>
<p data-nodeid="8494">Allure 有很多独有的功能，可用来方便自定义测试报告，下面我将详细为你讲解。</p>
<h4 data-nodeid="8495">1.Allure 的安装和配置</h4>
<p data-nodeid="8496">在不同操作系统下安装 Allure 报告的方式各有不同。关于如何安装、配置 Allure 测试报告，我在前面的章节《<strong data-nodeid="8779">10 | 你的第一个 API 测试框架（二</strong>）》介绍过，你可以回顾一下。</p>
<p data-nodeid="8497">你也可以直接通过如下方式安装：</p>
<pre class="lang-plain" data-nodeid="8498"><code data-language="plain">pip install allure-pytest
</code></pre>
<blockquote data-nodeid="8499">
<p data-nodeid="8500">注意，如果你安装过 Allure 2.0 之前的版本，你需要先将之前的版本卸载。</p>
</blockquote>
<h4 data-nodeid="8501">2.Allure 测试报告基础使用</h4>
<p data-nodeid="8502">Allure 测试报告安装配置好后，由 pytest 运行的测试便可以直接使用。假设当前你有个项目名为 allureDemo，则你可以采用如下方式使用 Allure 报告：</p>
<ul data-nodeid="8503">
<li data-nodeid="8504">
<p data-nodeid="8505">首先运行你的测试</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="8506"><code data-language="python"><span class="hljs-comment"># 直接执行allureDemo项目下的所有测试用例，并将测试报告文件夹allure_reports放在项目根目录下</span>
D:\_Automation\allureDemo&gt;pytest -s&nbsp; -v --alluredir=./allure_results
</code></pre>
<ul data-nodeid="8507">
<li data-nodeid="8508">
<p data-nodeid="8509">运行完成后，打开 allure 报告</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="8510"><code data-language="python"><span class="hljs-comment"># 以Win10为例：</span>
<span class="hljs-comment"># 1. 使用快捷键 Win + R 调起运行提示框</span>
<span class="hljs-comment"># 2. 输入“cmd”进入到命令行</span>
<span class="hljs-comment"># 3. 切换目录到项目根目录，本例中在D:\_Automation\allureDemo&gt;：</span>
<span class="hljs-comment"># 4. 输入命令生成allure报告：</span>
allure serve allure_reports
</code></pre>
<p data-nodeid="8511">此时，Allure 会帮你生成测试报告会自动打开。</p>
<h3 data-nodeid="8512">Allure 报告实战</h3>
<p data-nodeid="8513">为了清晰地讲解 Allure 各个模块的使用，但又尽量少地引入其他代码，我将重新建立一个项目来详解 Allure 测试报告。</p>
<pre class="lang-plain" data-nodeid="8514"><code data-language="plain">|--allureDemo
    |--tests
        |--test_baidu.py
        |--test_basic_report.py
        |--__init__.py
    |--conftest.py
</code></pre>
<p data-nodeid="8515">其中 conftest.py 里的代码如下：</p>
<pre class="lang-python" data-nodeid="8516"><code data-language="python"><span class="hljs-keyword">import</span> allure
<span class="hljs-keyword">import</span> pytest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_addoption</span>(<span class="hljs-params">parser</span>):</span>
    parser.addoption(
        <span class="hljs-string">"--flag"</span>, action=<span class="hljs-string">"store_true"</span>, default=<span class="hljs-literal">False</span>, help=<span class="hljs-string">"set skip or not"</span>)
    parser.addoption(
        <span class="hljs-string">"--browser"</span>, action=<span class="hljs-string">"store"</span>, default=<span class="hljs-string">"Firefox"</span>, help=<span class="hljs-string">"set browser"</span>)

<span class="hljs-meta">@pytest.fixture(scope='session')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_flag</span>(<span class="hljs-params">request</span>):</span>
    <span class="hljs-keyword">return</span> request.config.getoption(<span class="hljs-string">'--flag'</span>)

<span class="hljs-meta">@pytest.fixture(scope='session')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_browser</span>(<span class="hljs-params">request</span>):</span>
    <span class="hljs-keyword">return</span> request.config.getoption(<span class="hljs-string">'--browser'</span>)

<span class="hljs-meta">@pytest.hookimpl(tryfirst=True, hookwrapper=True)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_runtest_makereport</span>(<span class="hljs-params">item, call</span>):</span>
    <span class="hljs-string">"""
    　　本hook用于制作测试报告
    　　:param item:测试用例对象
    　　:param call:测试用例的测试步骤
    　　         执行完常规钩子函数返回的report报告有个属性叫report.when
                when=’setup’ 代表返回setup 的执行结果
                when=’call’ 代表返回call 的执行结果
    　　:return:
    """</span>
    outcome = <span class="hljs-keyword">yield</span>
    rep = outcome.get_result()
    <span class="hljs-keyword">if</span> (rep.when == <span class="hljs-string">"call"</span> <span class="hljs-keyword">or</span> rep.when == <span class="hljs-string">'setup'</span>) <span class="hljs-keyword">and</span> (rep.failed <span class="hljs-keyword">or</span> rep.skipped):
        <span class="hljs-keyword">try</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-string">"initial_browser"</span> <span class="hljs-keyword">in</span> item.fixturenames:
                web_driver = item.funcargs[<span class="hljs-string">'initial_browser'</span>]
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># 如果找不到driver，则直接return</span>
                <span class="hljs-keyword">return</span>
            allure.attach(web_driver.get_screenshot_as_png(), name=<span class="hljs-string">"wrong picture"</span>,
                          attachment_type=allure.attachment_type.PNG)
        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            print(<span class="hljs-string">"failed to take screenshot"</span>.format(e))
</code></pre>
<p data-nodeid="8517">在这个代码中，我分别定义了两个命令行参数 flag 和 browser。</p>
<ul data-nodeid="8518">
<li data-nodeid="8519">
<p data-nodeid="8520">flag：只有两个值 True 和 False，当用户不传 flag 参数时，默认为 False，当用户传递 flag 时，值为 True。</p>
</li>
<li data-nodeid="8521">
<p data-nodeid="8522">browser：代表要启用的浏览器，默认是 Firefox 浏览器。</p>
</li>
</ul>
<p data-nodeid="8523">对应地，get_flag 和 get_browser 这两个 fixture 就是分别用来取 flag 和 browser 的值。</p>
<p data-nodeid="8524">被装饰器 @pytest.hookimpl(tryfirst=True, hookwrapper=True) 装饰的函数 pytest_runtest_makereport，是 pytest 提供的 Hook 函数，它有以下两个作用：</p>
<ul data-nodeid="8525">
<li data-nodeid="8526">
<p data-nodeid="8527">可以获取到测试用例不同执行阶段的结果（setup，call，teardown）；</p>
</li>
<li data-nodeid="8528">
<p data-nodeid="8529">可以获取钩子方法的调用结果（yield 返回一个 result 对象）和调用结果的测试报告（返回一个 report 对象，即 _pytest.runner.TestReport）。</p>
</li>
</ul>
<p data-nodeid="8530">而在本例中，我通过它实现了当测试失败或者被 skip 时，自动根据 WebDriver 提供的 get_screenshot_as_png() 方法来截图。</p>
<p data-nodeid="8531">接着，我们来看下文件 test_baidu.py 的内容：</p>
<pre class="lang-python" data-nodeid="8532"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> allure
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver

<span class="hljs-meta">@allure.epic('baidu')</span>
<span class="hljs-meta">@allure.description('测试百度的搜索功能')</span>
<span class="hljs-meta">@allure.severity('BLOCKER')</span>
<span class="hljs-meta">@allure.feature("百度搜索")</span>
<span class="hljs-meta">@allure.testcase("http://www.baidu.com")</span>
<span class="hljs-meta">@pytest.mark.baidu</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBaidu</span>:</span>
<span class="hljs-meta">    @pytest.fixture</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initial_browser</span>(<span class="hljs-params">self, get_browser</span>):</span>
        <span class="hljs-keyword">if</span> get_browser:
            <span class="hljs-keyword">if</span> get_browser.lower() == <span class="hljs-string">"Chrome"</span>:
                self.driver = webdriver.Chrome()
            <span class="hljs-keyword">elif</span> get_browser.lower() == <span class="hljs-string">"firefox"</span>:
                self.driver = webdriver.Firefox()
            <span class="hljs-keyword">else</span>:
                self.driver = webdriver.Chrome()
        <span class="hljs-keyword">else</span>:
            self.driver = webdriver.Chrome()
            self.driver.implicitly_wait(<span class="hljs-number">30</span>)
        self.base_url = <span class="hljs-string">"http://www.baidu.com/"</span>
        <span class="hljs-keyword">yield</span> self.driver
        self.driver.quit()
<span class="hljs-meta">    @allure.title("测试百度搜索正确")</span>
<span class="hljs-meta">    @pytest.mark.parametrize('search_string, expect_string', [('iTesting', 'iTesting'), ('helloqa.com', 'iTesting')])</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_baidu_search</span>(<span class="hljs-params">self, initial_browser, search_string, expect_string</span>):</span>
        driver = initial_browser
        driver.get(self.base_url + <span class="hljs-string">"/"</span>)
        driver.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(search_string)
        driver.find_element_by_id(<span class="hljs-string">"su"</span>).click()
        time.sleep(<span class="hljs-number">2</span>)
        search_results = driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="1"]/h3/a'</span>).get_attribute(<span class="hljs-string">'innerHTML'</span>)
        print(search_results)
        <span class="hljs-keyword">assert</span> (expect_string <span class="hljs-keyword">in</span> search_results) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>
<span class="hljs-meta">    @allure.title("测试百度搜索失败")</span>
<span class="hljs-meta">    @pytest.mark.parametrize('search_string, expect_string', [('iTesting', 'isGood')])</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_baidu_search_fail</span>(<span class="hljs-params">self, initial_browser, search_string, expect_string</span>):</span>
        driver = initial_browser
        driver.get(self.base_url + <span class="hljs-string">"/"</span>)
        driver.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(search_string)
        driver.find_element_by_id(<span class="hljs-string">"su"</span>).click()
        time.sleep(<span class="hljs-number">2</span>)
        search_results = driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="1"]/h3/a'</span>).get_attribute(<span class="hljs-string">'innerHTML'</span>)
        <span class="hljs-keyword">assert</span> (expect_string <span class="hljs-keyword">in</span> search_results) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main([<span class="hljs-string">"-m"</span>, <span class="hljs-string">"baidu"</span>, <span class="hljs-string">"-s"</span>, <span class="hljs-string">"-v"</span>, <span class="hljs-string">"-k"</span>, <span class="hljs-string">"test_baidu_search"</span>, <span class="hljs-string">"test_baidu_fixture_sample.py"</span>])
</code></pre>
<p data-nodeid="8533">在这个文件中，我创建了一个测试类 TestBaidu 和两个测试方法 test_baidu_search() 和 test_baidu_search_fail()。注意：这两个方法有很多关于 allure 的装饰器，例如 @allure.epic、 @allure.feature 等，它们分别代表什么含义我等下再讲，我们继续往下看。</p>
<p data-nodeid="8534">最后，test_basic_report.py 的内容如下：</p>
<pre class="lang-python" data-nodeid="8535"><code data-language="python"><span class="hljs-keyword">import</span> allure
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">from</span> flaky <span class="hljs-keyword">import</span> flaky

<span class="hljs-meta">@allure.epic("演示下allure支持的测试")</span>
<span class="hljs-meta">@allure.description('测试模块1用来对模块1进行测试')</span>
<span class="hljs-meta">@allure.feature("测试模块1")</span>
<span class="hljs-meta">@allure.story("测试模块1_story1")</span>
<span class="hljs-meta">@allure.testcase("http://www.baidu.com")</span>
<span class="hljs-meta">@pytest.mark.basic</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBasic</span>:</span>
<span class="hljs-meta">    @allure.step("测试步骤1 -- 判断登录成功")</span>
<span class="hljs-meta">    @allure.severity('BLOCKER')</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_login</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""模拟成功的测试用例"""</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>
<span class="hljs-meta">    @flaky</span>
<span class="hljs-meta">    @allure.step("测试步骤2 -- 查询余额")</span>
<span class="hljs-meta">    @allure.severity("normal")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_savings</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""模拟失败的测试用例"""</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
<span class="hljs-meta">    @allure.step("测试步骤2.1 -- 查询余额")</span>
<span class="hljs-meta">    @allure.severity("normal")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_savings1</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""模拟失败的测试用例"""</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
<span class="hljs-meta">    @allure.description("调试用，不执行")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_deposit_temp</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""模拟skip的测试用例"""</span>
        pytest.skip(<span class="hljs-string">'调试用例，skip'</span>)
<span class="hljs-meta">    @allure.issue("http://itesting.club", "此处之前有bug，bug号如上")</span>
<span class="hljs-meta">    @allure.step("测试步骤3 -- 取现")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_deposit</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'oops'</span>)
<span class="hljs-meta">    @pytest.mark.xfail(ccondition=lambda: True, reason='this test is expecting failure')</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_xfail_expected_failure</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""被期望的失败"""</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>
<span class="hljs-meta">    @pytest.mark.xfail(condition=lambda: True, reason='this test is expecting failure')</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_xfail_unexpected_pass</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-string">"""期望失败，但是却成功，会被标记为不期望的成功"""</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-literal">True</span>
<span class="hljs-meta">    @allure.step("测试步骤4 -- teardown")</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_skip_by_triggered_condition</span>(<span class="hljs-params">self, get_flag</span>):</span>
        <span class="hljs-keyword">if</span> get_flag == <span class="hljs-literal">True</span>:
            pytest.skip(<span class="hljs-string">"flag 是true时， skip掉此条用例"</span>)
</code></pre>
<p data-nodeid="8536">在这个文件中，为了模拟到所有的测试运行情况，我人为定义了一些 pass 和 fail，以及 skip、xfail 的情况。</p>
<h4 data-nodeid="8537">1.Allure 测试报告装饰器</h4>
<p data-nodeid="8538">在运行整个测试之前，我们来学习下 Allure 测试报告的各个装饰器及其作用：<br>
<img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_Ey0uALwAnAALgzgxDn64368.png" alt="图片8.png" data-nodeid="8839"><br>
关于每一个装饰器的具体用法，可以直接参考上文中的代码示例。</p>
<h4 data-nodeid="8539">2.为 Allure 测试报告添加 Environment</h4>
<p data-nodeid="8540">现在，我来生成下测试报告：</p>
<pre class="lang-python" data-nodeid="8541"><code data-language="python"><span class="hljs-comment"># 在项目根目录下执行</span>
<span class="hljs-comment"># 本例中，根目录是D:\_Automation\allureDemo&gt;</span>
D:\_Automation\allureDemo&gt;pytest -m baidu -s&nbsp; -v --alluredir=./allure_results
</code></pre>
<p data-nodeid="8542">执行成功后，通过如下命令打开测试报告：</p>
<pre class="lang-plain" data-nodeid="8543"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8544">可以看到如下的结果。默认情况下，Allure 生成的报告是不带 Environment 信息的，如下图中“1.Environment 默认没有”所示。</p>
<p data-nodeid="8545"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_Ey1mAEBDMAAHzvqGkl94603.png" alt="图片9.png" data-nodeid="8848"></p>
<p data-nodeid="8546"><strong data-nodeid="8852">那么如何让测试报告带上 Environment 信息呢？</strong></p>
<ul data-nodeid="8547">
<li data-nodeid="8548">
<p data-nodeid="8549">首先，执行完测试用例后，创建文件 environment.properties，其内容格式如下：</p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="8550"><code data-language="plain">Browser=Chrome
Browser.Version=86.0.4240
Environment=QA
</code></pre>
<blockquote data-nodeid="8551">
<p data-nodeid="8552">注意：这里为 key=value 的格式。这个文件你可以通过编写相关函数动态获取每次执行时的真实值，然后写入 environment.properties 文件。这里为了方便，我直接 Hard Coded.</p>
</blockquote>
<ul data-nodeid="8553">
<li data-nodeid="8554">
<p data-nodeid="8555">然后，把文件 <strong data-nodeid="8866">environment.properties</strong> 拷贝到你在执行测试用例时设置的 allure 报告目录下，在本例中为 <strong data-nodeid="8867">allure_results</strong> 这个目录。</p>
</li>
<li data-nodeid="8556">
<p data-nodeid="8557">最后，执行如下命令：</p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="8558"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8559">你会发现 Environment 里出现了我们刚刚配置的值：</p>
<p data-nodeid="8560"><img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_Ey2CAWRjwAADdVWfDWFk007.png" alt="图片10.png" data-nodeid="8872"></p>
<h4 data-nodeid="8561">3.为 Allure 测试报告增加错误类型</h4>
<p data-nodeid="8562">在默认情况下，Allure 仅仅会列出以下两种类型的 Categories。</p>
<ul data-nodeid="8563">
<li data-nodeid="8564">
<p data-nodeid="8565"><strong data-nodeid="8878">Product Defects（failed tests）</strong></p>
</li>
</ul>
<p data-nodeid="8566">表示真正的测试执行失败，如果 Categories 里出现这个错误，通常表明测试用例最后的输出跟期望不符合，有 Bug 出现。</p>
<ul data-nodeid="8567">
<li data-nodeid="8568">
<p data-nodeid="8569"><strong data-nodeid="8883">Test Defects（broken tests）</strong></p>
</li>
</ul>
<p data-nodeid="8570">表示测试用例本身有问题导致的错误，如果 Categories 里出现这个错误，通常表明测试用例在执行过程中出错了，需要我们进一步调查原因。</p>
<p data-nodeid="8571">如果你仔细观察 test_basic_report.py 里的代码，你可以看到，我们很多用例是要 skip，或者需要根据用户的传参来 skip 的，这些测试用例没有被反映到 Categories 里。</p>
<p data-nodeid="8572"><strong data-nodeid="8893">那么如何自定义 Categories 呢？</strong></p>
<ul data-nodeid="8573">
<li data-nodeid="8574">
<p data-nodeid="8575">首先，创建名称为 <strong data-nodeid="8899">categories.json</strong> 的文件，内容如下：</p>
</li>
</ul>
<pre class="lang-json" data-nodeid="8576"><code data-language="json">[
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Ignored tests"</span>,
    <span class="hljs-attr">"matchedStatuses"</span>: [<span class="hljs-string">"skipped"</span>]
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Infrastructure problems"</span>,
    <span class="hljs-attr">"matchedStatuses"</span>: [<span class="hljs-string">"broken"</span>, <span class="hljs-string">"failed"</span>],
    <span class="hljs-attr">"messageRegex"</span>: <span class="hljs-string">".*bye-bye.*"</span>
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Outdated tests"</span>,
    <span class="hljs-attr">"matchedStatuses"</span>: [<span class="hljs-string">"broken"</span>],
    <span class="hljs-attr">"traceRegex"</span>: <span class="hljs-string">".*FileNotFoundException.*"</span>
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Product defects"</span>,
    <span class="hljs-attr">"matchedStatuses"</span>: [<span class="hljs-string">"failed"</span>]
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Test defects"</span>,
    <span class="hljs-attr">"matchedStatuses"</span>: [<span class="hljs-string">"broken"</span>]
  }
]
</code></pre>
<ul data-nodeid="8577">
<li data-nodeid="8578">
<p data-nodeid="8579">然后，把文件 <strong data-nodeid="8911">categories.json</strong> 拷贝到你在执行测试用例时设置的 allure 报告目录下，在本例中为 <strong data-nodeid="8912">allure_results</strong> 这个目录。</p>
</li>
<li data-nodeid="8580">
<p data-nodeid="8581">最后，执行如下命令：</p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="8582"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8583">你会发现 Categories 里出现了我们刚刚配置的值 Ignored tests：</p>
<p data-nodeid="8584"><img src="https://s0.lgstatic.com/i/image/M00/72/C8/Ciqc1F_Ey2-AAf2rAADu51OZMIw212.png" alt="图片11.png" data-nodeid="8917"></p>
<h4 data-nodeid="8585">4.显示历次运行的 trends</h4>
<p data-nodeid="8586">同样地，默认生成的 Allure 报告不包括历次运行信息 Trends，如果想添加历次运行信息到Trends，步骤如下。</p>
<ul data-nodeid="8587">
<li data-nodeid="8588">
<p data-nodeid="8589">执行完测试后，不要执行 allure serve 命令，转而执行 allure generate。</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="8590"><code data-language="python">allure generate ./allure_results
</code></pre>
<p data-nodeid="8591">这个操作会生成一个新的文件夹，名为 allure-report。拷贝 allure-report 文件夹下的 history 文件夹，及其子文件夹到 allure_results 这个目录中。</p>
<ul data-nodeid="8592">
<li data-nodeid="8593">
<p data-nodeid="8594">在新的一次测试执行后执行 allure serve，即可把历史记录带到 Allure 报告中。</p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="8595"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8596">执行完后，打开 Allure 测试报告，你将看到 Trend 的内容。</p>
<p data-nodeid="8597"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_Ey3iAILzPAADDNRhR5wE627.png" alt="图片12.png" data-nodeid="8928"></p>
<h4 data-nodeid="8598">5.为 Allure 测试报告添加执行人</h4>
<p data-nodeid="8599">同样地，默认的 Allure 测试报告也不显示 Executor，这是因为 Executor 通常是由 Builder 自动生成的，比如通过 Jenkins plugin<a href="http://wiki.jenkins-ci.org/display/JENKINS/Allure+Plugin" data-nodeid="8933">Allure Jenkins Plugin</a> 来生成。</p>
<blockquote data-nodeid="8600">
<p data-nodeid="8601">关于如何使用 Allure Jenkins Plugin 配置 Allure，你可以在课后另外了解。</p>
</blockquote>
<ul data-nodeid="8602">
<li data-nodeid="8603">
<p data-nodeid="8604">当然你也可以自己生成， 首先创建名称为<strong data-nodeid="8941">executor.json</strong> 的文件，内容如下：</p>
</li>
</ul>
<pre class="lang-json" data-nodeid="8605"><code data-language="json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"iTesting"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"jenkins"</span>,
  <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://helloqa.com"</span>,
  <span class="hljs-attr">"buildOrder"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"buildName"</span>: <span class="hljs-string">"allure-report_deploy#1"</span>,
  <span class="hljs-attr">"buildUrl"</span>: <span class="hljs-string">"http://helloqa.com#1"</span>,
  <span class="hljs-attr">"reportUrl"</span>: <span class="hljs-string">"http://helloqa.com#1/AllureReport"</span>,
  <span class="hljs-attr">"reportName"</span>: <span class="hljs-string">"iTesting Allure Report"</span>
}
</code></pre>
<ul data-nodeid="8606">
<li data-nodeid="8607">
<p data-nodeid="8608">然后，拷贝 <strong data-nodeid="8953">executor.json</strong> 到 <strong data-nodeid="8954">allure_results</strong> 这个目录中去。</p>
</li>
<li data-nodeid="8609">
<p data-nodeid="8610">最后， 执行如下命令即可：</p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="8611"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8612">执行完后，打开 Allure 测试报告，你将看到 Executor 的信息：</p>
<p data-nodeid="8613"><img src="https://s0.lgstatic.com/i/image/M00/72/C9/Ciqc1F_Ey4iAPkZGAAEEPbshx8s382.png" alt="图片13.png" data-nodeid="8959"></p>
<h4 data-nodeid="8614">6.Allure 测试报告实现错误自动截图</h4>
<p data-nodeid="8615">在测试时，特别是 UI 自动化测试错误发生时，我们会想通过系统截图的方式，来更清楚地了解系统当时的状态，于是错误截图就很必要。</p>
<p data-nodeid="8616">使用 Allure 自动实现错误截图，可以参考下我在本讲 conftest.py 这个文件中定义的如下函数：</p>
<pre class="lang-plain" data-nodeid="8617"><code data-language="plain">pytest_runtest_makereport
</code></pre>
<p data-nodeid="8618">现在，我们来看下错误截图的实际效果。<br>
首先，通过如下命令运行所有测试：</p>
<pre class="lang-python" data-nodeid="8619"><code data-language="python">pytest -s&nbsp; -v --alluredir=./allure_results --flag --browser chrome
</code></pre>
<p data-nodeid="8620">执行成功后，通过如下命令打开测试报告：</p>
<pre class="lang-plain" data-nodeid="8621"><code data-language="plain">allure serve ./allure_results
</code></pre>
<p data-nodeid="8622">可以看到如下结果：</p>
<p data-nodeid="8623"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_Ey5OAaEzMAAHmNLdCM-o051.png" alt="图片14.png" data-nodeid="8970"></p>
<p data-nodeid="8624">点击图中的 <strong data-nodeid="8980">“FEATURES BY STORIES”，</strong> 进入 <strong data-nodeid="8981">Behaviors</strong> 页面，展开后你可以看到下图：</p>
<p data-nodeid="8625"><img src="https://s0.lgstatic.com/i/image/M00/72/C9/Ciqc1F_Ey6WAbEY8AAMRLlxLq50690.png" alt="图片15.png" data-nodeid="8984"></p>
<p data-nodeid="8626">可以看到，第 3 条测试用例执行失败了，截图信息也自动保存了。</p>
<h4 data-nodeid="8627">7.通过 Allure 测试报告查看测试用例详情</h4>
<p data-nodeid="8628">Allures 生成后，我们可以通过点击左侧的导航栏，进入到不同的页面，观察 Allure 的不同维度的测试分析。这里我不再一一阐述，我重点分享一下如下页面：</p>
<p data-nodeid="8629"><img src="https://s0.lgstatic.com/i/image/M00/72/D4/CgqCHl_Ey62APFSEAALVV7C1Jes905.png" alt="图片16.png" data-nodeid="8990"></p>
<p data-nodeid="8630">你点击任何一条测试用例，都能在 OverView 里看到这个测试用例的详细情况，包括测试所属的模块、测试用例的重要程度，以及这个测试用例对应 Jira 的 story 等信息，非常清晰明了。</p>
<h3 data-nodeid="8631">自研的测试报告</h3>
<p data-nodeid="8632">除了用 Allure 来生成测试报告外，你的测试报告也可以自研，那么自研怎么操作呢？</p>
<p data-nodeid="8633">最简单的方式是你写一个 HTML 模板，然后把涉及运行信息的要素，比如运行环境、执行人、测试成功条数、测试失败条数定义为变量，然后在你的自研框架运行完后，把这些变量替换为真实的值即可。</p>
<p data-nodeid="8634">至于图表的操作，你可以使用 hicharts、echarts 等图表可视化工具完成。因为这里涉及 HTML 还有一些前端的代码知识，我就不再详细介绍。</p>
<h3 data-nodeid="8635">总结</h3>
<p data-nodeid="8636">通过本章的学习，你应该对如何在 pytest 中应用 Allure 测试报告非常熟悉了，对于自研的测试报告的实现原理你应该也能有一点了解。</p>
<p data-nodeid="8637">测试报告在测试中的重要性不言而喻，一个好的测试报告，不仅可以让项目中的每个人时刻了解当前项目的质量情况，还可以通过对历史版本的测试报告进行分析，提炼出软件质量的演变过程。</p>
<p data-nodeid="8638">除此之外，一个美观、功能齐全的测试报告，也能让项目管理者更加理解测试工程师的辛勤付出，更助于项目组获取更多的资源支持，可见测试报告在技术之外的重要性。</p>
<p data-nodeid="14587" class="">好的，我是蔡超，我们下节课再见。</p>







<p data-nodeid="17061">关于更多开发测试报告的内容，可以关注我的公众号 iTesting 并回复“测试报告”进行查阅。</p>
<hr data-nodeid="18300">
<p data-nodeid="18301" class="te-preview-highlight"><a href="https://wj.qq.com/s2/7506053/9b01" data-nodeid="18304">课程评价入口，挑选 5 名小伙伴赠送小礼品～</a></p>

---

### 精选评论

##### **0423：
> 老师用allure generate可以生成测试报告，但是没有测试数据啊

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 请确认下前期Allure的配置是否正确，包括有没有历史版本的allure， 你的测试结果跑出来了没有。可以参考第10节看看allure如何配置（10 | 你的第一个 API 测试框架（二）在这一节）。

