<p data-nodeid="12506" class="">欢迎来到第 10 课时，进入“API 测试框架”的第二个部分。上一课时我们介绍了 Requests，以及测试框架核心模块 pytest，这一课时我将深入讲解 pytest 的使用，这节课的知识内容如下。</p>






<p data-nodeid="3334"><img src="https://s0.lgstatic.com/i/image/M00/5D/4A/Ciqc1F-EHU-ABZ8aAADaqpxn2Rw509.png" alt="Drawing 0.png" data-nodeid="3660"></p>
<h3 data-nodeid="3335">融会贯通 pytest 使用</h3>
<h4 data-nodeid="3336">1. pytest 运行方式详解及其参数</h4>
<p data-nodeid="109250" class="">pytest 有两个测试运行方式，命令行运行和 pytest.main() 运行。</p>


























































<ul data-nodeid="3338">
<li data-nodeid="3339">
<p data-nodeid="3340"><strong data-nodeid="3669">命令行运行</strong></p>
</li>
</ul>
<p data-nodeid="112586" class="">pytest 支持在命令行中以如下方式运行：</p>


<pre class="lang-python" data-nodeid="3342"><code data-language="python">&nbsp;python -m pytest [...]
</code></pre>
<ul data-nodeid="3343">
<li data-nodeid="3344">
<p data-nodeid="3345"><strong data-nodeid="3674">pytest.main() 运行</strong></p>
</li>
</ul>
<p data-nodeid="3346">除了命令行运行方式外，pytest 还支持在程序中运行，在程序中运行的命令如下：</p>
<pre class="lang-python" data-nodeid="3347"><code data-language="python">pytest.main([...])
</code></pre>
<p data-nodeid="114254">不管是使用命令行运行或者使用 pytest.main() 的方式运行，它们支持的参数都是一样的。<strong data-nodeid="114260">需要注意的是：pytest 的参数必须放在一个 list 或者 tuple 里。</strong></p>
<p data-nodeid="114255" class=""><strong data-nodeid="114264">pytest 参数</strong></p>

<p data-nodeid="3349">pytest 支持特别多的参数，具体有哪些参数可以通过如下命令查看：</p>
<pre class="lang-python" data-nodeid="3350"><code data-language="python">pytest --help
</code></pre>
<p data-nodeid="119277">在这里，我列出我们在工作中常用的几个。</p>
<p data-nodeid="119278"><strong data-nodeid="119283">-m: 用表达式指定多个标记名。</strong></p>



<p data-nodeid="120950" class="">pytest 提供了一个装饰器 @pytest.mark.xxx，用于标记测试并分组（xxx是你定义的分组名），以便你快速选中并运行，各个分组直接用 and、or 来分割。</p>

<p data-nodeid="3353"><strong data-nodeid="3697">-v: 运行时输出更详细的用例执行信息</strong></p>
<p data-nodeid="3354">不使用 -v 参数，运行时不会显示运行的具体测试用例名称；使用 -v 参数，会在 console 里打印出具体哪条测试用例被运行。</p>
<p data-nodeid="3355"><strong data-nodeid="3702">-q: 类似 unittest 里的&nbsp;verbosity，用来简化运行输出信息。</strong></p>
<p data-nodeid="3356">使用 -q 运行测试用例，仅仅显示很简单的运行信息， 例如：</p>
<pre class="lang-java" data-nodeid="3357"><code data-language="java">.s..&nbsp;  [<span class="hljs-number">100</span>%]
<span class="hljs-number">3</span> passed, <span class="hljs-number">1</span> skipped in <span class="hljs-number">9.60</span>s
</code></pre>
<p data-nodeid="3358"><strong data-nodeid="3709">-k: 可以通过表达式运行指定的测试用例。</strong><br>
它是一种模糊匹配，用 and 或 or 区分各个关键字，匹配范围有文件名、类名、函数名。</p>
<p data-nodeid="3359"><strong data-nodeid="3713">-x: 出现一条测试用例失败就退出测试。</strong></p>
<p data-nodeid="3360">在调试时，这个功能非常有用。当出现测试失败时，停止运行后续的测试。</p>
<p data-nodeid="3361">以上这些命令，我将把它们融合进日常工作场景，逐个向大家介绍。</p>
<h4 data-nodeid="3362">2.运行指定文件夹下的测试用例</h4>
<p data-nodeid="3363">pytest 支持更简单的方法实现指定文件夹运行：</p>
<pre class="lang-python" data-nodeid="3364"><code data-language="python"><span class="hljs-comment"># 执行所有当前文件夹及子文件夹下的所有测试用例</span>
pytest .
<span class="hljs-comment"># 执行跟当前文件夹同级的tests文件夹及子文件夹下的所有测试用例</span>
pytest ../tests
</code></pre>
<p data-nodeid="3365">除此之外，pytest 还允许你通过更复杂的方式来<strong data-nodeid="3723">挑选测试用例执行</strong>。例如，我们可以通过 -m 或者 -k 的参数，把我们的测试用例限制在某一个文件夹下，这样就实现了仅允许指定文件夹下的测试用例。</p>
<blockquote data-nodeid="3366">
<p data-nodeid="3367">关于 -m 和 -k 的使用，请看接下来我要讲的 <strong data-nodeid="3733">“动态挑选测试用例运行 — 按 Tag”</strong> 及 <strong data-nodeid="3734">“动态挑选测试用例运行 — 按名称”</strong> 这两个部分。</p>
</blockquote>
<h4 data-nodeid="3368">3.选择测试用例执行</h4>
<p data-nodeid="3369">pytest 里选择测试用例执行有很多方法，可以按照测试文件夹、测试文件、测试类和测试方法四种。</p>
<ul data-nodeid="3370">
<li data-nodeid="3371">
<p data-nodeid="3372"><strong data-nodeid="3740">按照测试文件夹执行</strong></p>
</li>
</ul>
<p data-nodeid="3373">在刚刚**“运行指定文件夹下的测试用例”**中已经详细说明，我不再赘述。</p>
<ul data-nodeid="3374">
<li data-nodeid="3375">
<p data-nodeid="3376"><strong data-nodeid="3751">按照测试文件执行</strong></p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3377"><code data-language="python"><span class="hljs-comment"># 运行test_lagou.py下的所有的测试用例</span>
pytest test_lagou.py
</code></pre>
<ul data-nodeid="3378">
<li data-nodeid="3379">
<p data-nodeid="3380"><strong data-nodeid="3755">按照测试类执行</strong></p>
</li>
</ul>
<p data-nodeid="3381">按照测试类执行，必须以如下格式：</p>
<p data-nodeid="3382">pytest 文件名 .py:: 测试类，其中“::”是分隔符，用于分割测试 module 和测试类。</p>
<pre class="lang-python" data-nodeid="3383"><code data-language="python"><span class="hljs-comment"># 运行test_lagou.py文件下的，类名是TestLaGou下的所有测试用例</span>
pytest test_lagou.py::TestLaGou
</code></pre>
<ul data-nodeid="3384">
<li data-nodeid="3385">
<p data-nodeid="3386"><strong data-nodeid="3761">按照测试方法执行</strong></p>
</li>
</ul>
<p data-nodeid="3387">同样的测试方法执行，必须以如下格式：</p>
<p data-nodeid="3388">pytest 文件名 .py:: 测试类 :: 测试方法，其中 “::” 是分隔符，用于分割测试 module、测试类，以及测试方法。</p>
<pre class="lang-python" data-nodeid="3389"><code data-language="python"><span class="hljs-comment"># 运行test_lagou.py文件下的，类名是TestLaGou下的，名字为test_get_new_message的测试用例 </span>
pytest test_lagou.py::TestLaGou::test_get_new_message
</code></pre>
<ul data-nodeid="3390">
<li data-nodeid="3391">
<p data-nodeid="3392"><strong data-nodeid="3767">不在命令行执行，在程序中执行</strong></p>
</li>
</ul>
<p data-nodeid="3393">以上选择测试用例执行的方法，可以不在命令行，而直接在测试程序里执行，其语法为<br>
pytest.main([模块.py::类::方法])</p>
<h4 data-nodeid="3394">4.动态挑选测试用例运行 — 按 Tag</h4>
<p data-nodeid="124286" class="">动态挑选测试用例一直是测试框架的刚需，在 pytest 里动态挑选测试用例需要借助两个步骤。</p>


<ul data-nodeid="3396">
<li data-nodeid="3397">
<p data-nodeid="3398">首先给测试用例打标签（mark），在 Class、method 上加上如下装饰器：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3399"><code data-language="python"><span class="hljs-meta">@pytest.mark.xxx</span>
</code></pre>
<ul data-nodeid="3400">
<li data-nodeid="3401">
<p data-nodeid="3402">在运行时，命令行动态指定标签运行：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3403"><code data-language="python"><span class="hljs-comment"># 同时选中带有这两个标签的所有测试用例运行</span>
pytest -m <span class="hljs-string">"mark1 and mark2"</span>
<span class="hljs-comment"># 选中带有mark1的测试用例，不运行mark2的测试用例</span>
pytest -m <span class="hljs-string">"mark1 and not mark2"</span>&nbsp;
<span class="hljs-comment"># 选中带有mark1或 mark2标签的所有测试用例</span>
pytest -m <span class="hljs-string">"mark1 or mark2"</span>
</code></pre>
<p data-nodeid="3404">下面来实际演示下，仍然以我们的项目 lagouTest 为例，我们更改 tests 文件夹下的两个文件，<br>
其中对 test_baidu.py 文件的修改如下：</p>
<pre class="lang-python" data-nodeid="3405"><code data-language="python"><span class="hljs-comment"># test_baidu.py下更改</span>
<span class="hljs-keyword">import</span> pytest
<span class="hljs-comment"># 在Baidu这个类上加标签baidu</span>
<span class="hljs-meta">@pytest.mark.baidu</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baidu</span>(<span class="hljs-params">unittest.TestCase</span>):</span>
<span class="hljs-comment"># 以下代码皆不变</span>
</code></pre>
<p data-nodeid="3406">对 test_lagou.py 文件的修改如下：</p>
<pre class="lang-python" data-nodeid="3407"><code data-language="python"><span class="hljs-comment"># test_lagou.py下更改</span>
<span class="hljs-keyword">import</span> pytest
<span class="hljs-comment"># 在TestLaGou这个类上加标签lagou</span>
<span class="hljs-meta">@pytest.mark.lagou</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLaGou</span>:</span>
<span class="hljs-comment"># 以下代码皆不变</span>
</code></pre>
<p data-nodeid="3408">我给这两个测试类分别加上了标签 baidu 和标签 lagou，现在我们按需运行下：</p>
<pre class="lang-java" data-nodeid="3409"><code data-language="java">pytest -v -m <span class="hljs-string">"lagou and not baidu"</span>
</code></pre>
<p data-nodeid="3410"><img src="https://s0.lgstatic.com/i/image/M00/5D/55/CgqCHl-EHYmAOi13AABotxo1Vw4813.png" alt="Drawing 1.png" data-nodeid="3790"></p>
<p data-nodeid="3411">可以看到标记为 lagou 下面的 2 条测试用例都被执行了，但是 baidu 标签下的 2 条都没有被执行，在 Console 中显示 “2 deselected”。</p>
<p data-nodeid="3412">同样地，我们还可以用以下命令，运行所有包含 lagou 和 baidu 标签的测试用例。</p>
<pre class="lang-java" data-nodeid="3413"><code data-language="java">pytest -v -m <span class="hljs-string">"lagou and baidu"</span>
</code></pre>
<p data-nodeid="127637">请注意，不同标签之间的分割要使用<strong data-nodeid="127648">and</strong>或者<strong data-nodeid="127649">or</strong>关键字。</p>
<p data-nodeid="127638"><strong data-nodeid="127653">在这里给你布置一个课外作业：</strong></p>



<p data-nodeid="3415">如果给一个类打了一个标签叫作 toRun，然后给这个类下的某一个方法也打了一个标签叫作 notToRun， 如果我在命令行中输入以下命令，运行状况是什么呢？</p>
<pre class="lang-python" data-nodeid="3416"><code data-language="python">pytest -v -m <span class="hljs-string">"toRun and not notToRun"</span>
</code></pre>
<p data-nodeid="3417">如果我输入以下的命令，运行情况又是怎么样呢？</p>
<pre class="lang-python" data-nodeid="3418"><code data-language="python">pytest -m <span class="hljs-string">"notToRun and not toRun"</span>
</code></pre>
<h4 data-nodeid="3419">5.动态挑选测试用例运行 — 按名称</h4>
<p data-nodeid="3420">pytest 中，动态挑选测试用例，除了打标签（mark）外，还有另外一种方式：</p>
<pre class="lang-java" data-nodeid="3421"><code data-language="java"># -k 参数是按照文件名、类名、方法名来模糊匹配的
pytest -k xxxPattern
</code></pre>
<p data-nodeid="3422">下面来详细演示下，我们的项目文件结构如下：</p>
<pre class="lang-java" data-nodeid="3423"><code data-language="java">|--lagouAPITest
    |--tests
        |--test_baidu.py
        |--test_lagou.py
        |--__init__.py
    |--common
        |--__init__.py
    |--__init__.py
</code></pre>
<p data-nodeid="3424">其中：</p>
<ul data-nodeid="3425">
<li data-nodeid="3426">
<p data-nodeid="3427">test_baidu.py 里定义了一个测试类 Baidu， 这个测试类下有两个测试方法 test_baidu_search 和 test_baidu_set；</p>
</li>
<li data-nodeid="3428">
<p data-nodeid="3429">test_lagou.py 中定义了一个测试类 TestLaGou，这个测试类下面有两个测试方法 test_visit_lagou 和 test_get_new_message。</p>
</li>
</ul>
<p data-nodeid="3430">在命令行中以如下方式运行。</p>
<ul data-nodeid="3431">
<li data-nodeid="3432">
<p data-nodeid="3433">按照文件名称全匹配：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3434"><code data-language="python"><span class="hljs-comment"># 运行test_lagou.py下的所有的测试</span>
pytest -k <span class="hljs-string">"test_lagou.py"</span>
</code></pre>
<ul data-nodeid="3435">
<li data-nodeid="3436">
<p data-nodeid="3437">按照文件名字部分匹配：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3438"><code data-language="python"><span class="hljs-comment"># 因为lagou能匹配上test_lagou.py,故运行test_lagou.py下所有的测试</span>
pytest -k <span class="hljs-string">"lagou"</span>
</code></pre>
<ul data-nodeid="3439">
<li data-nodeid="3440">
<p data-nodeid="3441">按照类名匹配：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3442"><code data-language="python"><span class="hljs-comment"># 因为Baidu能匹配上test_baidu.py里定义的测试类Baidu,故运行Baidu测试类下所有的测试。 你也可以写成Bai</span>
pytest -k <span class="hljs-string">"Baidu"</span>
</code></pre>
<ul data-nodeid="3443">
<li data-nodeid="3444">
<p data-nodeid="3445">按照方法名匹配：</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3446"><code data-language="python"><span class="hljs-comment"># message只能匹配test_lagou.py中定义的测试类TestLaGou下的测试方法test_get_new_message， 故仅有test_get_new_message这个方法会执行</span>
pytest -k <span class="hljs-string">"message"</span>
</code></pre>
<h4 data-nodeid="3447">6.忽略测试用例执行</h4>
<p data-nodeid="3448">有挑选测试用例执行，那么就一定会有忽略测试用例执行，忽略测试用例执行有如下 3 种方式：</p>
<ul data-nodeid="3449">
<li data-nodeid="3450">
<p data-nodeid="3451"><strong data-nodeid="3849">直接忽略测试执行</strong></p>
</li>
</ul>
<p data-nodeid="3452">直接忽略可以使用 @pytest.mark.skip 装饰器来实现。</p>
<pre class="lang-python" data-nodeid="3453"><code data-language="python"><span class="hljs-comment"># test_lagou.py</span>
<span class="hljs-meta">@pytest.mark.skip(reason='skip此测试用例')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_new_message</span>:</span>
  <span class="hljs-comment"># 实现方法</span>
</code></pre>
<p data-nodeid="3454">比如，在 test_lagou.py 里，我定义了一个测试方法 test_get_new_message，然后我给他加上装饰器 pytest.mark.skip，那么当我在命令行中执行如下语句时，test_get_new_message 将会被忽略执行：</p>
<pre class="lang-python" data-nodeid="3455"><code data-language="python">pytest test_lagou.py
</code></pre>
<ul data-nodeid="3456">
<li data-nodeid="3457">
<p data-nodeid="3458"><strong data-nodeid="3869">按条件忽略测试执行 — 使用 skipif 忽略</strong></p>
</li>
</ul>
<p data-nodeid="3459">按 skipif 条件，当条件符合时便会忽略某条测试用例执行。</p>
<pre class="lang-python" data-nodeid="3460"><code data-language="python"><span class="hljs-comment"># test_lagou.py </span>
<span class="hljs-comment"># 定义一个flag，用来指示是否要skip一个测试用例</span>
flag = <span class="hljs-number">1</span>
 
<span class="hljs-comment"># 此处判断flag的值，为1则忽略，0则不忽略 </span>
<span class="hljs-meta">@pytest.mark.skipif(flag == 1, reason='by condition')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_get_new_message</span>:</span>
  <span class="hljs-comment"># 实现方法</span>
</code></pre>
<p data-nodeid="3461">当我在命令行中执行如下语句时，test_get_new_message 将会被忽略执行：</p>
<pre class="lang-python" data-nodeid="3462"><code data-language="python">pytest test_lagou.py
</code></pre>
<p data-nodeid="3463">更改 flag 的值为 0 ，再次运行这条语句，你将发现此方法将会被执行。</p>
<ul data-nodeid="3464">
<li data-nodeid="3465">
<p data-nodeid="3466"><strong data-nodeid="3882">按条件忽略测试执行 — 使用 -m 或者 -k 忽略</strong></p>
</li>
</ul>
<p data-nodeid="3467">除了 skip 和 skipif 外，我们也可以通过 -m 或者 -k 的方式，把我们不需要运行的测试用例给过滤掉，从而实现测试用例的忽略执行。在刚刚的内容中便详细讲解了 -m 和 -k 的具体用法，你可详细回顾一下。</p>
<h4 data-nodeid="3468">7.setUp 和 tearDown 详解</h4>
<p data-nodeid="128487" class="">我们在“07 | 你的第一个 Web 测试框架（一）”（“Test Fixture 的使用”部分）中便讲解了如何在 unittest 中使用 setUp 和 tearDown 方法实现测试执行前的准备工作和测试执行后的清理工作。</p>

<p data-nodeid="3470">其实在 pytest 里也有类似的方法，而且在粒度上更加精细。</p>
<p data-nodeid="3471"><strong data-nodeid="3892">（1）按 module 进行 setup 和 tear down</strong></p>
<p data-nodeid="3472">按 module 进行 setup 和 tear down，即在某一个 module 内 setup 或者 tear down 的方法只会执行一次，pytest 里用于 module 的 set up 和 tear down 方法为：</p>
<pre class="lang-python" data-nodeid="3473"><code data-language="python"><span class="hljs-keyword">import</span> pytest
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup_module</span>(<span class="hljs-params">module</span>):</span>
    <span class="hljs-string">"""
    module级别的setup，直接定义为一个module里的函数
    在本module里所有test执行之前，被调用一次
    """</span>
    <span class="hljs-comment">## 你的set up代码，例如：</span>
    print(<span class="hljs-string">"------ set up for module ------"</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teardown_module</span>(<span class="hljs-params">module</span>):</span>
  <span class="hljs-string">"""
    module级别的setup，直接定义为一个module里的函数
    在本module里所有test执行之后，被调用一次
    """</span>
    <span class="hljs-comment">## 你的tear down代码，例如：</span>
    print(<span class="hljs-string">"------ tead down for module ------"</span>)
</code></pre>
<p data-nodeid="3474">需注意以下几个事情：</p>
<ul data-nodeid="131845">
<li data-nodeid="131846">
<p data-nodeid="131847">setup_module(module) 和 teardown_module(module) 的写法最好不要改动；</p>
</li>
<li data-nodeid="131848">
<p data-nodeid="131849">当 setup_module 出错，teardown_module 不会被执行；</p>
</li>
<li data-nodeid="131850">
<p data-nodeid="131851" class="">一个 module（.py 文件）可以包括多个 Class，多个classs 下可能有多个 case，但是 setup_module 和 teardown_module 只会执行一次。</p>
</li>
</ul>


<p data-nodeid="3482"><strong data-nodeid="3913">（2）按 class 进行 setup 和 tear down</strong></p>
<p data-nodeid="3483">在某一个测试类内，同样可以进行 set up 和 tear down。</p>
<pre class="lang-python" data-nodeid="3484"><code data-language="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Baidu</span>(<span class="hljs-params">object</span>):</span>
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setup_class</span>(<span class="hljs-params">cls</span>):</span>
        <span class="hljs-string">""" 
        仅在当前测试类下的所有test执行之前，被调用一次
        注意它必须以@classmethod装饰
        """</span>
        <span class="hljs-comment">## 你的set up代码，例如：</span>
        print(<span class="hljs-string">"------ set up for class------"</span>)
<span class="hljs-meta">    @classmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teardown_class</span>(<span class="hljs-params">cls</span>):</span>
        <span class="hljs-string">""" 
        仅在当前测试类下的所有test执行之后，被调用一次
        注意它必须以@classmethod装饰
        """</span>
        <span class="hljs-comment">## 你的tear down代码，例如：</span>
        print(<span class="hljs-string">"------tear down for class------"</span>)
</code></pre>
<p data-nodeid="3485">需注意以下几个事情：</p>
<ul data-nodeid="3486">
<li data-nodeid="3487">
<p data-nodeid="3488">setup_class(cls) 和 teardown_class(cls) 的写法最好不要改动。</p>
</li>
<li data-nodeid="3489">
<p data-nodeid="3490">setup_class(cls) 和 teardown_class(cls) 必须以 @classmethod 装饰。</p>
</li>
<li data-nodeid="3491">
<p data-nodeid="3492">当 setup_class(cls) 出错，teardown_class(cls) 不会被执行。</p>
</li>
</ul>
<p data-nodeid="3493"><strong data-nodeid="3934">（3）按 method 进行 setup 和 tear down</strong></p>
<p data-nodeid="3494">针对每一个测试用例，同样可以进行 set up 和 tear down。</p>
<pre class="lang-python" data-nodeid="3495"><code data-language="python">def setup_method(self, method):
        """ 
        在当前测试类里，每一个test执行之前，被调用一次
        """
        ## 你的set up代码，例如：
        print("------set up for method------）

    def teardown_method(self, method):
        """ 
        在当前测试类里，每一个test执行之前，被调用一次
        """
        ## 你的tear down代码，例如：
        print("------tear down for method------）
</code></pre>
<p data-nodeid="148545" class="">需注意以下两个事情：</p>










<ul data-nodeid="3497">
<li data-nodeid="3498">
<p data-nodeid="3499" class="">setup_method(self, method) 和 teardown_method(self, method) 的写法最好不要改动。</p>
</li>
<li data-nodeid="3500">
<p data-nodeid="3501">当 setup_method(self, method)用例执行失败时，teardown_method(self, method) 不会被执行。</p>
</li>
</ul>
<p data-nodeid="150213">setup 和 teardown 在我们测试开始和结束后准备/清理测试数据，系统状态时非常有用。</p>

<h4 data-nodeid="3503">8.使用 pytest.ini 文件破除默认 pattern，灵活命名测试文件</h4>
<p data-nodeid="167726" class="">我在上一课时的“pytest 查找测试用例的原则”部分说过，pytest 查找测试用例，会根据测试用例名，仅默认查找前缀以 _tes开头或者后缀以 _test 结尾的测试文件；而查找测试方法，仅查找测试类以 Test 开头，测试方法以 test 开头。</p>











<p data-nodeid="174372" class="">那有没有办法破除这一依赖呢？当然有，那就是使用 pytest.ini 文件。</p>



<p data-nodeid="171049" class="">pytest.ini 是 pytest 的主配置文件，可以改变 pytest 的默认行为。在项目根目录 lagoutAPITest 下新创建一个文件 pytest.ini，我们的项目结构就变成这样：</p>


<pre class="lang-dart" data-nodeid="3507"><code data-language="dart">|--lagouAPITest
    |--tests
        |--test_baidu.py
        |--test_lagou.py
        |--__init__.py
    |--common
        |--__init__.py
    |--__init__.py
    |--__pytest.ini
</code></pre>
<p data-nodeid="3508">pytest.ini 的内容如下：</p>
<pre class="lang-java" data-nodeid="3509"><code data-language="java">[pytest]
python_classes = *
python_files= *
python_functions = test*
</code></pre>
<p data-nodeid="3510">其中：</p>
<ul data-nodeid="3511">
<li data-nodeid="3512">
<p data-nodeid="3513">python_classes，表示要匹配的测试类的 pattern，*匹配所有。</p>
</li>
<li data-nodeid="3514">
<p data-nodeid="3515">python_files，表示要匹配的测试文件。</p>
</li>
<li data-nodeid="3516">
<p data-nodeid="3517">python_functions，表示要匹配的测试方法。</p>
</li>
</ul>
<p data-nodeid="3518">在这里我把 python_files 和 python_classes 均设置为*，表示任何 *.py 都将被认为是测试文件。任何名字的测试类都将被认为是测试类。</p>
<p data-nodeid="3519">下面我再次在根目录 lagouAPITest 下建立一个测试文件 sample.py，里面的内容如下：</p>
<pre class="lang-python" data-nodeid="3520"><code data-language="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>(<span class="hljs-params">object</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">1</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> != <span class="hljs-number">0</span>
</code></pre>
<p data-nodeid="176028" class="">我定义了一个 Sample 类，其中包括两个测试方法 test_equal 和 not_equal。然后我切换到项目根目录下，在命令行运行如下命令：</p>

<pre class="lang-java" data-nodeid="3522"><code data-language="java">D:\_Automation\lagouAPITest&gt;pytest
</code></pre>
<p data-nodeid="3523">结果如下：</p>
<pre class="lang-java" data-nodeid="3524"><code data-language="java">tests/sample.py::Sample::test_equal PASSED
</code></pre>
<p data-nodeid="3525">可以看到，sample.py 这个文件被当作了测试文件，并且 Sample 这个类也被 pytest 视为测试类，因为他们符合 pytest.ini 里的配置。</p>
<p data-nodeid="3526">而 Sample 类的两个测试方法中，test_equal 被执行，而 not_equal 没有被执行，因为我在 pytest.ini 里关于 python_functions 的配置是必须以 test 开头。</p>
<p data-nodeid="212376" class="">使用 pytest.ini 可以针对 pytest 做更多配置，做法如下所示。</p>






















<ul data-nodeid="3528">
<li data-nodeid="3529">
<p data-nodeid="3530"><strong data-nodeid="4005">注册标签：</strong></p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="3531"><code data-language="plain">[pytest]
markers = 
    smoke: run smoke test
    sanity: run sanity test
</code></pre>
<p data-nodeid="3532">你可以在 pytest.ini 里注册标签，并统一管理。<br>
在 pytest.ini 文件里注册标签并不意味着你不需要在测试类/测试方法里忽略 @pytest.mark.xxx 装饰器，你仍需要在你的测试用例上加上标签。</p>
<pre class="lang-python" data-nodeid="3533"><code data-language="python"><span class="hljs-comment"># 例如在sample.py文件里的Sample类上加标签</span>
<span class="hljs-meta">@pytest.mark.smoke</span>
Class Sample:
  <span class="hljs-comment"># 测试方法</span>
</code></pre>
<ul data-nodeid="3534">
<li data-nodeid="3535">
<p data-nodeid="3536"><strong data-nodeid="4012">指定测试目录</strong></p>
</li>
</ul>
<pre class="lang-plain" data-nodeid="3537"><code data-language="plain">[pytest]
testpaths=tests
</code></pre>
<p data-nodeid="214028">此方法把 testpaths 指定为 tests，当你在命令行中直接执行 pytest 时，会自动查询 testpaths 文件夹，如果没有设置 testpaths，则会自动从当前文件夹找起。</p>
<p data-nodeid="215692" class="">除了以上这些，pytest.ini 还有其他很多用处，例如<strong data-nodeid="215702">更改默认命令行参数、指定 pytest 最低版本号、指定忽略某些目录</strong>、<strong data-nodeid="215703">禁用 XPASS</strong> 等功能，大家有兴趣可以自行查询。</p>


<blockquote data-nodeid="3539">
<p data-nodeid="3540">另外，pytest 里查找测试用例的 pattern 是采用的 Glob 这个库，你可以进入 <a href="https://docs.python.org/3/library/glob.html" data-nodeid="4029">Python 官网</a>查看更多关于如何匹配 pattern 的内容。</p>
</blockquote>
<h4 data-nodeid="3541">9.数据驱动</h4>
<p data-nodeid="228912" class="">pytest 支持数据驱动，关于数据驱动，我将在后续的章节第 13、14 讲“DDT：博采众长，数据驱动的秘诀”中为你详细讲解。</p>








<h4 data-nodeid="3543">10.失败重跑测试用例</h4>
<p data-nodeid="3544">在测试执行中，偶尔会出现由于环境不稳定，或者网络不稳定造成的测试运行失败的情况，如果第一次运行就报错，那么势必会增加我们排查的工作量。</p>
<p data-nodeid="3545">所以 pytest 支持错误失败重跑，使用失败重跑机制的步骤如下：</p>
<ul data-nodeid="3546">
<li data-nodeid="3547">
<p data-nodeid="3548">安装</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3549"><code data-language="python">pip install -U pytest-rerunfailures
</code></pre>
<ul data-nodeid="3550">
<li data-nodeid="3551">
<p data-nodeid="3552">命令行执行失败重跑次数</p>
</li>
</ul>
<pre class="lang-python" data-nodeid="3553"><code data-language="python"><span class="hljs-comment"># 语法：</span>
--reruns Num。 其中Num是重跑的次数
</code></pre>
<p data-nodeid="3554">下面我们来实际看一个 re-run 的例子，我更改 sample.py 文件如下：</p>
<pre class="lang-python" data-nodeid="3555"><code data-language="python"><span class="hljs-keyword">import</span> pytest

<span class="hljs-meta">@pytest.mark.smoke</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sample</span>(<span class="hljs-params">object</span>):</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-comment"># 在这里，我让这个case失败，来演示re-run</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == <span class="hljs-number">0</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_equal</span>(<span class="hljs-params">self</span>):</span>
        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> != <span class="hljs-number">0</span>
</code></pre>
<p data-nodeid="3556">然后我们在命令行执行如下命令：</p>
<pre class="lang-python" data-nodeid="3557"><code data-language="python"><span class="hljs-comment"># sample.py目录为 D:\_Automation\lagouAPITest\tests</span>
<span class="hljs-comment"># 需切换至此目录执行</span>
pytest sample.py --reruns <span class="hljs-number">2</span>
</code></pre>
<p data-nodeid="3558">执行后观察测试输出，会发现如下信息“1 failed，2 rerun”：</p>
<p data-nodeid="3559"><img src="https://s0.lgstatic.com/i/image/M00/5D/56/CgqCHl-EHeOATmAKAABbpslTqbs982.png" alt="Drawing 2.png" data-nodeid="4049"></p>
<h4 data-nodeid="3560">11.并发运行测试用例集</h4>
<p data-nodeid="3561">当你的测试用例比较多时，最好可以通过并发测试来减少测试整体的运行时间。pytest 支持并发测试，并且有不同的并发测试库，其中如下两个比较著名：</p>
<ul data-nodeid="232188">
<li data-nodeid="232189">
<p data-nodeid="232190"><strong data-nodeid="232195">pytest-parallel</strong></p>
</li>
</ul>
<p data-nodeid="232191" class=""><strong data-nodeid="232200">安装</strong>：</p>


<pre class="lang-python" data-nodeid="3566"><code data-language="python">pip install pytest-parallel
</code></pre>
<p data-nodeid="233843" class=""><strong data-nodeid="233848">运行</strong>：使用 pytest-parallel&nbsp;运行，需要指定参数。</p>


<blockquote data-nodeid="3568">
<p data-nodeid="3569">–workers (optional)&nbsp; X</p>
</blockquote>
<p data-nodeid="3570">多进程运行， X 是进程数，默认值 1。</p>
<blockquote data-nodeid="3571">
<p data-nodeid="3572">–tests-per-worker (optional)&nbsp; &nbsp;X</p>
</blockquote>
<p data-nodeid="3573">多线程运行， X 是每个 worker 运行的最大并发线程数， 默认值1。</p>
<p data-nodeid="3574"><strong data-nodeid="4067">注意：这个插件仅仅支持 python 3.6 版本及以上，而且如果你想多进程并发，必须跑在 Unix 或者 Mac 机器上，windows 环境仅仅支持多线程运行。</strong></p>
<p data-nodeid="3575">运行命令如下：</p>
<pre class="lang-python" data-nodeid="3576"><code data-language="python">pytest --workers <span class="hljs-number">2</span> <span class="hljs-comment">#指定2个进程并发</span>
<span class="hljs-comment">#指定2个进程并发，每个进程最多运行3个线程</span>
pytest --workers <span class="hljs-number">2</span> --test-per-worker <span class="hljs-number">3</span>
</code></pre>
<ul data-nodeid="235499">
<li data-nodeid="235500">
<p data-nodeid="235501"><strong data-nodeid="235506">pytest-xdist</strong></p>
</li>
</ul>
<p data-nodeid="235502" class=""><strong data-nodeid="235511">安装</strong>：</p>


<pre class="lang-python" data-nodeid="3581"><code data-language="python">pip install pytest-xdist
</code></pre>
<p data-nodeid="237170" class=""><strong data-nodeid="237175">运行</strong>：</p>

<pre class="lang-python" data-nodeid="3583"><code data-language="python"><span class="hljs-comment"># 语法：</span>
pytest -n NUMCPUS
<span class="hljs-comment"># 以下为2个进程并行运行</span>
pytest -n <span class="hljs-number">2</span>
<span class="hljs-comment">#使用与CPU内核一样多的进程来并发</span>
pytest -n auto
</code></pre>
<p data-nodeid="3584"><strong data-nodeid="4078">从理论上来说，pytest-parallel 要更好一些，因为 pytest-xdist 有以下缺点：</strong></p>
<ul data-nodeid="3585">
<li data-nodeid="3586">
<p data-nodeid="3587">非线程安全</p>
</li>
<li data-nodeid="3588">
<p data-nodeid="3589">多线程时性能不佳</p>
</li>
<li data-nodeid="3590">
<p data-nodeid="3591">需要状态隔离</p>
</li>
</ul>
<p data-nodeid="3592">但是实际应用中，pytest-parallel 有时会出现如下运行错误：</p>
<pre class="lang-java" data-nodeid="3593"><code data-language="java">BrokenPipeError: [WinError <span class="hljs-number">109</span>] 管道已结束
</code></pre>
<p data-nodeid="3594">而且这个错误发生的原因不确定，官方暂时没有修复， 如果你在测试中发现这个错误，那么可以使用 pytest-xdist 来进行并发测试。</p>
<h3 data-nodeid="3595">pytest 集成测试报告</h3>
<p data-nodeid="3596">在 pytest 中集成测试报告也有两个方式：</p>
<h4 data-nodeid="3597">1.pytest-html</h4>
<p data-nodeid="3598">安装：</p>
<pre class="lang-java" data-nodeid="3599"><code data-language="java">pip install pytest-html
</code></pre>
<p data-nodeid="3600">使用：</p>
<pre class="lang-python" data-nodeid="3601"><code data-language="python">pytest --html=report.html
</code></pre>
<p data-nodeid="3602">以我们的项目 lagouAPITest 为例，在项目根目录下执行</p>
<pre class="lang-python" data-nodeid="3603"><code data-language="python">pytest --html=report.html
</code></pre>
<p data-nodeid="3604">然后在项目根目录下会生成一个 report.html 文件。</p>
<p data-nodeid="3605"><img src="https://s0.lgstatic.com/i/image/M00/5D/4B/Ciqc1F-EHfmAWUTzAAC0YsyYy9Y669.png" alt="Drawing 3.png" data-nodeid="4093"></p>
<p data-nodeid="3606">pytest-html 也可以支持 pytest-xdist，也就是说，如果你使用了pytest-xdist来进行并发测试， pytest-html也可以收集并发测试结果了。两者结合使用的命令如下：</p>
<pre class="lang-python" data-nodeid="3607"><code data-language="python">pytest -n <span class="hljs-number">3</span> --html=report.html --self-contained-html
</code></pre>
<p data-nodeid="3608">运行结束后查看结果如下：</p>
<p data-nodeid="3609"><img src="https://s0.lgstatic.com/i/image/M00/5D/4B/Ciqc1F-EHgGALE1NAAC6hgFUAO0670.png" alt="Drawing 4.png" data-nodeid="4098"></p>
<p data-nodeid="3610">pytest-html 还支持错误重试，使用如下命令运行</p>
<pre class="lang-python" data-nodeid="3611"><code data-language="python">pytest -n <span class="hljs-number">3</span> --html=report.html --self-contained-html --reruns <span class="hljs-number">2</span>
</code></pre>
<p data-nodeid="3612">运行结束你会发现，错误的测试用例被运行了 2 次。</p>
<p data-nodeid="3613"><img src="https://s0.lgstatic.com/i/image/M00/5D/56/CgqCHl-EHgeAQbaiAACTBJmZLww890.png" alt="Drawing 5.png" data-nodeid="4103"></p>
<h4 data-nodeid="3614">2.allure</h4>
<p data-nodeid="3615">使用 allure 生成测试报告的步骤如下。</p>
<ul data-nodeid="3616">
<li data-nodeid="3617">
<p data-nodeid="3618"><strong data-nodeid="4109">安装 allure</strong></p>
</li>
</ul>
<p data-nodeid="3619">在不同操作系统上安装 allure 的步骤是不同的。</p>
<p data-nodeid="3620"><strong data-nodeid="4114">MacOS：</strong></p>
<pre class="lang-java" data-nodeid="3621"><code data-language="java">brew install allure
</code></pre>
<p data-nodeid="3622"><strong data-nodeid="4118">Linux：</strong></p>
<pre class="lang-java" data-nodeid="3623"><code data-language="java">sudo apt-add-repository ppa:qameta/allure
sudo apt-get update&nbsp;
sudo apt-get install allure
</code></pre>
<p data-nodeid="3624"><strong data-nodeid="4124">Windows：</strong><br>
在 Windows 上安装 allure，首先要安装 Scoop，Scoop 的安装步骤如下：</p>
<pre class="lang-java" data-nodeid="3625"><code data-language="java"># 以Win10为例：
1. 使用快捷键 Win + R 调起运行提示框
2. 输入“cmd”进入到命令行
3. 输入“powershell”进入到powershell模式（此时你的命令提示应该以PS开始）
4. 确保你的PowerShell版本大于5.0，命令如下：
$psversiontable.psversion.major # 这个运行后出现的值应该&gt;=5.0
5. 允许PowerShell 执行本地脚本：
set-executionpolicy remotesigned -scope currentuser
6. 安装Scoop
Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')
</code></pre>
<p data-nodeid="3626">使用上述方式安装好后，你应该可以看到如下界面：</p>
<p data-nodeid="3627"><img src="https://s0.lgstatic.com/i/image/M00/5D/4B/Ciqc1F-EHheAZlvIAAAvur73UMc511.png" alt="Drawing 6.png" data-nodeid="4128"></p>
<p data-nodeid="3628">安装好 Scoop 后，不要关闭 powershell，直接输入如下命令安装 allure：</p>
<pre class="lang-java" data-nodeid="3629"><code data-language="java">PS C:\Users\Admin&gt;scoop install allure
</code></pre>
<p data-nodeid="3630">安装好后，你将看到如下界面：</p>
<p data-nodeid="3631"><img src="https://s0.lgstatic.com/i/image/M00/5D/56/CgqCHl-EHiCAKqtcAAAkfEMMpH8475.png" alt="Drawing 7.png" data-nodeid="4133"></p>
<p data-nodeid="3632">如果你之前安装过 allure，也可以通过如下方式更新：</p>
<pre class="lang-java" data-nodeid="3633"><code data-language="java">PS C:\Users\Admin&gt;scoop update allure
</code></pre>
<p data-nodeid="3634">你还可以查看当前使用的 allure 版本：</p>
<pre class="lang-java" data-nodeid="3635"><code data-language="java">PS C:\Users\Admin&gt;allure --version
</code></pre>
<ul data-nodeid="3636">
<li data-nodeid="3637">
<p data-nodeid="3638"><strong data-nodeid="4139">执行 pytest 命令，并指定 allure 报告目录</strong></p>
</li>
</ul>
<p data-nodeid="3639">可以直接在命令行里执行：</p>
<pre class="lang-python" data-nodeid="3640"><code data-language="python"><span class="hljs-comment"># 直接执行lagouAPITest项目下的所有测试用例，并将测试报告文件夹allure_reports放在项目根目录下</span>
D:\_Automation\lagouAPITest&gt;pytest --alluredir=./allure_reports
</code></pre>
<p data-nodeid="3641">还可以在程序里执行：</p>
<pre class="lang-python" data-nodeid="3642"><code data-language="python"><span class="hljs-comment"># 执行所有的标记为smoke的测试用例，并且报告文件夹设置为allure_reports</span>
pytest.main([<span class="hljs-string">"-m"</span>, <span class="hljs-string">"smoke"</span>, 
             <span class="hljs-string">"--alluredir=./allure_reports"</span>])
</code></pre>
<ul data-nodeid="3643">
<li data-nodeid="3644">
<p data-nodeid="3645"><strong data-nodeid="4145">打开 allure 报告</strong></p>
</li>
</ul>
<p data-nodeid="3646">测试执行完成后，通过以下方式打开生成的 allure 报告：</p>
<pre class="lang-plain" data-nodeid="3647"><code data-language="plain"># 以Win10为例：
1. 使用快捷键 Win + R 调起运行提示框
2. 输入“cmd”进入到命令行
3. 切换目录到项目根目录，本例中在D:\_Automation\lagouAPITest&gt;：
4. 输入命令生成allure报告：
allure serve allure_reports
</code></pre>
<p data-nodeid="3648">需要注意的是，allure_reports 文件夹就是我们在第 2 步中定义的 allure 报告文件夹所在的位置，命令执行后，会自动打开 allure 测试报告：</p>
<p data-nodeid="3649"><img src="https://s0.lgstatic.com/i/image/M00/5D/4B/Ciqc1F-EHi2AemzEAADkfPwy6Xg873.png" alt="Drawing 8.png" data-nodeid="4152"></p>
<p data-nodeid="3650">更多关于测试报告的技巧，我将在 <strong data-nodeid="4160">“23 | 对外输出，让测试报告自己说话”</strong> 一节中向你详细介绍。</p>
<p data-nodeid="3651">至此，我们的第一个 API 接口自动化测试框架已经全部完成。</p>
<h3 data-nodeid="3652">总结</h3>
<p data-nodeid="3653">“模块二：项目实战，搭建自动化测试框架”这一部分便结束了，完成学习的你已经可以胜任 Web 自动化测试框架，API 自动化测试框架的搭建工作了。</p>
<p data-nodeid="3654">本章节实践较多，希望大家能够把所讲的内容亲自实践一下，尽可能多的掌握测试框架搭建基本功，从下一章开始，我将带领大家进入能力修炼，全面掌握多项技能。</p>
<hr data-nodeid="3655">
<p data-nodeid="3656" class="">更多关于测试框架的知识，请关注测试公众号 iTesting，搜索“测试框架”查看。</p>

---

### 精选评论

##### **捷：
> 之前学习unittest，pytest，后面就习惯性使用pytest了，但具体为什么要用pytest，unittest有什么缺点，自己但是没有印象了，老师这节课讲得很清楚！

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 感谢认可，共同学习。

##### **艺：
> 并行运行，多进程多线程无法共享同一个fixture

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 实际上“并发”运行时候，是没有共享的，每个test case均运行了一遍fixture。
所以如果你的fixture里会生成某个用于共享的数据，并且你的不同case均有可能会更改这个数据的话。
那真是无解。

担心我没理解正确你的意图，如果你的疑问是下面这个：
1. fixture里放了 setup的东西，那么“并发”运行时，我想setup仅运行一次（不并发），其它case并发执行。

如果是这样，最简单可行的办法可以把setup的东西抽出来，专门放一个文件。运行时候分两步，先运行这个setup，然后再运行需要并发运行的脚本。

##### **军：
> 一直没有时间学习pytest，unittest一直是我的爱。。。这次终于学习了pytest，挺强大的。但是，在我的需求没有需要以上的功能时，我觉得还是没有必要换。但是，学习还是要学习的，感谢蔡老师。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 合适就是最好的。不过还是给你一个理由：1.unittest原生不支持并发。

##### **良：
> 你好，老师，我能问一下，我如果需要把allure通过邮件发给其他人，那么其他人也需要安装allure，然后通过命令查看报告吗，可有简单的方法哈

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你把生成的Allure报告地址发过去就可以了。只要公司内网是通的，通过url访问，跟你在本地访问是一样的，都可以看到全部内容。导出的话意义不是很大，也比较麻烦。

##### **辉：
> 麻烦老师分享下requests的基础封装呢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 文章里有啊。另外你可以在conftest.py里定义一个fixture类，把requests的请求给放进去，这样就可以全局使用了。 requests的封装，在我看来，仅仅需要封装requests.session()就好了，有了它，你全局登录态就保持了。

##### **娟：
> 总是安装scoop的过程提示调用downloadFile发送异常，这个一般怎么解决

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你可以尝试直接从官方网站安装， 地址：https://scoop.sh/

##### **胜：
> 源码文件呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 所有文章源码都在文章里，根据文章指引练习即可。

##### **4022：
> 期望能够有一讲能够讲解pytest如何做到完全兼容unittest（大胆猜测一下pytest将unittest作为默认的插件），pytest.main()代码运行起来之后做了什么。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 我们已经支持，并且实例，在第一个接口自动化框架中有中哦

##### **潜：
> 除了pytest-parallel和pytest-xdist 有什么好的用例并发方案吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你可以借助Selenium Grid，然后在每个slaves所在机器上提前安装requests即可实现同时支持UI和API测试。

##### **佳：
> 打开 allure 报告在windows系统下的对应python项目目录下执行allure serve allure_reports提示：'allure' 不是内部或外部命令，也不是可运行的程序或批处理文件。要怎么解决？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 属于allure的安装问题。请参考章节的内容， 在powershell中使用allure --version查看allure是否正确安装。

