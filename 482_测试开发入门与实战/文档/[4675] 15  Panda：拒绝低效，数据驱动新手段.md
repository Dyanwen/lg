<p data-nodeid="137144" class="">你好，我是蔡超，欢迎来到第 15 课时，经过从第一节课迄今为止的学习，你已经对测试框架的搭建，使用有比较深入的理解。 公司里的各种项目假设需要自动化测试，你也可以根据本专栏能融合 API 测试和 UI 测试，并学会了使用 PageObject 模型，且拥有数据驱动能力的测试框架了。</p>
<p data-nodeid="138672">今天我将带你在<strong data-nodeid="138682">数据驱动这个话题上继续深耕</strong>，一起来探索在自动化测试中<strong data-nodeid="138683">如何使用不同类型的数据驱动，下方这个本课时的内容脑图可供你学习参考。</strong></p>
<p data-nodeid="138673" class=""><img src="https://s0.lgstatic.com/i/image/M00/64/E7/CgqCHl-ZUKyAIUsJAALUSW5S0PI459.png" alt="Lark20201028-190551.png" data-nodeid="138686"></p>


<h3 data-nodeid="137147">使用 pytest 进行数据驱动的基本思路</h3>
<p data-nodeid="137148">我们知道 pytest 可以通过 pytest.mark.parametrize 来实现数据驱动，而 pytest.mark.parametrize 接受的数据格式要求为：</p>
<ul data-nodeid="137149">
<li data-nodeid="137150">
<p data-nodeid="137151">如果只有一组数据，以列表的形式存在；</p>
</li>
<li data-nodeid="137152">
<p data-nodeid="137153">如果有多组数据，以列表嵌套元组的形式存在（例如 [0,1] 或者 [(0,1), (1,2)]）。</p>
</li>
</ul>
<p data-nodeid="137154">既然如此，我们只需要创建一个方法，在这个方法里解析我们提供的各种数据格式，然后解析后返回 pytest.mark.parametrize 支持的格式就好。</p>
<h3 data-nodeid="137155">常规的数据驱动方法</h3>
<h4 data-nodeid="137156">1.pytest 操作 JSON/YAML 文件实现数据驱动</h4>
<p data-nodeid="137157">在《13 | DDT：博采众长，数据驱动的秘诀（一）》中我们讲到了在 unittest 框架中操作 JSON 和 YAML 文件实现数据驱动。</p>
<p data-nodeid="137158">那么在 pytest 中，又该如何实现呢？</p>
<p data-nodeid="137159">我们先按照刚刚所说的<strong data-nodeid="137335">使用 pytest 进行数据驱动的基本思路</strong>创建一个读取 JSON 文件和 YAML 文件的方法：</p>
<pre class="lang-python" data-nodeid="137160"><code data-language="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_json_yaml</span>(<span class="hljs-params">data_file</span>):</span>
    return_value = []
    data_file_path = os.path.abspath(data_file)
    print(data_file_path)
    _is_yaml_file = data_file_path.endswith((<span class="hljs-string">".yml"</span>, <span class="hljs-string">".yaml"</span>))
    <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(data_file_path, <span class="hljs-string">'r'</span>, <span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-comment"># Load the data from YAML or JSON</span>
        <span class="hljs-keyword">if</span> _is_yaml_file:
            data = yaml.safe_load(f)
        <span class="hljs-keyword">else</span>:
            data = json.load(f)
    <span class="hljs-keyword">for</span> i, elem <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):
            key, value = elem, data[elem]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">dict</span>):
                case_data = []
                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> value.values():
                    case_data.append(v)
                return_value.append(<span class="hljs-built_in">tuple</span>(case_data))
            <span class="hljs-keyword">else</span>:
                return_value.append((value,))
    <span class="hljs-keyword">return</span> return_value
</code></pre>
<p data-nodeid="137161">read_data_from_json_yaml 这个方法，实现了自动读取 JSON 文件和 YAML 文件，并且把 JSON 文件和 YAML 文件中的数据提取出来，并按照 pytest.mark.parametrize 可接收的方式返回。代码比较简单，我就不再一一讲解其含义</p>
<blockquote data-nodeid="137162">
<p data-nodeid="137163"><strong data-nodeid="137348">注意：如果你的测试文件与本文中的 YAML 和 JSON 文件的层次不同，此方法也需要做相应的修正。</strong></p>
</blockquote>
<p data-nodeid="137164">有了这个方法，JSON 或者 YAML 文件的数据通过此方法就可以转换成 pytest.mark.parametrize 认可的格式直接传入了。</p>
<p data-nodeid="137165">下面实践一下，在 lagouAPITest 项目根目录下创建如下文件目录：</p>
<pre class="lang-java" data-nodeid="137166"><code data-language="java">|--lagouAPITest
    |--tests_pytest_ddt
        |--test_baidu_ddt.py
        |--test_baidu_ddt.json
        |--test_baidu_ddt.yaml
        |--test_baidu_ddt.xlsx
        |--__init__.py
        |--conftest.py
</code></pre>
<p data-nodeid="137167">其中，test_baidu_ddt.json 文件的内容如下：</p>
<pre class="lang-python" data-nodeid="137168"><code data-language="python">{ 
  <span class="hljs-string">"case1"</span>: {
  <span class="hljs-string">"search_string"</span>: <span class="hljs-string">"itesting"</span>,
  <span class="hljs-string">"expect_string"</span>: <span class="hljs-string">"iTesting"</span>
  },
  <span class="hljs-string">"case2"</span>: {
  <span class="hljs-string">"search_string"</span>: <span class="hljs-string">"helloqa.com"</span>,
  <span class="hljs-string">"expect_string"</span>: <span class="hljs-string">"iTesting"</span>
  }
}
</code></pre>
<p data-nodeid="137169">test_baidu_ddt.yaml 文件的内容如下：</p>
<pre class="lang-python" data-nodeid="137170"><code data-language="python"><span class="hljs-string">"case1"</span>:
  <span class="hljs-string">"search_string"</span>: <span class="hljs-string">"itesting"</span>
  <span class="hljs-string">"expect_string"</span>: <span class="hljs-string">"iTesting"</span>
 
<span class="hljs-string">"case2"</span>: 
  <span class="hljs-string">"search_string"</span>: <span class="hljs-string">"helloqa.com"</span>
  <span class="hljs-string">"expect_string"</span>: <span class="hljs-string">"iTesting"</span>
</code></pre>
<p data-nodeid="137171">test_baidu_ddt.py 文件的代码如下：</p>
<pre class="lang-python" data-nodeid="137172"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> codecs
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">import</span> yaml

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_json_yaml</span>(<span class="hljs-params">data_file</span>):</span>
    return_value = []
    data_file_path = os.path.abspath(data_file)
    print(data_file_path)
    _is_yaml_file = data_file_path.endswith((<span class="hljs-string">".yml"</span>, <span class="hljs-string">".yaml"</span>))
    <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(data_file_path, <span class="hljs-string">'r'</span>, <span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-comment"># Load the data from YAML or JSON</span>
        <span class="hljs-keyword">if</span> _is_yaml_file:
            data = yaml.safe_load(f)
        <span class="hljs-keyword">else</span>:
            data = json.load(f)
    <span class="hljs-keyword">for</span> i, elem <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):
            key, value = elem, data[elem]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">dict</span>):
                case_data = []
                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> value.values():
                    case_data.append(v)
                return_value.append(<span class="hljs-built_in">tuple</span>(case_data))
            <span class="hljs-keyword">else</span>:
                return_value.append((value,))
    <span class="hljs-keyword">return</span> return_value

<span class="hljs-meta">@pytest.mark.baidu</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBaidu</span>:</span>
<span class="hljs-meta">    @pytest.mark.parametrize('search_string, expect_string',  read_data_from_json_yaml('tests_pytest_ddt/test_baidu_ddt.yaml'))</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_baidu_search</span>(<span class="hljs-params">self, login, search_string, expect_string</span>):</span>
        driver, s, base_url = login
        driver.get(base_url + <span class="hljs-string">"/"</span>)
        driver.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(search_string)
        driver.find_element_by_id(<span class="hljs-string">"su"</span>).click()
        time.sleep(<span class="hljs-number">2</span>)
        search_results = driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="1"]/h3/a'</span>).get_attribute(<span class="hljs-string">'innerHTML'</span>)
        print(search_results)
        <span class="hljs-keyword">assert</span> (expect_string <span class="hljs-keyword">in</span> search_results) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main([<span class="hljs-string">'-s'</span>, <span class="hljs-string">'-v'</span>])
</code></pre>
<p data-nodeid="137173">此段代码跟我们在《14 | DDT：博采众长，数据驱动的秘诀（二）》中讲解的代码几乎相同，唯一的改变在于增加了一个新方法 read_data_from_json_yaml，另外 @pytest.mark.parametrize 的参数，从直接提供参数变成了<strong data-nodeid="137384">从文件提供参数。</strong></p>
<pre class="lang-java" data-nodeid="137174"><code data-language="java">（read_data_from_json_yaml(<span class="hljs-string">'tests_pytest_ddt/test_baidu_ddt.yaml'</span>)）
</code></pre>
<p data-nodeid="137175">在命令行中通过如下方式运行：</p>
<pre class="lang-python" data-nodeid="137176"><code data-language="python">D:\_Automation\lagouAPITest&gt;pytest tests_pytest_ddt -s -v
</code></pre>
<p data-nodeid="137177">运行结束后查看结果如下：</p>
<p data-nodeid="137178"><img src="https://s0.lgstatic.com/i/image/M00/64/E6/CgqCHl-ZTzeAXyTQAACWaRTvsc0516.png" alt="Drawing 1.png" data-nodeid="137389"></p>
<p data-nodeid="137179">可以看到，两个测试用例都执行了，并且 YAML 文件中的数据被正确读取。</p>
<p data-nodeid="137180">那么如果我们现在要执行 JSON 文件中的数据该如何操作呢？把上述第 40 行代码中的 yaml 文件后缀换成 json 文件后缀，再次执行即可。</p>
<h4 data-nodeid="137181">2.pytest 操作 Excel 文件实现数据驱动</h4>
<p data-nodeid="137182">在实际应用中，也有很多公司使用 Excel 来做数据驱动。 在 python 中，读写 Excel 的 library 很多，常见的有 xlrd、xlwt，以及<strong data-nodeid="137398">openpyxl</strong>。由于 xlrd 和 xlwt 只能分别用作读和写，实现同样的读写操作，它的代码行数较多，故逐渐变得不再流行。所以下面我将重点介绍 openpyxl 的使用。</p>
<p data-nodeid="137183"><strong data-nodeid="137402">（1）openpyxl 安装</strong></p>
<pre class="lang-python" data-nodeid="137184"><code data-language="python">pip install openpyxl
</code></pre>
<p data-nodeid="137185"><strong data-nodeid="137406">（2）openpyxl 使用</strong></p>
<pre class="lang-python" data-nodeid="137186"><code data-language="python">   <span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook, Workbook
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># 创建一个workbook</span>
    file_name = <span class="hljs-string">r'c:\test.xlsx'</span>
    wb = Workbook()
    <span class="hljs-comment"># 创建一个sheet，名为iTesting，把它插入到最前的位置</span>
    wb.create_sheet(<span class="hljs-string">'iTesting'</span>,<span class="hljs-number">0</span>)
    <span class="hljs-comment"># 创建一个sheet，名为VIPTEST，把它插入index为1的位置</span>
    wb.create_sheet(<span class="hljs-string">'VIPTEST'</span>,<span class="hljs-number">1</span>)
    <span class="hljs-comment"># 保存表格</span>
    wb.save(file_name)
    <span class="hljs-comment"># 读和写</span>
    <span class="hljs-comment"># 初始化表格</span>
    wb2 = load_workbook(file_name)
    <span class="hljs-comment"># 读，获取所有的sheet名称</span>
    print(wb2.sheetnames)

    <span class="hljs-comment"># 获取sheet名为iTesting的表格</span>
    s = wb2[<span class="hljs-string">'iTesting'</span>]
    <span class="hljs-comment"># 将A1行的值设置为iTesting</span>
    s[<span class="hljs-string">'A1'</span>] = <span class="hljs-string">'iTesting'</span>
    <span class="hljs-comment"># 将第2行，第一列的值设置为1</span>
    s.cell(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">1</span>).value = <span class="hljs-number">1</span>
    <span class="hljs-comment"># 打印第2行第一列单元格的值 --方法1</span>
    print(s.cell(row=<span class="hljs-number">2</span>,column=<span class="hljs-number">1</span>).value)
    <span class="hljs-comment"># 打印第2行第一列单元格的值 --方法2</span>
    print(s[<span class="hljs-string">'A2'</span>].value)
    <span class="hljs-comment"># 保存表格</span>
    wb.save(file_name)
</code></pre>
<p data-nodeid="137187">上面的一段代码里，我简单介绍了 openpyxl 的用法，涉及创建表格、创建 sheet 名、读取单元格的值、设置单元格的值等部分。你可以看出使用 openpyxl 操作 excel 是相对比较简单的。<br>
<strong data-nodeid="137412">（3）openpyxl 结合 pytest 实现数据驱动</strong></p>
<p data-nodeid="137188">文件 test_baidu_ddt.xlsx 的内容如下（sheet 名 iTesting）：</p>
<p data-nodeid="137189"><img src="https://s0.lgstatic.com/i/image/M00/64/E7/CgqCHl-ZUAyAOH7TAAAJXFXWlIE940.png" alt="Drawing 2.png" data-nodeid="137420"></p>
<p data-nodeid="137190">我们来写个读 Excel 的方法，代码如下：</p>
<pre class="lang-python" data-nodeid="137191"><code data-language="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_excel</span>(<span class="hljs-params">excel_file, sheet_name</span>):</span>
    return_value = []
    <span class="hljs-comment"># 判断文件是否存在</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(excel_file):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"File not exists"</span>)
    <span class="hljs-comment"># 打开指定的sheet</span>
    wb = load_workbook(excel_file)
    <span class="hljs-comment"># 按照pytest接受的格式输出数据</span>
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> wb.sheetnames:
        <span class="hljs-keyword">if</span> s == sheet_name:
            sheet = wb[sheet_name]
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.rows:
                return_value.append([col.value <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> row])
    <span class="hljs-comment"># 第一行数据是标题，故skip掉</span>
    <span class="hljs-keyword">return</span> return_value[<span class="hljs-number">1</span>:]
</code></pre>
<p data-nodeid="137192">更新 test_baidu_ddt.py 文件，把 read_data_from_excel 的方法加进去，更新后的代码如下：</p>
<pre class="lang-python" data-nodeid="137193"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> codecs
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">import</span> yaml
<span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_json_yaml</span>(<span class="hljs-params">data_file</span>):</span>
    return_value = []
    data_file_path = os.path.abspath(data_file)
    print(data_file_path)
    _is_yaml_file = data_file_path.endswith((<span class="hljs-string">".yml"</span>, <span class="hljs-string">".yaml"</span>))
    <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(data_file_path, <span class="hljs-string">'r'</span>, <span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-comment"># Load the data from YAML or JSON</span>
        <span class="hljs-keyword">if</span> _is_yaml_file:
            data = yaml.safe_load(f)
        <span class="hljs-keyword">else</span>:
            data = json.load(f)
    <span class="hljs-keyword">for</span> i, elem <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):
            key, value = elem, data[elem]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">dict</span>):
                case_data = []
                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> value.values():
                    case_data.append(v)
                return_value.append(<span class="hljs-built_in">tuple</span>(case_data))
            <span class="hljs-keyword">else</span>:
                return_value.append((value,))
    <span class="hljs-keyword">return</span> return_value

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_excel</span>(<span class="hljs-params">excel_file, sheet_name</span>):</span>
    return_value = []
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(excel_file):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"File not exists"</span>)
    wb = load_workbook(excel_file)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> wb.sheetnames:
        <span class="hljs-keyword">if</span> s == sheet_name:
            sheet = wb[sheet_name]
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.rows:
                return_value.append([col.value <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> row])
    print(return_value)
    <span class="hljs-keyword">return</span> return_value[<span class="hljs-number">1</span>:]

<span class="hljs-meta">@pytest.mark.baidu</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBaidu</span>:</span>
    <span class="hljs-comment"># 注意，此处调用我换成了读Excel的方法</span>
<span class="hljs-meta">    @pytest.mark.parametrize('search_string, expect_string',  read_data_from_excel(r'D:\_Automation\lagouAPITest\tests_pytest_ddt\test_baidu_ddt.xlsx', 'iTesting'))</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_baidu_search</span>(<span class="hljs-params">self, login, search_string, expect_string</span>):</span>
        driver, s, base_url = login
        driver.get(base_url + <span class="hljs-string">"/"</span>)
        driver.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(search_string)
        driver.find_element_by_id(<span class="hljs-string">"su"</span>).click()
        time.sleep(<span class="hljs-number">2</span>)
        search_results = driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="1"]/h3/a'</span>).get_attribute(<span class="hljs-string">'innerHTML'</span>)
        print(search_results)
        <span class="hljs-keyword">assert</span> (expect_string <span class="hljs-keyword">in</span> search_results) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main([<span class="hljs-string">'-s'</span>， <span class="hljs-string">'-v'</span>，<span class="hljs-string">'tests_pytest_ddt'</span>])
</code></pre>
<p data-nodeid="137194">在命令行中通过如下方式再次运行即可：</p>
<pre class="lang-python" data-nodeid="137195"><code data-language="python">D:\_Automation\lagouAPITest&gt;pytest tests_pytest_ddt -s -v
</code></pre>
<p data-nodeid="137196">运行后查看结果，你会发现测试被正确执行，测试数据是从 Excel 指定的 sheet 名中获取的。</p>
<h3 data-nodeid="137197">数据驱动新姿势</h3>
<h4 data-nodeid="137198">1.Pandas 实现数据驱动</h4>
<p data-nodeid="137199">openpyxl 操作 Excel 非常简洁，但是相对于 Pandas 来说，还不够简洁，而且 openpyxl 运算效率不如 Pandas，特别是当表格行项目过多时，openpyxl 运算较慢。</p>
<p data-nodeid="137200">我们知道，当测试脚本过多时，单个脚本的运行时间差异加起来也会是个不小的浪费。作为测试开发，我们有义务提升测试效率。</p>
<p data-nodeid="137201">Pandas 是一个强大的<strong data-nodeid="137444">分析结构化数据</strong>的工具集，它的使用基础是 Numpy（提供高性能的矩阵运算）；Pandas 用于数据挖掘和数据分析，同时也提供数据清洗功能。使用 Pandas 操作 Excel 数据，就好像数数那样简单。</p>
<p data-nodeid="137202"><strong data-nodeid="137448">Pandas 安装</strong></p>
<pre class="lang-java" data-nodeid="137203"><code data-language="java"># pandas默认依赖xlrd库，故先安装xlrd
pip install xlrd
# 安装Pandas
pip install Pandas
</code></pre>
<p data-nodeid="137204"><strong data-nodeid="137452">Pandas 语法</strong></p>
<pre class="lang-python" data-nodeid="137205"><code data-language="python"><span class="hljs-keyword">import</span> Pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># 首先初始化，engine默认是xlrd</span>
s = pd.ExcelFile(path_or_buffer, engine=<span class="hljs-literal">None</span>)

<span class="hljs-comment"># 接着parse</span>
s.parse(sheet_name=<span class="hljs-number">0</span>,header=<span class="hljs-number">0</span>,names=<span class="hljs-literal">None</span>,index_col=<span class="hljs-literal">None</span>,usecols=<span class="hljs-literal">None</span>,
squeeze=<span class="hljs-literal">False</span>,converters=<span class="hljs-literal">None</span>,true_values=<span class="hljs-literal">None</span>,false_values=<span class="hljs-literal">None</span>,
skiprows=<span class="hljs-literal">None</span>,nrows=<span class="hljs-literal">None</span>,na_values=<span class="hljs-literal">None</span>,parse_dates=<span class="hljs-literal">False</span>,
date_parser=<span class="hljs-literal">None</span>,thousands=<span class="hljs-literal">None</span>,comment=<span class="hljs-literal">None</span>,skipfooter=<span class="hljs-number">0</span>,
convert_float=<span class="hljs-literal">True</span>,mangle_dupe_cols=<span class="hljs-literal">True</span>,**kwds,)
</code></pre>
<p data-nodeid="137206">Pandas 读取 Excel 文件非常简单，首先使用 Pandas 初始化 ExcelFile。其两个参数path_or_buffer 是我们要读取的文件路径。</p>
<p data-nodeid="137207">Excel 文件名称建议使用英文路径及英文命名方式，尽量不要使用中文。</p>
<pre class="lang-java" data-nodeid="137208"><code data-language="java"><span class="hljs-keyword">import</span> pandas as pd
path_or_buffer = r<span class="hljs-string">'D:\_Automation\lagouAPITest\tests_pytest_ddt\test_baidu_ddt.xlsx'</span>
</code></pre>
<p data-nodeid="137209">engine 是供 Pandas 使用的 engine，可选项为“xlrd”“openpyxl”“odf”和“pyxlsb”，如果不提供，默认使用 xlrd。</p>
<p data-nodeid="137210"><strong data-nodeid="137463">parse 函数的参数</strong></p>
<p data-nodeid="137211">初始化后，可以使用 s.parse() 函数。parse 函数有非常多的参数，在此我列出常用的几个。</p>
<ul data-nodeid="137212">
<li data-nodeid="137213">
<p data-nodeid="137214"><strong data-nodeid="137470">sheet_name: Excel 的 sheet 名</strong></p>
</li>
</ul>
<p data-nodeid="137215">sheet_name 可以是整型数字、列表名，或者上述两者组合。</p>
<pre class="lang-python" data-nodeid="137216"><code data-language="python"><span class="hljs-comment"># 通过整型数字读取。读取第一个sheet。 Pandas sheet名下标以0开始</span>
s = pd.ExcelFile(path_or_buffer, sheet_name = <span class="hljs-number">0</span>)
<span class="hljs-comment"># 通过列表名读取</span>
data = s.parse(sheet_name = <span class="hljs-string">'iTesting'</span>)
<span class="hljs-comment"># 通过index读取。读取第一个sheet</span>
data = s.parse(sheet_name = <span class="hljs-number">0</span>)
<span class="hljs-comment">#组合读取。读取第4个sheet，名为iTesting的sheet以及第7个sheet</span>
data = s.parse(sheet_name = [<span class="hljs-number">3</span>, <span class="hljs-string">'iTesting'</span>, <span class="hljs-string">'Sheet6'</span>])
</code></pre>
<ul data-nodeid="137217">
<li data-nodeid="137218">
<p data-nodeid="137219"><strong data-nodeid="137477">header：使用哪一行作为列名</strong></p>
</li>
</ul>
<p data-nodeid="137220">header 默认值为 0，即第一行，也可以设置为 [0, x]。</p>
<p data-nodeid="137221">（例如 [0,1] 意味着将前两行作为多重索引）</p>
<pre class="lang-python" data-nodeid="137222"><code data-language="python">data = s.parse(sheet_name = <span class="hljs-string">'iTesting'</span>, header = <span class="hljs-number">0</span>)
</code></pre>
<p data-nodeid="137223">需要注意： Pandas 默认使用第一行为 header，所以在 Excel 里，第一行必须是 title，如果第一行是数据，将会导致第一行数据被遗漏。如果不想要 header，可以参数传递 header=None。</p>
<ul data-nodeid="137224">
<li data-nodeid="137225">
<p data-nodeid="137226"><strong data-nodeid="137492">usecols：待读取的列</strong></p>
</li>
</ul>
<p data-nodeid="137227">usecols 接收整型，从 0 开始，例如 [0, 1, 2]，也可以使用列名例如 “A:D, F”，表示读取 A 到 D 列，以及 F 列。</p>
<pre class="lang-python" data-nodeid="137228"><code data-language="python">data = s.parse(sheet_name = <span class="hljs-string">'iTesting'</span>, usecols=<span class="hljs-string">'A:D'</span>)
</code></pre>
<ul data-nodeid="137229">
<li data-nodeid="137230">
<p data-nodeid="137231"><strong data-nodeid="137501">skiprows：读取时，跳过特定行</strong></p>
</li>
</ul>
<p data-nodeid="137232">skiprows=n，跳过前 n 行；skiprows = [a, b, c]，跳过第 a+1、b+1、c+1 行（索引从0开始）</p>
<pre class="lang-python" data-nodeid="137233"><code data-language="python">data = s.parse(sheet_name = <span class="hljs-string">'iTesting'</span>, skiprows = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])
</code></pre>
<ul data-nodeid="137234">
<li data-nodeid="137235">
<p data-nodeid="137236"><strong data-nodeid="137510">nrows：需要读取的行数</strong></p>
</li>
</ul>
<p data-nodeid="137237">仅仅列出要读取的行数</p>
<pre class="lang-python" data-nodeid="137238"><code data-language="python">data = s.parse(sheet_name = <span class="hljs-string">'iTesting'</span>, nrows = <span class="hljs-number">3</span>)
</code></pre>
<p data-nodeid="137239"><strong data-nodeid="137515">Pandas 结合 pytest 实现数据驱动</strong></p>
<p data-nodeid="137240">了解了 Pandas 语法后，我们来看下如何使用 Pandas 读取 Excel 数据：</p>
<pre class="lang-python" data-nodeid="137241"><code data-language="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_pandas</span>(<span class="hljs-params">excel_file, sheet_name</span>):</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(excel_file):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"File not exists"</span>)
    <span class="hljs-comment"># 初始化</span>
    s = pd.ExcelFile(excel_file)
    <span class="hljs-comment"># 解析Excel Sheet</span>
    df = s.parse(sheet_name)
    <span class="hljs-comment"># 以list格式返回数据</span>
    <span class="hljs-keyword">return</span> df.values.tolist()
</code></pre>
<p data-nodeid="137242">可以看到，使用 pandas 读取 Excel 数据更加简洁方便。</p>
<p data-nodeid="137243">最后，我们来更新下 test_baidu_ddt.py 文件，更新后的代码如下：</p>
<pre class="lang-python" data-nodeid="137244"><code data-language="python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>
<span class="hljs-keyword">import</span> codecs
<span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> pytest
<span class="hljs-keyword">import</span> yaml
<span class="hljs-keyword">from</span> openpyxl <span class="hljs-keyword">import</span> load_workbook
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-comment"># 读取Yaml文件和Json文件</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_json_yaml</span>(<span class="hljs-params">data_file</span>):</span>
    return_value = []
    data_file_path = os.path.abspath(data_file)
    print(data_file_path)
    _is_yaml_file = data_file_path.endswith((<span class="hljs-string">".yml"</span>, <span class="hljs-string">".yaml"</span>))
    <span class="hljs-keyword">with</span> codecs.<span class="hljs-built_in">open</span>(data_file_path, <span class="hljs-string">'r'</span>, <span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> f:
        <span class="hljs-comment"># Load the data from YAML or JSON</span>
        <span class="hljs-keyword">if</span> _is_yaml_file:
            data = yaml.safe_load(f)
        <span class="hljs-keyword">else</span>:
            data = json.load(f)
    <span class="hljs-keyword">for</span> i, elem <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):
        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>):
            key, value = elem, data[elem]
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">dict</span>):
                case_data = []
                <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> value.values():
                    case_data.append(v)
                return_value.append(<span class="hljs-built_in">tuple</span>(case_data))
            <span class="hljs-keyword">else</span>:
                return_value.append((value,))
    <span class="hljs-keyword">return</span> return_value
<span class="hljs-comment"># 读取Excel 文件 -- openpyxl</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_excel</span>(<span class="hljs-params">excel_file, sheet_name</span>):</span>
    return_value = []
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(excel_file):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"File not exists"</span>)
    wb = load_workbook(excel_file)
    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> wb.sheetnames:
        <span class="hljs-keyword">if</span> s == sheet_name:
            sheet = wb[sheet_name]
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> sheet.rows:
                return_value.append([col.value <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> row])
    print(return_value)
    <span class="hljs-keyword">return</span> return_value[<span class="hljs-number">1</span>:]
<span class="hljs-comment"># 读取Excel文件 -- Pandas</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_data_from_pandas</span>(<span class="hljs-params">excel_file, sheet_name</span>):</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(excel_file):
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"File not exists"</span>)
    s = pd.ExcelFile(excel_file)
    df = s.parse(sheet_name)
    <span class="hljs-keyword">return</span> df.values.tolist()
<span class="hljs-meta">@pytest.mark.baidu</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestBaidu</span>:</span>
<span class="hljs-meta">    @pytest.mark.parametrize('search_string, expect_string',  read_data_from_pandas(r'D:\_Automation\lagouAPITest\tests_pytest_ddt\test_baidu_ddt.xlsx', 'iTesting'))</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_baidu_search</span>(<span class="hljs-params">self, login, search_string, expect_string</span>):</span>
        driver, s, base_url = login
        driver.get(base_url + <span class="hljs-string">"/"</span>)
        driver.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(search_string)
        driver.find_element_by_id(<span class="hljs-string">"su"</span>).click()
        time.sleep(<span class="hljs-number">2</span>)
        search_results = driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="1"]/h3/a'</span>).get_attribute(<span class="hljs-string">'innerHTML'</span>)
        print(search_results)
        <span class="hljs-keyword">assert</span> (expect_string <span class="hljs-keyword">in</span> search_results) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main([<span class="hljs-string">'-s'</span>, <span class="hljs-string">'-v'</span>, <span class="hljs-string">'tests_pytest_ddt'</span>])
</code></pre>
<p data-nodeid="137245">在命令行中通过如下方式再次运行即可：</p>
<pre class="lang-js" data-nodeid="137246"><code data-language="js">D:\_Automation\lagouAPITest&gt;pytest tests_pytest_ddt -s -v
</code></pre>
<p data-nodeid="137247">运行后查看结果，你会发现测试被正确执行，测试数据是通过 Pandas 从 Excel 指定的 sheet 名中获取的。<br>
事实在，Pandas 不仅仅能读取 Excel 文件，还可以读取 HTML 文件、TXT 文件、JSON 文件、数据库文件 (.sql) 等。在数据分析领域，Pandas 使用非常广泛，更多具体的 Pandas 使用，请自行查阅。</p>
<h4 data-nodeid="137248">2.自定义实现数据驱动</h4>
<p data-nodeid="137249">我在第 11、12 课时的“ DDT：博采众长，数据驱动的秘诀”里，详细讲解了如何使用 ddt、pytest.mark.parametrize 和 pytest.fixture 来实现数据驱动。今天我来讲 pytest 里另外一个实现数据驱动的方式 pytest_generate_tests。</p>
<ul data-nodeid="137250">
<li data-nodeid="137251">
<p data-nodeid="137252"><strong data-nodeid="137536">直接提供数据实现数据驱动</strong></p>
</li>
</ul>
<p data-nodeid="137253">pytest 中提供了一个钩子函数，名为 pytest_generate_tests。此函数在 pytest 收集测试函数时会被调用。通过传入 metafunc 对象，我们可以“自定义”数据驱动，即通过调用metafunc.parametrize() 来进行参数化。</p>
<p data-nodeid="137254">我们先看一个例子：</p>
<pre class="lang-python" data-nodeid="137255"><code data-language="python"><span class="hljs-comment"># 定义文件test_customize_ddt.py</span>
<span class="hljs-keyword">import</span> pytest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_generate_tests</span>(<span class="hljs-params">metafunc</span>):</span>
    <span class="hljs-comment"># 查看metafunc有多少种可用方法</span>
    print(<span class="hljs-built_in">dir</span>(metafunc))
    <span class="hljs-keyword">if</span> <span class="hljs-string">"text_para"</span> <span class="hljs-keyword">in</span> metafunc.fixturenames:
        <span class="hljs-comment"># 指定参数化名称，及其对应的值</span>
        metafunc.parametrize(<span class="hljs-string">"text_para"</span>, [[<span class="hljs-string">"iTesting"</span>, <span class="hljs-string">"iTesting"</span>], [<span class="hljs-string">"always"</span>, <span class="hljs-string">"always"</span>], [<span class="hljs-string">"awesome"</span>, <span class="hljs-string">"good"</span>]])

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span>(<span class="hljs-params">self, text_para</span>):</span>
        input_str, output_str = text_para
        print(input_str)
        print(output_str)
        <span class="hljs-keyword">assert</span> input_str == output_str

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main([<span class="hljs-string">'-s'</span>, <span class="hljs-string">'-v'</span>, <span class="hljs-string">'test_pytest_ddt/test_customize_ddt.py'</span>])
</code></pre>
<p data-nodeid="137256">直接在 Pycharm 中运行此文件，或者在命令行中通过如下方式运行：</p>
<pre class="lang-plain" data-nodeid="137257"><code data-language="plain">D:\_Automation\lagouAPITest&gt;pytest -s -v tests_pytest_ddt/test_customize_ddt.py
</code></pre>
<p data-nodeid="137258">运行后查看结果：</p>
<p data-nodeid="137259"><img src="https://s0.lgstatic.com/i/image/M00/64/DB/Ciqc1F-ZT4mAECokAABqMkmXXgs908.png" alt="Drawing 3.png" data-nodeid="137547"></p>
<p data-nodeid="137260">可以看到，有 3 个测试用例被执行了，执行的测试用例是 test_func 这个函数，执行的结果是两个成功，一个失败（注意，一个用例失败不会影响其他用例执行）。其使用的数据正好就是我们提供的这组数据：</p>
<pre class="lang-js" data-nodeid="137261"><code data-language="js">[[<span class="hljs-string">"iTesting"</span>, <span class="hljs-string">"iTesting"</span>], [<span class="hljs-string">"always"</span>, <span class="hljs-string">"always"</span>], [<span class="hljs-string">"awesome"</span>, <span class="hljs-string">"good"</span>]]
</code></pre>
<p data-nodeid="137262">下面我来讲解下这段代码。</p>
<p data-nodeid="137263">首先，我定义了一个函数，名字为 pytest_generate_tests(metafunc)， 注意这个函数名称和参数名称均是固定的，不可更改。</p>
<p data-nodeid="137264">然后，我在函数 pytest_generate_tests 中（第 7 行）打印出 metafunc 可用的方法有哪些。 事实上，通过查看源代码可以发现，metafunc 支持的属性有：</p>
<pre class="lang-js" data-nodeid="137265"><code data-language="js">#: Access to the :class:`_pytest.config.Config` object for the test session.
# 用于在测试session中访问:class:`_pytest.config.Config`对象
metafunc.config
#: The module object where the test function is defined in.
#： 代表使用参数名称进行参数化的test function所在的模块对象
metafunc.module
#: Underlying Python test function.
#： 测试用例对象
metafunc.function
#: Set of fixture names required by the test function.
#： test function参数化所需的fixtures名字
metafunc.fixturenames
#: Class object where the test function is defined in or ``None``.
# test function所属的类的类对象，如果没有，就是None
metafunc.cls
</code></pre>
<p data-nodeid="137266">我使用 metafunc.fixturenames 列出所有可能的 fixture 名字，并当它的名字跟我提供的 fixture 名称一样时，我使用 metafunc.parametrize 函数为其提供参数化的数据值，以便实现数据驱动（8~11 行）。</p>
<p data-nodeid="137267">接着，我定义了一个测试类 TestClass，然后在其中定义了一个类方法 test_func，并在其中定义了一个“参数” text_para。 而这个“参数“名称 text_para 实际上就是我提供的 fixtures。</p>
<p data-nodeid="137268">最后，pytest.main() 函数运行， 在收集测试函数时，会找到 test_func 这个函数，然后在运行这个函数前，函数 pytest_generate_tests 会被调用，通过查看代码运行，你可以看到：</p>
<p data-nodeid="137269">metafunc 对象被传入进来，它的 5 个属性分别是：</p>
<p data-nodeid="137270"><img src="https://s0.lgstatic.com/i/image/M00/64/DB/Ciqc1F-ZT5CAadvKAAA6CFGmj18747.png" alt="Drawing 4.png" data-nodeid="137582"></p>
<p data-nodeid="137271">接着 pytest 会在其中经过一系列复杂的操作，最终为 text_para 这个 fixture 完成参数化，并且根据数据的组数将测试用例 test_func 分成多个测试用例，接着依次运行新生成的测试用例，并且为每一个测试用例提供一组数据，如下：</p>
<p data-nodeid="137272"><img src="https://s0.lgstatic.com/i/image/M00/64/E7/CgqCHl-ZT6iADUUHAAANxdO_dSA750.png" alt="Drawing 5.png" data-nodeid="137590"></p>
<p data-nodeid="137273">接着，这些测试用例依次运行完毕，输出结果。</p>
<ul data-nodeid="137274">
<li data-nodeid="137275">
<p data-nodeid="137276"><strong data-nodeid="137595">从外部文件提供数据实现数据驱动</strong></p>
</li>
</ul>
<p data-nodeid="137277">数据驱动的最大好处就是更改数据不需要更改代码， 所以将测试数据抽离出来到外部文件是通用的做法，下面我们就来看下如何做。</p>
<p data-nodeid="137278">在 lagouAPITest 项目根目录下创建如下文件目录：</p>
<pre class="lang-js" data-nodeid="137279"><code data-language="js">|--lagouAPITest
    |--tests_pytest_new_ddt
        |--test_new_ddt.py
        |--data_new_ddt.py
        |--__init__.py
</code></pre>
<p data-nodeid="137280">其中 data_new_ddt.py 文件的内容如下：</p>
<pre class="lang-python" data-nodeid="137281"><code data-language="python">tests = [
    [<span class="hljs-string">"iTesting"</span>, <span class="hljs-string">"iTesting"</span>], 
    [<span class="hljs-string">"always"</span>, <span class="hljs-string">"always"</span>], 
    [<span class="hljs-string">"awesome"</span>, <span class="hljs-string">"good"</span>]
]
</code></pre>
<p data-nodeid="137282">test_new_ddt.py 的代码如下：</p>
<pre class="lang-python" data-nodeid="137283"><code data-language="python"><span class="hljs-keyword">import</span> importlib
<span class="hljs-keyword">import</span> pytest

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pytest_generate_tests</span>(<span class="hljs-params">metafunc</span>):</span>
    package_name = metafunc.module.__package__
    <span class="hljs-keyword">for</span> fixture <span class="hljs-keyword">in</span> metafunc.fixturenames:
        <span class="hljs-keyword">if</span> fixture.startswith(<span class="hljs-string">'data_'</span>):
            <span class="hljs-comment"># 加载测试数据</span>
            module_name = package_name + <span class="hljs-string">'.'</span> + fixture
            tests = TestClass.load_tests(module_name)
            metafunc.parametrize(fixture, tests)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClass</span>:</span>
<span class="hljs-meta">    @staticmethod</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_tests</span>(<span class="hljs-params">name</span>):</span>
        <span class="hljs-comment"># 加载测试数据文件</span>
        tests_module = importlib.import_module(name)
        <span class="hljs-comment"># 针对每一个测试文件，赋予不同的测试值</span>
        <span class="hljs-keyword">for</span> test <span class="hljs-keyword">in</span> tests_module.tests:
            <span class="hljs-keyword">yield</span> test
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_func</span>(<span class="hljs-params">self, data_new_ddt</span>):</span>
        input_str, output_str = data_new_ddt
        <span class="hljs-keyword">assert</span> input_str == output_str

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    pytest.main(args=[<span class="hljs-string">'-s'</span>, <span class="hljs-string">'-v'</span>, <span class="hljs-string">'tests_new_ddt/test_new_ddt.py'</span>])
</code></pre>
<p data-nodeid="137284">这段代码比较复杂，我来一一解释。</p>
<p data-nodeid="137285">首先，函数 pytest_generate_tests 仍然是实现了把给定的 fixture（data_new_ddt）加载进来，并且根据测试数据生成多组测试用例。</p>
<p data-nodeid="137286">其次， 测试类 TestClass 中的 load_tests 静态方法实现了解析测试数据并逐个返回， 这里用了yield。 yield 在fixture 里是个特殊的存在，它用于返回 fixture 的分组测试数据。正因为此，通过 load_tests 函数返回的数据才能正确地被 metafunc.parametrize 参数化（把 load_tests 里的 yield 改成 true，测试会出错）。</p>
<p data-nodeid="137287">最后， 分组测试数据被生成的多组新测试用例返回，并用于测试方法 test_func 中，从而实现了从外部文件提供数据实现数据启动。</p>
<h3 data-nodeid="137288">总结</h3>
<p data-nodeid="137289">本节课我们首先学习了数据驱动的新姿势 —— Pandas。不同格式数据驱动的要点在于解析这些文件并将数据转换成 pytest.mark.parametrize 认可的数据格式。</p>
<p data-nodeid="137290">至此，JSON、YAML、TXT、CSV、xlsx、sql 甚至 .py 格式的数据格式，对你来说就仅仅是写一个数据解析方法而已。</p>
<p data-nodeid="137291">其次，本节课着重介绍了通过 pytest 的预留方法 pytest_generate_tests 来实现数据驱动。使用 pytest_generate_tests 实现数据驱动，可以允许你灵活地定制你的数据驱动模式。这部分代码稍微有点复杂，在了解其原理时，建议大家多读 pytest 源码，所谓书读千遍，其意自现。</p>
<h3 data-nodeid="137292">课后作业</h3>
<p data-nodeid="137293">在本节课中，介绍数据驱动时，为了讲解简单，我实现数据驱动的 fixture 方法，都是直接放在测试文件中的，例如 read_data_from_excel、read_data_from_pandas 等。请尝试将他们放入 conftest.py 文件中 ，并更改你的代码使之能够正确运行。</p>
<p data-nodeid="137294">好了，今天的课程就到这里，有任何问题也可以在下方讨论区留言，我是蔡超， 我们下节课再见。</p>
<hr data-nodeid="137295">
<p data-nodeid="137296" class="">关注公众号 iTesting，回复“测试框架”，查看更多自研测试框架的技术原理。</p>

---

### 精选评论

##### **5470：
> 老师你好，我想问一下，我把read_data_from_excel、read_data_from_pandas放到conftest.py 文件中后，test_baidu_ddt.py文件中的@pytest.mark.parametrize无法调用read_data_from_pandas，如何解决呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 很高兴你问这个问题。这个作业题我是花了一点小心思的，直接移动过去肯定不能执行。
这里我先不说答案，给出以下的思路你参考下：
1. 直接移动代码，然后运行。
2. 从运行错误中读取有用信息，然后根据信息提示更改你的代码。
3. 信息提示中截取部分通用字段，然后搜索引擎搜索，你会学到新的知识：）

如果这3步下来你还没有解决，可以联系班主任索要我的个人微信。我手把手教会你。

##### **崇：
> 老师你好，我想问一下，在执行多条用例的时候，打开一个浏览器驱动执行所有用例好还是一个浏览器驱动执行一条用例好，可以说下他们的优劣吗，谢谢了！

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 要看你的目的。还要关注1. 用例之间有没有互相依赖。2。用例会不会共享同个数据。 都没有可以并发执行。
其实我不建议在一个机器上打开多个浏览器。如果你有多开的要求，我建议你用并发，通过把测试用例分发到不同的机器上执行。

##### **0321：
> 老师你好，我想问一下，我把read_data_from_pandas放到conftest.py 文件中后，test_baidu_ddt.py文件中调用@pytest.mark.parametrize会提示Failed: Fixture "read_data_from_pandas" called directly. Fixtures are not meant to be called directly,but are created automatically when test functions request them as parameters.我在网上查了半小时，还是没有头绪，麻烦提示一下😂

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 1. 你不能在测试中再用@pytest.mark.parametrize装饰你的测试方法了，需要去掉即test_baidu_search不需要pytest.mark.parametrize装饰了。
2. 你的测试方法应该改为类似这样的函数test_baidu_search（read_data_from_pandas）
3. 你要在conftest.py里定义pytest_addoption（parser）方法来接受你来自命令行的参数，可以定义两个参数，分别为--excelFile和--sheetName。这个你需要查下pytest_addoption的用法。
4. 你conftest.py文件里把read_data_from_pandas方法，改成@pytest.fixture()
def read_data_from_pandas(request)， 使用request来接受来自命令行的参数作为输入（提示：request.config.getoption（‘xxx’）），这个函数返回的数据就自动会被test_baidu_search函数接收并使用。

##### **莹：
> 老师，问一下如果测试里有需要不同环节不同角色的人数据不同，这种的测试数据是放置在一个文件中还是分开存放读取呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 有两种方式：
1.建数据时，就根据角色建立不同的测试数据，这个数据是跟角色强绑定的，比如都放在同一个文件里。那么代码在运行时候，A角色就只能查存放A数据的文件。无法查看到B的数据。好处是简单，坏处是部分数据可能重复（比如A和B的通用数据）。
2. 角色是角色，数据是数据。 这样就要编写业务规则方法，用于处理和redirect不同角色的数据应该如何查找和生成。好处是数据不需重复保存（通用数据只会有一份），坏处是要维护业务规则，有一些代码量。

##### **华：
> test_baidu_ddt.py 文件的代码有遗漏

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这里的代码跟之前章节讲到的稍有不同。主要是为了演示pytest.mark.parametrize的用法。

##### **芝：
> 老师你好，有个问题咨询下。read_data_from_excel方法，打印后的返回值为1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2，是列表嵌套列表的样式，但是在测试用例中，也可以识别这样的数据。文章最开始有说"如果有多组数据，以列表嵌套元组的形式存在（例如 [0,1] 或者 [(0,1), (1,2)]）。"。请问这中间是有什么内部自动转换么？谢谢老师解答

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个其实只要是可iterable的数据都应该可以识别的。但是官方介绍是列表嵌套数组。

