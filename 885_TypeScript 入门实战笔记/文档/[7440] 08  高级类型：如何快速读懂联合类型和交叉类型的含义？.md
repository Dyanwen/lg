<p data-nodeid="2616" class="">在前边课程中，我们介绍了基础类型、字面量类型、函数类型及接口类型等内容，它们都是单一、原子的类型元素。其实，如前边课程中一些稍微复杂、实际编程场景的示例所示，我们还需要通过组合/结合单一、原子类型构造更复杂的类型，以此描述更复杂的数据和结构。这就是这一讲中将介绍的内容——联合和交叉类型（Unions and Intersection Types）。</p>
<blockquote data-nodeid="2617">
<p data-nodeid="2618"><strong data-nodeid="2711">学习建议</strong>：请使用 VS Code 新建一个 08.ts 文件，并尝试这一讲中涉及的所有示例。</p>
</blockquote>
<h3 data-nodeid="2619">联合类型</h3>
<p data-nodeid="2620">联合类型（Unions）用来表示变量、参数的类型不是单一原子类型，而可能是多种不同的类型的组合。</p>
<p data-nodeid="2621">我们主要通过“|”操作符分隔类型的语法来表示联合类型。这里，我们可以把“|”类比为 JavaScript 中的逻辑或 “||”，只不过前者表示可能的类型。</p>
<p data-nodeid="2622">举个例子，我们封装了一个将 string 或者 number 类型的输入值转换成 '数字 + "px" 格式的函数，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2623"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatPX</span>(<span class="hljs-params">size: unknown</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> size === <span class="hljs-string">'number'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${size}</span>px`</span>;
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> size === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-built_in">parseInt</span>(size) || <span class="hljs-number">0</span>}</span>px`</span>;
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">` 仅支持 number 或者 string`</span>);
}
formatPX(<span class="hljs-number">13</span>);
formatPX(<span class="hljs-string">'13px'</span>);
</code></pre>
<p data-nodeid="2624"><strong data-nodeid="2732">说明：在学习联合类型之前，我们可能免不了使用 any 或 unknown 类型来表示参数的类型（为了让大家养成好习惯，推荐使用 unknown）。</strong></p>
<p data-nodeid="2625">通过这样的方式带来的问题是，在调用 formatPX 时，我们可以传递任意的值，并且可以通过静态类型检测（使用 any 亦如是），但是运行时还是会抛出一个错误，例如：</p>
<pre class="lang-typescript" data-nodeid="2626"><code data-language="typescript">formatPX(<span class="hljs-literal">true</span>);
formatPX(<span class="hljs-literal">null</span>);
</code></pre>
<p data-nodeid="2627">这显然不符合我们的预期，因为 size 应该是更明确的，即可能也只可能是 number 或 string 这两种可选类型的类型。</p>
<p data-nodeid="2628">所幸有联合类型，我们可以使用一个更明确表示<strong data-nodeid="2740">可能是 number 或 string 的联合类型</strong>来注解 size 参数，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2629"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatPX</span>(<span class="hljs-params">size: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span></span>) </span>{
  <span class="hljs-comment">// ...</span>
}
formatPX(<span class="hljs-number">13</span>); <span class="hljs-comment">// ok</span>
formatPX(<span class="hljs-string">'13px'</span>); <span class="hljs-comment">// ok</span>
formatPX(<span class="hljs-literal">true</span>); <span class="hljs-comment">// ts(2345) 'true' 类型不能赋予 'number | string' 类型</span>
formatPX(<span class="hljs-literal">null</span>); <span class="hljs-comment">// ts(2345) 'null' 类型不能赋予 'number | string' 类型</span>
</code></pre>
<p data-nodeid="2630">在第 1 行，我们定义了函数 formatPX 的参数 size 既可以是 number 类型也可以是 string 类型，所以第 5 行和第 6 行传入数字 13 和字符串 '13px' 都正确，但在第 8 行和第 9 行传入布尔类型的 true 或者 null 类型都会提示一个 ts(2345) 错误。</p>
<p data-nodeid="2631">当然，我们可以组合任意个、任意类型来构造更满足我们诉求的类型。比如，我们希望给前边的示例再加一个 unit 参数表示可能单位，这个时候就可以声明一个字符串字面类型组成的联合类型，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2632"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">formatUnit</span>(<span class="hljs-params">size: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>, unit: 'px' | 'em' | 'rem' | '%' = 'px'</span>) </span>{
  <span class="hljs-comment">// ...</span>
}
formatUnit(<span class="hljs-number">1</span>, <span class="hljs-string">'em'</span>); <span class="hljs-comment">// ok</span>
formatUnit(<span class="hljs-string">'1px'</span>, <span class="hljs-string">'rem'</span>); <span class="hljs-comment">// ok</span>
formatUnit(<span class="hljs-string">'1px'</span>, <span class="hljs-string">'bem'</span>); <span class="hljs-comment">// ts(2345)</span>
</code></pre>
<p data-nodeid="2633">我们定义了 formatPX 函数的第二个参数 unit，它的类型是由 'px'、'em'、'rem'、'%' 字符串字面类型组成的类型集合。因此，我们可以在第 5 行和第 6 行传入字符串字面量 'em' 和 'rem' 作为第二个实参。如果在第 8 行我们传入一个不在类型集合中的字符串字面量 'bem' ，就会提示一个 ts(2345) 错误。</p>
<p data-nodeid="2634">我们也可以使用类型别名抽离上边的联合类型，然后再将其进一步地联合，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2635"><code data-language="typescript"><span class="hljs-keyword">type</span> ModernUnit = <span class="hljs-string">'vh'</span> | <span class="hljs-string">'vw'</span>;
<span class="hljs-keyword">type</span> Unit = <span class="hljs-string">'px'</span> | <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span>;
<span class="hljs-keyword">type</span> MessedUp = ModernUnit | Unit; <span class="hljs-comment">// 类型是 'vh' | 'vw' | 'px' | 'em' | 'rem'</span>
</code></pre>
<p data-nodeid="2636">这里我们定义了 ModernUnit 别名表示 'vh' 和 'vw' 这两个字面量类型的组合，且定义了 Unit 别名表示 'px' 和 'em' 和 'rem' 字面量类型组合，同时又定义了 MessedUp 别名表示 ModernUnit 和 Unit 两个类型别名的组合。</p>
<blockquote data-nodeid="2637">
<p data-nodeid="2638"><strong data-nodeid="2802">这里埋一个伏笔：</strong> 如果将 string 原始类型和“string 字面量类型”组合成一个联合类型会是什么效果？你可以自己尝试一下，答案将在这一讲的最后揭晓。</p>
</blockquote>
<p data-nodeid="2639">我们也可以把接口类型联合起来表示更复杂的结构，如下所示示例（援引官方示例，顺带复习一下类型断言 as）：</p>
<pre class="lang-typescript" data-nodeid="2640"><code data-language="typescript"><span class="hljs-keyword">interface</span> Bird {
  fly(): <span class="hljs-built_in">void</span>;
  layEggs(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">interface</span> Fish {
  swim(): <span class="hljs-built_in">void</span>;
  layEggs(): <span class="hljs-built_in">void</span>;
}
<span class="hljs-keyword">const</span> getPet: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Bird | Fish = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">return</span> {
   <span class="hljs-comment">// ...</span>
  } <span class="hljs-keyword">as</span> Bird | Fish;
};
<span class="hljs-keyword">const</span> Pet = getPet();
Pet.layEggs(); <span class="hljs-comment">// ok</span>
Pet.fly(); <span class="hljs-comment">// ts(2339) 'Fish' 没有 'fly' 属性; 'Bird | Fish' 没有 'fly' 属性</span>
</code></pre>
<p data-nodeid="2641">从上边的示例可以看到，在联合类型中，我们可以直接访问各个接口成员都拥有的属性、方法，且不会提示类型错误。但是，如果是个别成员特有的属性、方法，我们就需要区分对待了，此时又要引入类型守卫（详见 11 讲）来区分不同的成员类型。</p>
<p data-nodeid="2642">只不过，在这种情况下，我们还需要使用基于 in 操作符判断的类型守卫，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2643"><code data-language="typescript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> Pet.fly === <span class="hljs-string">'function'</span>) { <span class="hljs-comment">// ts(2339)</span>
  Pet.fly(); <span class="hljs-comment">// ts(2339)</span>
}
<span class="hljs-keyword">if</span> (<span class="hljs-string">'fly'</span> <span class="hljs-keyword">in</span> Pet) {
  Pet.fly(); <span class="hljs-comment">// ok</span>
}
</code></pre>
<p data-nodeid="2644">因为 Pet 的类型既可能是 Bird 也可能是 Fish，这就意味着在第 1 行可能会通过 Fish 类型获取 fly 属性，但 Fish 类型没有 fly 属性定义，所以会提示一个 ts(2339) 错误。</p>
<h3 data-nodeid="2645">交叉类型</h3>
<p data-nodeid="2646">前边我们使用了逻辑或“||” 类比联合类型，那是不是还有一个逻辑与“&amp;&amp;”可以类比类型？</p>
<p data-nodeid="2647">在 TypeScript 中，确实还存在一种类似逻辑与行为的类型——交叉类型（Intersection Type），它可以把多个类型合并成一个类型，合并后的类型将拥有所有成员类型的特性。</p>
<p data-nodeid="2648">在 TypeScript 中，我们可以使用“&amp;”操作符来声明交叉类型，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2649"><code data-language="typescript">{
  <span class="hljs-keyword">type</span> Useless = <span class="hljs-built_in">string</span> &amp; <span class="hljs-built_in">number</span>;
}
</code></pre>
<p data-nodeid="2650">很显然，如果我们仅仅把原始类型、字面量类型、函数类型等原子类型合并成交叉类型，是没有任何用处的，因为任何类型都不能满足同时属于多种原子类型，比如既是 string 类型又是 number 类型。因此，在上述的代码中，类型别名 Useless 的类型就是个 never。</p>
<h4 data-nodeid="2651">合并接口类型</h4>
<p data-nodeid="2652">联合类型真正的用武之地就是将多个接口类型合并成一个类型，从而实现等同接口继承的效果，也就是所谓的合并接口类型，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2653"><code data-language="typescript">  <span class="hljs-keyword">type</span> IntersectionType = { id: <span class="hljs-built_in">number</span>; name: <span class="hljs-built_in">string</span>; } 
    &amp; { age: <span class="hljs-built_in">number</span> };
  <span class="hljs-keyword">const</span> mixed: IntersectionType = {
    id: <span class="hljs-number">1</span>,
    name: <span class="hljs-string">'name'</span>,
    age: <span class="hljs-number">18</span>
  }
</code></pre>
<p data-nodeid="2654">在上述示例中，我们通过交叉类型，使得 IntersectionType 同时拥有了 id、name、age 所有属性，这里我们可以试着将合并接口类型理解为求并集。</p>
<blockquote data-nodeid="2655">
<p data-nodeid="2656">这里，我们来发散思考一下：如果合并的多个接口类型存在同名属性会是什么效果呢？</p>
</blockquote>
<p data-nodeid="2657">此时，我们可以根据同名属性的类型是否兼容（详见 12 讲）将这个问题分开来看。</p>
<p data-nodeid="2658">如果同名属性的类型不兼容，比如上面示例中两个接口类型同名的 name 属性类型一个是 number，另一个是 string，合并后，name 属性的类型就是 number 和 string 两个原子类型的交叉类型，即 never，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2659"><code data-language="typescript">  <span class="hljs-keyword">type</span> IntersectionTypeConfict = { id: <span class="hljs-built_in">number</span>; name: <span class="hljs-built_in">string</span>; } 
    &amp; { age: <span class="hljs-built_in">number</span>; name: <span class="hljs-built_in">number</span>; };
  <span class="hljs-keyword">const</span> mixedConflict: IntersectionTypeConfict = {
    id: <span class="hljs-number">1</span>,
    name: <span class="hljs-number">2</span>, <span class="hljs-comment">// ts(2322) 错误，'number' 类型不能赋给 'never' 类型</span>
    age: <span class="hljs-number">2</span>
  };
</code></pre>
<p data-nodeid="2660">此时，我们赋予 mixedConflict 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 IntersectionTypeConfict 类型是一个无用类型。</p>
<p data-nodeid="2661">如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</p>
<p data-nodeid="2662">如下所示示例中 name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p>
<pre class="lang-typescript" data-nodeid="2663"><code data-language="typescript">  <span class="hljs-keyword">type</span> IntersectionTypeConfict = { id: <span class="hljs-built_in">number</span>; name: <span class="hljs-number">2</span>; } 
  &amp; { age: <span class="hljs-built_in">number</span>; name: <span class="hljs-built_in">number</span>; };
  <span class="hljs-keyword">let</span> mixedConflict: IntersectionTypeConfict = {
    id: <span class="hljs-number">1</span>,
    name: <span class="hljs-number">2</span>, <span class="hljs-comment">// ok</span>
    age: <span class="hljs-number">2</span>
  };
  mixedConflict = {
    id: <span class="hljs-number">1</span>,
    name: <span class="hljs-number">22</span>, <span class="hljs-comment">// '22' 类型不能赋给 '2' 类型</span>
    age: <span class="hljs-number">2</span>
  };
</code></pre>
<h4 data-nodeid="2664">合并联合类型</h4>
<p data-nodeid="2665">另外，我们可以合并联合类型为一个交叉类型，这个交叉类型需要同时满足不同的联合类型限制，也就是提取了所有联合类型的相同类型成员。这里，我们也可以将合并联合类型理解为求交集。</p>
<p data-nodeid="2666">在如下示例中，两个联合类型交叉出来的类型 IntersectionUnion 其实等价于 'em' | 'rem'，所以我们只能把 'em' 或者 'rem' 字符串赋值给 IntersectionUnion 类型的变量。</p>
<pre class="lang-typescript" data-nodeid="2667"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionA = <span class="hljs-string">'px'</span> | <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span> | <span class="hljs-string">'%'</span>;
  <span class="hljs-keyword">type</span> UnionB = <span class="hljs-string">'vh'</span> | <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span> | <span class="hljs-string">'pt'</span>;
  <span class="hljs-keyword">type</span> IntersectionUnion = UnionA &amp; UnionB;
  <span class="hljs-keyword">const</span> intersectionA: IntersectionUnion = <span class="hljs-string">'em'</span>; <span class="hljs-comment">// ok</span>
  <span class="hljs-keyword">const</span> intersectionB: IntersectionUnion = <span class="hljs-string">'rem'</span>; <span class="hljs-comment">// ok</span>
  <span class="hljs-keyword">const</span> intersectionC: IntersectionUnion = <span class="hljs-string">'px'</span>; <span class="hljs-comment">// ts(2322)</span>
  <span class="hljs-keyword">const</span> intersectionD: IntersectionUnion = <span class="hljs-string">'pt'</span>; <span class="hljs-comment">// ts(2322)</span>
</code></pre>
<p data-nodeid="2668">既然是求交集，如果多个联合类型中没有相同的类型成员，交叉出来的类型自然就是 never 了，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2669"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionC = <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span>;
  <span class="hljs-keyword">type</span> UnionD = <span class="hljs-string">'px'</span> | <span class="hljs-string">'pt'</span>;
  <span class="hljs-keyword">type</span> IntersectionUnionE = UnionC &amp; UnionD;
  <span class="hljs-keyword">const</span> intersectionE: IntersectionUnionE = <span class="hljs-string">'any'</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>; <span class="hljs-comment">// ts(2322) 不能赋予 'never' 类型</span>
</code></pre>
<p data-nodeid="2670">在上述示例中，因为 UnionC 和 UnionD 没有交集，交叉出来的类型 IntersectionUnionE 就是 never，所以我们不能把任何类型的值赋予 IntersectionUnionE 类型的变量。</p>
<h3 data-nodeid="2671">联合、交叉组合</h3>
<p data-nodeid="2672">在前面的示例中，我们把一些联合、交叉类型抽离成了类型别名，再把它作为原子类型进行进一步的联合、交叉。其实，联合、交叉类型本身就可以直接组合使用，这就涉及 |、&amp; 操作符的优先级问题。实际上，联合、交叉运算符不仅在行为上表现一致，还在运算的优先级和 JavaScript 的逻辑或 ||、逻辑与 &amp;&amp; 运算符上表现一致 。</p>
<p data-nodeid="2673">联合操作符 | 的优先级低于交叉操作符 &amp;，同样，我们可以通过使用小括弧 () 来调整操作符的优先级。</p>
<pre class="lang-typescript" data-nodeid="2674"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionIntersectionA = { id: <span class="hljs-built_in">number</span>; } &amp; { name: <span class="hljs-built_in">string</span>; } | { id: <span class="hljs-built_in">string</span>; } &amp; { name: <span class="hljs-built_in">number</span>; }; <span class="hljs-comment">// 交叉操作符优先级高于联合操作符</span>
  <span class="hljs-keyword">type</span> UnionIntersectionB = (<span class="hljs-string">'px'</span> | <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span> | <span class="hljs-string">'%'</span>) | (<span class="hljs-string">'vh'</span> | <span class="hljs-string">'em'</span> | <span class="hljs-string">'rem'</span> | <span class="hljs-string">'pt'</span>); <span class="hljs-comment">// 调整优先级</span>
</code></pre>
<p data-nodeid="2675">进而，我们也可以把分配率、交换律等基本规则引入类型组合中，然后优化出更简洁、清晰的类型，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2676"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionIntersectionC = ({ id: <span class="hljs-built_in">number</span>; } &amp; { name: <span class="hljs-built_in">string</span>; } | { id: <span class="hljs-built_in">string</span>; }) &amp; { name: <span class="hljs-built_in">number</span>; };
  <span class="hljs-keyword">type</span> UnionIntersectionD = { id: <span class="hljs-built_in">number</span>; } &amp; { name: <span class="hljs-built_in">string</span>; } &amp; { name: <span class="hljs-built_in">number</span>; } | { id: <span class="hljs-built_in">string</span>; } &amp; { name: <span class="hljs-built_in">number</span>; }; <span class="hljs-comment">// 满足分配率</span>
  <span class="hljs-keyword">type</span> UnionIntersectionE = ({ id: <span class="hljs-built_in">string</span>; } | { id: <span class="hljs-built_in">number</span>; } &amp; { name: <span class="hljs-built_in">string</span>; }) &amp; { name: <span class="hljs-built_in">number</span>; }; <span class="hljs-comment">// 满足交换律</span>
</code></pre>
<p data-nodeid="2677">在上述代码中，第 2 行是在第 1 行的基础上进行展开，说明 &amp; 满足分配率；第 3 行则是在第 1 行的基础上调整了成员的顺序，说明 | 操作满足交换律。</p>
<h3 data-nodeid="2678">类型缩减</h3>
<p data-nodeid="2679">这里呼应一下在介绍联合类型时埋下的伏笔：如果将 string 原始类型和“string字面量类型”组合成联合类型会是什么效果？效果就是类型缩减成 string 了。</p>
<p data-nodeid="2680">同样，对于 number、boolean（其实还有枚举类型，详见第 9 讲）也是一样的缩减逻辑，如下所示示例：</p>
<pre class="lang-typescript" data-nodeid="2681"><code data-language="typescript">  <span class="hljs-keyword">type</span> URStr = <span class="hljs-string">'string'</span> | <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 类型是 string</span>
  <span class="hljs-keyword">type</span> URNum = <span class="hljs-number">2</span> | <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 类型是 number</span>
  <span class="hljs-keyword">type</span> URBoolen = <span class="hljs-literal">true</span> | <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 类型是 boolean</span>
  <span class="hljs-keyword">enum</span> EnumUR {
    ONE,
    TWO
  }
  <span class="hljs-keyword">type</span> URE = EnumUR.ONE | EnumUR; <span class="hljs-comment">// 类型是 EnumUR</span>
</code></pre>
<p data-nodeid="2682">TypeScript 对这样的场景做了缩减，它把字面量类型、枚举成员类型缩减掉，只保留原始类型、枚举类型等父类型，这是合理的“优化”。</p>
<p data-nodeid="2683">可是这个缩减，却极大地削弱了 IDE 自动提示的能力，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2684"><code data-language="typescript">  <span class="hljs-keyword">type</span> BorderColor = <span class="hljs-string">'black'</span> | <span class="hljs-string">'red'</span> | <span class="hljs-string">'green'</span> | <span class="hljs-string">'yellow'</span> | <span class="hljs-string">'blue'</span> | <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 类型缩减成 string</span>
</code></pre>
<p data-nodeid="2685">在上述代码中，我们希望 IDE 能自动提示显示注解的字符串字面量，但是因为类型被缩减成 string，所有的字符串字面量 black、red 等都无法自动提示出来了。<br>
不要慌，TypeScript 官方其实还提供了一个黑魔法，它可以让类型缩减被控制。如下代码所示，我们只需要给父类型添加“&amp; {}”即可。</p>
<pre class="lang-typescript" data-nodeid="2686"><code data-language="typescript">  <span class="hljs-keyword">type</span> BorderColor = <span class="hljs-string">'black'</span> | <span class="hljs-string">'red'</span> | <span class="hljs-string">'green'</span> | <span class="hljs-string">'yellow'</span> | <span class="hljs-string">'blue'</span> | <span class="hljs-built_in">string</span> &amp; {}; <span class="hljs-comment">// 字面类型都被保留</span>
</code></pre>
<p data-nodeid="4268" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M01/41/AB/Cgp9HWCtuN2AaTQhAAIsKJ6nHYA767.png" alt="图片1.png" data-nodeid="4272"></p>
<div data-nodeid="4269"><p style="text-align:center">VS Code 自动提示效果图</p></div>






<p data-nodeid="2689">此时，其他字面量类型就不会被缩减掉了，在 IDE 中字符串字面量 black、red 等也就自然地可以自动提示出来了。</p>
<p data-nodeid="2690">此外，当联合类型的成员是接口类型，如果满足其中一个接口的属性是另外一个接口属性的子集，这个属性也会类型缩减，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2691"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionInterce =
  | {
      age: <span class="hljs-string">'1'</span>;
    }
  | ({
      age: <span class="hljs-string">'1'</span> | <span class="hljs-string">'2'</span>;
      [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
    });
</code></pre>
<p data-nodeid="2692">这里因为 '1' 是 '1' | '2' 的子集，所以 age 的属性变成 '1' | '2'：</p>
<p data-nodeid="2693">利用这个特性，我们来实现 07 讲中埋下的那个伏笔，如何定义如下所示 age 属性是数字类型，而其他不确定的属性是字符串类型的数据结构的对象？</p>
<pre class="lang-javascript" data-nodeid="2694"><code data-language="javascript">{
  <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 数字类型</span>
  <span class="hljs-attr">anyProperty</span>: <span class="hljs-string">'str'</span>, <span class="hljs-comment">// 其他不确定的属性都是字符串类型</span>
  ...
}
</code></pre>
<p data-nodeid="2695">在这里提到这个伏笔，想必你应该明白了，我们肯定要用到两个接口的联合类型及类型缩减，这个问题的核心在于找到一个既是 number 的子类型，这样 age 类型缩减之后的类型就是 number；同时也是 string 的子类型，这样才能满足属性和 string 索引类型的约束关系。</p>
<p data-nodeid="2696">哪个类型满足这个条件呢？我们一起回忆一下 02 讲中介绍的特殊类型 never。</p>
<p data-nodeid="2697">never 有一个特性是它是所有类型的子类型，自然也是 number 和 string 的子类型，所以答案如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="2698"><code data-language="typescript">  <span class="hljs-keyword">type</span> UnionInterce =
  | {
      age: <span class="hljs-built_in">number</span>;
    }
  | ({
      age: never;
      [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
    });
  <span class="hljs-keyword">const</span> O: UnionInterce = {
    age: <span class="hljs-number">2</span>,
    <span class="hljs-built_in">string</span>: <span class="hljs-string">'string'</span>
  };
</code></pre>
<p data-nodeid="2699">在上述代码中，我们在第 3 行定义了 number 类型的 age 属性，第 6 行定义了 never 类型的 age 属性，等价于 age 属性的类型是由 number 和 never 类型组成的联合类型，所以我们可以把 number 类型的值（比如说数字字面量 1）赋予 age 属性；但是不能把其他任何类型的值（比如说字符串字面量 'string' ）赋予 age。</p>
<p data-nodeid="2700">同时，我们在第 5 行~第 8 行定义的接口类型中，还额外定义了 string 类型的字符串索引签名。因为 never 同时又是 string 类型的子类型，所以 age 属性的类型和字符串索引签名类型不冲突。如第 9 行~第 12 行所示，我们可以把一个 age 属性是 2、string 属性是 'string' 的对象字面量赋值给 UnionInterce 类型的变量 O。</p>
<h3 data-nodeid="2701">小结与预告</h3>
<p data-nodeid="2702">这一讲中介绍的联合和交叉类型赋予了 TypeScript 类型最基本的“编程”（运算）能力，学习和掌握联合和交叉类型后，可以培养我们抽离、复用公共类型的意识和能力。</p>
<p data-nodeid="2703">插播一个思考题：在联合类型中，类型缩减的规则是什么？欢迎你在留言区与我进行交流、互动。</p>
<p data-nodeid="2704">09 讲我们将介绍如何定义常量集合的方法——枚举类型，敬请期待~</p>
<p data-nodeid="2705" class="">另外，如果你觉得本专栏有价值，欢迎分享给更多好友。</p>

---

### 精选评论

##### **8866：
> 请教一下，同样是取逻辑与，这两种case为什么表现不一样？type IntersectionType = { id: number; name: string; }type UnionA = 'px' | 'em' | 'rem' | '%';type UnionB = 'vh' | 'em' | 'rem' | 'pt';type IntersectionUnion = UnionA 对interface  会只取交集？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; A & B 本质上就是说类型既符合 A 也符合 B，所以如果 A、B 是接口类型，就等于是把他们合并为一个接口类型（类比求并集）；但是如果 A、B 是联合类型，则会得到他们公共成员类型（类比求交集）。

##### **乐：
> type URStr = 'string' | string; // 类型是 string 这个地方的类型缩减感觉不是太理解, 字符串字面量是 string类型的子集, 组合成联合类型为string类型,不是应该为类型拓展. 组合成联合类型类型种类缩减(字符串字面量类型和string类型两种类型缩减为string类型)

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你这样理解也不是不可以——我之所以会解释成“缩减”，一方面是因为官方原文是用的“reduction”；另外从集合的概念上看，是从 'string' 和 string 并集，变成了 string 子集，所以是“缩减”。

##### **阳：
> 这节课的内容在工作中用到的情况多么？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 以一个 React + TypeScript 重度使用者的经验来看，会用的比较多。比如说连接到 Redux 的高阶组件的 Props，一般可以通过 OwnProps 和 ConnectedProps 交叉得来。

##### **澳：
> 这一讲特别实用，解决了很多我在开发React + TypeScript项目中使用TypeScript的一些困惑，感谢老师！

##### **俊：
> 子类型

##### **英：
> '1' | '2' | string，我的ide没缩减，我的ts版本是4.3.2，可能是新版本改了吧，不需要‘ {}’了

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 不太有可能，这不符合逻辑。而且我通过 playground 4.3.0 beta 验证，还是会缩减的。

