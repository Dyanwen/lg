<p data-nodeid="973" class="">【黑马】2</p>
<p data-nodeid="5638" class="te-preview-highlight">05 讲我们学习了 TypeScript 中抽象、封装的利器——函数类型，接下来我们将学习另一个集面向对象继承、封装、多态三要素为一体的编程利器，类类型。</p>










<blockquote data-nodeid="975">
<p data-nodeid="976">学习建议：请使用 VS Code，新建一个 06.ts 文件尝试以下所有示例，以便帮助你更好地理解、吸收知识。</p>
</blockquote>
<p data-nodeid="977">在JavaScript（ES5）中仅支持通过函数和原型链继承模拟类的实现（用于抽象业务模型、组织数据结构并创建可重用组件），自 ES6 引入 class 关键字后，它才开始支持使用与<code data-backticks="1" data-nodeid="1068">Java</code>类似的语法定义声明类。</p>
<p data-nodeid="978">TypeScript 作为 JavaScript 的超集，自然也支持 class 的全部特性，并且还可以对类的属性、方法等进行静态类型检测。</p>
<h3 data-nodeid="979">类</h3>
<p data-nodeid="980">在实际业务中，任何实体都可以被抽象为一个使用类表达的类似对象的数据结构，且这个数据结构既包含属性，又包含方法，比如我们在下方抽象了一个狗的类。</p>
<pre class="lang-typescript" data-nodeid="981"><code data-language="typescript"><span class="hljs-keyword">class</span> Dog {
 &nbsp;name: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.name = name;
  }

 &nbsp;bark() {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
  }
}

<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'Q'</span>);
dog.bark(); <span class="hljs-comment">// =&gt; 'Woof! Woof!'</span>
</code></pre>
<p data-nodeid="982">首先，我们定义了一个 class Dog ，它拥有 string 类型的 name 属性（见第 2 行）、bark 方法（见第 7 行）和一个构造器函数（见第 3 行）。然后，我们通过 new 关键字创建了一个 Dog 的实例，并把实例赋值给变量 dog（见 12 行）。最后，我们通过实例调用了类中定义的 bark 方法（见 13 行）。</p>
<p data-nodeid="983">如果使用传统的 JavaScript 代码定义类，我们需要使用函数+原型链的形式进行模拟，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="984"><code data-language="typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) </span>{
 &nbsp;<span class="hljs-keyword">this</span>.name = name; <span class="hljs-comment">// ts(2683) 'this' implicitly has type 'any' because it does not have a type annotation.</span>
}
Dog.prototype.bark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
 &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
};

<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">'Q'</span>); <span class="hljs-comment">// ts(7009) 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.</span>
dog.bark(); <span class="hljs-comment">// =&gt; 'Woof! Woof!'</span>
</code></pre>
<p data-nodeid="985">在第 1～ 3 行，我们定义了 Dog 类的构造函数，并在构造函数内部定义了 name 属性，再在第 4 行通过 Dog 的原型链添加 bark 方法。</p>
<p data-nodeid="986">和通过 class 方式定义类相比，这种方式明显麻烦不少，而且还缺少静态类型检测。因此，类是 TypeScript 编程中十分有用且不得不掌握的工具。</p>
<p data-nodeid="987">下面我们看一下关于类最主要的特性——继承，也是面向对象编程三大要素之一。</p>
<h3 data-nodeid="988">继承</h3>
<p data-nodeid="989">在 TypeScript 中，使用 extends 关键字就能很方便地定义类继承的抽象模式，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="990"><code data-language="typescript"><span class="hljs-keyword">class</span> Animal {
 &nbsp;<span class="hljs-keyword">type</span> = <span class="hljs-string">'Animal'</span>;
 &nbsp;say(name: <span class="hljs-built_in">string</span>) {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I'm <span class="hljs-subst">${name}</span>!`</span>);
  }
}

<span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">extends</span> Animal {
 &nbsp;bark() {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
  }
}

<span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> Dog();
dog.bark(); <span class="hljs-comment">// =&gt; 'Woof! Woof!'</span>
dog.say(<span class="hljs-string">'Q'</span>); <span class="hljs-comment">// =&gt; I'm Q!</span>
dog.type; <span class="hljs-comment">// =&gt; Animal</span>
</code></pre>
<p data-nodeid="991">上面的例子展示了类最基本的继承用法。比如第 8 ～12 行定义的<code data-backticks="1" data-nodeid="1081">Dog</code>是派生类，它派生自第 1～6 行定义的<code data-backticks="1" data-nodeid="1083">Animal</code>基类，此时<code data-backticks="1" data-nodeid="1085">Dog</code>实例继承了基类<code data-backticks="1" data-nodeid="1087">Animal</code>的属性和方法。因此，在第 15～17 行我们可以看到，实例 dog 支持 bark、say、type 等属性和方法。</p>
<blockquote data-nodeid="992">
<p data-nodeid="993">说明：派生类通常被称作子类，基类也被称作超类（或者父类）。</p>
</blockquote>
<p data-nodeid="994">细心的你可能发现了，这里的 Dog 基类与第一个例子中的类相比，少了一个构造函数。<strong data-nodeid="1094">这是因为派生类如果包含一个构造函数，则必须在构造函数中调用 super() 方法，这是 TypeScript 强制执行的一条重要规则。</strong></p>
<p data-nodeid="995">如下示例，因为第 1～10 行定义的 Dog 类构造函数中没有调用 super 方法，所以提示了一个 ts(2377) 的错误；而第 12～22 行定义的 Dog 类构造函数中添加了 super 方法调用，所以可以通过类型检测。</p>
<pre class="lang-typescript" data-nodeid="996"><code data-language="typescript"><span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">extends</span> Animal {
 &nbsp;name: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) { <span class="hljs-comment">// ts(2377) Constructors for derived classes must contain a 'super' call.</span>
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.name = name;
  }

 &nbsp;bark() {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
  }
}

<span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">extends</span> Animal {
 &nbsp;name: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">super</span>(); <span class="hljs-comment">// 添加 super 方法</span>
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.name = name;
  }

 &nbsp;bark() {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
  }
}
</code></pre>
<p data-nodeid="997">有些同学可能会好奇，这里的 super() 是什么作用？其实这里的 super 函数会调用基类的构造函数，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="998"><code data-language="typescript"><span class="hljs-keyword">class</span> Animal {
 &nbsp;weight: <span class="hljs-built_in">number</span>;
 &nbsp;<span class="hljs-keyword">type</span> = <span class="hljs-string">'Animal'</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">weight: <span class="hljs-built_in">number</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.weight = weight;
  }
 &nbsp;say(name: <span class="hljs-built_in">string</span>) {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`I'm <span class="hljs-subst">${name}</span>!`</span>);
  }
}

<span class="hljs-keyword">class</span> Dog <span class="hljs-keyword">extends</span> Animal {
 &nbsp;name: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">super</span>(); <span class="hljs-comment">// ts(2554) Expected 1 arguments, but got 0.</span>
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.name = name;
  }

 &nbsp;bark() {
 &nbsp; &nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Woof! Woof!'</span>);
  }
}
</code></pre>
<p data-nodeid="999">将鼠标放到第 15 行 Dog 类构造函数调用的 super 函数上，我们可以看到一个提示，它的类型是基类 Animal 的构造函数：constructor Animal(weight: number): Animal 。并且因为 Animal 类的构造函数要求必须传入一个数字类型的 weight 参数，而第 15 行实际入参为空，所以提示了一个 ts(2554) 的错误；如果我们显式地给 super 函数传入一个 number 类型的值，比如说 super(20)，则不会再提示错误了。</p>
<h3 data-nodeid="1000">公共、私有与受保护的修饰符</h3>
<p data-nodeid="1001">类属性和方法除了可以通过 extends 被继承之外，还可以通过修饰符控制可访问性。</p>
<p data-nodeid="1002">在 TypeScript 中就支持 3 种访问修饰符，分别是 public、private、protected。</p>
<ul data-nodeid="1003">
<li data-nodeid="1004">
<p data-nodeid="1005">public 修饰的是在任何地方可见、公有的属性或方法；</p>
</li>
<li data-nodeid="1006">
<p data-nodeid="1007">private 修饰的是仅在同一类中可见、私有的属性或方法；</p>
</li>
<li data-nodeid="1008">
<p data-nodeid="1009">protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。</p>
</li>
</ul>
<p data-nodeid="1010">在之前的代码中，示例类并没有用到可见性修饰符，在缺省情况下，类的属性或方法默认都是 public。如果想让有些属性对外不可见，那么我们可以使用<code data-backticks="1" data-nodeid="1105">private</code>进行设置，如下所示：</p>
<pre class="lang-typescript" data-nodeid="1011"><code data-language="typescript"><span class="hljs-keyword">class</span> Son {
 &nbsp;<span class="hljs-keyword">public</span> firstName: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">private</span> lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Stark'</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.firstName = firstName;
    <span class="hljs-keyword">this</span>.lastName; <span class="hljs-comment">// ok</span>
  }
}

<span class="hljs-keyword">const</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'Tony'</span>);
<span class="hljs-built_in">console</span>.log(son.firstName); <span class="hljs-comment">//  =&gt; "Tony"</span>
son.firstName = <span class="hljs-string">'Jack'</span>;
<span class="hljs-built_in">console</span>.log(son.firstName); <span class="hljs-comment">//  =&gt; "Jack"</span>
<span class="hljs-built_in">console</span>.log(son.lastName); <span class="hljs-comment">// ts(2341) Property 'lastName' is private and only accessible within class 'Son'.</span>
</code></pre>
<p data-nodeid="1012">在上面的例子中我们可以看到，第 3 行 Son 类的 lastName 属性是私有的，只在 Son 类中可见；第 2 行定义的 firstName 属性是公有的，在任何地方都可见。因此，我们既可以通过第 10 行创建的 Son 类的实例 son 获取或设置公共的 firstName 的属性（如第 11 行所示），还可以操作更改 firstName 的值（如第 12 行所示）。</p>
<p data-nodeid="1013">不过，对于 private 修饰的私有属性，只可以在类的内部可见。比如第 6 行，私有属性 lastName 仅在 Son 类中可见，如果其他地方获取了 lastName ，TypeScript 就会提示一个 ts(2341) 的错误（如第 14 行）。</p>
<blockquote data-nodeid="1014">
<p data-nodeid="1015"><strong data-nodeid="1113">注意</strong>：TypeScript 中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略 TypeScript 类型的检查错误，转译且运行 JavaScript 时依旧可以获取到 lastName 属性，这是因为 JavaScript 并不支持真正意义上的私有属性。</p>
</blockquote>
<p data-nodeid="1016">目前，JavaScript 类支持 private 修饰符的提案已经到 stage 3 了。相信在不久的将来，私有属性在类型检测和运行阶段都可以被限制为仅在类的内部可见。如果你感兴趣的话，可以在<a href="https://github.com/tc39/proposal-private-methods?fileGuid=KLALBzHdpAQfyj7n" data-nodeid="1117">proposal-private-methods</a>中进行查看。</p>
<p data-nodeid="1017">接下来我们再看一下受保护的属性和方法，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1018"><code data-language="typescript"><span class="hljs-keyword">class</span> Son {
 &nbsp;<span class="hljs-keyword">public</span> firstName: <span class="hljs-built_in">string</span>;
 &nbsp;<span class="hljs-keyword">protected</span> lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Stark'</span>;
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">this</span>.firstName = firstName;
    <span class="hljs-keyword">this</span>.lastName; <span class="hljs-comment">// ok</span>
  }
}

<span class="hljs-keyword">class</span> GrandSon <span class="hljs-keyword">extends</span> Son {
 &nbsp;<span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
 &nbsp; &nbsp;<span class="hljs-keyword">super</span>(firstName);
  }

 &nbsp;<span class="hljs-keyword">public</span> getMyLastName() {
 &nbsp; &nbsp;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lastName;
  }
}

<span class="hljs-keyword">const</span> grandSon = <span class="hljs-keyword">new</span> GrandSon(<span class="hljs-string">'Tony'</span>);
<span class="hljs-built_in">console</span>.log(grandSon.getMyLastName()); <span class="hljs-comment">// =&gt; "Stark"</span>
grandSon.lastName; <span class="hljs-comment">// ts(2445) Property 'lastName' is protected and only accessible within class 'Son' and its subclasses.</span>
</code></pre>
<p data-nodeid="1019">在第 3 行，修改 Son 类的 lastName 属性可见修饰符为 protected，表明此属性在 Son 类及其子类中可见。如示例第 6 行和第 16 行所示，我们既可以在父类 Son 的构造器中获取 lastName 属性值，又可以在继承自 Son 的子类 GrandSon 的 getMyLastName 方法获取 lastName 属性的值。</p>
<blockquote data-nodeid="1020">
<p data-nodeid="1021"><strong data-nodeid="1127">需要注意</strong>：虽然我们不能通过派生类的实例访问<code data-backticks="1" data-nodeid="1125">protected</code>修饰的属性和方法，但是可以通过派生类的实例方法进行访问。比如示例中的第 21 行，通过实例的 getMyLastName 方法获取受保护的属性 lastName 是 ok 的，而第 22 行通过实例直接获取受保护的属性 lastName 则提示了一个 ts(2445) 的错误。</p>
</blockquote>
<h3 data-nodeid="1022">只读修饰符</h3>
<p data-nodeid="1023">在前面的例子中，Son 类 public 修饰的属性既公开可见，又可以更改值，如果我们不希望类的属性被更改，则可以使用 readonly 只读修饰符声明类的属性，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1024"><code data-language="typescript"><span class="hljs-keyword">class</span> Son {
  <span class="hljs-keyword">public</span> readonly firstName: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.firstName = firstName;
  }
}
<span class="hljs-keyword">const</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'Tony'</span>);
son.firstName = <span class="hljs-string">'Jack'</span>; <span class="hljs-comment">// ts(2540) Cannot assign to 'firstName' because it is a read-only property.</span>
</code></pre>
<p data-nodeid="1025">在第 2 行，我们给公开可见属性 firstName 指定了只读修饰符，这个时候如果再更改 firstName 属性的值，TypeScript 就会提示一个 ts(2540) 的错误（参见第 9 行）。这是因为只读属性修饰符保证了该属性只能被读取，而不能被修改。</p>
<blockquote data-nodeid="1026">
<p data-nodeid="1027">注意：如果只读修饰符和可见性修饰符同时出现，我们需要将只读修饰符写在可见修饰符后面。</p>
</blockquote>
<h3 data-nodeid="1028">存取器</h3>
<p data-nodeid="1029">除了上边提到的修饰符之外，在 TypeScript 中还可以通过<code data-backticks="1" data-nodeid="1134">getter</code>、<code data-backticks="1" data-nodeid="1136">setter</code>截取对类成员的读写访问。</p>
<p data-nodeid="1030">通过对类属性访问的截取，我们可以实现一些特定的访问控制逻辑。下面我们把之前的示例改造一下，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1031"><code data-language="typescript"><span class="hljs-keyword">class</span> Son {
  <span class="hljs-keyword">public</span> firstName: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">protected</span> lastName: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Stark'</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.firstName = firstName;
  }
}
<span class="hljs-keyword">class</span> GrandSon <span class="hljs-keyword">extends</span> Son {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">firstName: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">super</span>(firstName);
  }
  <span class="hljs-keyword">get</span> myLastName() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lastName;
  }
  <span class="hljs-keyword">set</span> myLastName(name: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.firstName === <span class="hljs-string">'Tony'</span>) {
      <span class="hljs-keyword">this</span>.lastName = name;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'Unable to change myLastName'</span>);
    }
  }
}
<span class="hljs-keyword">const</span> grandSon = <span class="hljs-keyword">new</span> GrandSon(<span class="hljs-string">'Tony'</span>);
<span class="hljs-built_in">console</span>.log(grandSon.myLastName); <span class="hljs-comment">// =&gt; "Stark"</span>
grandSon.myLastName = <span class="hljs-string">'Rogers'</span>;
<span class="hljs-built_in">console</span>.log(grandSon.myLastName); <span class="hljs-comment">// =&gt; "Rogers"</span>
<span class="hljs-keyword">const</span> grandSon1 = <span class="hljs-keyword">new</span> GrandSon(<span class="hljs-string">'Tony1'</span>);
grandSon1.myLastName = <span class="hljs-string">'Rogers'</span>; <span class="hljs-comment">// =&gt; "Unable to change myLastName"</span>
</code></pre>
<p data-nodeid="1032">在第 14～24 行，我们使用 myLastName 的<code data-backticks="1" data-nodeid="1140">getter</code>、<code data-backticks="1" data-nodeid="1142">setter</code>重写了之前的 GrandSon 类的方法，在 getter 中实际返回的是 lastName 属性。然后，在 setter 中，我们限定仅当 lastName 属性值为 'Tony' ，才把入参 name 赋值给它，否则打印错误。<br>
在第 28 行中，我们可以像访问类属性一样访问<code data-backticks="1" data-nodeid="1150">getter</code>，同时也可以像更改属性值一样给<code data-backticks="1" data-nodeid="1152">setter</code>赋值，并执行一些自定义逻辑。</p>
<p data-nodeid="1033">在第 27 行，因为 grandSon 实例的 lastName 属性被初始化成了 'Tony'，所以在第 29 行我们可以把 'Rogers' 赋值给 setter 。而 grandSon1 实例的 lastName 属性在第 32 行被初始化为 'Tony1'，所以在第 33 行把 'Rogers' 赋值给 setter 时，打印了我们自定义的错误信息。</p>
<h3 data-nodeid="1034">静态属性</h3>
<p data-nodeid="1035">以上介绍的关于类的所有属性和方法，只有类在实例化时才会被初始化。实际上，我们也可以给类定义静态属性和方法。</p>
<p data-nodeid="1036">因为这些属性存在于类这个特殊的对象上，而不是类的实例上，所以我们可以直接通过类访问静态属性，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1037"><code data-language="typescript"><span class="hljs-keyword">class</span> MyArray {
  <span class="hljs-keyword">static</span> displayName = <span class="hljs-string">'MyArray'</span>;
  <span class="hljs-keyword">static</span> isArray(obj: unknown) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>) === <span class="hljs-string">'Array'</span>;
  }
}
<span class="hljs-built_in">console</span>.log(MyArray.displayName); <span class="hljs-comment">// =&gt; "MyArray"</span>
<span class="hljs-built_in">console</span>.log(MyArray.isArray([])); <span class="hljs-comment">// =&gt; true</span>
<span class="hljs-built_in">console</span>.log(MyArray.isArray({})); <span class="hljs-comment">// =&gt; false</span>
</code></pre>
<p data-nodeid="1038">在第 2～3 行，通过 static 修饰符，我们给 MyArray 类分别定义了一个静态属性 displayName 和静态方法 isArray。之后，我们无须实例化 MyArray 就可以直接访问类上的静态属性和方法了，比如第 8 行访问的是静态属性 displayName，第 9～10 行访问的是静态方法 isArray。</p>
<p data-nodeid="1039">基于静态属性的特性，我们往往会把与类相关的常量、不依赖实例 this 上下文的属性和方法定义为静态属性，从而避免数据冗余，进而提升运行性能。</p>
<blockquote data-nodeid="1040">
<p data-nodeid="1041"><strong data-nodeid="1179">注意：上边我们提到了不依赖实例 this 上下文的方法就可以定义成静态方法，这就意味着需要显式注解 this 类型才可以在静态方法中使用 this；非静态方法则不需要显式注解 this 类型，因为 this 的指向默认是类的实例。</strong></p>
</blockquote>
<h3 data-nodeid="1042">抽象类</h3>
<p data-nodeid="1043">接下来我们看看关于类的另外一个特性——抽象类，它是一种不能被实例化仅能被子类继承的特殊类。</p>
<p data-nodeid="1044">我们可以使用抽象类定义派生类需要实现的属性和方法，同时也可以定义其他被继承的默认属性和方法，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1045"><code data-language="typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> Adder {
  <span class="hljs-keyword">abstract</span> x: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">abstract</span> y: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">abstract</span> add(): <span class="hljs-built_in">number</span>;
  displayName = <span class="hljs-string">'Adder'</span>;
  addTwice(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y) * <span class="hljs-number">2</span>;
  }
}
<span class="hljs-keyword">class</span> NumAdder <span class="hljs-keyword">extends</span> Adder {
  x: <span class="hljs-built_in">number</span>;
  y: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-keyword">super</span>();
    <span class="hljs-keyword">this</span>.x = x;
    <span class="hljs-keyword">this</span>.y = y;
  }
  add(): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y;
  }
}
<span class="hljs-keyword">const</span> numAdder = <span class="hljs-keyword">new</span> NumAdder(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-built_in">console</span>.log(numAdder.displayName); <span class="hljs-comment">// =&gt; "Adder"</span>
<span class="hljs-built_in">console</span>.log(numAdder.add()); <span class="hljs-comment">// =&gt; 3</span>
<span class="hljs-built_in">console</span>.log(numAdder.addTwice()); <span class="hljs-comment">// =&gt; 6</span>
</code></pre>
<p data-nodeid="1046">在第 1～10 行，通过 abstract 关键字，我们定义了一个抽象类 Adder，并通过<code data-backticks="1" data-nodeid="1184">abstract</code>关键字定义了抽象属性<code data-backticks="1" data-nodeid="1186">x</code>、<code data-backticks="1" data-nodeid="1188">y</code>及方法<code data-backticks="1" data-nodeid="1190">add</code>，而且任何继承 Adder 的派生类都需要实现这些抽象属性和方法。</p>
<p data-nodeid="1047">同时，我们还在抽象类 Adder 中定义了可以被派生类继承的非抽象属性<code data-backticks="1" data-nodeid="1193">displayName</code>和方法<code data-backticks="1" data-nodeid="1195">addTwice</code>。</p>
<p data-nodeid="1048">然后，我们在第 12～23 行定义了继承抽象类的派生类 NumAdder， 并实现了抽象类里定义的 x、y 抽象属性和 add 抽象方法。如果派生类中缺少对 x、y、add 这三者中任意一个抽象成员的实现，那么第 12 行就会提示一个 ts(2515) 错误，关于这点你可以亲自验证一下。</p>
<p data-nodeid="1049">抽象类中的其他非抽象成员则可以直接通过实例获取，比如第 26～28 行中，通过实例 numAdder，我们获取了 displayName 属性和 addTwice 方法。</p>
<p data-nodeid="1050">因为抽象类不能被实例化，并且派生类必须实现继承自抽象类上的抽象属性和方法定义，所以抽象类的作用其实就是对基础逻辑的封装和抽象。</p>
<p data-nodeid="1051">实际上，我们也可以定义一个描述对象结构的接口类型（详见 07 讲）抽象类的结构，并通过 implements 关键字约束类的实现。</p>
<p data-nodeid="1052">使用接口与使用抽象类相比，区别在于接口只能定义类成员的类型，如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1053"><code data-language="typescript"><span class="hljs-keyword">interface</span> IAdder {
&nbsp; x: <span class="hljs-built_in">number</span>;
&nbsp; y: <span class="hljs-built_in">number</span>;
&nbsp; add: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">number</span>;
}
<span class="hljs-keyword">class</span> NumAdder <span class="hljs-keyword">implements</span> IAdder {
&nbsp; x: <span class="hljs-built_in">number</span>;
&nbsp; y: <span class="hljs-built_in">number</span>;
&nbsp; <span class="hljs-keyword">constructor</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span></span>) {
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.x = x;
&nbsp; &nbsp; <span class="hljs-keyword">this</span>.y = y;
&nbsp; }
&nbsp; add() {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y;
&nbsp; }
&nbsp; addTwice() {
&nbsp; &nbsp; <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.x + <span class="hljs-keyword">this</span>.y) * <span class="hljs-number">2</span>;
&nbsp; }
}
</code></pre>
<p data-nodeid="1054">在第 1～5 行，我们定义了一个包含 x、y、add 属性和方法的接口类型（详见 07 讲），然后在第 6～12 行实现了拥有接口约定的x、y 属性和 add 方法，以及接口未约定的 addTwice 方法的NumAdder类 。</p>
<h3 data-nodeid="1055">类的类型</h3>
<p data-nodeid="1056">类的最后一个特性——类的类型和函数类似，即在声明类的时候，其实也同时声明了一个特殊的类型（确切地讲是一个接口类型），这个类型的名字就是类名，表示类实例的类型；在定义类的时候，我们声明的除构造函数外所有属性、方法的类型就是这个特殊类型的成员。如下代码所示：</p>
<pre class="lang-typescript" data-nodeid="1057"><code data-language="typescript"><span class="hljs-keyword">class</span> A {
  name: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) {
    <span class="hljs-keyword">this</span>.name = name;
  }
}
<span class="hljs-keyword">const</span> a1: A = {}; <span class="hljs-comment">// ts(2741) Property 'name' is missing in type '{}' but required in type 'A'.</span>
<span class="hljs-keyword">const</span> a2: A = { name: <span class="hljs-string">'a2'</span> }; <span class="hljs-comment">// ok</span>
</code></pre>
<p data-nodeid="1058">在第 1～6 行，我们在定义类 A ，也说明我们同时定义了一个包含字符串属性 name 的同名接口类型 A。因此，在第 7 行把一个空对象赋值给类型是 A 的变量 a1 时，TypeScript 会提示一个 ts(2741) 错误，因为缺少 name 属性。在第 8 行把对象{ name: 'a2' }赋值给类型同样是 A 的变量 a2 时，TypeScript 就直接通过了类型检查，因为有 name 属性。</p>
<h3 data-nodeid="1059">小结与预告</h3>
<p data-nodeid="1060">在 TypeScript 中，因为我们需要实践 OOP 编程思想，所以离不开类的支撑。在实际工作中，类与函数一样，都是极其有用的抽象、封装利器。</p>
<p data-nodeid="1061">这里插播一道思考题：public、private、protected 属性的区别是什么？欢迎你在留言区互动、交流。</p>
<p data-nodeid="1062">07 讲我们将详细介绍这一讲中重度涉及和依赖的接口类型，敬请期待。</p>
<p data-nodeid="1063" class="">另外，如果你觉得本专栏有价值，欢迎分享给更多好友哦~</p>

---

### 精选评论

##### **6105：
> public哪都能用，private只有基类可以用，protected基类和派生类中可以用

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 正解！

##### **路：
> public是公开的，可以被访问和修改，private是私有的,只在其定义的类内可被访问和修改，protected是受保护的，只能在自身及子类中被访问和修改

##### **其：
> public可以在类、子类内部以及类的实例上访问和修改；private只能在类的内部访问和修改，子类无法访问，类的实例也无法访问；protected可以在类和子类内部访问和修改，但是不能在实例上访问。问一下protected修饰符有什么使用场景？ts为什么要加es规范里没有的一个修饰符

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; protected：内部可访问，子类可访问，外部不可访问（单纯类型层面）。

##### **凤：
> public：内部可访问，子类可访问，外部可访问。protected：内部可访问，子类可访问，外部不可访问。private：内部可访问，子类不可访问，外部不可访问。

