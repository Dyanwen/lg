<p data-nodeid="31453" class="">上一讲我们花了不少篇幅讲解了软件退化的根源，以及 DDD 如何解决软件退化的问题。现在，我们以电商网站的支付功能为例，来重新演练一下基于 DDD 的软件设计及其变更的过程。</p>
<h3 data-nodeid="31454">运用 DDD 进行软件设计</h3>
<p data-nodeid="31455">开发人员在最开始收到的关于用户付款功能的需求描述是这样的：</p>
<ul data-nodeid="31456">
<li data-nodeid="31457">
<p data-nodeid="31458">在用户下单以后，经过下单流程进入付款功能；</p>
</li>
<li data-nodeid="31459">
<p data-nodeid="31460">通过用户档案获得用户名称、地址等信息；</p>
</li>
<li data-nodeid="31461">
<p data-nodeid="31462">记录商品及其数量，并汇总付款金额；</p>
</li>
<li data-nodeid="31463">
<p data-nodeid="31464">保存订单；</p>
</li>
<li data-nodeid="31465">
<p data-nodeid="31466">通过远程调用支付接口进行支付。</p>
</li>
</ul>
<p data-nodeid="31467">以往当拿到这个需求时，开发人员往往草草设计以后就开始编码，设计质量也就不高。</p>
<p data-nodeid="31468">而<strong data-nodeid="31574">采用领域驱动的方式，在拿到新需求以后，应当先进行需求分析，设计领域模型。</strong> 按照以上业务场景，可以分析出：</p>
<ul data-nodeid="31469">
<li data-nodeid="31470">
<p data-nodeid="31471">该场景中有“订单”，每个订单都对应一个用户；</p>
</li>
<li data-nodeid="31472">
<p data-nodeid="31473">一个用户可以有多个用户地址，但每个订单只能有一个用户地址；</p>
</li>
<li data-nodeid="31474">
<p data-nodeid="31475">此外，一个订单对应多个订单明细，每个订单明细对应一个商品，每个商品对应一个供应商。</p>
</li>
</ul>
<p data-nodeid="31476"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziNWAAo44AAC1mEZLzQ4146.png" alt="Drawing 0.png" data-nodeid="31580"></p>
<p data-nodeid="31477">最后，我们对订单可以进行“下单”“付款”“查看订单状态”等操作。因此形成了以下领域模型图：</p>
<p data-nodeid="31478"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziMaANHZ2AABItYXLHGw993.png" alt="Drawing 2.png" data-nodeid="31584"></p>
<p data-nodeid="31479">有了这样的领域模型，就可以通过该模型进行以下程序设计：</p>
<p data-nodeid="31480"><img src="https://s0.lgstatic.com/i/image/M00/6E/C4/Ciqc1F-ziN2Ado7rAABZ7uoFaUk291.png" alt="Drawing 4.png" data-nodeid="31588"></p>
<p data-nodeid="31481">通过领域模型的指导，将“订单”分为订单 Service 与值对象，将“用户”分为用户 Service 与值对象，将“商品”分为商品 Service 与值对象……然后，在此基础上实现各自的方法。</p>
<h3 data-nodeid="31482">商品折扣的需求变更</h3>
<p data-nodeid="31483">当电商网站的付款功能按照领域模型完成了第一个版本的设计后，很快就迎来了<strong data-nodeid="31596">第一次需求变更，即增加折扣功能</strong>，并且该折扣功能分为限时折扣、限量折扣、某类商品的折扣、某个商品的折扣与不折扣。当我们拿到这个需求时应当怎样设计呢？很显然，在 payoff() 方法中去插入 if 语句是不 OK 的。这时，按照领域驱动设计的思想，应当将需求变更还原到领域模型中进行分析，进而根据领域模型背后的真实世界进行变更。</p>
<p data-nodeid="31484"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziOaAfB4LAAC5Mx6eA2E697.png" alt="Drawing 6.png" data-nodeid="31599"></p>
<p data-nodeid="31485">这是上一个版本的领域模型，现在我们要在这个模型的基础上增加折扣功能，并且还要分为限时折扣、限量折扣、某类商品的折扣等不同类型。这时，我们应当怎么分析设计呢？</p>
<p data-nodeid="31486"><strong data-nodeid="31604">首先要分析付款与折扣的关系。</strong></p>
<p data-nodeid="31487">付款与折扣是什么关系呢？你可能会认为折扣是在付款的过程中进行的折扣，因此就应当将折扣写到付款中。这样思考对吗？我们应当基于什么样的思想与原则来设计呢？这时，另外一个重量级的设计原则应该出场了，那就是“单一职责原则”。</p>
<p data-nodeid="31488"><strong data-nodeid="31610">单一职责原则</strong>：软件系统中的每个元素只完成自己职责范围内的事，而将其他的事交给别人去做，我只是去调用。</p>
<p data-nodeid="31489">单一职责原则是软件设计中一个非常重要的原则，但如何正确地理解它成为一个非常关键的问题。在这句话中，准确理解的关键就在于“<strong data-nodeid="31616">职责</strong>”二字，即自己职责的范围到底在哪里。以往，我们错误地理解这个“职责”就是做某一个事，与这个事情相关的所有事情都是它的职责，正因为这个错误的理解，带来了许多错误的设计，而将折扣写到付款功能中。那么，怎样才是对“职责”正确的理解呢？</p>
<p data-nodeid="31490">“一个职责就是软件变化的一个原因”是著名的软件大师 Bob 大叔在他的《敏捷软件开发：原则、模式与实践》中的表述。但这个表述过于精简，很难深刻地理解其中的内涵，从而不能有效地提高我们的设计质量。这里我好好解读一下这句话。</p>
<p data-nodeid="31491">先思考一下什么是高质量的代码。你可能立即会想到“低耦合、高内聚”，以及各种设计原则，但这些评价标准都太“虚”。<strong data-nodeid="31623">最直接、最落地的评价标准就是，当用户提出一个需求变更时，为了实现这个变更而修改软件的成本越低，那么软件的设计质量就越高。</strong> 当来了一个需求变更时，怎样才能让修改软件的成本降低呢？如果为了实现这个需求，需要修改 3 个模块的代码，完后这 3 个模块都需要测试，其维护成本必然是“高”。那么怎样才能降到最低呢？维护 0 个模块的代码？那显然是不可能的，因此最现实的方案就是只修改 1 个模块，维护成本最低。</p>
<p data-nodeid="31492">那么，怎样才能在每次变更的时候都只修改一个模块就能实现新需求呢？那就需要我们在平时就不断地整理代码，将那些因同一个原因而变更的代码都放在一起，而将因不同原因而变更的代码分开放，放在不同的模块、不同的类中。这样，当因为这个原因而需要修改代码时，需要修改的代码都在这个模块、这个类中，修改范围就缩小了，维护成本降低了，自然设计质量就提高了。</p>
<p data-nodeid="31493"><strong data-nodeid="31629">总之，单一职责原则要求我们在维护软件的过程中需要不断地进行整理，将软件变化同一个原因的代码放在一起，将软件变化不同原因的代码分开放。</strong> 按照这样的设计原则，回到前面那个案例中，那么应当怎样去分析“付款”与“折扣”之间的关系呢？只需要回答两个问题：</p>
<ul data-nodeid="31494">
<li data-nodeid="31495">
<p data-nodeid="31496">当“付款”发生变更时，“折扣”是不是一定要变？</p>
</li>
<li data-nodeid="31497">
<p data-nodeid="31498">当“折扣”发生变更时，“付款”是不是一定要变？</p>
</li>
</ul>
<p data-nodeid="31499">当这两个问题的答案是否定时，就说明“付款”与“折扣”是软件变化的两个不同的原因，那么把它们放在一起，放在同一个类、同一个方法中，合适吗？不合适，就应当将“折扣”从“付款”中提取出来，单独放在一个类中。</p>
<p data-nodeid="31500">同样的道理：</p>
<ul data-nodeid="31501">
<li data-nodeid="31502">
<p data-nodeid="31503">当“限时折扣”发生变更的时候，“限量折扣”是不是一定要变？</p>
</li>
<li data-nodeid="31504">
<p data-nodeid="31505">当“限量折扣”发生变更的时候，“某类商品的折扣”是不是一定要变？</p>
</li>
<li data-nodeid="31506">
<p data-nodeid="31507">……</p>
</li>
</ul>
<p data-nodeid="31508">最后发现，不同类型的折扣也是软件变化不同的原因。将它们放在同一个类、同一个方法中，合适吗？通过以上分析，我们做出了如下设计：</p>
<p data-nodeid="31509"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziPSAEj-iAACZkldRtxU363.png" alt="Drawing 8.png" data-nodeid="31640"></p>
<p data-nodeid="31510">在该设计中，将折扣功能从付款功能中独立出去，做出了一个接口，然后以此为基础设计了各种类型的折扣实现类。这样的设计，当付款功能发生变更时不会影响折扣，而折扣发生变更的时候不会影响付款。同样，当“限时折扣”发生变更时只与“限时折扣”有关，“限量折扣”发生变更时也只与“限量折扣”有关，与其他折扣类型无关。变更的范围缩小了，维护成本就降低了，设计质量提高了。这样的设计就是“单一职责原则”的真谛。</p>
<p data-nodeid="31511">接着，在这个版本的领域模型的基础上进行程序设计，在设计时还可以加入一些设计模式的内容，因此我们进行了如下的设计：</p>
<p data-nodeid="31512"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziPyAAJUgAABRUq9tq5Y944.png" alt="Drawing 10.png" data-nodeid="31645"></p>
<p data-nodeid="31513">显然，在该设计中加入了“策略模式”的内容，将折扣功能做成了一个折扣策略接口与各种折扣策略的实现类。当哪个折扣类型发生变更时就修改哪个折扣策略实现类；当要增加新的类型的折扣时就再写一个折扣策略实现类，设计质量得到了提高。</p>
<h3 data-nodeid="31514">VIP 会员的需求变更</h3>
<p data-nodeid="31515">在第一次变更的基础上，很快迎来了第二次变更，这次是要<strong data-nodeid="31653">增加 VIP 会员</strong>，业务需求如下。</p>
<p data-nodeid="31516">增加 VIP 会员功能：</p>
<ul data-nodeid="31517">
<li data-nodeid="31518">
<p data-nodeid="31519">对不同类型的 VIP 会员（金卡会员、银卡会员）进行不同的折扣；</p>
</li>
<li data-nodeid="31520">
<p data-nodeid="31521">在支付时，为 VIP 会员发放福利（积分、返券等）；</p>
</li>
<li data-nodeid="31522">
<p data-nodeid="31523">VIP 会员可以享受某些特权。</p>
</li>
</ul>
<p data-nodeid="31524">我们拿到这样的需求又应当怎样设计呢？同样，先回到领域模型，分析“用户”与“VIP 会员”的关系，“付款”与“VIP 会员”的关系。在分析的时候，还是回答那两个问题。</p>
<ul data-nodeid="31525">
<li data-nodeid="31526">
<p data-nodeid="31527">“用户”发生变更时，“VIP 会员”是否要变？</p>
</li>
<li data-nodeid="31528">
<p data-nodeid="31529">“VIP 会员”发生变更时，“用户”是否要变？</p>
</li>
</ul>
<p data-nodeid="31530">通过分析发现，“用户”与“VIP 会员”是两个完全不同的事物。</p>
<ul data-nodeid="31531">
<li data-nodeid="31532">
<p data-nodeid="31533">“用户”要做的是用户的注册、变更、注销等操作；</p>
</li>
<li data-nodeid="31534">
<p data-nodeid="31535">“VIP 会员”要做的是会员折扣、会员福利与会员特权；</p>
</li>
<li data-nodeid="31536">
<p data-nodeid="31537">而“付款”与“VIP 会员”的关系是在付款的过程中去调用会员折扣、会员福利与会员特权。</p>
</li>
</ul>
<p data-nodeid="31538">通过以上的分析，我们做出了以下版本的领域模型：</p>
<p data-nodeid="31539"><img src="https://s0.lgstatic.com/i/image/M00/6E/C4/Ciqc1F-ziQaAevJdAACdptUfGFQ317.png" alt="Drawing 12.png" data-nodeid="31668"></p>
<p data-nodeid="31540"><strong data-nodeid="31672">有了这些领域模型的变更，然后就可以以此作为基础，指导后面程序代码的变更了。</strong></p>
<h3 data-nodeid="31541">支付方式的需求变更</h3>
<p data-nodeid="31542">同样，第三次变更是<strong data-nodeid="31679">增加更多的支付方式</strong>，我们在领域模型中分析“付款”与“支付方式”之间的关系，发现它们也是软件变化不同的原因。因此，我们果断做出了这样的设计：</p>
<p data-nodeid="31543"><img src="https://s0.lgstatic.com/i/image/M00/6E/CF/CgqCHl-ziQ6ABA-UAABxRFWKpk4419.png" alt="Drawing 14.png" data-nodeid="31682"></p>
<p data-nodeid="31544">而在设计实现时，因为要与各个第三方的支付系统对接，也就是要与外部系统对接。为了使第三方的外部系统的变更对我们的影响最小化，在它们中间果断加入了“适配器模式”，设计如下：</p>
<p data-nodeid="31545"><img src="https://s0.lgstatic.com/i/image/M00/6E/C4/Ciqc1F-ziRWARy4TAAB8IgTzU7A472.png" alt="Drawing 16.png" data-nodeid="31686"></p>
<p data-nodeid="31546">通过加入适配器模式，订单 Service 在进行支付时调用的不再是外部的支付接口，而是“支付方式”接口，与外部系统解耦。只要保证“支付方式”接口是稳定的，那么订单 Service 就是稳定的。比如：</p>
<ul data-nodeid="31547">
<li data-nodeid="31548">
<p data-nodeid="31549">当支付宝支付接口发生变更时，影响的只限于支付宝 Adapter；</p>
</li>
<li data-nodeid="31550">
<p data-nodeid="31551">当微信支付接口发生变更时，影响的只限于微信支付 Adapter；</p>
</li>
<li data-nodeid="31552">
<p data-nodeid="31553">当要增加一个新的支付方式时，只需要再写一个新的 Adapter。</p>
</li>
</ul>
<p data-nodeid="31554"><strong data-nodeid="31694">日后不论哪种变更，要修改的代码范围缩小了，维护成本自然降低了，代码质量就提高了。</strong></p>
<h3 data-nodeid="31555">总结</h3>
<p data-nodeid="31556">这一讲通过以上的过程，我们演练了如何运用 DDD 进行软件的设计与变更，以及在设计与变更的过程中如何分析思考、如何评估代码、如何实现高质量。后面，我们将演练如何将领域模型的设计进一步落实到软件系统的微服务设计与数据库设计。</p>
<p data-nodeid="31557"><a href="https://shenceyun.lagou.com/t/Mka" data-nodeid="31703"><img src="https://s0.lgstatic.com/i/image/M00/6D/AB/CgqCHl-uXGGAP0KpAAhXSgFweBY227.png" alt="微信图片_20201113105039.png" data-nodeid="31702"></a></p>
<p data-nodeid="31558">《Java 工程师高薪训练营》</p>
<p data-nodeid="31559" class="te-preview-highlight">拉勾背书内推+硬核实战技术干货，帮助每位 Java 工程师达到阿里 P7 技术能力。<a href="https://shenceyun.lagou.com/t/Mka" data-nodeid="31708">点击链接</a>，快来领取！</p>

---

### 精选评论

##### *凯：
> 打折和会员不都是对订单金额的计算么？比如我在加一个混合支付，像京东一样积分抵现金那种，都放到金额计算里面不是更好么。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 首先，随着业务变更，金额的计算会越来越复杂，形成许多规则。将所有规则都放到金额支付中会变得难于维护。此外，会员不仅是计算金额，还有返券、积分、奖励等各种福利

##### **福：
> 上士闻道，勤而行之，中士闻道，若存若亡，下士闻道则笑之，不笑不足以为道

##### *特：
> 对于策略，必须通过代码提供新的策略实现吗，对于策略如何选择呢，策略的选择是在聚合内部封装更好一些，还是在领域服务中提供更好一些

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 每增加一个新的折扣类型增加一个实现类，通常放到Service中比较好

##### *权：
> 通过上面的讲解，首先第一点感受，干货满满；第二，单一性原则，是我们去做领域设计时的一种规范，是可以指导我们设计出高质量的程序；第三，在第二点的基础上面，在编码时加入一些设计模式，可以让我们程序耦合度更低。按照文中说的：要求我们在维护软件的过程中需要不断地进行整理，这也是一个长期的过程

##### *杰：
> 你这都是用到策率和责任链和适配器模式。感觉你说的这2章内容要用到抽象思维去解决现实中问题。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 注意，DDD的精髓在于先跳出编程，站在业务的角度进行领域建模，至于那些设计模式，都是最后的设计实现。学习的时候要抓住精髓与关键

##### *哈：
> 电商的那个案例 折扣用策略模式，支付用适配器模式，可以都用策略模式或者都用适配器模式吗？还是说这两种区别特别大？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 作用不一样，策略模式是应对不同类型的折扣，一个方法有多种算法的场景；适配器模式是让外部系统（如支付系统）与我们解耦，降低外部系统变更对我们的影响

##### halweg：
> 新加入的vip类和折扣类，放在哪里呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 新加入的vip类与折扣类，在设计实现的时候，会根据充血模型或贫血模型，落地到Service, Entity, Value Object，以及相关的代码

##### **0960：
> 受益匪浅，茅塞顿开

##### **彪：
> 好文

##### *峥：
> 醍醐灌顶呀！

##### **7540：
> 你好老师，我问怎么根据折扣类型，调用不用折扣方法呢？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 做一个for循环，每个折扣都有一个isAvalable()进行校验，校验通过就执行payoff()，所有校验都不通过就调用不用折扣方法。

##### **学：
> 如雨后甘霖，第一次看懂了什么是领域驱动设计，牛，这个level的架构师适合在家数钱了

##### **0099：
> 什么是适配器模式？没能理解出代码层面要做什么

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 就是在我们与外部系统对接时，中间增加一个适配器，让外部系统变更对我们的影响更小，你可以在网上搜一下适配器模式

##### *文：
> 干货

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 加油，坚持学习

##### **聪：
> 厉害了

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 加油，坚持学习就会学有所获。

##### *超：
> 看完之后有点感悟，可以在以后项目中实践实践

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 实践是学习最好的方法，加油

##### **用户2312：
> 能提供点示例代码看看？😇

 ###### &nbsp;&nbsp;&nbsp; 编辑回复：
> &nbsp;&nbsp;&nbsp; 会在模块三给大家代码的地址哈

##### *特：
> 订单service和折扣strategy的关系通过代码如何体现？如果某一个折扣strategy不仅仅需要订单作为形参，还和用户临时抢券（新增的需求）的结果产生关联那么折扣strategy的接口设计如何体现这种情况

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 每种折扣都有一个isAvailable()去判断每个订单对其十分有效，有效就调用其折扣，否则就跳过。如果某个折扣还需要用户临时抢卷信息，则该折扣通过读数据库或调用某个类的某个方法获取这些信息，然后在折扣中进行判断。这种新需求建议在原有折扣类的基础上加一个装饰者，查看装饰者模式。

##### **2868：
> 很清晰，比领域驱动设计（翻译版）易懂，期待下一课

##### Then：
> 以场景建模，受益匪浅

##### **攀：
> 期待更新

