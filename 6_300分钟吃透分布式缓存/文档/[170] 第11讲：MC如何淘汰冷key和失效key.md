<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">你好，我是你的缓存课老师陈波，欢迎进入第&nbsp;11&nbsp;课时“Memcached&nbsp;淘汰策略”的学习。</span></p>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">淘汰策略</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;作为缓存组件，意味着&nbsp;Mc&nbsp;中只能存储访问最频繁的热数据，一旦存入数据超过内存限制，就需要对&nbsp;Mc&nbsp;中的冷&nbsp;key&nbsp;进行淘汰工作。Mc&nbsp;中的&nbsp;key&nbsp;基本都会有过期时间，在&nbsp;key&nbsp;过期后，出于性能考虑，Mc&nbsp;并不会立即删除过期的&nbsp;key，而是由维护线程逐步清理，同时，只有这个失效的&nbsp;key&nbsp;被访问时，才会进行删除，从而回收存储空间。所以&nbsp;Mc&nbsp;对&nbsp;key&nbsp;生命周期的管理，即&nbsp;Mc&nbsp;对&nbsp;key&nbsp;的淘汰，包括失效和删除回收两个纬度，知识结构如下图所示。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/C1/CgoB5l2lMr6ASGzEAACB7rAcaqU851.png" style="font-size: 32px; font-weight: 700; text-align: justify;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">key&nbsp;的失效，包括&nbsp;key&nbsp;在&nbsp;expire&nbsp;时间之后的过期，以及用户在&nbsp;flush_all&nbsp;之后对所有&nbsp;key&nbsp;的过期&nbsp;2&nbsp;种方式。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">而&nbsp;Mc&nbsp;对&nbsp;key/value&nbsp;的删除回收，则有&nbsp;3&nbsp;种方式。</span></p>
<ol style=" white-space: normal;">
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">第一种是获取时的惰性删除，即&nbsp;key&nbsp;在失效后，不立即删除淘汰，而在获取时，检测&nbsp;key&nbsp;的状态，如果失效，才进行真正的删除并回收存储空间。</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">第二种方式是在需要对&nbsp;Item&nbsp;进行内存分配申请时，如果内存已全部用完，且该&nbsp;Item&nbsp;对应的slabclass&nbsp;没有空闲的&nbsp;chunk&nbsp;可用，申请失败，则会对&nbsp;LRU&nbsp;队尾进行同步扫描，回收过期失效的&nbsp;key，如果没有失效的&nbsp;key，则会强制删除一个&nbsp;key。</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em; text-indent: 0em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">第三种方式是&nbsp;LRU&nbsp;维护线程，不定期扫描&nbsp;4&nbsp;个&nbsp;LRU&nbsp;队列，对过期&nbsp;key/value&nbsp;进行异步淘汰。</span></p></li>
</ol>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">flush_all</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;中，key&nbsp;失效除了常规的到达过期时间之外，还有一种用&nbsp;flush_all&nbsp;的方式进行全部过期。如果缓存数据写入异常，出现大量脏数据，而又没有简单的办法快速找出所有的脏数据，可以用&nbsp;flush_all&nbsp;立即让所有数据失效，通过&nbsp;key&nbsp;重新从&nbsp;DB&nbsp;加载的方式来保证数据的正确性。flush_all&nbsp;可以让&nbsp;Mc&nbsp;节点的所有&nbsp;key&nbsp;立即失效，不过，在某些场景下，需要让多个&nbsp;Mc&nbsp;节点的数据在某个时间同时失效，这时就可以用&nbsp;flush_all&nbsp;的延迟失效指令了。该指令通过&nbsp;flush_all 指令后面加一个&nbsp;expiretime&nbsp;参数，可以让多个&nbsp;Mc&nbsp;在某个时间同时失效所有的&nbsp;key。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">flush_all&nbsp;后面没有任何参数，等价于&nbsp;flush_all 0，即立即失效所有的&nbsp;key。当&nbsp;Mc&nbsp;收到&nbsp;flush_all&nbsp;指令后，如果是延迟失效，会将全局&nbsp;setting&nbsp;中的&nbsp;oldest_live 设为指定&nbsp;N&nbsp;秒后的时间戳，即&nbsp;N&nbsp;秒后失效；如果是立即失效，则将全局&nbsp;setting&nbsp;中的&nbsp;oldest_cas&nbsp;设为当前最大的全局&nbsp;cas&nbsp;值。设置完这个全局变量值后，立即返回。因此，在 Mc&nbsp;通过&nbsp;flush_all&nbsp;失效所有&nbsp;key&nbsp;时，实际不做任何&nbsp;key&nbsp;的删除操作，这些&nbsp;key&nbsp;，后续会通过用户请求同步删除，或&nbsp;LRU&nbsp;维护线程的异步删除，来完成真正的删除动作。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">惰性删除</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;中，过期失效&nbsp;key&nbsp;的惰性主动删除，是指在&nbsp;touch、get、gets&nbsp;等指令处理时，首先需要查询&nbsp;key，找到&nbsp;key&nbsp;所在的&nbsp;Item，然后校验&nbsp;key&nbsp;是否过期，是否被&nbsp;flush，如果过期或被&nbsp;flush，则直接进行真正的删除回收操作。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">对于校验&nbsp;key&nbsp;过期很容易，直接判断过期时间即可。对于检查&nbsp;key&nbsp;是否被&nbsp;flush，处理逻辑是首先检查&nbsp;key&nbsp;的最近访问时间是否小于全局设置中的&nbsp;oldest_live，如果小于则说明&nbsp;key&nbsp;被&nbsp;flush&nbsp;了；否则，再检查&nbsp;key&nbsp;的&nbsp;cas&nbsp;唯一&nbsp;id&nbsp;值，如果小于全局设置中的&nbsp;oldest_cas，说明也被&nbsp;flush&nbsp;了。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">内存分配失败，LRU 同步淘汰</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;在插入或变更&nbsp;key&nbsp;时，首先会在适合的&nbsp;slabclass&nbsp;为新的&nbsp;key/value&nbsp;分配一个空闲的&nbsp;Item&nbsp;空间，如果分配失败，会同步对该&nbsp;slabclass&nbsp;的&nbsp;COLD LRU&nbsp;进行队尾元素淘汰，如果淘汰回收成功，则&nbsp;slabclass&nbsp;会多一个空闲的&nbsp;Item，这个&nbsp;Item&nbsp;就可以被前面那个&nbsp;key&nbsp;来使用。如果&nbsp;COLD LRU&nbsp;队列没有&nbsp;Item&nbsp;数据，则淘汰失败，此时会对&nbsp;HOT LRU&nbsp;进行队尾轮询，如果&nbsp;key&nbsp;过期失效则进行淘汰回收，否则进行迁移。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">LRU 维护线程，异步淘汰</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">在&nbsp;key&nbsp;进行读取、插入或变更时，同步进行&nbsp;key&nbsp;淘汰回收，并不是一种高效的办法，因为淘汰回收操作相比请求处理，也是一个重量级操作，会导致&nbsp;Mc&nbsp;性能大幅下降。因此&nbsp;Mc&nbsp;额外增加了一个&nbsp;LRU&nbsp;维护线程，对过期失效&nbsp;key&nbsp;进行回收，在不增加请求负担的情况下，尽快回收失效&nbsp;key&nbsp;锁占用的空间。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">前面讲到，Mc&nbsp;有&nbsp;64&nbsp;个&nbsp;slabclass，其中&nbsp;1~63&nbsp;号&nbsp;slabclass&nbsp;用于存取&nbsp;Item&nbsp;数据。实际上，为了管理过期失效数据，1~63&nbsp;号&nbsp;slabclass&nbsp;还分别对应了&nbsp;4&nbsp;个&nbsp;LRU，分布是&nbsp;TEMP、HOT、WARM、COLD LRU。所以这就总共有&nbsp;63*4&nbsp;=&nbsp;252&nbsp;个&nbsp;LRU。LRU&nbsp;维护线程，会按策略间断&nbsp;sleep，待&nbsp;sleep&nbsp;结束，就开始对&nbsp;4&nbsp;个&nbsp;LRU&nbsp;进行队尾清理工作。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;在新写入&nbsp;key&nbsp;时，如果&nbsp;key&nbsp;的过期时间小于&nbsp;61s，就会直接插入到&nbsp;TEMP LRU&nbsp;中，如下图所示。TEMP LRU&nbsp;没有长度限制，可以一直插入，同时因为过期时间短，TEMP LRU&nbsp;不进行队列内部的搬运和队列间的迁移，确保处理性能最佳。LRU&nbsp;维护线程在&nbsp;sleep&nbsp;完毕后，首先会对&nbsp;TEMP LRU&nbsp;队尾进行&nbsp;500&nbsp;次轮询，然后在每次轮询时，会进行&nbsp;5&nbsp;次小循环。小循环时，首先检查&nbsp;key是否过期失效，如果失效则进行回收淘汰，然后继续小循环；如果遇到一个没失效的&nbsp;key，则回收该&nbsp;key&nbsp;并退出&nbsp;TEMP LRU&nbsp;的清理工作。如果&nbsp;TEMP LRU&nbsp;队尾&nbsp;key&nbsp;全部失效，维护线程一次可以回收&nbsp;500*5&nbsp;共&nbsp;2500&nbsp;个失效的&nbsp;key。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/E1/CgotOV2lMr-AaQVZAAC-AitDERU510.png" style="text-align: justify;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">如下图，MC 在新写入 key 时，如果 key 的过期时间超过 61s，就会直接插入到 HOT LRU。HOT LRU 会有内存限制，每个 HOT LRU 所占内存不得超过所在 slabclass 总实际使用内存的 20%。LRU 维护线程在执行日常维护工作时，首先对 TEMP LRU 进行清理，接下来就会对 HOT LRU 进行维护。HOT LRU 的维护，也是首先轮询 500 次，每次轮询进行 5 次小循环，小循环时，首先检查 key 是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的 key。如果这个 key 的状态是 ACTIVE，则迁移到 WARM LRU。对于非 ACTIVE 状态的 key，如果 HOT LRU 内存占用超过限制，则迁移到 COLD LRU，否则进行纾困性清理掉该 key，注意这种纾困性清理操作一般不会发生，一旦发生时，虽然会清理掉该 key，但操作函数此时也认定本次操作回收和清理 keys 数仍然为 0。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/C1/CgoB5l2lMr-Adai5AADecNLamqw346.png" style="text-align: justify;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">如下图，如果 HOT LRU 中回收和迁移的 keys 数为 0，LRU 维护线程会对 WARM LRU 进行轮询。WARM LRU 也有内存限制，每个 WARM LRU 所占内存不得超过所在 slabclass 总实际使用内存的 40%。WARM LRU 的维护，也是首先轮询 500 次，每次轮询进行 5 次小循环，小循环时，首先检查 key 是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的 key。如果这个 key 的状态是 ACTIVE，则内部搬运到 LRU 队列头部。对于非 ACTIVE 状态的 key，如果 WARM LRU 内存占用超过限制，则迁移到 COLD LRU，否则进行纾困性清理掉该 key。注意这种纾困性清理操作一般不会发生，一旦发生时，虽然会清理掉该 key，但操作函数此时也认定本次操作回收和清理 keys 数仍然为 0。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><img src="http://s0.lgstatic.com/i/image2/M01/99/E1/CgotOV2lMr-AYNh7AAEBqGNruvU217.png" style="text-align: justify;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">LRU&nbsp;维护线程最后会对&nbsp;COLD LRU&nbsp;进行维护，如下图。与&nbsp;TEMP LRU&nbsp;相同，COLD LRU&nbsp;也没有长度限制，可以持续存放数据。COLD LRU&nbsp;的维护，也是首先轮询&nbsp;500&nbsp;次，每次轮询进行&nbsp;5&nbsp;次小循环，小循环时，首先检查&nbsp;key&nbsp;是否过期失效，如果失效则进行回收淘汰，然后继续小循环。直到遇到没失效的&nbsp;key。如果这个&nbsp;key&nbsp;的状态是&nbsp;ACTIVE，则会迁移到&nbsp;WARM LRU&nbsp;队列头部，否则不处理直接返回。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/C1/CgoB5l2lMr-AVx39AADL6FNQktQ690.png" style="text-align: justify;">&nbsp; &nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">LRU&nbsp;维护线程处理时，TEMP LRU&nbsp;是在独立循环中进行，其他三个&nbsp;LRU&nbsp;在另外一个循环中进行，如果&nbsp;HOT、WARM、COLD LRU&nbsp;清理或移动的&nbsp;keys&nbsp;数为&nbsp;0，则那个&nbsp;500&nbsp;次的大循环就立即停止。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="text-indent: 0em; font-size: 16px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="text-indent: 0em; font-size: 16px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">OK，这节课就讲到这里啦，下一课时我将分享“Memcached 内存管理 slab 机制”，记得按时来听课哈。好，下节课见，拜拜！</span><span style="text-indent: 0em; color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><br></p>
<p><br></p>

---

### 精选评论

##### *源：
> <span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">首先检查&nbsp;key是否过期失效，如果失效则进行回收淘汰，然后继续小循环；如果遇到一个没失效的&nbsp;key，则回收该&nbsp;key&nbsp;并退出&nbsp;TEMP LRU&nbsp;的清理工作。</span><div><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">老师，既然key没有失效为什么还回收该key？</span></div>

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 因为temp_lru里面的都是短命key，即1分钟内会过期的key，队尾的key肯定小于1分钟，在维护线程对这些短命key处理时，如果所有的key都还没失效，会在队尾清理一个最快就要过期的key，同时停止本次对temp_lru的维护循环，这样做的目的：即便mc里的key全部都是短命key，一次轮询至少也会清理掉一个key。

##### **超：
> <span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">HOT LRU&nbsp;中回收和迁移的&nbsp;keys&nbsp;数为&nbsp;0。</span><div><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">这个时什么情况产生的?不是非active就移入cold吗，失效key删除，有效key要么移入warm要么移入cold，所以只要执行了hot的清理工作，keys就不会为0吧？</span></div>

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个问题很赞，这里实际需要进一步细分。对于hot lru，如果这个 key 的状态是 ACTIVE，则迁移到 WARM LRU。对于非ACTIVE状态的key，如果HOT LRU内存占用超过限制，则迁移到 COLD LRU，否则进行纾困性清理掉该key，注意这种纾困性清理操作一般不会发生，一旦发生时，虽然会清理掉该key，但操作函数此时也认定本次操作回收和清理keys数仍然为0。

##### **超：
> <div><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">“”</span><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">如果这个&nbsp;key&nbsp;的状态是&nbsp;ACTIVE，则会迁移到&nbsp;WARM LRU&nbsp;队列头部</span><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">“”</span></div><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-align: justify;">老师，不是只有非active状态的key才会移入cold队列，所以，cold队列的key应该没有active状态的对吗？</span>

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; memcached可以用touch指令来更新key的失效时间，在cold队列的key如果被多次touch时，就会被设为active状态，这样，cold队列的这个key也就有了active状态。

##### **超：
> 老师，warm中的内容都是从hot中移入的吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; warm lru中的数据有2个入口，首先可以从hot中移入；同时，如果cold lru中的key变为active后，也会被迁移到warm。

