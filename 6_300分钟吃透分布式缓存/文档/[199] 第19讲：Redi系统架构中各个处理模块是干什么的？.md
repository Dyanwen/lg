<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">你好，我是你的缓存课老师陈波，欢迎进入第 19 课时“Redis 系统架构”的学习。</span></p>
<h1></h1>
<h6 style="text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px; color: rgb(63, 63, 63);">Redis 系统架构</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">通过前面的学习，相信你已经掌握了&nbsp;Redis&nbsp;的原理、数据类型及访问协议等内容。本课时，我将进一步分析&nbsp;Redis&nbsp;的系统架构，重点讲解 Redis 系统架构的事件处理机制、数据管理、功能扩展、系统扩展等内容。</span></p>
<h2></h2>
<h6 style="text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">事件处理机制</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis&nbsp;组件的系统架构如图所示，主要包括事件处理、数据存储及管理、用于系统扩展的主从复制/集群管理，以及为插件化功能扩展的&nbsp;Module&nbsp;System 模块。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><img src="http://s0.lgstatic.com/i/image2/M01/9C/33/CgotOV2phZSAJMETAACUckqH35I814.png">&nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis&nbsp;中的事件处理模块，采用的是作者自己开发的&nbsp;ae&nbsp;事件驱动模型，可以进行高效的网络&nbsp;IO&nbsp;读写、命令执行，以及时间事件处理。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">其中，网络&nbsp;IO&nbsp;读写处理采用的是&nbsp;IO&nbsp;多路复用技术，通过对&nbsp;evport、epoll、kqueue、select&nbsp;等进行封装，同时监听多个&nbsp;socket，并根据&nbsp;socket&nbsp;目前执行的任务，来为&nbsp;socket&nbsp;关联不同的事件处理器。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">当监听端口对应的&nbsp;socket&nbsp;收到连接请求后，就会创建一个&nbsp;client&nbsp;结构，通过&nbsp;client&nbsp;结构来对连接状态进行管理。在请求进入时，将请求命令读取缓冲并进行解析，并存入到&nbsp;client&nbsp;的参数列表。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">然后根据请求命令找到&nbsp;对应的redisCommand&nbsp;，最后根据命令协议，对请求参数进一步的解析、校验并执行。Redis&nbsp;中时间事件比较简单，目前主要是执行&nbsp;serverCron，来做一些统计更新、过期&nbsp;key&nbsp;清理、AOF&nbsp;及&nbsp;RDB&nbsp;持久化等辅助操作。</span></p>
<h2></h2>
<h6 style="text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">数据管理</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis&nbsp;的内存数据都存在&nbsp;redisDB&nbsp;中。Redis&nbsp;支持多&nbsp;DB，每个&nbsp;DB&nbsp;都对应一个&nbsp;redisDB&nbsp;结构。Redis&nbsp;的&nbsp;8&nbsp;种数据类型，每种数据类型都采用一种或多种内部数据结构进行存储。同时这些内部数据结构及数据相关的辅助信息，都以&nbsp;kye/value&nbsp;的格式存在&nbsp;redisDB&nbsp;中的各个&nbsp;dict&nbsp;字典中。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">数据在写入&nbsp;redisDB&nbsp;后，这些执行的写指令还会及时追加到&nbsp;AOF&nbsp;中，追加的方式是先实时写入AOF&nbsp;缓冲，然后按策略刷缓冲数据到文件。由于&nbsp;AOF&nbsp;记录每个写操作，所以一个&nbsp;key&nbsp;的大量中间状态也会呈现在&nbsp;AOF&nbsp;中，导致&nbsp;AOF&nbsp;冗余信息过多，因此&nbsp;Redis&nbsp;还设计了一个&nbsp;RDB&nbsp;快照操作，可以通过定期将内存里所有的数据快照落地到&nbsp;RDB&nbsp;文件，来以最简洁的方式记录&nbsp;Redis&nbsp;的所有内存数据。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis&nbsp;进行数据读写的核心处理线程是单线程模型，为了保持整个系统的高性能，必须避免任何kennel&nbsp;导致阻塞的操作。为此，Redis&nbsp;增加了&nbsp;BIO&nbsp;线程，来处理容易导致阻塞的文件&nbsp;close、fsync&nbsp;等操作，确保系统处理的性能和稳定性。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">在&nbsp;server&nbsp;端，存储内存永远是昂贵且短缺的，Redis&nbsp;中，过期的&nbsp;key&nbsp;需要及时清理，不活跃的&nbsp;key&nbsp;在内存不足时也可能需要进行淘汰。为此，Redis&nbsp;设计了&nbsp;8&nbsp;种淘汰策略，借助新引入的&nbsp;eviction pool，进行高效的&nbsp;key&nbsp;淘汰和内存回收。</span></p>
<h2></h2>
<h6 style="text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">功能扩展</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis 在&nbsp;4.0&nbsp;版本之后引入了&nbsp;Module&nbsp;System&nbsp;模块，可以方便使用者，在不修改核心功能的同时，进行插件化功能开发。使用者可以将新的&nbsp;feature&nbsp;封装成动态链接库，Redis&nbsp;可以在启动时加载，也可以在运行过程中随时按需加载和启用。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">在扩展模块中，开发者可以通过&nbsp;RedisModule_init&nbsp;初始化新模块，用&nbsp;RedisModule_CreateCommand&nbsp;扩展各种新模块指令，以可插拔的方式为&nbsp;Redis&nbsp;引入新的数据结构和访问命令。</span></p>
<h2></h2>
<h6 style="text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">系统扩展</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Redis作者在架构设计中对系统的扩展也倾注了大量关注。在主从复制功能中，psyn&nbsp;在不断的优化，不仅在&nbsp;slave&nbsp;闪断重连后可以进行增量复制，而且在&nbsp;slave&nbsp;通过主从切换成为&nbsp;master&nbsp;后，其他&nbsp;slave&nbsp;仍然可以与新晋升的&nbsp;master&nbsp;进行增量复制，另外，其他一些场景，如&nbsp;slave&nbsp;重启后，也可以进行增量复制，大大提升了主从复制的可用性。使用者可以更方便的使用主从复制，进行业务数据的读写分离，大幅提升&nbsp;Redis&nbsp;系统的稳定读写能力。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">通过主从复制可以较好的解决&nbsp;Redis&nbsp;的单机读写问题，但所有写操作都集中在&nbsp;master&nbsp;服务器，很容易达到&nbsp;Redis&nbsp;的写上限，同时&nbsp;Redis&nbsp;的主从节点都保存了业务的所有数据，随着业务发展，很容易出现内存不够用的问题。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">为此，Redis&nbsp;分区无法避免。虽然业界大多采用在&nbsp;client&nbsp;和&nbsp;proxy&nbsp;端分区，但&nbsp;Redis&nbsp;自己也早早推出了&nbsp;cluster&nbsp;功能，并不断进行优化。Redis cluster&nbsp;预先设定了&nbsp;16384&nbsp;个&nbsp;slot&nbsp;槽，在&nbsp;Redis&nbsp;集群启动时，通过手动或自动将这些&nbsp;slot&nbsp;分配到不同服务节点上。在进行&nbsp;key&nbsp;读写定位时，首先对&nbsp;key&nbsp;做&nbsp;hash，并将&nbsp;hash&nbsp;值对&nbsp;16383&nbsp;，做 按位与运算，确认&nbsp;slot，然后确认服务节点，最后再对 对应的 Redis&nbsp;节点，进行常规读写。如果&nbsp;client&nbsp;发送到错误的&nbsp;Redis&nbsp;分片，Redis&nbsp;会发送重定向回复。如果业务数据大量增加，Redis&nbsp;集群可以通过数据迁移，来进行在线扩容。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">OK，这节课就讲到这里啦，下一课时我将重点讲解“Redis 的事件驱动模型”，记得按时来听课哈。好，下节课见，拜拜！</span></p>
<p><br style="white-space: normal;"></p>
<p><br></p>

---

### 精选评论


