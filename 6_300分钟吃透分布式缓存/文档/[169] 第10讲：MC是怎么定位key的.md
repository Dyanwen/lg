<p style="text-align: justify; line-height: 1.75em;"><span style="text-indent: 29.3333px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">你好，我是你的缓存课老师陈波，欢迎你进入第&nbsp;10&nbsp;课时“Memcached&nbsp;哈希表”的学习。</span></p>
<p style="text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 0em;"><br></span></p>
<p style="text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 0em;">我们在进行&nbsp;Mc&nbsp;架构剖析时，除了学习&nbsp;Mc&nbsp;的系统架构、网络模型、状态机外，还对&nbsp;Mc&nbsp;的&nbsp;slab&nbsp;分配、Hashtable、LRU 有了简单的了解。本节课，将进一步深入学习这些知识点。</span></p>
<p style="text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 0em;"><br></span></p>
<p style="text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-indent: 0em;">接下来，进入 Memcached 进阶的学习。会讲解&nbsp;Mc&nbsp;是如何进行&nbsp;key&nbsp;定位，如何淘汰回收过期失效&nbsp;key&nbsp;的，还将分析&nbsp;Mc&nbsp;的内存管理&nbsp;slab&nbsp;机制，以及&nbsp;Mc&nbsp;进行数据存储维护的关键机理，最后还会对&nbsp;Mc&nbsp;进行完整的协议分析，并以&nbsp;Java&nbsp;语言为例，介绍&nbsp;Mc&nbsp;常用的&nbsp;client，以及如何进行调优及改进。</span></p>
<h1 style="white-space: normal;"></h1>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">key&nbsp;定位</span></h6>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">哈希表</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;将数据存储在&nbsp;Item&nbsp;中，然后这些&nbsp;Item&nbsp;会被&nbsp;slabclass&nbsp;的&nbsp;4&nbsp;个&nbsp;LRU&nbsp;管理。这些&nbsp;LRU&nbsp;都是通过双向链表实现数据记录的。双向链表在进行增加、删除、修改位置时都非常高效，但其获取定位&nbsp;key&nbsp;的性能非常低下，只能通过链表遍历来实现。因此，Mc&nbsp;还通过&nbsp;Hashtable，也就是哈希表，来记录管理这些&nbsp;Item，通过对&nbsp;key&nbsp;进行哈希计算，从而快速定位和读取这些&nbsp;key/value&nbsp;所在的&nbsp;Item，如下图所示。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8B/37/CgotOV143NmAUEwHAACYUBVU47E041.png" style="text-align: justify; white-space: normal;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">哈希表也称散列表，可以通过把&nbsp;key&nbsp;映射到哈希表中的一个位置来快速访问记录，定位&nbsp;key&nbsp;的时间复杂度只有&nbsp;O(1)。Mc&nbsp;的哈希表实际是一个一维指针数组，数组的每个位置称作一个&nbsp;bucket，即一个桶。性能考虑的需要，Mc&nbsp;的哈希表的长度设置为&nbsp;2&nbsp;的&nbsp;N&nbsp;次方。Mc&nbsp;启动时，默认会构建一个拥有 6.4万&nbsp;个桶的哈希表，随着新 key&nbsp;的不断插入，哈希表中的元素超过阀值后，会对哈希表进行扩容，最大可以构建 2 的 32 次方个桶的哈希表，也就是说 Mc 哈希表经过多次扩容后，最多只能有不超过 43亿&nbsp;个桶。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">哈希表设计</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">对于哈希表设计，有&nbsp;2&nbsp;个关键点，一个是哈希算法，一个是哈希冲突解决方案。Mc&nbsp;使用的哈希算法有&nbsp;2&nbsp;种，分别是&nbsp;Murmur3&nbsp;Hash&nbsp;和&nbsp;Jenkins&nbsp;Hash。Mc&nbsp;当前版本，默认使用&nbsp;Murmur3&nbsp;Hash&nbsp;算法。不同的&nbsp;key&nbsp;通过&nbsp;Hash&nbsp;计算，被定位到了相同的桶，这就是哈希冲突。Mc&nbsp;是通过对每个桶启用一个单向链表，来解决哈希冲突问题的。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">定位 key</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Memcached&nbsp;定位&nbsp;key&nbsp;时，首先根据&nbsp;key&nbsp;采用&nbsp;Murmur3&nbsp;或者&nbsp;Jenkins&nbsp;算法进行哈希计算，得到一个&nbsp;32&nbsp;位的无符号整型输出，存储到变量&nbsp;hv&nbsp;中。因为哈希表一般没有&nbsp;2^32&nbsp;那么大，所以需要将&nbsp;key&nbsp;的哈希值映射到哈希表的范围内。Mc&nbsp;采用最简单的取模算法作为映射函数，即采用&nbsp;hv%hashsize&nbsp;进行计算。由于普通的取模运算比较耗时，所以&nbsp;Mc&nbsp;将哈希表的长度设置为&nbsp;2&nbsp;的&nbsp;n 次方，采用位运算进行优化，即采用&nbsp;hv&amp;hashmask&nbsp;来计算。hashmask&nbsp;即&nbsp;2&nbsp;的&nbsp;n&nbsp;次方&nbsp;减&nbsp;1。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">定位到&nbsp;key&nbsp;所在的桶的位置后，如果是插入一个新数据，则将数据&nbsp;Item&nbsp;采用头部插入法插入桶的单向链表中。如果是查找，则轮询对应哈希桶中的那个单向链表，依次比对&nbsp;key&nbsp;字符串，key&nbsp;相同则找到数据&nbsp;Item。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8B/17/CgoB5l143NmAGePaAABhzHWbQBc983.png" style="text-align: justify; white-space: normal;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">如果哈希表桶中元素太多，这个链表轮询耗时会比较长，所以在哈希表中元素达到桶数的&nbsp;1.5&nbsp;倍之后，Mc&nbsp;会对哈希表进行&nbsp;2&nbsp;倍扩容。由于哈希表最多只有&nbsp;43&nbsp;亿左右个桶，所以性能考虑，单个&nbsp;Mc&nbsp;节点最多存储&nbsp;65亿&nbsp;个&nbsp;key/value。如果要存更多&nbsp;key，则需要修改&nbsp;Mc&nbsp;源码，将最大哈希，即&nbsp;HASHPOWER_MAX，&nbsp;进行调大设置。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;&nbsp;</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">哈希表扩容</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">当&nbsp;Mc&nbsp;的哈希表中，Item&nbsp;数量大于&nbsp;1.5&nbsp;倍的哈希桶数量后，Mc&nbsp;就对哈希表进行扩容处理。如下图所示，Mc&nbsp;的哈希扩容是通过哈希维护线程进行处理的。准备开始扩容时，哈希维护线程会首先将所有&nbsp;IO&nbsp;工作线程和辅助线程进行暂停，其中辅助线程包括&nbsp;LRU&nbsp;维护线程、slab&nbsp;维护线程、LRU&nbsp;爬虫线程。待这些线程暂停后，哈希维护线程会将当前的主哈希表设为旧哈希表，然后将新的主哈希表扩容之前的&nbsp;2&nbsp;倍容量。然后，工作线程及辅助线程继续工作，同时哈希维护线程开始逐步将&nbsp;Item&nbsp;元素从旧哈希表迁移到主哈希表。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><img src="http://s0.lgstatic.com/i/image2/M01/8B/37/CgotOV143NmAGr0AAAC_3sOBsnE256.png" style="font-size: 24px; font-weight: 700; text-align: justify; white-space: normal;"></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">Mc&nbsp;在启动时，会根据设置的工作线程数，来构建&nbsp;一个&nbsp;Item&nbsp;锁哈希表，线程越多，构建的锁哈希表越大，对于&nbsp;4&nbsp;个线程，锁哈希表有&nbsp;4096&nbsp;个桶，对于&nbsp;10&nbsp;个线程，锁哈希表会有&nbsp;8192&nbsp;个桶，Item&nbsp;锁哈希表最多有&nbsp;32k&nbsp;个桶，1k&nbsp;是&nbsp;1024，即最多即&nbsp;32768&nbsp;个桶。Mc&nbsp;的锁哈希表中，每个桶对应一个&nbsp;Item&nbsp;锁，所以&nbsp;Mc&nbsp;最多只有&nbsp;32768&nbsp;个&nbsp;Item&nbsp;锁。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;哈希表在读取、变更以及扩容迁移过程中，先将&nbsp;key hash&nbsp;定位到&nbsp;Item&nbsp;锁哈希表的锁桶，然后对&nbsp;Item&nbsp;锁进行加锁，然后再进行实际操作。实际上，除了在哈希表，在其他任何时候，只要涉及到在对&nbsp;Item&nbsp;的操作，都会根据&nbsp;Item&nbsp;中的&nbsp;key，进行&nbsp;Item&nbsp;哈希锁桶加锁，以避免&nbsp;Item&nbsp;被同时读写而产生脏数据。Mc&nbsp;默认有&nbsp;4096&nbsp;个锁桶，所以对&nbsp;key&nbsp;加锁时，冲突的概率较小，而且&nbsp;Mc&nbsp;全部是内存操作，操作速度很快，即便申请时锁被占用，也会很快被释放。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">Mc&nbsp;哈希表在扩容时，哈希表维护线程，每次按 桶链表纬度 迁移，即一次迁移一个桶里单向链表的所有 Item&nbsp;元素。在扩容过程中，如果要查找或插入&nbsp;key，会参照迁移位置选择哈希表。如果&nbsp;key&nbsp;对应的哈希桶在迁移位置之前，则到新的主哈希表进行查询或插入，否则到旧哈希表进行查询和插入。待全部扩容迁移完毕，所有的处理就会全部在新的主哈希表进行。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-align: justify; text-indent: 29.3333px;">OK，这节课就讲到这里啦，下一课时我将分享“Memcached 淘汰策略”，记得按时来听课哈。好，下节课见，拜拜！</span></span></p>

---

### 精选评论


