<p style="line-height: 1.75em; text-align: justify;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span><span style="color: rgb(73, 73, 73); text-indent: 29.3333px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;">你好，我是你的缓存老师陈波，欢迎进入第6课时“缓存特殊 key 相关的经典问题”。</span></p>
<p style="line-height: 1.75em; text-align: justify;"><span style="color: rgb(73, 73, 73); text-indent: 29.3333px; font-family: 微软雅黑, &quot;Microsoft YaHei&quot;;"></span></p>
<h6 style="text-indent: 0em; white-space: normal; margin-top: 0pt; margin-bottom: 0pt; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(0, 0, 0); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px; text-indent: 0em;">Hot key<br></span></h6>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">问题描述</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">第六个经典问题是&nbsp;Hot key。对于大多数互联网系统，数据是分冷热的。比如最近的新闻、新发表的微博被访问的频率最高，而比较久远的之前的新闻、微博被访问的频率就会小很多。而在突发事件发生时，大量用户同时去访问这个突发热点信息，访问这个&nbsp;Hot key，这个突发热点信息所在的缓存节点就很容易出现过载和卡顿现象，甚至会被&nbsp;Crash。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">原因分析</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">Hot key&nbsp;引发缓存系统异常，主要是因为突发热门事件发生时，超大量的请求访问热点事件对应的&nbsp;key，比如微博中数十万、数百万的用户同时去吃一个新瓜。数十万的访问请求同一个&nbsp;key，流量集中打在一个缓存节点机器，这个缓存机器很容易被打到物理网卡、带宽、CPU&nbsp;的极限，从而导致缓存访问变慢、卡顿。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">业务场景</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">引发&nbsp;Hot key&nbsp;的业务场景很多，比如明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618&nbsp;等线上促销活动，都很容易出现&nbsp;Hot key&nbsp;的情况。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">解决方案</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">要解决这种极热&nbsp;key&nbsp;的问题，首先要找出这些&nbsp;Hot key&nbsp;来。对于重要节假日、线上促销活动、集中推送这些提前已知的事情，可以提前评估出可能的热&nbsp;key&nbsp;来。而对于突发事件，无法提前评估，可以通过&nbsp;Spark，对应流任务进行实时分析，及时发现新发布的热点&nbsp;key。而对于之前已发出的事情，逐步发酵成为热&nbsp;key&nbsp;的，则可以通过&nbsp;Hadoop&nbsp;对批处理任务离线计算，找出最近历史数据中的高频热&nbsp;key。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">找到热&nbsp;key&nbsp;后，就有很多解决办法了。首先可以将这些热&nbsp;key&nbsp;进行分散处理，比如一个热&nbsp;key&nbsp;名字叫&nbsp;hotkey，可以被分散为&nbsp;hotkey#1、hotkey#2、hotkey#3，……hotkey#n，这&nbsp;n&nbsp;个&nbsp;key&nbsp;分散存在多个缓存节点，然后&nbsp;client&nbsp;端请求时，随机访问其中某个后缀的&nbsp;hotkey，这样就可以把热&nbsp;key&nbsp;的请求打散，避免一个缓存节点过载，如下图所示。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-align: center; text-indent: 0em; font-size: 16px;"><img src="http://s0.lgstatic.com/i/image2/M01/99/72/CgoB5l2kSmaALnx3AADSQZPFHOM649.png" style="text-align: center; white-space: normal;">&nbsp; &nbsp;&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">其次，也可以&nbsp;key&nbsp;的名字不变，对缓存提前进行多副本+多级结合的缓存架构设计。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">再次，如果热&nbsp;key&nbsp;较多，还可以通过监控体系对缓存的&nbsp;SLA&nbsp;实时监控，通过快速扩容来减少热&nbsp;key&nbsp;的冲击。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">最后，业务端还可以使用本地缓存，将这些热&nbsp;key&nbsp;记录在本地缓存，来减少对远程缓存的冲击。</span></p>
<h1 style="white-space: normal;"></h1>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 18px;">Big key</span></h6>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">问题描述</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">最后一个经典问题是&nbsp;Big key，也就是大&nbsp;Key&nbsp;的问题。大&nbsp;key，是指在缓存访问时，部分&nbsp;Key&nbsp;的&nbsp;Value&nbsp;过大，读写、加载易超时的现象。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">原因分析</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">造成这些大&nbsp;key&nbsp;慢查询的原因很多。如果这些大&nbsp;key&nbsp;占总体数据的比例很小，存&nbsp;Mc，对应的&nbsp;slab&nbsp;较少，导致很容易被频繁剔除，DB&nbsp;反复加载，从而导致查询较慢。如果业务中这种大&nbsp;key&nbsp;很多，而这种&nbsp;key&nbsp;被大量访问，缓存组件的网卡、带宽很容易被打满，也会导致较多的大&nbsp;key&nbsp;慢查询。另外，如果大&nbsp;key&nbsp;缓存的字段较多，每个字段的变更都会引发对这个缓存数据的变更，同时这些&nbsp;key&nbsp;也会被频繁地读取，读写相互影响，也会导致慢查现象。最后，大&nbsp;key&nbsp;一旦被缓存淘汰，DB&nbsp;加载可能需要花费很多时间，这也会导致大&nbsp;key&nbsp;查询慢的问题。</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">业务场景</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">大&nbsp;key&nbsp;的业务场景也比较常见。比如互联网系统中需要保存用户最新&nbsp;1万&nbsp;个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发&nbsp;feed&nbsp;统计等。微博的&nbsp;feed&nbsp;内容缓存也很容易出现，一般用户微博在&nbsp;140&nbsp;字以内，但很多用户也会发表&nbsp;1千&nbsp;字甚至更长的微博内容，这些长微博也就成了大&nbsp;key，如下图。</span></p>
<p style="text-indent: 0em; white-space: normal; text-align: center; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);"><img src="http://s0.lgstatic.com/i/image2/M01/99/92/CgotOV2kSmaAPcVbAAB3WSWtgpo221.png">&nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<h2 style="white-space: normal;"></h2>
<h6 style="text-indent: 0em; white-space: normal; text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px;">解决方案</span></h6>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">对于大&nbsp;key，给出&nbsp;3&nbsp;种解决方案。</span></p>
<ul style=" white-space: normal; font-size: 14px;">
 <li><p style="text-align: justify; text-indent: 0em; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">第一种方案，如果数据存在&nbsp;Mc&nbsp;中，可以设计一个缓存阀值，当&nbsp;value&nbsp;的长度超过阀值，则对内容启用压缩，让&nbsp;KV&nbsp;尽量保持小的&nbsp;size，其次评估大&nbsp;key&nbsp;所占的比例，在&nbsp;Mc&nbsp;启动之初，就立即预写足够数据的大&nbsp;key，让&nbsp;Mc&nbsp;预先分配足够多的&nbsp;trunk size&nbsp;较大的&nbsp;slab。确保后面系统运行时，大&nbsp;key&nbsp;有足够的空间来进行缓存。</span><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">&nbsp; &nbsp; &nbsp; &nbsp;</span></p></li>
</ul>
<p style="text-indent: 0em; white-space: normal; text-align: center; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/72/CgoB5l2kSmaAMET9AACrkN0JqFc011.png"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; color: rgb(63, 63, 63);">&nbsp; &nbsp; &nbsp;&nbsp;</span></p>
<ul style=" white-space: normal; font-size: 14px;">
 <li><p style="text-align: justify; text-indent: 0em; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">第二种方案，如果数据存在&nbsp;Redis&nbsp;中，比如业务数据存&nbsp;set&nbsp;格式，大&nbsp;key&nbsp;对应的&nbsp;set&nbsp;结构有几千几万个元素，这种写入&nbsp;Redis&nbsp;时会消耗很长的时间，导致&nbsp;Redis&nbsp;卡顿。此时，可以扩展新的数据结构，同时让&nbsp;client&nbsp;在这些大&nbsp;key&nbsp;写缓存之前，进行序列化构建，然后通过&nbsp;restore&nbsp;一次性写入，如下图所示。</span></p></li>
</ul>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: center; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;<img src="http://s0.lgstatic.com/i/image2/M01/99/92/CgotOV2kSmaAXnFGAAC1hm9Qofg743.png" style="text-align: center; white-space: normal;"></span></p>
<ul style=" white-space: normal; font-size: 14px;">
 <li><p style="text-align: justify; text-indent: 0em; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">第三种方案时，如下图所示，将大&nbsp;key&nbsp;分拆为多个&nbsp;key，尽量减少大&nbsp;key&nbsp;的存在。同时由于大&nbsp;key&nbsp;一旦穿透到&nbsp;DB，加载耗时很大，所以可以对这些大&nbsp;key&nbsp;进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰&nbsp;key&nbsp;时，同等条件下，尽量不淘汰这些大&nbsp;key。</span></p></li>
</ul>
<p style="text-indent: 0em; white-space: normal; text-align: center; line-height: 1.75em;"><img src="http://s0.lgstatic.com/i/image2/M01/99/72/CgoB5l2kSmeAeayMAAD0DTkVh1k994.png"></p>
<h1 style="white-space: normal;"></h1>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">至此，本课时缓存的&nbsp;7&nbsp;大经典问题全部讲完。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;"><br></span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; text-indent: 0em;">我们要认识到，对于互联网系统，由于实际业务场景复杂，数据量、访问量巨大，需要提前规避缓存使用中的各种坑。你可以通过提前熟悉&nbsp;Cache&nbsp;的经典问题，提前构建防御措施， 避免大量&nbsp;key&nbsp;同时失效，避免不存在&nbsp;key&nbsp;访问的穿透，减少大&nbsp;key、热&nbsp;key&nbsp;的缓存失效，对热&nbsp;key&nbsp;进行分流。你可以采取一系列措施，让访问尽量命中缓存，同时保持数据的一致性。另外，你还可以结合业务模型，提前规划&nbsp;cache&nbsp;系统的&nbsp;SLA，如&nbsp;QPS、响应分布、平均耗时等，实施监控，以方便运维及时应对。在遇到部分节点异常，或者遇到突发流量、极端事件时，也能通过分池分层策略、key&nbsp;分拆等策略，避免故障发生。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">&nbsp;</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);">最终，你能在各种复杂场景下，面对高并发、海量访问，面对突发事件和洪峰流量，面对各种网络或机器硬件故障，都能保持服务的高性能和高可用。</span></p>
<p style="margin-top: 0pt; margin-bottom: 0pt; text-indent: 0em; white-space: normal; font-size: 11pt; color: rgb(73, 73, 73); text-align: justify; line-height: 1.75em;"><span style="font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; font-size: 16px; color: rgb(63, 63, 63);"><br></span></p>
<p style="line-height: 1.75em; text-align: justify; text-indent: 0em;"><span style="color: rgb(73, 73, 73); text-indent: 29.3333px; font-size: 12pt;">OK，这节课就讲到这里，下一课时我会分享“<span style="color: rgb(63, 63, 63); font-family: 微软雅黑, &quot;Microsoft YaHei&quot;; text-align: justify;">Memcached&nbsp;的原理及特性</span>”，记得按时来听课哈。好，下节课见，拜拜！</span></p>

---

### 精选评论

##### **用户7027：
> 不懂就问，什么是Mc呢

##### **用户8616：
> 老师您好，请问一下把一个大key分成多个小key请问需要怎么操作呢，就算设置的超时时间是一样的，但是分解开来的程序执行也是需要时间的吧，这样如果访问是不是会容易丢失数据呢？上一章节的内容都处理过，但是这章节的内容并没有处理过，所以看着也有点难受，没有例子的话

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; "“分解开来的程序执行也是需要时间的吧” 是的，但分解的执行程序就分散在众多的前端，整体性能要远好于从db中的计算及加载。
“这样如果访问是不是会容易丢失数据呢” 设计好分片策略，如果缓存数据过期，而正好需要这个分片，那就从db中加载这个分片即可，这样只用加载1/n 的数据即可。比如10000条记录，分10片，如果其中一片在缓存被踢出，那就只用加载1/10的数据。
分片存储本身是一个复杂度较高的存储方案，一般业务存储优先考虑其他常规方案，只有常规方案无法满足业务需求是，才采用分片存储方案。"

