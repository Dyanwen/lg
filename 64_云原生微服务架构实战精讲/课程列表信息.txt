已发布: 47

1804  ||  已发布  ||  开篇词：实战是学习新技术的不二法门  ||  fba49982a8584687a71a303a858c1b6a
1805  ||  已发布  ||  第01讲：什么是微服务架构  ||  954e537bd93b40daba02953185882a4c
1806  ||  已发布  ||  第02讲：什么是 Docker 与容器化技术  ||  09565b51253744fb94fe9ff43bf54712
1807  ||  已发布  ||  第03讲：云原生应用的 15 个特征  ||  1c1077efec47457786f51b522053a1da
1808  ||  已发布  ||  第04讲：什么是 Kubernetes 容器化应用  ||  ebcb0c57aa1b4013a6eb3a3db675e0c7
1809  ||  已发布  ||  第05讲：什么是服务网格（Service Mesh）  ||  12a01b33d1ab4f8db8d969471f305573
1810  ||  已发布  ||  第06讲：示例应用介绍与用户场景分析  ||  bde5495b1189407c98942384fefc5352
1811  ||  已发布  ||  第07讲：如何进行领域驱动设计  ||  f7bcaf8a2950436d9a702461436fab6e
1812  ||  已发布  ||  第08讲：如何对示例应用进行微服务划分  ||  0ffb20539dd34f87baed1d397cae10a9
1813  ||  已发布  ||  第09讲：快速部署开发环境与框架  ||  eb4c2127ad494299a794f5597af3c5f0
1814  ||  已发布  ||  第10讲：使用 OpenAPI 和 Swagger 实现 API 优先设计  ||  aad5ff4e920e4dd9a886c51b40adcab2
1815  ||  已发布  ||  第11讲：使用 Spring Data JPA 实现数据库驱动微服务  ||  ef9c00253f1f4d549fcd8f9f1f1086be
1816  ||  已发布  ||  第12讲：如何基于 JUnit 5 的服务实现单元测试  ||  c5838904e4a04c84865b106c60bb0c63
1817  ||  已发布  ||  第13讲：如何基于 REST 服务实现集成测试  ||  0ad5efe1836f4406bd91585b4b6e80bc
1818  ||  已发布  ||  第14讲：事件如何驱动微服务设计与异步消息传递  ||  a0a465704c464ccfaecddcc5f04b2b0f
1819  ||  已发布  ||  第15讲：什么是事务性消息模式  ||  7e1e191b19ac479195a221667c9c8040
1820  ||  已发布  ||  第16讲：事件发布如何进行处理  ||  14bd003e91e2447885b83af778491b6c
1821  ||  已发布  ||  第17讲：如何设计与实现事件源（Event sourcing）  ||  224356718cf44501b06e7c9248daef46
1822  ||  已发布  ||  第18讲：如何处理司机位置更新事件  ||  f556a8d711064a198d70f4bb92205e99
1823  ||  已发布  ||  第19讲：如何实现行程派发与调度算法  ||  695545e03e5949cf91151e2cd9c1465a
1824  ||  已发布  ||  第20讲：什么是数据一致性与 Saga 模式  ||  4bac8a32741f4ae9916986b966fe18df
1825  ||  已发布  ||  第21讲：如何使用 Saga 模式实现行程验证  ||  3309f6e4a8de43eaa050246a44744ce6
1826  ||  已发布  ||  第22讲：CQRS 如何设计与实现  ||  be2f2e2c21d446a5b97449ec69e5aef2
1827  ||  已发布  ||  第23讲：如何查询乘客和司机的行程  ||  31a37b5c20dc4da1be3196586f869473
1828  ||  已发布  ||  第24讲：服务调用失败的处理策略与实践  ||  61ebae064ac04420817627dd7c2ae92c
1829  ||  已发布  ||  第25讲：如何基于 Spring Security 和 JWT 实现访问控制  ||  cc74e49834784174b9b21321b2d4f26b
1830  ||  已发布  ||  第26讲：服务版本更新策略是什么  ||  1ad20006d721422dab375a024ce63d36
1831  ||  已发布  ||  第27讲：如何实现应用配置的外部化与管理  ||  58ca5e673adb4c8fa73c2c8460020d6c
1832  ||  已发布  ||  第28讲：使用 Prometheus 和 Grafana 处理性能指标数据  ||  b3b4d1403eaa4ec5a86543ab5fcd06aa
1833  ||  已发布  ||  第29讲：使用 Fluentd、ElasticSearch 和 Kibana 管理日志  ||  4755ed112ebe4a8497b2cf072c0f8fe8
1834  ||  已发布  ||  第30讲：使用 Sentry 处理异常  ||  a059b20a1848452dabc83cd73e486504
1835  ||  已发布  ||  第31讲：如何设计与实现 API 组合  ||  ea47add7041141dfa2e52a76af465ecd
1836  ||  已发布  ||  第32讲：如何使用 Netflix Falcor 组合 API  ||  16465aeaf1744476adb62f36d6ea203f
1837  ||  已发布  ||  第33讲：如何使用 GraphQL 组合 API  ||  9ddf4b60a175473499668aca3c7695ec
1838  ||  已发布  ||  第34讲：如何安装与配置 Istio  ||  06dae966888b42eb828c7b8894cd5e58
1839  ||  已发布  ||  第35讲：使用 API 网关作为应用请求入口  ||  d86d7d7321bb453bb8be9c570b825efc
1840  ||  已发布  ||  第36讲：什么是服务重试与熔断器  ||  e35cb52a753f40c48f140440bfbf0996
1841  ||  已发布  ||  第37讲：如何实现追踪服务性能指标  ||  5b7cf04dd71a4ceb973fa722c460c0af
1842  ||  已发布  ||  第38讲：如何实现服务访问控制与双向 TLS  ||  f3744313dd5448e48c5cb0531ff85131
1843  ||  已发布  ||  第39讲：使用 Jenkins 进行持续集成  ||  56f0585b7de14a5b8f4d18010bf118ff
1844  ||  已发布  ||  第40讲：如何持续部署到阿里云  ||  1df4e0dfc7b641758cab25d18bf2de5c
1845  ||  已发布  ||  第41讲：如何结合服务网格进行灰度发布  ||  a7525ee9e7c04c2798131649165c4955
1846  ||  已发布  ||  第42讲：使用 Spring HATEOAS 增强 REST 服务的语义  ||  dd506fb367b34141b66dd5f0ce64ad7a
1847  ||  已发布  ||  第43讲：使用 gRPC 作为服务之间的交互方式  ||  722dd5b88f624a66994860df9f84d9ec
1848  ||  已发布  ||  第44讲：使用 Quarkus 开发微服务  ||  2f7636c1c81740b4bfee1d3a618f9b21
1849  ||  已发布  ||  第45讲：消费者驱动的服务契约测试  ||  881e6200140b42ea85abdceeea6dcd58
1850  ||  已发布  ||  结束语：微服务架构展望  ||  8c4b6dea48864e2fbc7d5dad8852b7c1
