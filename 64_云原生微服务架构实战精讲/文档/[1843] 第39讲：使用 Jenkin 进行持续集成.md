<p data-nodeid="2749" class="">从本课时开始，我们将开始进入<strong data-nodeid="2963">持续集成（Continuous Integration）</strong> 和<strong data-nodeid="2964">持续部署（Continuous Deployment）</strong> 相关的内容，持续集成和部署是目前软件开发中的标准实践。在微服务架构的应用中，持续集成和部署的重要性和复杂度都提高了，因为每个服务都需要独立的集成和部署。本课时将介绍如何使用 Jenkins 进行持续集成。</p>
<p data-nodeid="2750">我们首先要明确的是持续集成的目标，即从源代码到容器镜像，每一个源代码的提交，都应该创建出对应的不可变的容器镜像，这个构建过程是可重复的。对于同样的代码提交，无论在什么时候构建，所得到的容器镜像都应该是完全相同的，这就保证了容器镜像是可丢弃的，可以随时从源代码中构建出所需要的镜像，这使得我们可以把不同环境上的应用部署回退到任意版本。创建出来的镜像一般被发布到镜像注册表中，由 Kubernetes 在运行时拉取并运行。</p>
<p data-nodeid="2751">下面首先介绍如何使用 Dockerfile 创建镜像。</p>
<h3 data-nodeid="2752">使用 Dockerfile</h3>
<p data-nodeid="2753">为了部署在 Kubernetes 上，我们需要为每个微服务创建各自的容器镜像。</p>
<p data-nodeid="2754">创建简单的 Docker 镜像并不是复杂的事情，只需要编写描述镜像内容的 Dockerfile 文件，再使用 docker build 命令来创建镜像即可。下面代码中的 Dockerfile 用来创建地址管理服务的镜像。</p>
<pre class="lang-dockerfile" data-nodeid="2755"><code data-language="dockerfile"><span class="hljs-keyword">FROM</span> adoptopenjdk/openjdk8:jre8u262-b10-alpine 
<span class="hljs-keyword">ADD</span><span class="bash"> target/happyride-address-service-1.0.0-SNAPSHOT.jar /opt/app.jar </span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [ <span class="hljs-string">"java"</span>, <span class="hljs-string">"-jar"</span>, <span class="hljs-string">"/opt/app.jar"</span> ]</span>
</code></pre>
<p data-nodeid="2756">这个 Dockerfile 的内容很简单，只有 3 条指令，具体的说明如下表所示。</p>
<table data-nodeid="2758">
<thead data-nodeid="2759">
<tr data-nodeid="2760">
<th data-org-content="**指令**" data-nodeid="2762"><strong data-nodeid="2974">指令</strong></th>
<th data-org-content="**说明**" data-nodeid="2763"><strong data-nodeid="2978">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2766">
<tr data-nodeid="2767">
<td data-org-content="FROM" data-nodeid="2768">FROM</td>
<td data-org-content="使用的基础镜像是 AdoptOpenJDK 的 JRE 8 的 Alpine 镜像" data-nodeid="2769">使用的基础镜像是 AdoptOpenJDK 的 JRE 8 的 Alpine 镜像</td>
</tr>
<tr data-nodeid="2770">
<td data-org-content="ADD" data-nodeid="2771">ADD</td>
<td data-org-content="添加服务的 JAR 文件到 /opt 目录" data-nodeid="2772">添加服务的 JAR 文件到 /opt 目录</td>
</tr>
<tr data-nodeid="2773">
<td data-org-content="ENTRYPOINT" data-nodeid="2774">ENTRYPOINT</td>
<td data-org-content="设置容器镜像运行时的入口为使用 Java 命令来运行 JAR 文件" data-nodeid="2775">设置容器镜像运行时的入口为使用 Java 命令来运行 JAR 文件</td>
</tr>
</tbody>
</table>
<p data-nodeid="2776">这里利用了 Spring Boot 的 Maven 插件来把整个应用打包成单一的 JAR 文件。</p>
<p data-nodeid="2777">我们使用下面的命令来创建并运行镜像，-t 参数的作用是为镜像指定一个标签：</p>
<pre class="lang-shell" data-nodeid="2778"><code data-language="shell"><span class="hljs-meta">$</span><span class="bash"> docker build . -t <span class="hljs-built_in">local</span>/address-service:1.0.0 </span>
<span class="hljs-meta">$</span><span class="bash"> docker run <span class="hljs-built_in">local</span>/address-service:1.0.0</span>
</code></pre>
<p data-nodeid="2779">在 Maven 构建过程的 package 阶段中，在 Spring Boot 的 Maven 插件产生了 JAR 文件之后，使用 Maven 的 exec-maven-plugin 插件来调用 docker build 命令。下面的代码给出了 Maven 插件的使用示例。</p>
<pre class="lang-xml" data-nodeid="2780"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>exec-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>exec<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>docker<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>-f<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>${project.basedir}/src/docker/Dockerfile<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>-t<span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">argument</span>&gt;</span>happyride/${project.artifactId}:${project.version} 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">argument</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2781">在使用 Maven 插件完成构建之后，产生的容器镜像会缓存在本地，可以通过 docker images 命令来查看。</p>
<h3 data-nodeid="2782">OCI 镜像规范</h3>
<p data-nodeid="2783">虽然我们在谈论容器镜像时，通常会使用 Docker 镜像来代替，但两者并不是等同的。为了对容器镜像的格式进行规范化，Linux 基金会下的开放容器倡议（Open Container Initiative，OCI）组织负责维护容器镜像规范和容器运行规范。在 OCI 规范的基础上，不同的厂商可以开发自己的基于 OCI 规范的工具或产品。</p>
<p data-nodeid="2784">OCI 镜像规范以 Docker 公司贡献的 Docker 镜像版本 2 格式作为基础。每个 OCI 镜像由下表中的几个部分组成：</p>
<table data-nodeid="2786">
<thead data-nodeid="2787">
<tr data-nodeid="2788">
<th data-org-content="**组成部分**" data-nodeid="2790"><strong data-nodeid="2995">组成部分</strong></th>
<th data-org-content="**说明**" data-nodeid="2791"><strong data-nodeid="2999">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2794">
<tr data-nodeid="2795">
<td data-org-content="清单文件" data-nodeid="2796">清单文件</td>
<td data-org-content="描述对应于特定底层架构和操作系统的容器镜像" data-nodeid="2797">描述对应于特定底层架构和操作系统的容器镜像</td>
</tr>
<tr data-nodeid="2798">
<td data-org-content="清单文件索引" data-nodeid="2799">清单文件索引</td>
<td data-org-content="清单文件的索引" data-nodeid="2800">清单文件的索引</td>
</tr>
<tr data-nodeid="2801">
<td data-org-content="层（Layer）" data-nodeid="2802">层（Layer）</td>
<td data-org-content="对文件系统的改动" data-nodeid="2803">对文件系统的改动</td>
</tr>
<tr data-nodeid="2804">
<td data-org-content="配置" data-nodeid="2805">配置</td>
<td data-org-content="与容器运行相关的配置" data-nodeid="2806">与容器运行相关的配置</td>
</tr>
</tbody>
</table>
<p data-nodeid="2807">在上表中，镜像中的层是开发中需要注意的概念。把镜像划分成多个层之后，可以更有效地利用缓存，从而加快构建的速度。在推送镜像到注册表时，只有改变的层才会被推送。以一个 Java 应用来说，如果把应用所依赖的第三方库和应用自身的类文件划分成不同的层，由于第三方库很少变化，在构建镜像时，只需要更新和推送类文件所在的层即可。如果整个 Java 应用的全部文件被划分在一个层中，那么每次构建镜像时，该层都必然被更新，即便其中的第三方库没有变化，这也会产生不必要的传输开销。</p>
<h3 data-nodeid="2808">使用 Spring Boot 的 Buildpacks</h3>
<p data-nodeid="2809">Dockerfile 虽然简单易懂，但是缺乏必要的组织，造成复用起来很困难，只能复制粘贴 Dockerfile 中的部分内容。如果有很多服务都使用 Spring Boot 开发，那么每个服务中都需要复制一份大部分内容都重复的 Dockerfile。解决这个问题的一种做法是使用 Buildpacks。</p>
<p data-nodeid="2810"><a href="https://buildpacks.io/" data-nodeid="3013">Buildpacks</a>是 CNCF 之下的一个沙盒项目，其所要解决的问题是从源代码中构建出 OCI 容器镜像。与 Dockerfile 相比，Buildpacks 的抽象层次更高，更容易理解和复用，它的基本组成单元是 Buildpack。每个 Buildpack 分成<strong data-nodeid="3023">检测</strong>和<strong data-nodeid="3024">构建</strong>两个步骤：检测步骤用来判断该 Buildpack 是否应该被应用；构建步骤则负责对镜像进行修改，包括修改层的内容，或是修改配置。每个 Buildpack 只对镜像做特定的改动。</p>
<p data-nodeid="2811">在每一个应用的镜像构建过程中，会有多个 Buildpack 按照顺序来依次检测和应用修改。通过这种方式，不同的 Buildpack 可以进行组合和复用。</p>
<p data-nodeid="2812">Spring Boot 从 2.3.0 版本开始，支持使用 Buildpacks 来创建 OCI 镜像。在 Maven 中，只需要使用 Spring Boot Maven 插件的 build-image 命令即可。下面的代码给出了插件的基本用法。</p>
<pre class="lang-xml" data-nodeid="2813"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2814">在生成的 Spring Boot 镜像中，不仅仅包含了 JRE 和应用的 JAR 文件，还包含了一些辅助的工具，如下表所示：</p>
<table data-nodeid="2816">
<thead data-nodeid="2817">
<tr data-nodeid="2818">
<th data-org-content="**工具**" data-nodeid="2820"><strong data-nodeid="3031">工具</strong></th>
<th data-org-content="**说明**" data-nodeid="2821"><strong data-nodeid="3035">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2824">
<tr data-nodeid="2825">
<td data-org-content="memory-calculator" data-nodeid="2826">memory-calculator</td>
<td data-org-content="计算 JVM 使用的内存大小" data-nodeid="2827">计算 JVM 使用的内存大小</td>
</tr>
<tr data-nodeid="2828">
<td data-org-content="jvmkill" data-nodeid="2829">jvmkill</td>
<td data-org-content="当无法分配内存或创建线程时，终止 JVM" data-nodeid="2830">当无法分配内存或创建线程时，终止 JVM</td>
</tr>
<tr data-nodeid="2831">
<td data-org-content="class-counter" data-nodeid="2832">class-counter</td>
<td data-org-content="计算类文件的数量" data-nodeid="2833">计算类文件的数量</td>
</tr>
<tr data-nodeid="2834">
<td data-org-content="link-local-dns" data-nodeid="2835">link-local-dns</td>
<td data-org-content="修改 DNS 设置" data-nodeid="2836">修改 DNS 设置</td>
</tr>
<tr data-nodeid="2837">
<td data-org-content="openssl-security-provider" data-nodeid="2838">openssl-security-provider</td>
<td data-org-content="加载 JRE 的权威机构证书" data-nodeid="2839">加载 JRE 的权威机构证书</td>
</tr>
<tr data-nodeid="2840">
<td data-org-content="security-providers-configurer" data-nodeid="2841">security-providers-configurer</td>
<td data-org-content="配置 Java 的安全服务的提供者" data-nodeid="2842">配置 Java 的安全服务的提供者</td>
</tr>
<tr data-nodeid="2843">
<td data-org-content="java-security-properties" data-nodeid="2844">java-security-properties</td>
<td data-org-content="Java 安全属性" data-nodeid="2845">Java 安全属性</td>
</tr>
</tbody>
</table>
<p data-nodeid="2846">这些工具的作用是优化 Java 应用在容器中的运行。下面的代码是 Spring Boot 应用的容器在运行时的输出，从中可以看到，JVM 的内存设置会根据容器的内存限制来做出调整。</p>
<pre class="lang-java" data-nodeid="2847"><code data-language="java">Container memory limit unset. Configuring JVM <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>G container. 
Calculated JVM Memory Configuration: -XX:MaxDirectMemorySize=<span class="hljs-number">10</span>M -XX:MaxMetaspaceSize=<span class="hljs-number">126109</span>K -XX:ReservedCodeCacheSize=<span class="hljs-number">240</span>M -Xss1M -Xmx410466K (Head Room: <span class="hljs-number">0</span>%, Loaded Class Count: <span class="hljs-number">19851</span>, Thread Count: <span class="hljs-number">250</span>, Total Memory: <span class="hljs-number">1073741824</span>) 
Adding <span class="hljs-number">127</span> container CA certificates to JVM truststore
</code></pre>
<p data-nodeid="2848">下面的代码给出了 Spring Boot 的 Buildpacks 在构建时的部分输出，从中可以看到，在检测阶段中，在 16 个 Buildpack 中， 只有 5 个会参与构建，并给出了每个 Buildpack 的名称和版本号。</p>
<pre class="lang-java" data-nodeid="2849"><code data-language="java">[INFO]&nbsp; &gt; Running creator 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;===&gt; DETECTING 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;<span class="hljs-number">5</span> of <span class="hljs-number">16</span> buildpacks participating 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/bellsoft-liberica <span class="hljs-number">2.11</span>.<span class="hljs-number">0</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/executable-jar&nbsp; &nbsp; <span class="hljs-number">2.0</span>.<span class="hljs-number">2</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/apache-tomcat&nbsp; &nbsp; &nbsp;<span class="hljs-number">1.4</span>.<span class="hljs-number">0</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/dist-zip&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-number">1.3</span>.<span class="hljs-number">8</span> 
[INFO]&nbsp; &nbsp; &nbsp;[creator]&nbsp; &nbsp; &nbsp;paketo-buildpacks/spring-boot&nbsp; &nbsp; &nbsp; &nbsp;<span class="hljs-number">2.3</span>.<span class="hljs-number">0</span>
</code></pre>
<h3 data-nodeid="2850">使用 Jib</h3>
<p data-nodeid="2851"><a href="https://github.com/GoogleContainerTools/jib" data-nodeid="3055">Jib</a> 是由 Google 维护的工具，用来对 Java 应用进行容器化。其优势在于不需要依赖 Docker 守护进程，就可以创建出 OCI 容器镜像，构建镜像也不需要编写 Dockerfile。Jib 会自动把应用分成多层，把应用依赖的第三方库和应用自身的类文件分开。</p>
<p data-nodeid="2852">Jib 支持 3 种不同的构建方式，对应于不同的 Maven 目标，如下表所示。</p>
<table data-nodeid="2854">
<thead data-nodeid="2855">
<tr data-nodeid="2856">
<th data-org-content="**Maven 目标**" data-nodeid="2858"><strong data-nodeid="3061">Maven 目标</strong></th>
<th data-org-content="**说明**" data-nodeid="2859"><strong data-nodeid="3065">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2862">
<tr data-nodeid="2863">
<td data-org-content="build" data-nodeid="2864">build</td>
<td data-org-content="不使用 Docker 来构建镜像，并推送到注册表" data-nodeid="2865">不使用 Docker 来构建镜像，并推送到注册表</td>
</tr>
<tr data-nodeid="2866">
<td data-org-content="dockerBuild" data-nodeid="2867">dockerBuild</td>
<td data-org-content="使用 Docker 来构建镜像" data-nodeid="2868">使用 Docker 来构建镜像</td>
</tr>
<tr data-nodeid="2869">
<td data-org-content="buildTar" data-nodeid="2870">buildTar</td>
<td data-org-content="把镜像打包成 tar 文件" data-nodeid="2871">把镜像打包成 tar 文件</td>
</tr>
</tbody>
</table>
<p data-nodeid="2872">下面的代码给出了 jib 的 Maven 插件的基本用法，其中 from 表示基础镜像的名称，to 表示构建出来的镜像的发布地址。这里使用的是 build 目标来创建并发布 OCI 镜像，并不依赖 Docker。</p>
<pre class="lang-xml" data-nodeid="2873"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.cloud.tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jib-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>adoptopenjdk/openjdk8:jre8u262-b10-alpine<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; docker-registry:5000/happyride/${project.artifactId}:${parsedVersion.majorVersion}.${parsedVersion.minorVersion}.${parsedVersion.incrementalVersion}-${git.commit.id.abbrev} 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">allowInsecureRegistries</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">allowInsecureRegistries</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">container</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>OCI<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">container</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
&nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
&nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2874">与 Spring Boot 构建镜像的方式相比，Jib 的优势在于可以对任意 Java 应用进行构建，并且不依赖 Docker 运行时的支持；不足之处在于缺少对 Java 应用运行的优化。</p>
<h3 data-nodeid="2875">容器镜像注册表</h3>
<p data-nodeid="2876">在本地开发环境上运行 docker build 命令之后，产生的镜像会缓存在本地。当在 Kubernetes 上部署时，这些本地缓存的镜像并不能直接使用。根据部署环境的不同，可以通过相应的方式来使用镜像。</p>
<p data-nodeid="2877">在本地开发环境中，Minikube 内置包含了 Docker 运行时，为 Kubernetes 提供容器运行时的支持。我们可以配置本地开发环境中的 docker 命令，来连接 Minikube 中的 Docker 守护进程。在本地上构建完成之后，得到的镜像会被缓存在 Minikube 的 Docker 进程中，从而可以在 Kubernetes 中直接使用。</p>
<p data-nodeid="2878">使用下面的命令可以显示连接到 Minikube 的 Docker 守护进程的配置方式。</p>
<pre class="lang-plain" data-nodeid="2879"><code data-language="plain">$ minikube docker-env
</code></pre>
<p data-nodeid="2880">上述命令的输出如下所示，只是设置了一些环境变量：</p>
<pre class="lang-sql" data-nodeid="2881"><code data-language="sql">export DOCKER_TLS_VERIFY="1" 
export DOCKER_HOST="tcp://192.168.64.9:2376" 
export DOCKER_CERT_PATH="/Users/alexcheng/.minikube/certs" 
export MINIKUBE_ACTIVE_DOCKERD="minikube" 
<span class="hljs-comment"># To point your shell to minikube's docker-daemon, run: </span>
<span class="hljs-comment"># eval $(minikube -p minikube docker-env)</span>
</code></pre>
<p data-nodeid="2882">按照命令输出中的提示操作完成设置之后，在当前命令行窗口中使用 Maven 命令来构建镜像。在 Kubernetes 中，只需要重新创建 Pod，就可以使用新构建的镜像来进行测试。</p>
<p data-nodeid="2883">如果应用安装在用户的私有环境中，并且不能自由的访问外部的网络，可以使用 docker export 命令把镜像导出成压缩文件，保存在移动存储设备中。在内部网络中，把镜像的压缩文件复制到 Kubernetes 的每个节点上，再使用 docker import 命令把镜像导入缓存中。</p>
<p data-nodeid="2884">除了上述两种特殊情况之外，最常用的做法是使用容器镜像注册表来保存镜像。在持续集成中，容器镜像被发布到注册表中；在 Kubernetes 上运行时，容器镜像从注册表中下载到本地并运行。</p>
<p data-nodeid="2885">云平台一般都提供各自的容器注册表服务，也可以使用独立的注册表服务。Docker 的注册表实现是开源的，可以在集群内部安装自己的私有注册表。</p>
<h3 data-nodeid="2886">容器镜像的标签</h3>
<p data-nodeid="2887">在持续集成中，每次构建出来的容器镜像都应该有唯一的标签，如果不指定标签，那么默认使用的是 latest 标签。在实际的开发中，并不建议使用 latest 标签，因为该标签所指向的容器镜像的内容是不固定的。如果在测试或生产环境中使用了 latest 标签，那么一段时间之后重新运行测试或再次部署时，所得到的结果可能完全不同，因为对应的镜像可能被更新了。为了保证测试和部署的可重复性，所有的测试和部署都应该使用带标签的形式来引用镜像。</p>
<p data-nodeid="2888">镜像标签最常用的格式是使用语义化版本号，目前绝大部分的公开镜像都使用版本号作为标签。在实际开发中，单纯使用版本号并不足以区分不同的构建版本，因为同一个版本在开发过程中可能多次构建。通常的做法是在版本号之后添加后缀，作为附加的区分信息。常用的后缀包括构建时间、构建编号和 Git 提交的标识符，如下表所示：</p>
<table data-nodeid="2890">
<thead data-nodeid="2891">
<tr data-nodeid="2892">
<th data-org-content="**后缀**" data-nodeid="2894"><strong data-nodeid="3089">后缀</strong></th>
<th data-org-content="**说明**" data-nodeid="2895"><strong data-nodeid="3093">说明</strong></th>
</tr>
</thead>
<tbody data-nodeid="2898">
<tr data-nodeid="2899">
<td data-org-content="构建时间" data-nodeid="2900">构建时间</td>
<td data-org-content="使用构建完成时的时间戳" data-nodeid="2901">使用构建完成时的时间戳</td>
</tr>
<tr data-nodeid="2902">
<td data-org-content="构建编号" data-nodeid="2903">构建编号</td>
<td data-org-content="持续集成服务为每个构建分配的标识符" data-nodeid="2904">持续集成服务为每个构建分配的标识符</td>
</tr>
<tr data-nodeid="2905">
<td data-org-content="Git 提交标识符" data-nodeid="2906">Git 提交标识符</td>
<td data-org-content="触发持续集成的 Git 提交的标识符" data-nodeid="2907">触发持续集成的 Git 提交的标识符</td>
</tr>
</tbody>
</table>
<p data-nodeid="2908">在上表的这 3 种后缀形式中，并不推荐使用构建时间，因为时间本身并不能提供更多有用的信息。使用构建编号的好处是方便与已有的项目管理系统和 bug 追踪系统进行集成。测试团队一般工作在特定的构建编号之上。推荐的做法是使用 Git 提交的标识符作为后缀，从使用的镜像标签就可以快速定位到产生该镜像的代码。</p>
<p data-nodeid="2909">我们可以使用 Maven 的 git-commit-id-maven-plugin 插件来获取 Git 中提交的标识符，并在构建过程中引用。</p>
<p data-nodeid="2910">下面的代码给出了该插件的使用示例。该插件会提供一系列与 Git 相关的属性，比如 git.commit.id.abbrev 属性表示 Git 提交标识符的缩略形式。</p>
<pre class="lang-xml" data-nodeid="2911"><code data-language="xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>pl.project13.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>git-commit-id-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>get-the-git-infos<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span> 
        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>revision<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> 
      <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span> 
      <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>initialize<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span> 
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span> 
  <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
</code></pre>
<p data-nodeid="2912">最终生成的镜像标签类似与于 1.0.0-3228a39。</p>
<h3 data-nodeid="2913">使用 Jenkins</h3>
<p data-nodeid="2914">示例应用使用 Jenkins 作为持续集成的服务。Jenkins 使用 Helm 安装，运行在 Kubernetes 上。当需要运行构建任务时，Jenkins 会启动一个新的 Pod 来执行。</p>
<p data-nodeid="2915">下面的代码是 Jenkins 中流水线的声明。构建的容器运行的是 Maven 的镜像，从 GitHub 获取源代码之后，通过 Maven 来执行构建过程，构建过程中会发布镜像到注册表中。</p>
<pre class="lang-dart" data-nodeid="2916"><code data-language="dart">podTemplate(yaml: <span class="hljs-string">''' 
apiVersion: v1 
kind: Pod 
spec: 
&nbsp; securityContext: 
&nbsp; &nbsp; fsGroup: 1000 
&nbsp; containers: 
&nbsp; - name: maven 
&nbsp; &nbsp; image: maven:3.6.3-jdk-8 
&nbsp; &nbsp; command: 
&nbsp; &nbsp; - sleep 
&nbsp; &nbsp; args: 
&nbsp; &nbsp; - infinity 
&nbsp; &nbsp; resources: 
&nbsp; &nbsp; &nbsp; requests: 
&nbsp; &nbsp; &nbsp; &nbsp; cpu: 1 
&nbsp; &nbsp; &nbsp; &nbsp; memory: 1Gi 
&nbsp; &nbsp; volumeMounts: 
&nbsp; &nbsp; &nbsp; - name: dockersock 
&nbsp; &nbsp; &nbsp; &nbsp; mountPath: "/var/run/docker.sock" 
&nbsp; volumes: 
&nbsp; &nbsp; - name: dockersock 
&nbsp; &nbsp; &nbsp; hostPath: 
&nbsp; &nbsp; &nbsp; &nbsp; path: /var/run/docker.sock 
'''</span>) { 
&nbsp; &nbsp; node(POD_LABEL) { 
&nbsp; &nbsp; &nbsp; &nbsp; git <span class="hljs-string">'https://github.com/alexcheng1982/happyride'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; container(<span class="hljs-string">'maven'</span>) { 
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sh <span class="hljs-string">'mvn -B -ntp -Dmaven.test.failure.ignore deploy'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; } 
&nbsp; &nbsp; &nbsp; &nbsp; junit <span class="hljs-string">'**/target/surefire-reports/TEST-*.xml'</span> 
&nbsp; &nbsp; &nbsp; &nbsp; archiveArtifacts <span class="hljs-string">'**/target/*.jar'</span> 
&nbsp; &nbsp; } 
}
</code></pre>
<p data-nodeid="2917">这里需要着重介绍的是对 Docker 的使用。在构建过程中，单元测试和镜像发布都需要依赖 Docker 进程。在流水线的定义中，通过卷绑定的方式，把 Kubernetes 节点上的 /var/run/docker.sock 文件传到构建的 Pod 中，使得 Pod 中的容器可以访问节点上的 Docker 进程。通过这种方式，避免了在 Maven 容器中启动额外的 Docker 进程。</p>
<h3 data-nodeid="2918">其他构建镜像的工具</h3>
<p data-nodeid="2919">目前所介绍的构建容器镜像的方式是使用 Docker，这也是目前比较主流的方式。Docker 在本地开发时很方便，但在持续集成中也有一些不足之处。</p>
<p data-nodeid="2920">构建时需要有 Docker 守护进程存在，这就意味着需要在持续集成服务器上安装 Docker，并保持 Docker 在后台运行。如果在 Kubernetes 上运行，那么可以复用 Kubernetes 节点上的 Docker 进程。</p>
<p data-nodeid="2921">另外一个问题来自 Docker 自身。随着多年的开发，Docker 自身已经过于臃肿，提供了非常多的功能。在持续集成中，我们只需要能够构建镜像，并推送到容器注册表即可，并不需要 Docker 提供的其他功能。</p>
<p data-nodeid="2922">OCI 镜像规范的出现，使得容器镜像的格式不再锁定于特定的公司，从而促进了容器镜像构建相关工具的发展。目前已经有一些工具可以创建出 OCI 镜像，如下表所示。</p>
<table data-nodeid="2924">
<thead data-nodeid="2925">
<tr data-nodeid="2926">
<th data-org-content="**名称**" data-nodeid="2928"><strong data-nodeid="3116">名称</strong></th>
<th data-org-content="**支持者**" data-nodeid="2929"><strong data-nodeid="3120">支持者</strong></th>
</tr>
</thead>
<tbody data-nodeid="2932">
<tr data-nodeid="2933">
<td data-org-content="[BuildKit](https://github.com/moby/buildkit)" data-nodeid="2934"><a href="https://github.com/moby/buildkit" data-nodeid="3123">BuildKit</a></td>
<td data-org-content="Docker Inc" data-nodeid="2935">Docker Inc</td>
</tr>
<tr data-nodeid="2936">
<td data-org-content="[buildah](https://buildah.io/)" data-nodeid="2937"><a href="https://buildah.io/" data-nodeid="3127">buildah</a></td>
<td data-org-content="Red Hat" data-nodeid="2938">Red Hat</td>
</tr>
<tr data-nodeid="2939">
<td data-org-content="[umoci](https://umo.ci/)" data-nodeid="2940"><a href="https://umo.ci/" data-nodeid="3131">umoci</a></td>
<td data-org-content="SUSE" data-nodeid="2941">SUSE</td>
</tr>
<tr data-nodeid="2942">
<td data-org-content="[Kaniko](https://github.com/GoogleContainerTools/kaniko)" data-nodeid="2943"><a href="https://github.com/GoogleContainerTools/kaniko" data-nodeid="3135">Kaniko</a></td>
<td data-org-content="Google" data-nodeid="2944">Google</td>
</tr>
<tr data-nodeid="2945">
<td data-org-content="[Makisu](https://github.com/uber/makisu)" data-nodeid="2946"><a href="https://github.com/uber/makisu" data-nodeid="3139">Makisu</a></td>
<td data-org-content="Uber" data-nodeid="2947">Uber</td>
</tr>
</tbody>
</table>
<p data-nodeid="2948">在这些工具中，值得一提的是 Docker 的 BuildKit，其支持并发的构建，可以更高效地进行缓存，因此构建的速度更快。BuildKit 从 18.06 版本开始已经被集成到 Docker 中，可以通过下面的命令来启用 BuildKit。</p>
<pre class="lang-plain" data-nodeid="2949"><code data-language="plain">DOCKER_BUILDKIT=1 docker build
</code></pre>
<p data-nodeid="2950">有一些其他工具对 BuildKit 进行了封装，可以简化它的使用，包括 <a href="https://github.com/genuinetools/img" data-nodeid="3145">img</a>、阿里巴巴的 <a href="https://github.com/alibaba/pouch" data-nodeid="3149">pouch</a> 和 Rancher 的 <a href="https://github.com/rancher/k3c" data-nodeid="3153">k3c</a> 等。本课时不对这些工具进行具体的介绍，详细的使用请参考相关文档。</p>
<h3 data-nodeid="2951">总结</h3>
<p data-nodeid="2952">在微服务架构中，持续集成可以保证每一个代码提交都可以有与之对应的容器镜像，容器镜像是不可变的，而且构建的过程是可重复的。通过本课时的学习，你可以了解如何从 Dockerfile 中创建出 Docker 容器镜像，以及如何使用 Spring Boot 插件和 Google 的 Jib 工具来创建 Java 应用的容器镜像，还可以了解如何使用 Jenkins 来进行持续集成。</p>
<p data-nodeid="6490" class="">最后呢，成老师邀请你为本专栏课程进行结课评价，因为你的每一个观点都是我们最关注的点。<a href="https://wj.qq.com/s2/6902680/3fb2/" data-nodeid="6494">点击链接，即可参与课程评价</a>。</p>

---

### 精选评论


