<p data-nodeid="1522" class="">作为 iOS 开发者，我们每天都花大量的时间来开发和调试 UI，那有没有什么办法帮助我们把繁杂的 UI 开发工作简化成有章可循的步骤，从而提高开发的效率呢？在这一讲中，我就和你聊聊，如何架构和开发一套灵活的 UI 框架。</p>
<h3 data-nodeid="1523">通用列表 UI 模块的架构与实现</h3>
<p data-nodeid="1524">列表 UI 是 App 最为常用的 UI 页面，它可以帮我们通过滚动的方式支持无限的内容。为了简化大量的重复性劳动，我在 Moments App 架构实现了一个通用的列表 UI 模块。下面是这个模块的架构图。</p>
<p data-nodeid="1525"><img src="https://s0.lgstatic.com/i/image6/M01/3C/A9/Cgp9HWCL1DiANqbhAAMguDPxTIw094.png" alt="图片1.png" data-nodeid="1641"><br>
这个框架使用了<code data-backticks="1" data-nodeid="1644">UIViewController</code>和<code data-backticks="1" data-nodeid="1646">UITableView</code>来封装列表页面。其核心是<code data-backticks="1" data-nodeid="1648">BaseTableViewController</code>。<code data-backticks="1" data-nodeid="1650">BaseTableViewController</code>继承于<code data-backticks="1" data-nodeid="1652">BaseViewController</code>，而<code data-backticks="1" data-nodeid="1654">BaseViewController</code>继承自<code data-backticks="1" data-nodeid="1656">UIViewController</code>。</p>
<p data-nodeid="1526">我们先看看<code data-backticks="1" data-nodeid="1659">BaseViewController</code>的具体实现，代码示例如下。</p>
<pre class="lang-swift" data-nodeid="1527"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-keyword">init</span>() {
      <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: <span class="hljs-literal">nil</span>, bundle: <span class="hljs-literal">nil</span>)
    }
    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don't support init view controller from a nib."</span>)
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(nibName nibNameOrNil: <span class="hljs-type">String?</span>, bundle nibBundleOrNil: <span class="hljs-type">Bundle?</span>) {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    }
    <span class="hljs-meta">@available</span>(*, unavailable, message: <span class="hljs-string">"We don't support init view controller from a nib."</span>)
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)
    }
}
</code></pre>
<p data-nodeid="1528">因为 Moments App 是使用纯代码的方式来编写 UI，所以<code data-backticks="1" data-nodeid="1662">BaseViewController</code>重写了<code data-backticks="1" data-nodeid="1664">init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)</code>和<code data-backticks="1" data-nodeid="1666">init?(coder: NSCoder)</code>两个方法，并直接抛出异常。这样做使得所有继承<code data-backticks="1" data-nodeid="1668">BaseViewController</code>的子类，都没办法通过 Storyboard 或者 Xib 文件来生成 ViewController 的实例。因为我们使用 RxSwift，<code data-backticks="1" data-nodeid="1670">BaseViewController</code>还定义了一个<code data-backticks="1" data-nodeid="1672">disposeBag</code>属性来方便管理所有 Obervable 序列的订阅。</p>
<p data-nodeid="1529"><code data-backticks="1" data-nodeid="1674">BaseTableViewController</code>继承了<code data-backticks="1" data-nodeid="1676">BaseViewController</code>，并使用<code data-backticks="1" data-nodeid="1678">UITableView</code>来封装一个通用的列表页面。我们一起看看它是怎样实现的。</p>
<p data-nodeid="1530">在 MVVM 模式里，View 依赖于 ViewModel。作为 View 的<code data-backticks="1" data-nodeid="1681">BaseTableViewController</code>依赖于 ViewModel 层的<code data-backticks="1" data-nodeid="1683">ListViewModel</code>协议，这使得<code data-backticks="1" data-nodeid="1685">BaseTableViewController</code>只依赖于接口而不是具体的类型，从而提高了程序的可扩展性。</p>
<p data-nodeid="1531">同时，<code data-backticks="1" data-nodeid="1688">BaseTableViewController</code>还定义了三个属性来显示 UI 控件：</p>
<ul data-nodeid="1532">
<li data-nodeid="1533">
<p data-nodeid="1534"><code data-backticks="1" data-nodeid="1690">tableView</code>属性用于显示一个 TableView；</p>
</li>
<li data-nodeid="1535">
<p data-nodeid="1536"><code data-backticks="1" data-nodeid="1692">activityIndicatorView</code>属性用于显示俗称小菊花的加载器；</p>
</li>
<li data-nodeid="1537">
<p data-nodeid="1538"><code data-backticks="1" data-nodeid="1694">errorLabel</code>用于显示出错信息的标签控件。</p>
</li>
</ul>
<p data-nodeid="1539">以下是属性定义的代码示例。</p>
<pre class="lang-swift" data-nodeid="1540"><code data-language="swift"><span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">ListViewModel!</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> tableView: <span class="hljs-type">UITableView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.separatorStyle = .<span class="hljs-keyword">none</span>
    $<span class="hljs-number">0</span>.rowHeight = <span class="hljs-type">UITableView</span>.automaticDimension
    $<span class="hljs-number">0</span>.estimatedRowHeight = <span class="hljs-number">100</span>
    $<span class="hljs-number">0</span>.contentInsetAdjustmentBehavior = .never
    $<span class="hljs-number">0</span>.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> activityIndicatorView: <span class="hljs-type">UIActivityIndicatorView</span> = configure(.<span class="hljs-keyword">init</span>(style: .large)) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> errorLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.isHidden = <span class="hljs-literal">true</span>
    $<span class="hljs-number">0</span>.textColor = <span class="hljs-type">UIColor</span>.designKit.primaryText
    $<span class="hljs-number">0</span>.text = <span class="hljs-type">L10n</span>.<span class="hljs-type">MomentsList</span>.errorMessage
}
</code></pre>
<p data-nodeid="1541">为了方便初始化 UIKit 的控件，我写了一个公共的<code data-backticks="1" data-nodeid="1698">configure()</code>方法，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="1542"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">configure</span>&lt;T: AnyObject&gt;<span class="hljs-params">(<span class="hljs-number">_</span> object: T, closure: <span class="hljs-params">(T)</span></span></span> -&gt; <span class="hljs-type">Void</span>) -&gt; <span class="hljs-type">T</span> {
    closure(object)
    <span class="hljs-keyword">return</span> object
}
</code></pre>
<p data-nodeid="1543">有了该方法，我们就可以把所有初始化操作都放在一个闭包（Closure）里面，方便代码的维护。</p>
<p data-nodeid="1544">接着我们看一下<code data-backticks="1" data-nodeid="1702">setupUI()</code>方法的代码实现。</p>
<pre class="lang-swift" data-nodeid="1545"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {
    view.backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
    tableViewCellsToRegister.forEach {
        tableView.register($<span class="hljs-number">0</span>.value, forCellReuseIdentifier: $<span class="hljs-number">0</span>.key)
    }
    [tableView, activityIndicatorView, errorLabel].forEach {
        view.addSubview($<span class="hljs-number">0</span>)
    }
}
</code></pre>
<p data-nodeid="1546">该方法负责设置 UI 的样式，例如设置背景颜色，注册 TableView Cell 和添加子控件。</p>
<p data-nodeid="1547">配置完 UI 的样式以后，下一步是配置自动布局的约束（Auto Layout Constraint）。当使用 UIKit 作为 View 层的时候，我推荐使用苹果公司所推荐的<strong data-nodeid="1710">自动布局</strong>来排版 UI 页面。</p>
<p data-nodeid="1548">自动布局能帮助我们支持不同分辨率和屏幕对比率的页面，而且苹果公司每年都在不断优化自动布局引擎的性能。不过，它也有一个缺点，那就是手写自动布局的约束代码会十分冗长，为此我使用一个名叫<strong data-nodeid="1718">SnapKit 的库</strong>来进行简化。下面我们就通过<code data-backticks="1" data-nodeid="1716">setupConstraints()</code>的代码，来看看 SnapKit 的威力。</p>
<pre class="lang-swift" data-nodeid="1549"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {
    tableView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.edges.equalToSuperview()
    }
    activityIndicatorView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.center.equalToSuperview()
    }
    errorLabel.snp.makeConstraints {
        $<span class="hljs-number">0</span>.center.equalToSuperview()
    }
}
</code></pre>
<p data-nodeid="1550">如上述代码所示，当使用 SnapKit 来配置自动布局的约束时，我们需要调用它的扩展方法<code data-backticks="1" data-nodeid="1720">makeConstraints</code>，然后把所有约束的配置都放到闭包里面。在这里，我是通过<code data-backticks="1" data-nodeid="1722">edges.equalToSuperview()</code>把<code data-backticks="1" data-nodeid="1724">tableView</code>延伸到它的父组件（也就是<code data-backticks="1" data-nodeid="1726">BaseTableViewController</code>的<code data-backticks="1" data-nodeid="1728">view</code>）中，然后通过<code data-backticks="1" data-nodeid="1730">center.equalToSuperview()</code>方法把<code data-backticks="1" data-nodeid="1732">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1734">errorLabel</code>都分别居中。</p>
<p data-nodeid="1551">假如不使用 SnapKit，要完成延伸<code data-backticks="1" data-nodeid="1737">tableView</code>的操作，就需要以下的代码。</p>
<pre class="lang-swift" data-nodeid="1552"><code data-language="swift"><span class="hljs-type">NSLayoutConstraint</span>.activate([
    tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
    tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
    tableView.topAnchor.constraint(equalTo: view.topAnchor),
    tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
])
</code></pre>
<p data-nodeid="1553">我们不得不分别配置每一个约束，并放进一个数组里面，然后传递给静态方法<code data-backticks="1" data-nodeid="1740">NSLayoutConstraint.activate</code>。 所以你看，使用 SnapKit 多么方便。</p>
<p data-nodeid="1554">完成了 UI 的布局以后，我们看一下数据绑定。Moments App 使用了 RxSwift 把 ViewModel 层和 View 层进行绑定，绑定的代码在<code data-backticks="1" data-nodeid="1743">setupBindings()</code>函数里，具体如下。</p>
<pre class="lang-swift" data-nodeid="1555"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupBindings</span><span class="hljs-params">()</span></span> {
    tableView.refreshControl = configure(<span class="hljs-type">UIRefreshControl</span>()) {
        <span class="hljs-keyword">let</span> refreshControl = $<span class="hljs-number">0</span>
        $<span class="hljs-number">0</span>.rx.controlEvent(.valueChanged)
            .<span class="hljs-built_in">filter</span> { refreshControl.isRefreshing }
            .bind { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>?.loadItems() }
            .disposed(by: disposeBag)
    }
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="hljs-type">SectionModel</span>&lt;<span class="hljs-type">String</span>, <span class="hljs-type">ListItemViewModel</span>&gt;&gt;(configureCell: { <span class="hljs-number">_</span>, tableView, indexPath, item <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type">String</span>(describing: type(of: item)), <span class="hljs-keyword">for</span>: indexPath)
        (cell <span class="hljs-keyword">as</span>? <span class="hljs-type">ListItemCell</span>)?.update(with: item)
        <span class="hljs-keyword">return</span> cell
    })
    viewModel.listItems
        .bind(to: tableView.rx.items(dataSource: dataSource))
        .disposed(by: disposeBag)
    viewModel.hasError
        .<span class="hljs-built_in">map</span> { !$<span class="hljs-number">0</span> }
        .bind(to: errorLabel.rx.isHidden)
        .disposed(by: disposeBag)
}
</code></pre>
<p data-nodeid="1556">这个函数由三部分组成，第一部分是通过 RxSwift 和 RxCocoa ，把<code data-backticks="1" data-nodeid="1746">UIRefreshControl</code>控件里的<code data-backticks="1" data-nodeid="1748">isRefreshing</code>事件和<code data-backticks="1" data-nodeid="1750">loadItems()</code>函数绑定起来。当用户下拉刷新控件的时候会调用<code data-backticks="1" data-nodeid="1752">loadItems()</code>函数来刷新列表的数据。</p>
<p data-nodeid="1557">第二部分是把 TableView Cell 控件与 ViewModel 的<code data-backticks="1" data-nodeid="1755">listItems</code>Subject 属性绑定起来，当<code data-backticks="1" data-nodeid="1757">listItems</code>发出新的事件时，我们会调用<code data-backticks="1" data-nodeid="1759">ListItemCell</code>的<code data-backticks="1" data-nodeid="1761">update(with viewModel: ListItemViewModel)</code>方法来更新 UI。<strong data-nodeid="1766">经过了这一绑定，UI 就能随着 ViewModel 的数据变化而自动更新。</strong></p>
<p data-nodeid="1558">第三部分与第二部分类似，都是把 ViewModel 与 View 层的控件进行绑定。在这里，我们把 ViewModel 的<code data-backticks="1" data-nodeid="1768">hasError</code>Subject 属性绑定到<code data-backticks="1" data-nodeid="1770">errorLabel.rx.isHidden</code>属性来控制<code data-backticks="1" data-nodeid="1772">errorLabel</code>是否可见。</p>
<p data-nodeid="1559">你可能注意到在<code data-backticks="1" data-nodeid="1775">errorLabel</code>后面有<code data-backticks="1" data-nodeid="1777">.rx</code>属性，这是 RxCocoa 为<code data-backticks="1" data-nodeid="1779">UILabel</code>控件所提供的一个扩展，它为<code data-backticks="1" data-nodeid="1781">isHidden</code>属性提供了响应式编程的功能。有了这一功能，它就可以与 ViewModel 的 Subject 属性进行绑定，从而实现自动更新。</p>
<p data-nodeid="1560">数据绑定以后，我们一起看看<code data-backticks="1" data-nodeid="1784">loadItems()</code>函数的实现。</p>
<pre class="lang-swift" data-nodeid="1561"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadItems</span><span class="hljs-params">()</span></span> {
    viewModel.hasError.onNext(<span class="hljs-literal">false</span>)
    viewModel.loadItems()
        .observeOn(<span class="hljs-type">MainScheduler</span>.instance)
        .<span class="hljs-keyword">do</span>(onDispose: { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>?.activityIndicatorView.rx.isAnimating.onNext(<span class="hljs-literal">false</span>)
            <span class="hljs-keyword">self</span>?.tableView.refreshControl?.endRefreshing()
        })
        .<span class="hljs-built_in">map</span> { <span class="hljs-literal">false</span> }
        .startWith(<span class="hljs-literal">true</span>)
        .distinctUntilChanged()
        .bind(to: activityIndicatorView.rx.isAnimating)
        .disposed(by: disposeBag)
}
</code></pre>
<p data-nodeid="1562"><code data-backticks="1" data-nodeid="1786">loadItems()</code>方法用于加载数据。当我们第一次进入朋友圈页面的时候，或者用户下拉刷新控件的时候，就会调用该方法来重新加载数据。</p>
<p data-nodeid="1563">该方法主要做两项工作，第一项是调用<code data-backticks="1" data-nodeid="1789">viewModel.hasError.onNext(false)</code>来更新 ViewModel 的<code data-backticks="1" data-nodeid="1791">hasError</code>属性， 它能让 UI 上的错误标签信息消失。</p>
<p data-nodeid="1564">从代码中你可以看到，尽管我们想更新 UI 层的<code data-backticks="1" data-nodeid="1794">errorLabel</code>控件，却没有直接通过<code data-backticks="1" data-nodeid="1796">errorLabel.isHidden = true</code>的方式来更新，而是通过 ViewModel 的<code data-backticks="1" data-nodeid="1798">hasError</code>属性来完成。这是因为我要保证 View/UI 层都是由 ViewModel 驱动，通过单方向的数据流来减少 Bug ，从而提高代码的可维护性。</p>
<p data-nodeid="1565"><code data-backticks="1" data-nodeid="1800">loadItems()</code>方法的第二项工作，是让 ViewModel 去加载数据并绑定到<code data-backticks="1" data-nodeid="1802">activityIndicatorView</code>控件的<code data-backticks="1" data-nodeid="1804">isAnimating</code>属性上。因为我们需要在主排程器上执行 UI 任务，因此调用了<code data-backticks="1" data-nodeid="1806">.observeOn(MainScheduler.instance)</code>，把所有任务都安排到主排程器上。</p>
<p data-nodeid="1566">当 ViewModel 的<code data-backticks="1" data-nodeid="1809">loadItems()</code>方法开始执行的时候，先通过<code data-backticks="1" data-nodeid="1811">.startWith(true)</code>来让<code data-backticks="1" data-nodeid="1813">activityIndicatorView</code>启动动画效果。当 ViewModel 的<code data-backticks="1" data-nodeid="1815">loadItems()</code>方法返回数据时，把结果数据通过<code data-backticks="1" data-nodeid="1817">.map { false }</code>方法来返回<code data-backticks="1" data-nodeid="1819">false</code>，从而使得<code data-backticks="1" data-nodeid="1821">activityIndicatorView</code>停止动画效果。</p>
<p data-nodeid="1567">假如用户在调用 ViewModel 的<code data-backticks="1" data-nodeid="1824">loadItems()</code>方法的过程中，退出列表页面，我们通过<code data-backticks="1" data-nodeid="1826">.do(onDispose:{})</code>方法来停止<code data-backticks="1" data-nodeid="1828">activityIndicatorView</code>和<code data-backticks="1" data-nodeid="1830">refreshControl</code>两个控件的刷新动画。</p>
<p data-nodeid="1568">到此为止，我们已经知道<code data-backticks="1" data-nodeid="1833">BaseTableViewController</code>是如何通过 TableView 来实现列表 UI 的了。</p>
<p data-nodeid="1569">为了显现不同的 TableView Cell，接下来我们了解下通用的 Cell 是如何实现的。</p>
<p data-nodeid="1570">这部分由四个类型所组成，分别是<code data-backticks="1" data-nodeid="1837">ListItemCell</code>协议及其子结构体<code data-backticks="1" data-nodeid="1839">BaseTableViewCell</code>，以及<code data-backticks="1" data-nodeid="1841">ListItemView</code>协议及其子结构体<code data-backticks="1" data-nodeid="1843">BaseListItemView</code>。</p>
<p data-nodeid="1571"><code data-backticks="1" data-nodeid="1845">ListItemCell</code>协议的定义非常简单，如下所示。</p>
<pre class="lang-swift" data-nodeid="1572"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemCell</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>
}
</code></pre>
<p data-nodeid="1573">该协议只包含了一个<code data-backticks="1" data-nodeid="1848">update(with viewModel: ListItemViewModel)</code>方法来让其子类型根据<code data-backticks="1" data-nodeid="1850">ListItemViewModel</code>的数据进行更新。</p>
<p data-nodeid="1574">其子类型<code data-backticks="1" data-nodeid="1853">BaseTableViewCell</code>的具体代码如下：</p>
<pre class="lang-swift" data-nodeid="1575"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTableViewCell</span>&lt;<span class="hljs-title">V</span>: <span class="hljs-title">BaseListItemView</span>&gt;: <span class="hljs-title">UITableViewCell</span>, <span class="hljs-title">ListItemCell</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> view: <span class="hljs-type">V</span>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(style: <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">CellStyle</span>, reuseIdentifier: <span class="hljs-type">String?</span>) {
        view = .<span class="hljs-keyword">init</span>()
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(style: style, reuseIdentifier: reuseIdentifier)
        selectionStyle = .<span class="hljs-keyword">none</span>
        contentView.addSubview(view)
        view.snp.makeConstraints {
            $<span class="hljs-number">0</span>.edges.equalToSuperview()
        }
    }
    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init</span>?(coder: <span class="hljs-type">NSCoder</span>) {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorInitCoderNotImplemented)
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
        view.update(with: viewModel)
    }
}
</code></pre>
<p data-nodeid="1576"><code data-backticks="1" data-nodeid="1855">BaseTableViewCell</code>是一个<code data-backticks="1" data-nodeid="1857">UITableViewCell</code>的子类，并遵循了<code data-backticks="1" data-nodeid="1859">ListItemCell</code>协议，因此它需要实现<code data-backticks="1" data-nodeid="1861">update(with viewModel: ListItemViewModel)</code>方法。在该方法里面，它直接调用<code data-backticks="1" data-nodeid="1863">view</code>属性的<code data-backticks="1" data-nodeid="1865">update(with viewModel: ListItemViewModel)</code>来更新<code data-backticks="1" data-nodeid="1867">BaseListItemView</code>组件的 UI。</p>
<p data-nodeid="1577">那为什么我们不把所有 UI 子控件都直接写在 Cell 里，而使用一个额外的<code data-backticks="1" data-nodeid="1870">BaseListItemView</code>呢？因为这样做可以把<code data-backticks="1" data-nodeid="1872">BaseListItemView</code>复用到<code data-backticks="1" data-nodeid="1874">UICollectionView</code>等其他容器中。</p>
<p data-nodeid="1578">接下来我们一起看看<code data-backticks="1" data-nodeid="1877">BaseListItemView</code>及其所遵循的<code data-backticks="1" data-nodeid="1879">ListItemView</code>协议的代码。</p>
<pre class="lang-swift" data-nodeid="1579"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">ListItemView</span>: <span class="hljs-title">class</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span>
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseListItemView</span>: <span class="hljs-title">UIView</span>, <span class="hljs-title">ListItemView</span> </span>{
    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> disposeBag: <span class="hljs-type">DisposeBag</span> = .<span class="hljs-keyword">init</span>()
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
        <span class="hljs-built_in">fatalError</span>(<span class="hljs-type">L10n</span>.<span class="hljs-type">Development</span>.fatalErrorSubclassToImplement)
    }
}
</code></pre>
<p data-nodeid="1580"><code data-backticks="1" data-nodeid="1881">ListItemView</code>协议只定义了<code data-backticks="1" data-nodeid="1883">update(with viewModel: ListItemViewModel)</code>接口来通过 ViewModel 更新 UI。因为每个 UI 组件的布局与呈现都可能不一样，因此，<code data-backticks="1" data-nodeid="1885">BaseListItemView</code>在实现<code data-backticks="1" data-nodeid="1887">update(with viewModel: ListItemViewModel)</code>方法时，直接抛出了异常，这样能迫使其子类重写该方法。</p>
<p data-nodeid="1581">上面就是通用列表 UI 模块的架构与实现，有了这一个框架，我们就能快速实现不同的列表页面，下面以朋友圈功能作为例子来看看如何实现一个朋友圈时间轴页面。</p>
<h3 data-nodeid="1582">朋友圈时间轴页面的实现</h3>
<p data-nodeid="1583">首先我们一起看看朋友圈时间轴页面的架构图。</p>
<p data-nodeid="1584"><img src="https://s0.lgstatic.com/i/image6/M00/3C/B1/CioPOWCL09mAbIiFAAIX3-W1eco290.png" alt="图片2.png" data-nodeid="1894"><br>
<code data-backticks="1" data-nodeid="1896">MomentsTimelineViewController</code>用于显示朋友圈时间轴页面，其具体代码如下。</p>
<pre class="lang-swift" data-nodeid="1585"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewController</span>: <span class="hljs-title">BaseTableViewController</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>() {
        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>()
        viewModel = <span class="hljs-type">MomentsTimelineViewModel</span>(userID: <span class="hljs-type">UserDataStore</span>.current.userID)
    }
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">viewDidAppear</span><span class="hljs-params">(<span class="hljs-number">_</span> animated: Bool)</span></span> {
        <span class="hljs-keyword">super</span>.viewDidAppear(animated)
        viewModel.trackScreenviews()
    }
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> tableViewCellsToRegister: [<span class="hljs-type">String</span> : <span class="hljs-type">UITableViewCell</span>.<span class="hljs-type">Type</span>] {
        <span class="hljs-keyword">return</span> [
            <span class="hljs-type">UserProfileListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">UserProfileListItemView</span>&gt;.<span class="hljs-keyword">self</span>,
            <span class="hljs-type">MomentListItemViewModel</span>.reuseIdentifier: <span class="hljs-type">BaseTableViewCell</span>&lt;<span class="hljs-type">MomentListItemView</span>&gt;.<span class="hljs-keyword">self</span>
        ]
    }
}
</code></pre>
<p data-nodeid="1586">因为<code data-backticks="1" data-nodeid="1899">BaseViewController</code>已经封装好绝大部分的 UI 处理逻辑，作为子类，<code data-backticks="1" data-nodeid="1901">MomentsTimelineViewController</code>的实现变得非常简单，只需三部分。</p>
<p data-nodeid="3060" class="">首先是初始化<code data-backticks="1" data-nodeid="3062">viewModel</code>。因为<code data-backticks="1" data-nodeid="3064">BaseViewController</code>通过<code data-backticks="1" data-nodeid="3066">var viewModel: ListViewModel!</code>来定义<code data-backticks="1" data-nodeid="3068">viewModel</code>属性，作为子类的<code data-backticks="1" data-nodeid="3070">MomentsTimelineViewController</code>也必须初始化<code data-backticks="1" data-nodeid="3072">viewModel</code>属性，否则程序会崩溃。具体来说，我们只需创建一个<code data-backticks="1" data-nodeid="3074">MomentsTimelineViewModel</code>对象来完成初始化即可。它的实现我在上一讲已经介绍过了，你可以再留意下。</p>



<p data-nodeid="1589">然后，我在<code data-backticks="1" data-nodeid="1919">func viewDidAppear(_ animated: Bool)</code>方法里面调用<code data-backticks="1" data-nodeid="1921">viewModel.trackScreenviews()</code>来让 ViewModel 发送用户行为数据。</p>
<p data-nodeid="1590">为了帮<code data-backticks="1" data-nodeid="1924">BaseViewController</code>提供需要注册的 TableView Cell ，最后我重写了<code data-backticks="1" data-nodeid="1926">tableViewCellsToRegister</code>属性。该属性存放<code data-backticks="1" data-nodeid="1928">BaseTableViewCell</code>的实例。<code data-backticks="1" data-nodeid="1930">BaseTableViewCell</code>使用范型（generic）来存放<code data-backticks="1" data-nodeid="1932">BaseListItemView</code>的子类，这些子类包括<code data-backticks="1" data-nodeid="1934">UserProfileListItemView</code>和<code data-backticks="1" data-nodeid="1936">MomentListItemView</code>。</p>
<p data-nodeid="1591">你可以从下图中看到它们所呈现的 UI 组件。</p>
<p data-nodeid="1592"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3JKAWyl6AAalmHPesaU548.png" alt="图片4.png" data-nodeid="1941"></p>
<p data-nodeid="1593"><code data-backticks="1" data-nodeid="1942">MomentsTimelineViewController</code>我们已介绍完毕了，下面咱们以<code data-backticks="1" data-nodeid="1944">UserProfileListItemView</code>为例，看一下开发子控件的步骤与实现。</p>
<p data-nodeid="1594"><code data-backticks="1" data-nodeid="1946">UserProfileListItemView</code>用于显示用户自己的资料，例如用户名字，头像和背景图。因为有了通用和统一的 UI 开发框架，每次开发 UI 页面的步骤都是一致的，具体我分为以下几步完成：</p>
<ol data-nodeid="1595">
<li data-nodeid="1596">
<p data-nodeid="1597">初始化 UI 控件的属性；</p>
</li>
<li data-nodeid="1598">
<p data-nodeid="1599">配置 UI 控件的样式；</p>
</li>
<li data-nodeid="1600">
<p data-nodeid="1601">设置自动布局的约束；</p>
</li>
<li data-nodeid="1602">
<p data-nodeid="1603">重写<code data-backticks="1" data-nodeid="1952">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。</p>
</li>
</ol>
<p data-nodeid="1604">先看一下初始化 UI 控件属性的代码。</p>
<pre class="lang-swift" data-nodeid="1605"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> backgroundImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill
    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> avatarImageView: <span class="hljs-type">UIImageView</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.asAvatar(cornerRadius: <span class="hljs-number">8</span>)
    $<span class="hljs-number">0</span>.contentMode = .scaleAspectFill
    $<span class="hljs-number">0</span>.accessibilityIgnoresInvertColors = <span class="hljs-literal">true</span>
}
<span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> nameLabel: <span class="hljs-type">UILabel</span> = configure(.<span class="hljs-keyword">init</span>()) {
    $<span class="hljs-number">0</span>.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal">false</span>
    $<span class="hljs-number">0</span>.font = <span class="hljs-type">UIFont</span>.designKit.title3
    $<span class="hljs-number">0</span>.textColor = .white
    $<span class="hljs-number">0</span>.numberOfLines = <span class="hljs-number">1</span>
}
</code></pre>
<p data-nodeid="1606">我们分别调用<code data-backticks="1" data-nodeid="1956">configure()</code>函数来初始化三个 UI 控件的属性，<code data-backticks="1" data-nodeid="1958">backgroundImageView</code>用于显示背景图，<code data-backticks="1" data-nodeid="1960">avatarImageView</code>用于显示用户头像，而<code data-backticks="1" data-nodeid="1962">nameLabel</code>用于显示用户名字。</p>
<p data-nodeid="1607">你可以根据下图，看到它们分别使用在哪里。</p>
<p data-nodeid="1608"><img src="https://s0.lgstatic.com/i/image6/M01/3C/B3/CioPOWCL3LGAfuNrABZKzpfsijg925.png" alt="图片5.png" data-nodeid="1967"></p>
<p data-nodeid="1609">接着来看在第二步中如何配置 UI 控件的样式，我用<code data-backticks="1" data-nodeid="1969">setupUI()</code>方法来实现。</p>
<pre class="lang-swift" data-nodeid="1610"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupUI</span><span class="hljs-params">()</span></span> {
    backgroundColor = <span class="hljs-type">UIColor</span>.designKit.background
    [backgroundImageView, avatarImageView, nameLabel].forEach {
        addSubview($<span class="hljs-number">0</span>)
    }
}
</code></pre>
<p data-nodeid="1611">在这里，我使用了 DesignKit 来设置了背景颜色，并把子控件添加到当前 View 里面。</p>
<p data-nodeid="1612">然后看第三步如何设置自动布局的约束，其实现代码如下。</p>
<pre class="lang-swift" data-nodeid="1613"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setupConstraints</span><span class="hljs-params">()</span></span> {
    backgroundImageView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.top.leading.trailing.equalToSuperview()
        $<span class="hljs-number">0</span>.bottom.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.height.equalTo(backgroundImageView.snp.width).multipliedBy(<span class="hljs-number">0.8</span>).priority(<span class="hljs-number">999</span>)
    }
    avatarImageView.snp.makeConstraints {
        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalToSuperview().offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.bottom.equalToSuperview()
        $<span class="hljs-number">0</span>.height.equalTo(<span class="hljs-number">80</span>)
        $<span class="hljs-number">0</span>.width.equalTo(<span class="hljs-number">80</span>)
    }
    nameLabel.snp.makeConstraints {
        $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.<span class="hljs-keyword">left</span>).offset(-<span class="hljs-type">Spacing</span>.medium)
        $<span class="hljs-number">0</span>.centerY.equalTo(<span class="hljs-keyword">self</span>.avatarImageView.snp.centerY)
    }
}
</code></pre>
<p data-nodeid="1614">其中<code data-backticks="1" data-nodeid="1974">backgroundImageView</code>的顶部和两边都延展到父控件，因为底部需要留白来显示用户头像，因此添加了<code data-backticks="1" data-nodeid="1976">medium</code>作为间距。背景图片的长宽比是 5:4。</p>
<p data-nodeid="1615"><code data-backticks="1" data-nodeid="1978">avatarImageView</code>位于父控件的右下角，并设定长度和宽度都为 80pt。<code data-backticks="1" data-nodeid="1980">nameLabel</code>位于<code data-backticks="1" data-nodeid="1982">avatarImageView</code>的左边，并与之水平。这样我们就使用 SnapKit 完成用户资料 UI 的布局了。<br>
最后一部分是调用<code data-backticks="1" data-nodeid="1986">update()</code>方法来更新 UI，其代码如下。</p>
<pre class="lang-swift" data-nodeid="1616"><code data-language="swift"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">(with viewModel: ListItemViewModel)</span></span> {
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> viewModel = viewModel <span class="hljs-keyword">as</span>? <span class="hljs-type">UserProfileListItemViewModel</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    backgroundImageView.kf.setImage(with: viewModel.backgroundImageURL)
    avatarImageView.kf.setImage(with: viewModel.avatarURL)
    nameLabel.text = viewModel.name
}
</code></pre>
<p data-nodeid="4088">因为<code data-backticks="1" data-nodeid="4091">UserProfileListItemViewModel</code>已经为<code data-backticks="1" data-nodeid="4093">UserProfileListItemView</code>准备好呈现所需的所有数据，因此，只要简单的赋值就可以更新 UI 了。</p>
<p data-nodeid="4089"><code data-backticks="1" data-nodeid="4095">MomentListItemView</code>的代码结构和<code data-backticks="1" data-nodeid="4097">UserProfileListItemView</code>基本一样，你可以到拉勾教育的代码仓库进行查看。</p>

<h3 data-nodeid="1618">总结</h3>
<p data-nodeid="1619">在这一讲中，我为你介绍了如何架构和实现一个通用的列表 UI 模块，有了这个模块，我们按照以下这几个步骤就可以完成 UI 的开发了。</p>
<ol data-nodeid="1620">
<li data-nodeid="1621">
<p data-nodeid="1622">初始化 UI 控件的属性，把 UI 分解成不同的子控件，然后通过<code data-backticks="1" data-nodeid="2001">configure()</code>来初始化各个控件属性。</p>
</li>
<li data-nodeid="1623">
<p data-nodeid="1624">配置 UI 控件的样式，如配置背景颜色等，并把各个子控件添加到父控件里面。</p>
</li>
<li data-nodeid="1625">
<p data-nodeid="1626">设置自动布局的约束，推荐使用 SnapKit 来简化配置约束的工作。</p>
</li>
<li data-nodeid="1627">
<p data-nodeid="1628">重写<code data-backticks="1" data-nodeid="2006">update(with viewModel: ListItemViewModel)</code>方法，根据 ViewModel 的数据来更新 UI。如果有数据绑定，那么使用 RxSwift 和 RxCocoa 把 ViewModel 的 Subject 属性绑定到 UI 控件上。如果不需要数据绑定，只需把 ViewModel 准备好的值赋给 UI 控件即可。</p>
</li>
</ol>
<p data-nodeid="1629"><strong data-nodeid="2011">思考题</strong></p>
<blockquote data-nodeid="1630">
<p data-nodeid="1631">请问你们使用苹果提供的自动布局吗？如果是，是使用原生语法还是类似 SnapKit 那种库呢？或者说使用 Texture 等其他非苹果的框架进行布局？能分享你的使用经验吗？</p>
</blockquote>
<p data-nodeid="1632">可以把你的思考写到留言区哦，下一讲，我会介绍如何使用现有架构添加点赞功能。</p>
<p data-nodeid="1633"><strong data-nodeid="2017">源码地址</strong></p>
<blockquote data-nodeid="1634">
<p data-nodeid="1635" class="">通用列表 UI 的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2022">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Views</a><br>
朋友圈时间轴页面实现的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2028">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Views</a></p>
</blockquote>

---

### 精选评论

##### **鑫：
> 您好。我有个疑问🤔️。func setupBindings() { tableView.refreshControl = configure(UIRefreshControl()) { let refreshControl = $0 $0.rx.controlEvent(.valueChanged) .filter { refreshControl.isRefreshing } .bind { [weak self] _ in self?.loadItems() } .disposed(by: disposeBag) }(configureCell: { _, tableView, indexPath, item in let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: type(of: item)), for: indexPath) (cell as? ListItemCell)?.update(with: item) return cell }) viewModel.listItems .bind(to: tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag) viewModel.hasError .map { !$0 } .bind(to: errorLabel.rx.isHidden) .disposed(by: disposeBag)}这段代码是放在BaseTableViewController。那如果cell中存在某个button。那这个button的响应事件应该如何写？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; Cell 里面存在 button 的例子可以看看 《第 22 讲| 功能实战：如何使用现有架构添加点赞功能？》里面的点缀按钮。

##### **一：
> 提一些可以改进的吧：1. SnapKit 会自动处理translatesAutoresizingMaskIntoConstraints，不需要单独设置；2. `update(with viewModel: ListItemViewModel)` 可以使用associatedtype 来避免子类 cast。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 谢谢你的建议，我在 configure 里面使用了 translatesAutoresizingMaskIntoConstraints 是因为在这个时候处理的是 View 的初始化过程，我不想让这个过程和配置约束的过程进行耦合，因为 View 初始化的时候并不知道后面会使用 SanpKit 来配置约束。我在写代码的时候偏向于所有模块都解耦合，不相互依赖。但是如果整个项目都规定好使用 SnapKit，那么这一句确实可以省掉的。第二个建议很实用呀，我有空再试试，如果你已经有实例代码，麻烦提交个 PR 让我看看，谢谢啦。

##### *治：
> 我们现在使用Yoga，感觉性能上会比snapkit好那么点

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 非常感谢你的分享~

##### **泽：
> 老师， 在swift中，使用struct和class的场景是什么

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 这个问题有点大呀，我建议你多看看不同的文章来深入了解。在这里我只能给一些简单的建议，例如 Struct 非常时候用来存放简单类型的数据，而且线程安全的，不需要再被继承的数据。假如你一时候无法选择，那可以选选择 struct，有需要的时候再改成 class，例如你不想使用 mutating。

##### **0520：
> 为什么TableView每一项cell不用rxswift绑定呢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 有的呀，封装在 BaseTableViewController 的 setupBindings() 方法

