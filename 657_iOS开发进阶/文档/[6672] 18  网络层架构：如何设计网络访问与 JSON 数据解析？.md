<p data-nodeid="1618" class="">为了存取服务器上的数据，并与其他用户进行通信，几乎所有的 iOS App 都会访问后台 API 。目前流行的后台 API 设计有几种方案： RESTful、gRPC、GraphQL 和 WebSocket。其中，gRPC 使用 Protobuf 进行数据传输， GraphQL 和 RESTful 往往使用 JSON 进行传输。</p>
<p data-nodeid="1619">为了把访问后台 API 的网络传输细节给屏蔽掉，并为上层模块提供统一的访问接口，我们在架构 App 的时候，往往会把网络访问封装成一个独立的 Networking 模块。像我们的 Moments App 也不例外，它的这个模块负责访问 BFF，同时把返回的 JSON 数据进行解码。所以，这一讲，我主要介绍下 Networking 模块的架构设计与实现，以及如何使用 Swift 的 Codable 来解码返回的 JSON 数据。</p>
<h3 data-nodeid="1620">Networking 模块架构</h3>
<p data-nodeid="3227">下图是朋友圈功能 Networking 模块的具体架构。</p>
<p data-nodeid="3228" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3o2AYfKOAAONWHcpJpI148.png" alt="图片2.png" data-nodeid="3232"></p>


<p data-nodeid="1623" class="">从上面的图可以看到，作为 Networking 模块的使用者，Repository 模块位于 Networking 模块的上层。在朋友圈功能里面， Repository 模块负责统一管理所有朋友圈的数据，由<code data-backticks="1" data-nodeid="1720">MomentsRepo</code>和<code data-backticks="1" data-nodeid="1722">MomentsRepoType</code>所组成。</p>
<p data-nodeid="1624" class="">其中<code data-backticks="1" data-nodeid="1725">MomentsRepoType</code>是用于定义接口的协议，实现的逻辑都在遵循了该协议的<code data-backticks="1" data-nodeid="1727">MomentsRepo</code>结构体里面。 当<code data-backticks="1" data-nodeid="1729">MomentsRepo</code>需要访问网络数据时，就需要使用到 Networking 模块的组件。</p>
<p data-nodeid="1625">在朋友圈功能里面，<code data-backticks="1" data-nodeid="1732">MomentsRepo</code>使用了<code data-backticks="1" data-nodeid="1734">GetMomentsByUserIDSessionType</code>来获取朋友圈信息，并使用了<code data-backticks="1" data-nodeid="1736">UpdateMomentLikeSessionType</code>来更新点赞信息。</p>
<p data-nodeid="1626"><code data-backticks="1" data-nodeid="1738">GetMomentsByUserIDSessionType</code>和<code data-backticks="1" data-nodeid="1740">UpdateMomentLikeSessionType</code>是 Networking 模块里的两个协议， 它们的实现类型分别是<code data-backticks="1" data-nodeid="1742">GetMomentsByUserIDSession</code>和<code data-backticks="1" data-nodeid="1744">UpdateMomentLikeSession</code>结构体。其中，<code data-backticks="1" data-nodeid="1746">GetMomentsByUserIDSession</code>通过访问 BFF 来读取朋友圈信息，而<code data-backticks="1" data-nodeid="1748">UpdateMomentLikeSession</code>通过 BFF 来更新点赞信息。当 BFF 返回时，它们都会使用<code data-backticks="1" data-nodeid="1750">JSONDecoder</code>来把返回的 JSON 数据解码成名为<code data-backticks="1" data-nodeid="1752">MomentsDetails</code>的 Model 数据。</p>
<p data-nodeid="1627">那为什么<code data-backticks="1" data-nodeid="1755">MomentsRepo</code>依赖<code data-backticks="1" data-nodeid="1757">GetMomentsByUserIDSessionType</code>协议而不是<code data-backticks="1" data-nodeid="1759">GetMomentsByUserIDSession</code>结构体？因为这样能使<code data-backticks="1" data-nodeid="1761">MomentsRepo</code>依赖于抽象的接口，而不是具体实现，在 Swift 中，这种模式叫作面对协议编程（Protocol Oriented Programming）。使用了这种模式以后，我们可以很灵活地替换具体的实现类型，提高架构的可扩展性和灵活性。</p>
<p data-nodeid="5381">目前，我们把访问 GraphQL 的技术细节封装在<code data-backticks="1" data-nodeid="5384">GetMomentsByUserIDSession</code>里面。假如以后需要把后台改成 gRPC API，在 Moments App 中可以实现另一个结构体来遵循<code data-backticks="1" data-nodeid="5386">GetMomentsByUserIDSessionType</code>协议，比如命名为<code data-backticks="1" data-nodeid="5388">GetMomentsByUserIDSessionGRPC</code>，然后把所有访问的 gRPC 的操作都封装在里面（如下图所示），这样我们在不改变<code data-backticks="1" data-nodeid="5390">MomentsRepo</code>的情况下就支持了新的网络 API。</p>
<p data-nodeid="5382" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3pmAR0JMAAGYfVaC1qI931.png" alt="图片1.png" data-nodeid="5394"></p>


<h3 data-nodeid="1630">Networking 模块实现</h3>
<p data-nodeid="1631">有了架构设计以后我们一起看看 Networking 模块的实现。首先，我会先介绍下底层 HTTP 网络通信模块，然后以 Moments App 朋友圈信息的网络请求为例，为你介绍下怎样开发一个网络请求模块，以及解码 JSON 返回数据。</p>
<h4 data-nodeid="1632">底层 HTTP 网络通信模块</h4>
<p data-nodeid="1633">为了方便访问支持 RESTFul 和 GraphQL 的 API， 在 Moments App 中，我们开发了一个底层 HTTP 网络通信模块，该模块把所有 HTTP 请求封装起来，核心是<code data-backticks="1" data-nodeid="1779">APISession</code>协议。下面是它的定义。</p>
<pre class="lang-swift" data-nodeid="1634"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">APISession</span> </span>{
   <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">ReponseType</span>: <span class="hljs-type">Codable</span>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, parameters: Parameters?, headers: HTTPHeaders)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt;
}
</code></pre>
<p data-nodeid="1635"><code data-backticks="1" data-nodeid="1781">APISession</code>定义了<code data-backticks="1" data-nodeid="1783">post(_ path: String, parameters: Parameters?, headers: HTTPHeaders) -&gt; Observable&lt;ReponseType&gt;</code>方法来发起 HTTP POST 请求，然后返回<code data-backticks="1" data-nodeid="1785">Observable&lt;ReponseType&gt;</code>。有了 Observable 序列，我们就能把网络返回数据引进到以 RxSwift 所连接的 MVVM 框架中。</p>
<p data-nodeid="1636">你可能问，为什么<code data-backticks="1" data-nodeid="1788">Observable</code>存放的是<code data-backticks="1" data-nodeid="1790">ReponseType</code>类型呢？由于<code data-backticks="1" data-nodeid="1792">APISession</code>并不知道每一个网络请求返回数据的具体类型，因此使用<code data-backticks="1" data-nodeid="1794">associatedtype</code>来定义<code data-backticks="1" data-nodeid="1796">ReponseType</code>，以迫使所有遵循它的实现类型都必须指定<code data-backticks="1" data-nodeid="1798">ReponseType</code>的具体数据类型。</p>
<p data-nodeid="1637">例如在<code data-backticks="1" data-nodeid="1801">GetMomentsByUserIDSession</code>里面的<code data-backticks="1" data-nodeid="1803">Session</code>结构体，我们使用<code data-backticks="1" data-nodeid="1805">typealias</code>来指定<code data-backticks="1" data-nodeid="1807">ReponseType</code>的具体类型为<code data-backticks="1" data-nodeid="1809">Response</code>，其代码示例如下。</p>
<pre class="lang-swift" data-nodeid="1638"><code data-language="swift"><span class="hljs-keyword">typealias</span> <span class="hljs-type">ReponseType</span> = <span class="hljs-type">Response</span>
</code></pre>
<p data-nodeid="1639">为了方便共享 HTTP 网络请求的功能，我们为<code data-backticks="1" data-nodeid="1812">APISession</code>定义了协议扩展，并给<code data-backticks="1" data-nodeid="1814">post(_ path: String, parameters: Parameters?, headers: HTTPHeaders) -&gt; Observable&lt;ReponseType&gt;</code>方法提供默认的实现。具体代码示例如下。</p>
<pre class="lang-swift" data-nodeid="1640"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">APISession</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">post</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, headers: HTTPHeaders = [:], parameters: Parameters? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt; {
       <span class="hljs-keyword">return</span> request(path, method: .post, headers: headers, parameters: parameters, encoding: <span class="hljs-type">JSONEncoding</span>.<span class="hljs-keyword">default</span>)
   }
}
</code></pre>
<p data-nodeid="1641">为了提高代码的可重用性，我们定义了名叫<code data-backticks="1" data-nodeid="1817">request(_ path: String, method: HTTPMethod, headers: HTTPHeaders, parameters: Parameters?, encoding: ParameterEncoding) -&gt; Observable&lt;ReponseType&gt;</code>的私有方法，来支持 HTTP 的其他 Method，代码示例如下。</p>
<pre class="lang-swift" data-nodeid="1642"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-number">_</span> path: String, method: HTTPMethod, headers: HTTPHeaders, parameters: Parameters?, encoding: ParameterEncoding)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">ReponseType</span>&gt; {
       <span class="hljs-keyword">let</span> url = baseUrl.appendingPathComponent(path)
       <span class="hljs-keyword">let</span> allHeaders = <span class="hljs-type">HTTPHeaders</span>(defaultHeaders.dictionary.merging(headers.dictionary) { $<span class="hljs-number">1</span> })
       <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.create { observer -&gt; <span class="hljs-type">Disposable</span> <span class="hljs-keyword">in</span>
           <span class="hljs-keyword">let</span> queue = <span class="hljs-type">DispatchQueue</span>(label: <span class="hljs-string">"moments.app.api"</span>, qos: .background, attributes: .concurrent)
           <span class="hljs-keyword">let</span> request = <span class="hljs-type">AF</span>.request(url, method: method, parameters: parameters, encoding: encoding, headers: allHeaders, interceptor: <span class="hljs-literal">nil</span>, requestModifier: <span class="hljs-literal">nil</span>)
               .validate()
               .responseJSON(queue: queue) { response <span class="hljs-keyword">in</span>
                   <span class="hljs-comment">// 处理返回的 JSON 数据</span>
               }
           <span class="hljs-keyword">return</span> <span class="hljs-type">Disposables</span>.create {
               request.cancel()
           }
       }
   }
</code></pre>
<p data-nodeid="1643">有了<code data-backticks="1" data-nodeid="1820">request()</code>方法，我们就可以支持不同的 HTTP Method 了。如果需要支持 HTTP GET 请求的时候，只需把<code data-backticks="1" data-nodeid="1822">HTTPMethod.get</code>传递给该方法就可以了。</p>
<p data-nodeid="1644"><code data-backticks="1" data-nodeid="1824">request()</code>方法的核心逻辑是怎么样的呢？在该方法里面，我们首先使用<code data-backticks="1" data-nodeid="1826">Observable.create()</code>方法来创建一个 Observable 序列并返回给调用者，然后在<code data-backticks="1" data-nodeid="1828">create()</code>方法的封包里使用 Alamofire 的<code data-backticks="1" data-nodeid="1830">request()</code>方法发起网络请求。为了不阻挡 UI 的响应，我们把该请求安排到后台队列中执行。当我们得到返回的 JSON 以后，会使用下面的代码进行处理。</p>
<pre class="lang-swift" data-nodeid="1645"><code data-language="swift"><span class="hljs-keyword">switch</span> response.result {
<span class="hljs-keyword">case</span> .success:
&nbsp; &nbsp; <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> data = response.data <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-comment">// if no error provided by Alamofire return .noData error instead.</span>
&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(response.error ?? <span class="hljs-type">APISessionError</span>.noData)
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span>
&nbsp; &nbsp; }
&nbsp; &nbsp; <span class="hljs-keyword">do</span> {
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">ReponseType</span>.<span class="hljs-keyword">self</span>, from: data)
&nbsp; &nbsp; &nbsp; &nbsp; observer.onNext(model)
&nbsp; &nbsp; &nbsp; &nbsp; observer.onCompleted()
&nbsp; &nbsp; } <span class="hljs-keyword">catch</span> {
&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(error)
&nbsp; &nbsp; }
<span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
&nbsp; &nbsp; <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> statusCode = response.response?.statusCode {
&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(<span class="hljs-type">APISessionError</span>.networkError(error: error, statusCode: statusCode))
&nbsp; &nbsp; } <span class="hljs-keyword">else</span> {
&nbsp; &nbsp; &nbsp; &nbsp; observer.onError(error)
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="1646">其逻辑是，当网络请求成功了，就把返回的 JSON 数据通过<code data-backticks="1" data-nodeid="1833">JSONDecoder</code>解码成<code data-backticks="1" data-nodeid="1835">ReponseType</code>类型，并通过<code data-backticks="1" data-nodeid="1837">onNext</code>方法发送到 Observable 序列中，接着调用<code data-backticks="1" data-nodeid="1839">onCompleted</code>方法来关闭数据流；如果发生网络错误，就通过<code data-backticks="1" data-nodeid="1841">onError</code>方法来发送错误事件。</p>
<h4 data-nodeid="1647">请求朋友圈信息模块</h4>
<p data-nodeid="1648">有了底层 HTTP 网络通信模块以后，我们来看看怎样开发一个网络请求模块。</p>
<p data-nodeid="1649">在 Moments App 中，为了分离责任和方便管理，我们为每一个网络请求都定义了一个协议以及对应的实现结构体。在我们的例子中，它们分别是<code data-backticks="1" data-nodeid="1846">GetMomentsByUserIDSessionType</code>协议和<code data-backticks="1" data-nodeid="1848">GetMomentsByUserIDSession</code>结构体。</p>
<p data-nodeid="1650">其中<code data-backticks="1" data-nodeid="1851">GetMomentsByUserIDSessionType</code>协议的定义如下。</p>
<pre class="lang-swift" data-nodeid="1651"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">GetMomentsByUserIDSessionType</span> </span>{
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;
}
</code></pre>
<p data-nodeid="1652">该协议只定义了一个<code data-backticks="1" data-nodeid="1854">getMoments(userID: String) -&gt; Observable&lt;MomentsDetails&gt;</code>方法来提供访问朋友圈信息的接口。因为每个用户的朋友圈信息都不一样，我们需要把用户 ID 传递给该方法，并返回包含了<code data-backticks="1" data-nodeid="1856">MomentsDetails</code>的 Observable 序列。</p>
<p data-nodeid="1653">接下来看看<code data-backticks="1" data-nodeid="1859">GetMomentsByUserIDSession</code>结构体的实现。因为<code data-backticks="1" data-nodeid="1861">GetMomentsByUserIDSession</code>遵循了<code data-backticks="1" data-nodeid="1863">etMomentsByUserIDSessionType</code>协议，因此必须实现来自该协议的<code data-backticks="1" data-nodeid="1865">getMoments(userID: String) -&gt; Observable&lt;MomentsDetails&gt;</code>方法。具体实现如下所示。</p>
<pre class="lang-swift" data-nodeid="1654"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; {
    <span class="hljs-keyword">let</span> session = <span class="hljs-type">Session</span>(userID: userID)
    <span class="hljs-keyword">return</span> sessionHandler(session).<span class="hljs-built_in">map</span> { 
        $<span class="hljs-number">0</span>.data.getMomentsDetailsByUserID }
}
</code></pre>
<p data-nodeid="1655">该方法通过<code data-backticks="1" data-nodeid="1868">sessionHandler</code>来获取网络请求的结果。其中<code data-backticks="1" data-nodeid="1870">sessionHandler</code>是一个封包，它接收了类型为<code data-backticks="1" data-nodeid="1872">Session</code>的入口参数，我们可以在<code data-backticks="1" data-nodeid="1874">init</code>方法里面看到<code data-backticks="1" data-nodeid="1876">sessionHandler</code>的具体实现，如下所示：</p>
<pre class="lang-swift" data-nodeid="1656"><code data-language="swift"><span class="hljs-keyword">init</span>(togglesDataStore: <span class="hljs-type">TogglesDataStoreType</span> = <span class="hljs-type">InternalTogglesDataStore</span>.shared, sessionHandler: @escaping (<span class="hljs-type">Session</span>) -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Response</span>&gt; = {
&nbsp; &nbsp; $<span class="hljs-number">0</span>.post($<span class="hljs-number">0</span>.path, headers: $<span class="hljs-number">0</span>.headers, parameters: $<span class="hljs-number">0</span>.parameters)
}) {
&nbsp; &nbsp; <span class="hljs-keyword">self</span>.togglesDataStore = togglesDataStore
&nbsp; &nbsp; <span class="hljs-keyword">self</span>.sessionHandler = sessionHandler
}
</code></pre>
<p data-nodeid="1657">其中<code data-backticks="1" data-nodeid="1879">$0</code>表示入口参数<code data-backticks="1" data-nodeid="1881">Session</code>的对象， 由于<code data-backticks="1" data-nodeid="1883">Session</code>遵循了<code data-backticks="1" data-nodeid="1885">APISession</code>协议，它可以直接调用<code data-backticks="1" data-nodeid="1887">APISession</code>的扩展方法<code data-backticks="1" data-nodeid="1889">post</code>来发起 HTTP POST 请求，并获取类型为<code data-backticks="1" data-nodeid="1891">Response</code>的返回值。</p>
<p data-nodeid="1658">那返回值<code data-backticks="1" data-nodeid="1894">Response</code>的类型是怎样定义出来的呢？其实它的定义来自 BFF 返回值 JSON 的数据结构，该 JSON 包含了<code data-backticks="1" data-nodeid="1896">data</code>属性，<code data-backticks="1" data-nodeid="1898">data</code>下有一个<code data-backticks="1" data-nodeid="1900">getMomentsDetailsByUserID</code>属性，具体数据结构如下。</p>
<pre class="lang-javascript" data-nodeid="1659"><code data-language="javascript">{
 <span class="hljs-string">"data"</span>: {
   <span class="hljs-string">"getMomentsDetailsByUserID"</span>: {
     <span class="hljs-comment">// MomentsDetails object</span>
     <span class="hljs-string">"userDetails"</span>: {...},
&nbsp; &nbsp; &nbsp; <span class="hljs-string">"moments"</span>: [...]
   }
 }
}
</code></pre>
<p data-nodeid="1660">我们可以根据 JSON 的数据结构来定义 Swift 的<code data-backticks="1" data-nodeid="1903">Response</code>类型，它也有类型为<code data-backticks="1" data-nodeid="1905">Data</code>的<code data-backticks="1" data-nodeid="1907">data</code>属性。在<code data-backticks="1" data-nodeid="1909">Data</code>类型下还包含了类型为<code data-backticks="1" data-nodeid="1911">MomentsDetails</code>的<code data-backticks="1" data-nodeid="1913">getMomentsDetailsByUserID</code>属性。</p>
<pre class="lang-swift" data-nodeid="1661"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span>: <span class="hljs-title">Codable</span> </span>{
&nbsp; &nbsp; <span class="hljs-keyword">let</span> data: <span class="hljs-type">Data</span>
&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span>: <span class="hljs-title">Codable</span> </span>{
&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">let</span> getMomentsDetailsByUserID: <span class="hljs-type">MomentsDetails</span>
&nbsp; &nbsp; }
}
</code></pre>
<p data-nodeid="1662">为了把 Observable 序列的类型从<code data-backticks="1" data-nodeid="1916">Response</code>转换成<code data-backticks="1" data-nodeid="1918">MomentsDetails</code>类型，我们在<code data-backticks="1" data-nodeid="1920">getMoments</code>方法里调用了转换操作符<code data-backticks="1" data-nodeid="1922">map { $0.data.getMomentsDetailsByUserID }</code>从<code data-backticks="1" data-nodeid="1924">Response</code>里抽出<code data-backticks="1" data-nodeid="1926">getMomentsDetailsByUserID</code>进行返回。</p>
<p data-nodeid="1663">接着我们看看<code data-backticks="1" data-nodeid="1929">Session</code>结构体的具体实现。 该结构体负责准备 GraphQL 请求的数据，这些数据包括 URL 路径、HTTP 头和参数。URL 路径比较简单，是一个值为<code data-backticks="1" data-nodeid="1931">/graphql</code>的常量。HTTP 头也是一个默认的<code data-backticks="1" data-nodeid="1933">HTTPHeaders</code>对象。最重要的数据是类型为<code data-backticks="1" data-nodeid="1935">Parameters</code>的<code data-backticks="1" data-nodeid="1937">parameters</code>属性。我们通过<code data-backticks="1" data-nodeid="1939">init</code>方法来看看该属性是怎样进行初始化的。它的实现代码如下所示。</p>
<pre class="lang-swift" data-nodeid="1664"><code data-language="swift"><span class="hljs-keyword">init</span>(userID: <span class="hljs-type">String</span>) {
&nbsp; &nbsp; <span class="hljs-keyword">let</span> variables: [<span class="hljs-type">AnyHashable</span>: <span class="hljs-type">Encodable</span>] = [<span class="hljs-string">"userID"</span>: userID]
&nbsp; &nbsp; parameters = [<span class="hljs-string">"query"</span>: <span class="hljs-type">Self</span>.query,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-string">"variables"</span>: variables]
}
</code></pre>
<p data-nodeid="1665">首先我们把传递进来的<code data-backticks="1" data-nodeid="1942">userID</code>存放到类型为<code data-backticks="1" data-nodeid="1944">[AnyHashable: Encodable]</code>的<code data-backticks="1" data-nodeid="1946">variables</code>变量里面，然后把它与<code data-backticks="1" data-nodeid="1948">query</code>属性一同赋值给<code data-backticks="1" data-nodeid="1950">parameters</code>。</p>
<p data-nodeid="1666">那么<code data-backticks="1" data-nodeid="1953">query</code>是怎样来的呢？因为所有的 GraphQL 的请求都需要发送 Query，在朋友圈信息请求的例子也不例外，<code data-backticks="1" data-nodeid="1955">query</code>属性就是用于定义要发送的 Query 的，其定义如下。</p>
<pre class="lang-swift" data-nodeid="1667"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> query = <span class="hljs-string">"""
    query getMomentsDetailsByUserID($userID: ID!) {
      getMomentsDetailsByUserID(userID: $userID) {
        userDetails {
          id
          name
          avatar
          backgroundImage
        }
        moments {
          id
          userDetails {
            name
            avatar
          }
          type
          title
          photos
          createdDate
        }
      }
    }
"""</span>
}
</code></pre>
<p data-nodeid="8661">在该 Query 定义中，我们定义了类型为<code data-backticks="1" data-nodeid="8664">ID!</code>的入口参数<code data-backticks="1" data-nodeid="8666">$userID</code>，同时定义了返回值的数据结构，例如返回<code data-backticks="1" data-nodeid="8668">getMomentsDetailsByUserID</code>，在它里面包含<code data-backticks="1" data-nodeid="8670">userDetails</code>和<code data-backticks="1" data-nodeid="8672">moments</code>两个属性。在开发过程中我们往往要经常调试 Query，你可以使用 GraphiQL 工具来进行调试。你可以在 Moments App 的 <a href="http://momentsapi.herokuapp.com/playground?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="8676">BFF</a>来尝试调试上面的 Query，执行效果如下。</p>
<p data-nodeid="10314" class=""><img src="https://s0.lgstatic.com/i/image6/M01/3A/82/Cgp9HWB_3tuABbZnAAUdSISnc44399.png" alt="图片10.png" data-nodeid="10317"><br>
在此，我们已经讲完<code data-backticks="1" data-nodeid="10320">Session</code>的实现了，有了 URL 路径，HTTP 头和参数。<code data-backticks="1" data-nodeid="10322">sessionHandler</code>就可以使用它来发起 HTTP POST 请求。具体调用如下所示。</p>








<pre class="lang-swift" data-nodeid="1671"><code data-language="swift">session.post(session.path, headers: session.headers, parameters: session.parameters)
</code></pre>
<h4 data-nodeid="1672">解码 JSON 返回数据</h4>
<p data-nodeid="1673">当我们从 BFF 取得 JSON 返回数据的时候，需要把它解析为 Swift Model 来引入 MVVM 架构里面。那怎样才能把 JSON 数据解码成 Model 类型<code data-backticks="1" data-nodeid="1982">MomentsDetails</code>呢？</p>
<p data-nodeid="1674">这要从返回 JSON 的数据结构入手。JSON 返回结果是由上面的 Query 定义所决定的，在<code data-backticks="1" data-nodeid="1985">getMomentsDetailsByUserID</code>对象里面包含了<code data-backticks="1" data-nodeid="1987">userDetails</code>和<code data-backticks="1" data-nodeid="1989">moments</code>属性，具体的 JSON 如下。</p>
<pre class="lang-javascript" data-nodeid="1675"><code data-language="javascript">{
 <span class="hljs-string">"userDetails"</span>: {
   <span class="hljs-string">"id"</span>: <span class="hljs-string">"0"</span>,
   <span class="hljs-string">"name"</span>: <span class="hljs-string">"Jake Lin"</span>,
   <span class="hljs-string">"avatar"</span>: <span class="hljs-string">"https://avatar-url"</span>,
   <span class="hljs-string">"backgroundImage"</span>: <span class="hljs-string">"https://background-image-url"</span>
 },
 <span class="hljs-string">"moments"</span>: [
   {
     <span class="hljs-string">"id"</span>: <span class="hljs-string">"0"</span>,
     <span class="hljs-string">"userDetails"</span>: {
       <span class="hljs-string">"name"</span>: <span class="hljs-string">"Taylor Swift"</span>,
       <span class="hljs-string">"avatar"</span>: <span class="hljs-string">"https://another-avatar-url"</span>
     },
     <span class="hljs-string">"type"</span>: <span class="hljs-string">"PHOTOS"</span>,
     <span class="hljs-string">"title"</span>: <span class="hljs-literal">null</span>,
     <span class="hljs-string">"photos"</span>: [
       <span class="hljs-string">"https://photo-url"</span>
     ],
     <span class="hljs-string">"createdDate"</span>: <span class="hljs-string">"1615899003"</span>
   }
 ]
}
</code></pre>
<p data-nodeid="1676">有了 JSON 数据结构，我们就可以定义一个 Swift 的 Model 来进行映射，例如把该 Model 命名为<code data-backticks="1" data-nodeid="1992">MomentsDetails</code>。它也包含了<code data-backticks="1" data-nodeid="1994">userDetails</code>和<code data-backticks="1" data-nodeid="1996">moments</code>两个属性，但我们没办法从 JSON 中看出来，所幸 GraphQL 为我们提供了 Schema ，它可以描述各个数据的具体类型。</p>
<p data-nodeid="1677">下面是<code data-backticks="1" data-nodeid="1999">MomentsDetails</code>及其子类型的 Schema 定义。其中<code data-backticks="1" data-nodeid="2001">MomentsDetails</code>包含了<code data-backticks="1" data-nodeid="2003">userDetails</code>和<code data-backticks="1" data-nodeid="2005">moments</code>两个属性 ，<code data-backticks="1" data-nodeid="2007">userDetails</code>为非空的<code data-backticks="1" data-nodeid="2009">UserDetails</code>类型。而<code data-backticks="1" data-nodeid="2011">moments</code>的类型是包含非空的<code data-backticks="1" data-nodeid="2013">Moment</code>数组，同样地，该数组自己也不能为空。具体定义如下所示。</p>
<pre class="lang-typescript" data-nodeid="1678"><code data-language="typescript"><span class="hljs-keyword">type</span> MomentsDetails {
 userDetails: UserDetails!
 moments: [Moment!]!
}
<span class="hljs-keyword">type</span> Moment {
 id: ID!
 userDetails: UserDetails!
 <span class="hljs-keyword">type</span>: MomentType!
 title: <span class="hljs-built_in">String</span>
 url: <span class="hljs-built_in">String</span>
 photos: [<span class="hljs-built_in">String</span>!]!
 createdDate: <span class="hljs-built_in">String</span>!
}
<span class="hljs-keyword">type</span> UserDetails {
&nbsp; id: ID!
&nbsp; name: <span class="hljs-built_in">String</span>!
&nbsp; avatar: <span class="hljs-built_in">String</span>!
&nbsp; backgroundImage: <span class="hljs-built_in">String</span>!
}
<span class="hljs-keyword">enum</span> MomentType {
 URL
 PHOTOS
}
</code></pre>
<p data-nodeid="1679">有了上面的 GraphQL Schema，加上 JSON 数据结构，我们可以完成<code data-backticks="1" data-nodeid="2016">MomentsDetails</code>的映射。</p>
<pre class="lang-swift" data-nodeid="1680"><code data-language="swift"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MomentsDetails</span>: <span class="hljs-title">Codable</span> </span>{
   <span class="hljs-keyword">let</span> userDetails: <span class="hljs-type">UserDetails</span>
   <span class="hljs-keyword">let</span> moments: [<span class="hljs-type">Moment</span>]
}
</code></pre>
<p data-nodeid="1681">具体做法是把 GraphQL 中的<code data-backticks="1" data-nodeid="2019">type</code>映射成<code data-backticks="1" data-nodeid="2021">struct</code>，然后每个属性都使用<code data-backticks="1" data-nodeid="2023">let</code>来定义成常量。在 GraphQL 中,<code data-backticks="1" data-nodeid="2025">!</code>符合表示非空类型，因此在 Swift 中也使用非空类型。在我们的例子中<code data-backticks="1" data-nodeid="2027">userDetails</code>属性的类型为非空的<code data-backticks="1" data-nodeid="2029">UserDetails</code>，而<code data-backticks="1" data-nodeid="2031">moments</code>是<code data-backticks="1" data-nodeid="2033">Moment</code>类型的数组。下面是<code data-backticks="1" data-nodeid="2035">UserDetails</code>类型的定义，它有<code data-backticks="1" data-nodeid="2037">id</code>,<code data-backticks="1" data-nodeid="2039">name</code>等属性。</p>
<pre class="lang-swift" data-nodeid="1682"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserDetails</span>: <span class="hljs-title">Codable</span> </span>{
    <span class="hljs-keyword">let</span> id: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> avatar: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> backgroundImage: <span class="hljs-type">String</span>
}
</code></pre>
<p data-nodeid="1683">接着我们看看<code data-backticks="1" data-nodeid="2042">Moment</code>类型定义。</p>
<pre class="lang-swift" data-nodeid="1684"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Moment</span>: <span class="hljs-title">Codable</span> </span>{
    <span class="hljs-keyword">let</span> id: <span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> userDetails: <span class="hljs-type">MomentUserDetails</span>
    <span class="hljs-keyword">let</span> type: <span class="hljs-type">MomentType</span>
    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String?</span>
    <span class="hljs-keyword">let</span> url: <span class="hljs-type">String?</span>
    <span class="hljs-keyword">let</span> photos: [<span class="hljs-type">String</span>]
    <span class="hljs-keyword">let</span> createdDate: <span class="hljs-type">String</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MomentUserDetails</span>: <span class="hljs-title">Codable</span> </span>{
        <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
        <span class="hljs-keyword">let</span> avatar: <span class="hljs-type">String</span>
    }
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MomentType</span>: <span class="hljs-title">String</span>, <span class="hljs-title">Codable</span> </span>{
        <span class="hljs-keyword">case</span> url = <span class="hljs-string">"URL"</span>
        <span class="hljs-keyword">case</span> photos = <span class="hljs-string">"PHOTOS"</span>
    }
}
</code></pre>
<p data-nodeid="1685"><code data-backticks="1" data-nodeid="2044">Moment</code>类型包含了<code data-backticks="1" data-nodeid="2046">id</code>,<code data-backticks="1" data-nodeid="2048">title</code>,<code data-backticks="1" data-nodeid="2050">userDetails</code>和<code data-backticks="1" data-nodeid="2052">type</code>等属性。其中<code data-backticks="1" data-nodeid="2054">title</code>在 GraphQL 中 Schema 里面没有定义为<code data-backticks="1" data-nodeid="2056">!</code>，表示这个属性可能为空，当我们映射成 Swift 类型时使用了<code data-backticks="1" data-nodeid="2058">?</code>来表示这个属性是可空类型（Optional）。<br>
<code data-backticks="1" data-nodeid="2061">userDetails</code>属性的类型是一个嵌套类型<code data-backticks="1" data-nodeid="2063">MomentUserDetails</code>，我推荐把所有的子类型都内嵌到父类型里面，这样能把所有的类型定义统一封装在<code data-backticks="1" data-nodeid="2065">MomentsDetails</code>里面，访问的时候就有命名空间。</p>
<p data-nodeid="1686">最后我们看一下<code data-backticks="1" data-nodeid="2068">type</code>属性，它在 GraphQL 里的定义是一个枚举。我们把它映射为类型是<code data-backticks="1" data-nodeid="2070">MomentType</code>的一个枚举。由于 GraphQL 会通过字符串来传输<code data-backticks="1" data-nodeid="2072">enum</code>，当我们在 Swift 中映射成枚举类型时，需要把该<code data-backticks="1" data-nodeid="2074">enum</code>定义为字符串类型，并为每一个<code data-backticks="1" data-nodeid="2076">case</code>都指定需要映射的字符串值。例如我们给<code data-backticks="1" data-nodeid="2078">url</code>指定为<code data-backticks="1" data-nodeid="2080">"URL"</code>。</p>
<p data-nodeid="1687">为了让 Swift 帮我们进行自动的解码与编码，我们把所有所有类型都遵守了<code data-backticks="1" data-nodeid="2083">Codable</code>协议，下面是<code data-backticks="1" data-nodeid="2085">Codable</code>协议的定义。</p>
<pre class="lang-swift" data-nodeid="1688"><code data-language="swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">typealias</span> <span class="hljs-type">Codable</span> = <span class="hljs-type">Decodable</span> &amp; <span class="hljs-type">Encodable</span>
</code></pre>
<p data-nodeid="12472"><code data-backticks="1" data-nodeid="12474">Codable</code>其实是<code data-backticks="1" data-nodeid="12476">Decodable</code>和<code data-backticks="1" data-nodeid="12478">Encodable</code>两个协议合体，一个类型遵循了<code data-backticks="1" data-nodeid="12480">Codable</code>表示该类型同时遵循<code data-backticks="1" data-nodeid="12482">Decodable</code>和<code data-backticks="1" data-nodeid="12484">Encodable</code>两个协议。如下图所示，因为 BFF 返回的是 JSON 数据，我们可以使用<code data-backticks="1" data-nodeid="12486">JSONDecoder</code>把 JSON 数据解码成 Swift 的 Model 类型，反过来，我们可以使用<code data-backticks="1" data-nodeid="12488">JSONEncoder</code>把 Swift 的 Model 编码成 JSON 数据。</p>
<p data-nodeid="12473" class="te-preview-highlight"><img src="https://s0.lgstatic.com/i/image6/M00/3A/8A/CioPOWB_3yGAbcmbAAT0CvLwTTw986.png" alt="图片11.png" data-nodeid="12492"></p>


<p data-nodeid="1691">在 Swift 4 之前，我们需要使用<code data-backticks="1" data-nodeid="2107">JSONSerialization</code>来反序列化 JSON 数据，然后把每一个属性单独转换成所需的类型。后来出现 SwiftyJSON 等库，帮我们减轻了一部分 JSON 转型工作，但还是需要大量手工编码来完成映射。</p>
<p data-nodeid="1692">Swift 4 以后，出现了<code data-backticks="1" data-nodeid="2110">Codable</code>协议，我们只需要把所定义的 Model 类型遵守该协议，Swift 在调用<code data-backticks="1" data-nodeid="2112">JSONDecoder</code>的<code data-backticks="1" data-nodeid="2114">decode</code>方法时就能自动完成转型。这样既能减少编写代码的数量，还能获得原生的性能。以下是<code data-backticks="1" data-nodeid="2116">APISession</code>里面转换 JSON 到 Model 类型的代码：</p>
<pre class="lang-swift" data-nodeid="1693"><code data-language="swift"><span class="hljs-keyword">let</span> model = <span class="hljs-keyword">try</span> <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">ReponseType</span>.<span class="hljs-keyword">self</span>, from: data)
</code></pre>
<p data-nodeid="1694">我们只需要把转换的 Model 类型告诉<code data-backticks="1" data-nodeid="2119">decode</code>方法即可。为了处理转换失败的情况，我们使用了<code data-backticks="1" data-nodeid="2121">try</code>语句。当转型失败时，它会返回<code data-backticks="1" data-nodeid="2123">nil</code>，使得我们的程序不会崩溃。</p>
<p data-nodeid="1695">这里有一个技巧，假如你在开发中转型失败了，可以把 Model 定义的一部分属性先注释起来，找出引起转型失败的那个属性；然后，通过 GraphQL Schema 来检查该属性的数据类型，并判断该属性能否为空，最后根据 Schema 的定义来修改转型失败的属性。</p>
<h3 data-nodeid="1696">总结</h3>
<p data-nodeid="1697">至此，我们就有了一个开发网络模块的模板，下面我来总结一下开发网络模块的具体流程。</p>
<ol data-nodeid="1698">
<li data-nodeid="1699">
<p data-nodeid="1700">根据 BFF 返回的 JSON 数据以及 GraphQL 的 Schema ，定义 Model 的数据类型，请记住所有类型都需要遵循<code data-backticks="1" data-nodeid="2129">Codable</code>协议。</p>
</li>
<li data-nodeid="1701">
<p data-nodeid="1702">定义一个网络请求的协议，并提供一个请求的方法，该方法需要接收请求所需的所有参数，并返回包含 Model 类型的 Observable 序列。这样上层模块就能使用响应式编程的方式来处理网络请求的结果了。</p>
</li>
<li data-nodeid="1703">
<p data-nodeid="1704">遵循上述的协议并实现一个网络请求的结构体。在该结构体里定义一个遵循了<code data-backticks="1" data-nodeid="2133">APISession</code>协议的<code data-backticks="1" data-nodeid="2135">Session</code>结构体，并在<code data-backticks="1" data-nodeid="2137">Session</code>结构体内定义发送给 GraphQL 的<code data-backticks="1" data-nodeid="2139">query</code>属性，我们可以通过 GraphiQL 工具来测试 Query 的定义。</p>
</li>
</ol>
<p data-nodeid="1705">思考题：</p>
<blockquote data-nodeid="1706">
<p data-nodeid="1707">请问在你们项目中是如何解析网络返回的 JSON 数据呢？能否分享一下经验。</p>
</blockquote>
<p data-nodeid="1708">可以把你的答案写得留言区哦，下一讲我将介绍如何使用仓库模式设计数据存储层。</p>
<p data-nodeid="1709" class=""><strong data-nodeid="2147">源码地址：</strong></p>
<blockquote data-nodeid="1710">
<p data-nodeid="1711" class="">底层 HTTP 网络通信模块：<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Networking?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2151">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Foundations/Networking</a><br>
请求朋友圈信息模块:<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Networking?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="2156">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/Moments/Features/Moments/Networking</a></p>
</blockquote>

---

### 精选评论

##### *浩：
> 老师，我再使用codable 转我自己定义的model 时遇到了一个问题，我再model中添加了一个JSON返回中没有的bool属性就会报错（var select : Bool），替换成字符串或者Int 就不会报错，是codable 协议中decode 不出来bool类型吗

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; Codable 可以支持 Bool 的，但是 JSON 中不返回的话需要定义为 Optional 哦。可以参考 MomentsDetails 里面的 let isLiked: Bool?

##### *静：
> 老师，网路请求回来后在onNext后面执行了onComplete，为什么在onError后面不执行onComplete呢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你看得很仔细呀。可以看看 《第 17 讲| 响应式编程：如何保证程序状态自动更新？》里面讲的 RxSwift 事件管理，一旦发生错误， Observable 序列就关闭了，无需执行 onComplete。

##### **泽：
> HTTPHeaders看代码的时候 发现老师这个类型这种赋值let headers: HTTPHeaders = [ "x-app-platform": "iOS", "x-app-version": UIApplication.appVersion, "x-os-version": UIDevice.current.systemVersion ]跳到Alamofire里看这个类型的时候， 它就是一个结构体， 是遵循了什么协议才支持这种字典的写法吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 好眼法，你是对的，可以看看这段代码 extension HTTPHeaders: ExpressibleByDictionaryLiteral

##### **泽：
> 老师，BFF是需要给每个端都配有吗， 比如iOS对应iOS的BFF， Android 对应 android的BFF。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 只需要一个 BFF 就行了，假如 iOS 和 Android 需要请求不同的数据，可以通过提供不同的 query 来解决。

##### **朋：
> 如果应对后台返回的数据某些字段缺失的问题呢（会直接导致json解析失败）？codable解决不了这个问题

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 不会呀，因为我们使用了 GraphQL，所有访问都遵循 Scheme。

##### *杰：
> 请教一下，Moments里面的 Foundations 如果作为独立组件而存在。那么Foundations基础组件引入的三方库（如 APISession 引入的Alamofire），Alamofire是不是不应该开放给业务组件来使用？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你说的对，业务组件不应该直接使用 Alamofire，而是使用 Foundations 里面的 Networking 模块。

##### *宇：
> 老师你架构关系图用的什么软件画的？求推荐

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 我用的是 draw.io，免费使用，推荐试试。

##### **一：
> 在选择 Swift 类型的时候，更习惯用 URL 和 Date，文中用的都是 String，应该可以改吧？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 我偏向于使用与 GraphQL Schema 里一模一样的类型，这样就无需单元测试 Model 了，所有的转型操作都在 ViewModel 层进行，这样能方便我们完整地测试所有转型操作。还有一点，如果 Model 数据都是一些简单的类型，例如 String，Int 那些，那很容易存放到数据库里面，无需任何额外操作。

##### **龙：
> 刚开始学Swift1.0和2.0的时候，还在用objc的那套模式，所有的模型继承NSObject，然后玩KVC那一套。在Swift3的时候，我用的最多是ObjectMapper，偶尔轻量级的会使用SwiftyJSON这个要是自己写起来很麻烦，所幸有工具直接转。Swift4之后，我一直都是用的Codable协议了，原生的，无侵入，简单。

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 哈哈，谢谢分享呀，我们也是这样一步步走过来的，目前觉得 Codable 最好用。

