<p data-nodeid="86083">如果一个 App 有很多的 Bug 或者崩溃率非常高，我们往往就需要花大量的时间和精力去不断查错和“救火”。那怎样才能提高代码的质量，让我们可以把有效的时间专注于产品功能的迭代上呢？经过多年实践经验的总结，我们发现<strong data-nodeid="86089">测试驱动开发</strong>，也叫作 TDD（Test-Driven Development），是一种行而有效的方法实践。</p>


<p data-nodeid="84435"><strong data-nodeid="84542">TDD 的核心是编写单元测试</strong>。单元测试能方便我们模拟不同的测试场景，覆盖不同的边界条件，从而提高代码的质量并减少 Bug 的数量。同时，使用 TDD 所开发的代码能降低模块间的耦合度，提高模块的灵活性和可扩展性。</p>
<p data-nodeid="84436">下面我们以 Moments App 作为例子来看看如何通过编写单元测试来进行 TDD。这里主要讲述测试代码的步骤与结构，以及如何为网络层、Repository 层和 ViewModel 层编写单元测试。</p>
<h3 data-nodeid="84437">测试代码的步骤与结构</h3>
<p data-nodeid="84438">在编写测试代码时候，我们一般遵守 AAA 步骤，所谓<strong data-nodeid="84550">AAA 就是 Arrange、Act 和 Assert</strong>。</p>
<ul data-nodeid="84439">
<li data-nodeid="84440">
<p data-nodeid="84441">Arrange：用于搭建测试案例，例如，初始化测试对象及其依赖。</p>
</li>
<li data-nodeid="84442">
<p data-nodeid="84443">Act：表示执行测试，例如，调用测试对象的方法。</p>
</li>
<li data-nodeid="84444">
<p data-nodeid="84445">Assert：用于检验测试的结果。</p>
</li>
</ul>
<p data-nodeid="84446">那怎样才能按照 AAA 步骤来编写测试代码呢？为了简化编写测试的工作，并提高代码的结构性与可读性，我们在 Moments App 中使用了 Quick 和 Nimble 库。下面我以<code data-backticks="1" data-nodeid="84555">MomentsTimelineViewModelTests</code>为例子给你讲述一种实用的测试代码结构：</p>
<pre class="lang-swift" data-nodeid="84447"><code data-language="swift"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MomentsTimelineViewModelTests</span>: <span class="hljs-title">QuickSpec</span> </span>{
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spec</span><span class="hljs-params">()</span></span> {
        describe(<span class="hljs-string">"MomentsTimelineViewModel"</span>) {
            <span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">MomentsTimelineViewModel!</span>
            beforeEach {
                testSubject = <span class="hljs-type">MomentsTimelineViewModel</span>() <span class="hljs-comment">// Arrange</span>
            }
            context(<span class="hljs-string">"loadItems()"</span>) {
                beforeEach {
                    testSubject.loadItems() <span class="hljs-comment">// Act</span>
                }
                it(<span class="hljs-string">"call `momentsRepo.getMoments` with the correct parameters"</span>) {
                    expect(mockMomentsRepo.getMomentsHasBeenCalled).to(beTrue()) <span class="hljs-comment">// Assert</span>
                }
                it(<span class="hljs-string">"check another assertion"</span>) { }
            }
            context(<span class="hljs-string">"anotherMethod()"</span>) { }
        }
    }
}
</code></pre>
<p data-nodeid="84448"><strong data-nodeid="84579">首先是测试类的定义</strong>。我们定义了一个继承于<code data-backticks="1" data-nodeid="84561">QuickSpec</code>的测试类，测试类通常以<code data-backticks="1" data-nodeid="84563">&lt;需要测试的类型&gt;Tests</code>的规范来命名。在上面的例子中，我们需要测试<code data-backticks="1" data-nodeid="84565">MomentsTimelineViewModel</code>，因此把测试类定义为<code data-backticks="1" data-nodeid="84567">MomentsTimelineViewModelTests</code>。然后在类里面重写<code data-backticks="1" data-nodeid="84569">spec()</code>方法来封装所有测试案例。接着在<code data-backticks="1" data-nodeid="84571">spec()</code>方法里面通过<code data-backticks="1" data-nodeid="84573">describe()</code>方法来进行分组，我的做法是一个测试类型只有一个<code data-backticks="1" data-nodeid="84575">describe()</code>方法，并把要测试类型的名称传递给该方法，在例子中就写成<code data-backticks="1" data-nodeid="84577">describe("MomentsTimelineViewModel")</code>，这样能保证在批量执行测试案例时可以快速定位出错的测试类。</p>
<p data-nodeid="84449"><strong data-nodeid="84612">接下来是执行 AAA 中的 Arrange 步骤来搭建测试案例所需的对象</strong>。在<code data-backticks="1" data-nodeid="84584">describe()</code>方法里，我们先定义一个名叫<code data-backticks="1" data-nodeid="84586">testSubject</code>的测试对象，它的类型为需要测试的类型，在我们的例子中，<code data-backticks="1" data-nodeid="84588">testSubject</code>的类型是<code data-backticks="1" data-nodeid="84590">MomentsTimelineViewModel!</code>。你可能注意到，我们定义<code data-backticks="1" data-nodeid="84592">testSubject</code>时使用了<code data-backticks="1" data-nodeid="84594">!</code>来表示该对象不会为<code data-backticks="1" data-nodeid="84596">nil</code>。不过，这里需要提醒一下，在生产代码中，我们绝对不使用<code data-backticks="1" data-nodeid="84598">!</code>来定义属性，因为一旦该属性为<code data-backticks="1" data-nodeid="84600">nil</code>时，调用该属性的方法就会导致程序崩溃。那为什么在测试代码中反而使用<code data-backticks="1" data-nodeid="84602">!</code>呢？因为我们希望在执行每一个测试案例之前都重新生成一个新的<code data-backticks="1" data-nodeid="84604">testSubject</code>对象来保证每个案例都是无状态的，所以我们需要把初始化操作放到<code data-backticks="1" data-nodeid="84606">beforeEach()</code>方法里面，如果<code data-backticks="1" data-nodeid="84608">testSubject</code>不是定义为<code data-backticks="1" data-nodeid="84610">!</code>，就会有编译错误。</p>
<p data-nodeid="84450"><strong data-nodeid="84629">然后是执行 AAA 里面的 Act 步骤</strong>。测试类型中的每一个公共的方法和属性都需要测试，因此，我们需要把它们的测试案例进行分组。为此，我会使用到<code data-backticks="1" data-nodeid="84617">context()</code>方法。例如，当我们要测试<code data-backticks="1" data-nodeid="84619">loadItems()</code>方法时，就把方法名字传递给<code data-backticks="1" data-nodeid="84621">context()</code>方法，写成<code data-backticks="1" data-nodeid="84623">context("loadItems()")</code>，并在该 context 下的<code data-backticks="1" data-nodeid="84625">beforeEach()</code>方法里调用测试方法<code data-backticks="1" data-nodeid="84627">loadItems()</code>，这样就执行 Act 步骤了。</p>
<p data-nodeid="84451"><strong data-nodeid="84646">最后看一下如何执行 AAA 里面的 Assert 步骤</strong>。我们可以通过<code data-backticks="1" data-nodeid="84634">it()</code>方法来检验每个测试案例的执行结果。为了使得测试更加容易读，我通常把测试的预期行为都写在<code data-backticks="1" data-nodeid="84636">it()</code>方法里面，示例中的<code data-backticks="1" data-nodeid="84638">it("call momentsRepo.getMoments()with the correct parameters")</code>表示当我们调用<code data-backticks="1" data-nodeid="84640">loadItems()</code>方法时就必须调用<code data-backticks="1" data-nodeid="84642">momentsRepo</code>属性的<code data-backticks="1" data-nodeid="84644">getMoments()</code>函数。</p>
<p data-nodeid="84452">至此，编写单元测试代码的步骤与框架就讲完了。下面我们再结合真实的例子来看看如何为网络层、Repository 层和 ViewModel 层编写测试代码。</p>
<h3 data-nodeid="84453">网络层的测试</h3>
<p data-nodeid="84454">我们以<code data-backticks="1" data-nodeid="84650">GetMomentsByUserIDSessionTests</code>为例子看看如何为网络层编写单元测试的代码。因为我们使用了 RxSwift，在测试的时候可以引用<strong data-nodeid="84656">RxTest 库</strong>来简化测试的流程。</p>
<p data-nodeid="84455">首先，我们在<code data-backticks="1" data-nodeid="84658">describe("GetMomentsByUserIDSession")</code>函数里定义需要初始化的变量，代码如下：</p>
<pre class="lang-swift" data-nodeid="84456"><code data-language="swift"><span class="hljs-keyword">var</span> testSubject: <span class="hljs-type">GetMomentsByUserIDSession!</span>
<span class="hljs-keyword">var</span> testScheduler: <span class="hljs-type">TestScheduler!</span>
<span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestableObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!
<span class="hljs-keyword">var</span> mockResponseEvent: <span class="hljs-type">Recorded</span>&lt;<span class="hljs-type">Event</span>&lt;<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>&gt;&gt;!
</code></pre>
<ul data-nodeid="84457">
<li data-nodeid="84458">
<p data-nodeid="84459"><code data-backticks="1" data-nodeid="84660">testSubject</code>是测试的对象，在这个例子中是我们需要测试的<code data-backticks="1" data-nodeid="84662">GetMomentsByUserIDSession</code>。</p>
</li>
<li data-nodeid="84460">
<p data-nodeid="84461"><code data-backticks="1" data-nodeid="84664">testScheduler</code>的类型是来自 RxTest 的<code data-backticks="1" data-nodeid="84666">TestScheduler</code>，是一个用于测试的排程器。</p>
</li>
<li data-nodeid="84462">
<p data-nodeid="84463"><code data-backticks="1" data-nodeid="84668">testObserver</code>的类型是 RxTest 的<code data-backticks="1" data-nodeid="84670">TestableObserver</code>，用来订阅 Observable 序列里的事件，并通过接收到的事件来检查测试的结果。</p>
</li>
<li data-nodeid="84464">
<p data-nodeid="84465"><code data-backticks="1" data-nodeid="84672">mockResponseEvent</code>是<code data-backticks="1" data-nodeid="84674">Recorded</code>类型，也是来自 RxTest，用于模拟事件的发送，例如模拟成功接收到网络数据事件或者错误事件。</p>
</li>
</ul>
<p data-nodeid="84466">所需的变量定义完毕以后，可以在<code data-backticks="1" data-nodeid="84677">beforeEach()</code>方法里面初始化<code data-backticks="1" data-nodeid="84679">testScheduler</code>和<code data-backticks="1" data-nodeid="84681">testObserver</code>，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84467"><code data-language="swift">beforeEach {
    testScheduler = <span class="hljs-type">TestScheduler</span>(initialClock: <span class="hljs-number">0</span>)
    testObserver = testScheduler.createObserver(<span class="hljs-type">MomentsDetails</span>.<span class="hljs-keyword">self</span>)
}
</code></pre>
<p data-nodeid="87186">因为初始化操作都在<code data-backticks="1" data-nodeid="87189">beforeEach()</code>方法里面，所以每个测试案例执行前都会重新初始化这两个变量。</p>
<p data-nodeid="87187">初始化完毕后，我们就可以测试<code data-backticks="1" data-nodeid="87192">GetMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="87194">getMoments()</code>方法了，具体代码如下：</p>

<pre class="lang-swift" data-nodeid="84469"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {
    context(<span class="hljs-string">"when response status code 200 with valid response"</span>) {
        beforeEach {
            mockResponseEvent = .next(<span class="hljs-number">100</span>, <span class="hljs-type">TestData</span>.successResponse)
            getMoments(mockEvent: mockResponseEvent)
        }
    }
}
</code></pre>
<p data-nodeid="84470">我们使用<code data-backticks="1" data-nodeid="84693">context("getMoments(userID:)")</code>把<code data-backticks="1" data-nodeid="84695">getMoments(userID:)</code>所有的测试案例都组织在一起。先看成功的测试案例，该案例封装在<code data-backticks="1" data-nodeid="84697">context("when response status code 200 with valid response")</code>函数里面，表示网络成功返回有效数据时的情况。在<code data-backticks="1" data-nodeid="84699">beforeEach()</code>方法里做了两件事情，第一件执行 Arrange 步骤，让<code data-backticks="1" data-nodeid="84701">mockResponseEvent</code>发出一个<code data-backticks="1" data-nodeid="84703">.next</code>事件，该事件里面包含了类型为<code data-backticks="1" data-nodeid="84705">GetMomentsByUserIDSession.Response</code>的数据对象<code data-backticks="1" data-nodeid="84707">successResponse</code>。下面是这个数据对象的定义：</p>
<pre class="lang-swift" data-nodeid="84471"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TestData</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successResponse: <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span> = {
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">try</span>! <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>,
                                               from: <span class="hljs-type">TestData</span>.successjson.data(using: .utf8)!)
        <span class="hljs-keyword">return</span> response
    }()
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> successjson = <span class="hljs-string">"""
    {
      "data": { ... } // JSON 数据
    }
    """</span>
}
</code></pre>
<p data-nodeid="84472">代码中的私有结构体<code data-backticks="1" data-nodeid="84710">TestData</code>用于配置测试数据，它提供了一个名叫<code data-backticks="1" data-nodeid="84712">successResponse</code>的静态属性来返回类型为<code data-backticks="1" data-nodeid="84714">GetMomentsByUserIDSession.Response</code>的测试数据。在这个属性里，我们使用了<code data-backticks="1" data-nodeid="84716">JSONDecoder().decode()</code>方法来解码 JSON 字符串。在开发的过程，我们可以从 BFF 的返回值中拷贝该 JSON 字符串。通过这个测试案例，我们可以快速地测试<code data-backticks="1" data-nodeid="84718">GetMomentsByUserIDSession</code>结构体的映射是否正确。这种做法比通过修改后台来返回测试数据要方便很多。</p>
<p data-nodeid="84473"><code data-backticks="1" data-nodeid="84720">beforeEach()</code>方法里第二件事情是执行 Act 步骤，可以通过调用<code data-backticks="1" data-nodeid="84722">getMoments(mockEvent: mockResponseEvent)</code>方法来完成这一任务。该方法是一个私有方法，其定义如下：</p>
<pre class="lang-swift" data-nodeid="84474"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(mockEvent: Recorded&lt;Event&lt;GetMomentsByUserIDSession.Response&gt;&gt;)</span></span> {
    <span class="hljs-keyword">let</span> testableObservable = testScheduler.createHotObservable([mockEvent])
    testSubject = <span class="hljs-type">GetMomentsByUserIDSession</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> testableObservable.asObservable() }
    testSubject.getMoments(userID: <span class="hljs-string">"0"</span>).subscribe(testObserver).disposed(by: disposeBag)
    testScheduler.start()
}
</code></pre>
<p data-nodeid="84475">首先我们把模拟数据传递给<code data-backticks="1" data-nodeid="84725">testScheduler.createHotObservable()</code>方法来生成一个新的<code data-backticks="1" data-nodeid="84727">testableObservable</code>对象，然后把该对象注入<code data-backticks="1" data-nodeid="84729">GetMomentsByUserIDSession</code>的初始化方法里并生成新的测试对象<code data-backticks="1" data-nodeid="84731">testSubject</code>，接着调用测试对象的<code data-backticks="1" data-nodeid="84733">getMoments(userID:)</code>方法，最后通过调用<code data-backticks="1" data-nodeid="84735">testScheduler.start()</code>方法来启动排程器，模拟一个异步网络请求的过程。</p>
<p data-nodeid="84476">执行完 Act 步骤以后，我们还需要执行 Assert 步骤来检验测试的结果，验证的代码都放在<code data-backticks="1" data-nodeid="84738">it("should complete and map the response correctly")</code>方法里面，如下所示：</p>
<pre class="lang-swift" data-nodeid="84477"><code data-language="swift">it(<span class="hljs-string">"should complete and map the response correctly"</span>) {
    <span class="hljs-keyword">let</span> expectedMomentsDetails = <span class="hljs-type">TestFixture</span>.momentsDetails
    <span class="hljs-keyword">let</span> actualMomentsDetails = testObserver.events.first!.value.element!
    expect(actualMomentsDetails).toEventually(<span class="hljs-built_in">equal</span>(expectedMomentsDetails))
}
</code></pre>
<p data-nodeid="84478">我们从<code data-backticks="1" data-nodeid="84741">testObserver</code>里取出它接收到的第一个事件，然后调用<code data-backticks="1" data-nodeid="84743">expect()</code>方法来比较实际数据和预期数据。因为网络的数据是异步返回的，所以我们在比较过程时使用了<code data-backticks="1" data-nodeid="84745">toEventually()</code>方法，该方法会等待结果返回以后才进行比较。</p>
<p data-nodeid="84479">成功案例已经测试完毕，接下来我们看一个失败的案例。下面的代码模拟了网络访问失败的情况：</p>
<pre class="lang-swift" data-nodeid="84480"><code data-language="swift">context(<span class="hljs-string">"when response status code non-200"</span>) {
    <span class="hljs-keyword">let</span> networkError: <span class="hljs-type">APISessionError</span> = .networkError(error: <span class="hljs-type">MockError</span>(), statusCode: <span class="hljs-number">500</span>)
    beforeEach {
        mockResponseEvent = .error(<span class="hljs-number">100</span>, networkError, <span class="hljs-type">GetMomentsByUserIDSession</span>.<span class="hljs-type">Response</span>.<span class="hljs-keyword">self</span>)
        getMoments(mockEvent: mockResponseEvent)
    }
    it(<span class="hljs-string">"should throw a network error"</span>) {
        <span class="hljs-keyword">let</span> actualError = testObserver.events.first!.value.error <span class="hljs-keyword">as</span>! <span class="hljs-type">APISessionError</span>
        expect(actualError).toEventually(<span class="hljs-built_in">equal</span>(networkError))
    }
}
</code></pre>
<p data-nodeid="84481">你可以看到，测试代码的结构和成功案例是一致的，不同的地方是我们让<code data-backticks="1" data-nodeid="84749">mockResponseEvent</code>返回一个错误的事件，在检验的过程中，我们从<code data-backticks="1" data-nodeid="84751">testObserver</code>取出<code data-backticks="1" data-nodeid="84753">error</code>来进行对比，而不是<code data-backticks="1" data-nodeid="84755">element</code>。</p>
<p data-nodeid="84482">网络测试的代码就讲到这里，你可以打开拉勾教育网的代码仓库来查看更多网络层的测试案例。</p>
<h3 data-nodeid="84483">Repository 层的测试</h3>
<p data-nodeid="84484">下面我们以<code data-backticks="1" data-nodeid="84760">MomentsRepoTests</code>为例子看一下如何测试 Repository 层。</p>
<p data-nodeid="84485"><code data-backticks="1" data-nodeid="84762">MomentsRepoTests</code>用于测试<code data-backticks="1" data-nodeid="84764">MomentsRepo</code>。我们在《19 | 数据层架构：如何使用仓库模式设计数据存储层？》中描述过，<code data-backticks="1" data-nodeid="84766">MomentsRepo</code>依赖了<code data-backticks="1" data-nodeid="84768">PersistentDataStoreType</code>来读取本地数据，并且依赖了<code data-backticks="1" data-nodeid="84770">GetMomentsByUserIDSessionType</code>从 BFF 读取朋友圈信息。那我们测试<code data-backticks="1" data-nodeid="84772">MomentsRepo</code>的时候是不是也一同测试两个类型的实现呢？答案是否定的，因为<strong data-nodeid="84788">所谓单元测试就是只单独测试某个类型的具体实现，而不测试它的依赖类型</strong>。回到<code data-backticks="1" data-nodeid="84778">MomentsRepoTests</code>的例子，它仅仅测试<code data-backticks="1" data-nodeid="84780">MomentsRepo</code>的实现。也就是说，哪怕我们替换了<code data-backticks="1" data-nodeid="84782">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84784">GetMomentsByUserIDSessionType</code>的实现，在不修改<code data-backticks="1" data-nodeid="84786">MomentsRepoTests</code>的情况下，所有测试案例都必须通过验证。</p>
<p data-nodeid="84486">那怎样才能使得<code data-backticks="1" data-nodeid="84790">MomentsRepoTests</code>只测试<code data-backticks="1" data-nodeid="84792">MomentsRepo</code>的实现，而不测试其他任何的依赖类型呢？我们可以通过 Mock 类型来达到这一目的。下面是 Mock 类型的示例代码：</p>
<pre class="lang-swift" data-nodeid="84487"><code data-language="swift"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockUserDefaultsPersistentDataStore</span>: <span class="hljs-title">PersistentDataStoreType</span> </span>{
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> momentsDetails: <span class="hljs-type">ReplaySubject</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; = .create(bufferSize: <span class="hljs-number">1</span>)
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> savedMomentsDetails: <span class="hljs-type">MomentsDetails?</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">save</span><span class="hljs-params">(momentsDetails: MomentsDetails)</span></span> {
        savedMomentsDetails = momentsDetails
    }
}
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockGetMomentsByUserIDSession</span>: <span class="hljs-title">GetMomentsByUserIDSessionType</span> </span>{
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> getMomentsHasbeenCalled = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> passedUserID: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt; {
        passedUserID = userID
        getMomentsHasbeenCalled = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Observable</span>.just(<span class="hljs-type">TestFixture</span>.momentsDetails)
    }
}
</code></pre>
<p data-nodeid="84488">我们分别定义了两个 Mock 类型来遵循<code data-backticks="1" data-nodeid="84795">PersistentDataStoreType</code>和<code data-backticks="1" data-nodeid="84797">GetMomentsByUserIDSessionType</code>协议，这些 Mock 类型只是把传递的参数保存在属性中，并不进行具体的操作，例如不会读写本地数据库和访问网络。</p>
<p data-nodeid="84489">有了这些 Mock 类型以后，我们就可以把它们注入测试对象<code data-backticks="1" data-nodeid="84800">testSubject</code>中，具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84490"><code data-language="swift">beforeEach {
    mockUserDefaultsPersistentDataStore = <span class="hljs-type">MockUserDefaultsPersistentDataStore</span>()
    mockGetMomentsByUserIDSession = <span class="hljs-type">MockGetMomentsByUserIDSession</span>()
    testSubject = <span class="hljs-type">MomentsRepo</span>(persistentDataStore: mockUserDefaultsPersistentDataStore, getMomentsByUserIDSession: mockGetMomentsByUserIDSession)
}
</code></pre>
<p data-nodeid="84491">在上一讲的思考题中我提问过：为什么保存依赖的属性都是通过<code data-backticks="1" data-nodeid="84803">init()</code>方法来注入，而不是在内部进行初始化？<strong data-nodeid="84817">一个重要的原因是我们可以在执行单元测试时把 Mock 类型注入进来</strong>。例如在生产代码中，我们为<code data-backticks="1" data-nodeid="84809">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84811">persistentDataStore</code>属性注入<code data-backticks="1" data-nodeid="84813">UserDefaultsPersistentDataStore.shared</code>来访问 iOS 系统的 UserDefaults。UserDefaults 上的数据在程序退出以后还会保留，而单元测试的案例是无状态的，因此所有测试都不应该读写 UserDefaults 上的数据。我们可以在测试代码中，通过注入<code data-backticks="1" data-nodeid="84815">MockUserDefaultsPersistentDataStore</code>的对象来避免访问 UserDefaults。</p>
<p data-nodeid="84492">依赖注入是面向抽象编程中一种有效的实践方式，不但方便我们编写测试代码，使得测试不依赖于任何的具体环境，同时还能帮我们很容易地替换某个模块的具体实现，例如，当我们决定使用 CoreData 来替换 UserDefaults 作为本地数据存储时，只需在生产代码中注入<code data-backticks="1" data-nodeid="84819">CoreDataPersistentDataStore.shared</code>即可。</p>
<p data-nodeid="84493">有了 Mock 类型以后，我们看一下如何测试<code data-backticks="1" data-nodeid="84822">MomentsRepo</code>的<code data-backticks="1" data-nodeid="84824">momentsDetails</code>属性，其中 Arrange 和 Act 步骤的代码如下：</p>
<pre class="lang-swift" data-nodeid="84494"><code data-language="swift">context(<span class="hljs-string">"momentsDetails"</span>) {
    <span class="hljs-keyword">var</span> testObserver: <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;!
    beforeEach {
        testObserver = <span class="hljs-type">TestObserver</span>&lt;<span class="hljs-type">MomentsDetails</span>&gt;() <span class="hljs-comment">// Arrange</span>
        testSubject.momentsDetails.subscribe(testObserver).disposed(by: disposeBag) <span class="hljs-comment">// Act</span>
    }
}
</code></pre>
<p data-nodeid="84495">首先，初始化了一个<code data-backticks="1" data-nodeid="84827">TestObserver</code>对象来帮助测试 RxSwift 的代码。<code data-backticks="1" data-nodeid="84829">TestObserver</code>是我们自定义的一个类，定义如下：</p>
<pre class="lang-swift" data-nodeid="84496"><code data-language="swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObserver</span>&lt;<span class="hljs-title">ElementType</span>&gt;: <span class="hljs-title">ObserverType</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> lastEvent: <span class="hljs-type">Event</span>&lt;<span class="hljs-type">ElementType</span>&gt;?
    <span class="hljs-keyword">var</span> lastElement: <span class="hljs-type">ElementType?</span> {
        <span class="hljs-keyword">return</span> lastEvent?.element
    }
    <span class="hljs-keyword">var</span> lastError: <span class="hljs-type">Error?</span> {
        <span class="hljs-keyword">return</span> lastEvent?.error
    }
    <span class="hljs-keyword">var</span> isCompleted: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> lastEvent?.isCompleted ?? <span class="hljs-literal">false</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">on</span><span class="hljs-params">(<span class="hljs-number">_</span> event: Event&lt;ElementType&gt;)</span></span> {
        lastEvent = event
    }
}
</code></pre>
<p data-nodeid="84497"><code data-backticks="1" data-nodeid="84831">TestObserver</code>定义了<code data-backticks="1" data-nodeid="84833">on(_ event: Event&lt;ElementType&gt;)</code>方法来接收事件，并提供了<code data-backticks="1" data-nodeid="84835">lastElement</code>、<code data-backticks="1" data-nodeid="84837">lastError</code>和<code data-backticks="1" data-nodeid="84839">isCompleted</code>属性来检查最后一条事件的类型。有了<code data-backticks="1" data-nodeid="84841">testObserver</code>对象，我们可以把它传递给<code data-backticks="1" data-nodeid="84843">subscribe()</code>方法来订阅<code data-backticks="1" data-nodeid="84845">momentsDetails</code>属性的事件，然后通过它来验证 RxSwift 代码的测试结果，下面是 Assert 步骤的代码：</p>
<pre class="lang-swift" data-nodeid="84498"><code data-language="swift">it(<span class="hljs-string">"should be `nil` by default"</span>) {
    expect(testObserver.lastElement).to(beNil()) <span class="hljs-comment">// Assert</span>
}
context(<span class="hljs-string">"when persistentDataStore has new data"</span>) {
    beforeEach {
        mockUserDefaultsPersistentDataStore.momentsDetails.onNext(<span class="hljs-type">TestFixture</span>.momentsDetails)
    }
    it(<span class="hljs-string">"should notify a next event with the new data"</span>) {
        expect(testObserver.lastElement).toEventually(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails)) <span class="hljs-comment">// Assert</span>
    }
}
</code></pre>
<p data-nodeid="84499">在开始的时候，<code data-backticks="1" data-nodeid="84848">testObserver</code>不应该接收到任何事件，所以它的<code data-backticks="1" data-nodeid="84850">lastElement</code>属性返回<code data-backticks="1" data-nodeid="84852">nil</code>。当我们往 Mock 类型<code data-backticks="1" data-nodeid="84854">mockUserDefaultsPersistentDataStore</code>的<code data-backticks="1" data-nodeid="84856">momentsDetails</code>属性发出一个<code data-backticks="1" data-nodeid="84858">next</code>事件后，<code data-backticks="1" data-nodeid="84860">testObserver</code>会接收到该事件，我们可以调用<code data-backticks="1" data-nodeid="84862">toEventually()</code>方法来进行检查。</p>
<p data-nodeid="84500">下面我们再看看<code data-backticks="1" data-nodeid="84865">getMoments(userID:)</code>方法的测试。具体代码如下：</p>
<pre class="lang-swift" data-nodeid="84501"><code data-language="swift">context(<span class="hljs-string">"getMoments(userID:)"</span>) {
    beforeEach {
        testSubject.getMoments(userID: <span class="hljs-string">"1"</span>).subscribe().disposed(by: disposeBag)
    }
    it(<span class="hljs-string">"should call `GetMomentsByUserIDSessionType.getMoments`"</span>) {
        expect(mockGetMomentsByUserIDSession.getMomentsHasbeenCalled).to(beTrue())
        expect(mockGetMomentsByUserIDSession.passedUserID).to(be(<span class="hljs-string">"1"</span>))
    }
    it(<span class="hljs-string">"should save a `MomentsDetails` object"</span>) {
        expect(mockUserDefaultsPersistentDataStore.savedMomentsDetails).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">TestFixture</span>.momentsDetails))
    }
}
</code></pre>
<p data-nodeid="84502">我们在<code data-backticks="1" data-nodeid="84868">beforeEach()</code>方法中执行了 Act 步骤来调用<code data-backticks="1" data-nodeid="84870">getMoments(userID:)</code>方法，这里首先复习一下《第 19 讲| 数据层架构：如何使用仓库模式设计数据存储层？》里讲过的<code data-backticks="1" data-nodeid="84872">MomentsRepo</code>方法的实现。</p>
<pre class="lang-swift" data-nodeid="84503"><code data-language="swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMoments</span><span class="hljs-params">(userID: String)</span></span> -&gt; <span class="hljs-type">Observable</span>&lt;<span class="hljs-type">Void</span>&gt; {
    <span class="hljs-keyword">return</span> getMomentsByUserIDSession
        .getMoments(userID: userID)
        .<span class="hljs-keyword">do</span>(onNext: { persistentDataStore.save(momentsDetails: $<span class="hljs-number">0</span>) })
        .<span class="hljs-built_in">map</span> { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> () }
        .catchErrorJustReturn(())
}
</code></pre>
<p data-nodeid="84504">在该方法实现中，我们会调用<code data-backticks="1" data-nodeid="84875">getMomentsByUserIDSession</code>的<code data-backticks="1" data-nodeid="84877">getMoments(userID:)</code>来读取网络数据，并调用<code data-backticks="1" data-nodeid="84879">persistentDataStore</code>的<code data-backticks="1" data-nodeid="84881">save(momentsDetails:)</code>方法把网络返回结果保存到本地数据库中。在测试过程中，我们已经为这两个依赖项分别注入了不同的 Mock 对象，因此在检验结果的时候，我们可以通过比较 Mock 对象的属性就能验证测试是否正确执行。例如，我们检查<code data-backticks="1" data-nodeid="84883">mockGetMomentsByUserIDSession.passedUserID</code>来验证<code data-backticks="1" data-nodeid="84885">getMomentsByUserIDSession</code>的执行结果，然后检查<code data-backticks="1" data-nodeid="84887">mockUserDefaultsPersistentDataStore.savedMomentsDetails</code>来验证<code data-backticks="1" data-nodeid="84889">persistentDataStore</code>的执行结果。</p>
<h3 data-nodeid="84505">ViewModel 层的测试</h3>
<p data-nodeid="84506">完成 Repository 层的测试以后，我们再一起看看如何测试 ViewModel 层的代码。</p>
<p data-nodeid="84507">朋友圈功能的 ViewModel 层由三个 ViewModel 类型所组成，其中<code data-backticks="1" data-nodeid="84894">MomentsTimelineViewModel</code>类型的测试方式与<code data-backticks="1" data-nodeid="84896">MomentsRepo</code>是一样的，<strong data-nodeid="84902">都是通过注入 Mock 类型类来测试 RxSwift 返回的结果</strong>。你可以在拉勾教育网的代码仓库查看详细的代码实现。</p>
<p data-nodeid="84508">因为<code data-backticks="1" data-nodeid="84904">UserProfileListItemViewModel</code>的责任是把 Model 类型的数据转换成 UI 呈现所需的 ViewModel 类型，那么作为其测试类型，<code data-backticks="1" data-nodeid="84906">UserProfileListItemViewModelTests</code>的工作就是验证这些数据转换的逻辑是否正确。我们一起看看<code data-backticks="1" data-nodeid="84908">UserProfileListItemViewModelTests</code>的实现代码，首先是成功的测试案例，如下所示：</p>
<pre class="lang-swift" data-nodeid="84509"><code data-language="swift">context(<span class="hljs-string">"init(userDetails:)"</span>) {
    context(<span class="hljs-string">"when all data provided"</span>) {
        beforeEach {
            testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">TestFixture</span>.userDetails)
        }
        it(<span class="hljs-string">"should initialize the properties correctly"</span>) {
            expect(testSubject.name).to(<span class="hljs-built_in">equal</span>(<span class="hljs-string">"Jake Lin"</span>))
            expect(testSubject.avatarURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://avatars-url.com"</span>)))
            expect(testSubject.backgroundImageURL).to(<span class="hljs-built_in">equal</span>(<span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://background-image-url.com"</span>)))
        }
    }
}
</code></pre>
<p data-nodeid="84510">因为所有的转换逻辑都封装在<code data-backticks="1" data-nodeid="84911">UserProfileListItemViewModel</code>的<code data-backticks="1" data-nodeid="84913">init(userDetails:)</code>方法里面，所以我们可以通过测试该<code data-backticks="1" data-nodeid="84915">init()</code>方法来验证数据转换的逻辑。上面的例子中，我们把预先准备好的 Model 数据<code data-backticks="1" data-nodeid="84917">TestFixture.userDetails</code>传递给<code data-backticks="1" data-nodeid="84919">UserProfileListItemViewModel</code>来初始化<code data-backticks="1" data-nodeid="84921">testSubject</code>，然后在<code data-backticks="1" data-nodeid="84923">it("should initialize the properties correctly")</code>方法里检验各个属性的转换结果，例如<code data-backticks="1" data-nodeid="84925">name</code>等于 “Jake Lin”，而<code data-backticks="1" data-nodeid="84927">avatarURL</code>和<code data-backticks="1" data-nodeid="84929">backgroundImageURL</code>都正确地从字符串转换成 URL 类型。</p>
<p data-nodeid="84511">下面是转换错误时的情况，代码如下：</p>
<pre class="lang-swift" data-nodeid="84512"><code data-language="swift">context(<span class="hljs-string">"when `userDetails.avatar` is not a valid URL"</span>) {
    beforeEach {
        testSubject = <span class="hljs-type">UserProfileListItemViewModel</span>(userDetails: <span class="hljs-type">MomentsDetails</span>.<span class="hljs-type">UserDetails</span>(id: <span class="hljs-string">"1"</span>, name: <span class="hljs-string">"name"</span>, avatar: <span class="hljs-string">"this is not a valid URL"</span>, backgroundImage: <span class="hljs-string">"https://background-image-url.com"</span>))
    }
    it(<span class="hljs-string">"`avatarURL` should be nil"</span>) {
        expect(testSubject.avatarURL).to(beNil())
    }
}
</code></pre>
<p data-nodeid="84513">当我们把无效的 URL 字符串传递给<code data-backticks="1" data-nodeid="84933">avatar</code>属性时，转换后的<code data-backticks="1" data-nodeid="84935">testSubject.avatarURL</code>就会变成<code data-backticks="1" data-nodeid="84937">nil</code>。</p>
<p data-nodeid="84514">其他转换错误的案例与上面的例子类似，你可以在拉勾教育的代码仓库里进行查看。</p>
<p data-nodeid="84515">到此为止，我们已经讲完如何为 MVVM 架构开发单元测试了。</p>
<h3 data-nodeid="84516">总结</h3>
<p data-nodeid="84517">在这一讲，我们以朋友圈功能作为例子，讲述如何通过 AAA 方法一步步地为网络层、Repository 层和 ViewModel 层编写单元测试。<strong data-nodeid="84947">通过 TDD 方式所开发的代码会迫使我们定义良好的接口，并使用依赖注入的方式来管理所有依赖项，因此，通过 TDD 方法所开发的模块都具备强内聚、弱耦合、可扩展等特性</strong>。同时，单元测试能帮助我们便捷地模拟不同的测试案例，从而提高代码的质量，减少 Bug 和 App 的崩溃率。希望你在工作中也可以推动 TDD，根据我的经验，编写单元测试所花费的时间远比以后修改 Bug 所需时间要少很多。</p>
<p data-nodeid="84518">现在，“架构与实现”模块我们已经讲述完毕了。在这个模块中，我们讲述了如何使用 BFF 设计跨平台的系统架构，然后分析了如何使用 RxSwift 来设计一套根据数据流自动更新的 MVVM 框架，并详细介绍了 MVVM 每一层的具体实现。</p>
<p data-nodeid="84519">在结束这一模块前，我还想再分享一下我个人对 App 架构与实现的理解，希望对你有所帮助。</p>
<p data-nodeid="84520">苹果公司所提供的 MVC 模式并没有很好地解决 App 架构的问题，iOS 开发社区在探索的过程中形成了多种架构，例如，使用 MVC 加上 Coordinator 的 MVCC 模式，还有 MVP、VIPER 以及文章中讲述的 MVVM 架构等。尽管它们的架构与实现可能不一样，但是它们的目的都是解决臃肿的 MVC 问题。除此之外，它们在设计过程中都遵循一些通用的原则，例如单一责任原则（每一个组件只完成单独的一个功能）和开闭原则（通过抽象的协议来封闭具体的实现，但同时开放对类型的扩展），等等。</p>
<p data-nodeid="84521">基于这些通用的设计原则，并结合多年的经验与教训，<strong data-nodeid="84960">我为 Moments App 重新架构和实现了一套基于 RxSwift 的 MVVM 架构</strong>。通过这一模块的学习，想必你已经见识到这套框架的威力了，但并不代表这就是默认的或者标准的 MVVM 实现方式，甚至可以说在软件架构领域根本就没有什么一成不变的标准方案，<strong data-nodeid="84961">一套好的方案应该可以根据需求的变化而不断地迭代与改进</strong>。</p>
<p data-nodeid="84522">当你想使用这套框架的时候，可以结合自己的项目，遵循通用的设计原则来慢慢改进，例如，把所有的网络层逻辑都封装到一个独立的模块中，其他模块必须通过网络层模块来访问网络，或者把所有数据访问都放到 Repository 模块中，UI 需要访问数据时都通过 Repository 来存取。又例如，当一个模块需要依赖于其他模块时，都在初始化方法中进行依赖注入，这样能方便我们以后替换具体实现，提高架构的可扩展性。</p>
<p data-nodeid="88292" class="te-preview-highlight">还有一点我想强调一下，写代码是一门手艺活。这个模块的代码实现比较多，我建议你从 GitHub 上把代码下载下来，并对照文章的内容一同学习，然后通过实现新功能来加深理解。<strong data-nodeid="88298">任何架构能力都是建立在代码能力之上的，要提高架构能力首先需要不断提高编写高质量代码的能力。</strong> 编写高质量代码通常需要灵活运用各种软件设计的原则，当能熟练使用这些原则时，架构 App 也就变成水到渠成的事情了。</p>

<p data-nodeid="84524"><strong data-nodeid="84971">思考题</strong></p>
<blockquote data-nodeid="84525">
<p data-nodeid="84526">这是架构与实现模块的最后一篇，我建议你在朋友圈时间轴页面里添加分享文章的功能，并编写相关的单元测试。通过这个功能的开发，能让你从头到尾理解整个 MVVM 框架的核心思想。</p>
</blockquote>
<p data-nodeid="84527">如果你完成该功能，请提交一个 PR 哦。如果你有什么想法，也可以写到留言区。下一讲我们会讲述“如何统一管理 Certificates 和 Profiles”，这就进入下一个模块——上架与优化。</p>
<p data-nodeid="84528"><strong data-nodeid="84977">源码地址</strong></p>
<blockquote data-nodeid="84529">
<p data-nodeid="84530">单元测试的源码地址：<br>
<a href="https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests?fileGuid=xxQTRXtVcqtHK6j8" data-nodeid="84982">https://github.com/lagoueduCol/iOS-linyongjian/tree/main/Moments/MomentsTests</a></p>
</blockquote>

---

### 精选评论

##### **鸿：
> 模块三打卡。

##### *静：
> 老师，可以再专门开个课讲单元测试吗😁

