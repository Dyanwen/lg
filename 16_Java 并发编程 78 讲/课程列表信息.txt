已发布: 80

238  ||  已发布  ||  开篇词： 由点及面，搭建你的 Java 并发知识网  ||  9e9ea635e5e4455cb782122770a34bf0
239  ||  已发布  ||  第01讲：为何说只有 1 种实现线程的方法？  ||  52a438dbdd194c48857e03cd4a913533
240  ||  已发布  ||  第02讲：如何正确停止线程？为什么 volatile 标记位的停止方法是错误的？  ||  dd6d4a0c6ba64c49b3c1d414c62cb1e9
241  ||  已发布  ||  第03讲：线程是如何在 6 种状态之间转换的？  ||  989e95da0f954a7899c54573c4663ed8
242  ||  已发布  ||  第04讲：wait/notify/notifyAll 方法的使用注意事项？  ||  03ecb0b65cb0485e912e6b713a77a7b2
243  ||  已发布  ||  第05讲：有哪几种实现生产者消费者模式的方法？  ||  5eacaf5926244a95bbcbc54f1e849e59
244  ||  已发布  ||  第06讲：一共有哪 3 类线程安全问题？  ||  7c9b4d1c85034d8983da0afc147ac5d3
245  ||  已发布  ||  第07讲：哪些场景需要额外注意线程安全问题？  ||  e7bf759c8267403dbf548a4852ff4f40
246  ||  已发布  ||  第08讲：为什么多线程会带来性能问题？  ||  d60017199dcb45a29371d112c6d7d67b
247  ||  已发布  ||  第09讲：使用线程池比手动创建线程好在哪里？  ||  f4a6ecb83a684af2a67a58da81631af0
248  ||  已发布  ||  第10讲：线程池的各个参数的含义？  ||  b8a8435e861e46e1870d3a5d562ccee2
249  ||  已发布  ||  第11讲：线程池有哪 4 种拒绝策略？  ||  0d4745d0b36042fbac02ac96a8bad204
250  ||  已发布  ||  第12讲：有哪 6 种常见的线程池？什么是 Java8 的 ForkJoinPool？  ||  fe0e2c8d024b413b83f67d3cbb966069
251  ||  已发布  ||  第13讲：线程池常用的阻塞队列有哪些？  ||  4dbce980ca9343aeba4f712aed730c97
252  ||  已发布  ||  第14讲：为什么不应该自动创建线程池？  ||  b1901dc7930c4069bf5e92e1626f06d9
253  ||  已发布  ||  第15讲：合适的线程数量是多少？CPU 核心数和线程数的关系？  ||  b57c50a0487d4418971ca67ddc55d2cc
254  ||  已发布  ||  第16讲：如何根据实际需要，定制自己的线程池？  ||  3a5184dd16694b6da95c7f7601e4cbb6
255  ||  已发布  ||  第17讲：如何正确关闭线程池？shutdown 和 shutdownNow 的区别？  ||  e8f9180b6f22457ba5c2af92a6e3a145
256  ||  已发布  ||  第18讲：线程池实现“线程复用”的原理？  ||  8552fe37caf84d289c25c76536e5fd2d
257  ||  已发布  ||  第19讲：你知道哪几种锁？分别有什么特点？  ||  7991f2044f24425982c8d0ae0c3c9aa0
258  ||  已发布  ||  第20讲：悲观锁和乐观锁的本质是什么？  ||  00e1a8d2510a4d9aac5c11d34266b123
259  ||  已发布  ||  第21讲：如何看到 synchronized 背后的“monitor 锁”？  ||  e3365fac8acd4601a21568f0b9f6e8fc
260  ||  已发布  ||  第22讲：synchronized 和 Lock 孰优孰劣，如何选择？  ||  256c8af94b8b4b5e923641a7c9db1279
261  ||  已发布  ||  第23讲：Lock 有哪几个常用方法？分别有什么用？  ||  854708dc576d48a5a75d6377c74443bc
262  ||  已发布  ||  第24讲：讲一讲公平锁和非公平锁，为什么要“非公平”？  ||  866744a9a282465da2b295a55d276872
265  ||  已发布  ||  第25讲：读写锁 ReadWriteLock 获取锁有哪些规则？  ||  f9a34d4bb02046de8e2d0ad3003fee2c
266  ||  已发布  ||  第26讲：读锁应该插队吗？什么是读写锁的升降级？  ||  7c33c1279bda4fd3a5c1330c822ba420
267  ||  已发布  ||  第27讲：什么是自旋锁？自旋的好处和后果是什么呢？  ||  ac27025274c34b5d9b5b193903972f41
268  ||  已发布  ||  第28讲：JVM 对锁进行了哪些优化？  ||  77a5b685c970491a94095807bdb72e61
263  ||  已发布  ||  第29讲：HashMap 为什么是线程不安全的？  ||  08e4494931a9499bad2fd324fd4fbd90
264  ||  已发布  ||  第30讲：ConcurrentHashMap 在 Java7 和 8 有何不同？  ||  43fdc12f1b9f4cc2bbeb1228dc182ec6
269  ||  已发布  ||  第31讲：为什么 Map 桶中超过 8 个才转为红黑树？  ||  a633642336b742ff80e4b026fd021a1f
270  ||  已发布  ||  第32讲：同样是线程安全，ConcurrentHashMap 和 Hashtable 的区别？  ||  3677c297d3c34b07b1d85fbdae5cfe8d
271  ||  已发布  ||  第33讲：CopyOnWriteArrayList 有什么特点？  ||  289dc16e4bb7458b8b65012e1d0b222b
272  ||  已发布  ||  第34讲：什么是阻塞队列？  ||  0e77171ee82a4ee287020c363a50cf05
273  ||  已发布  ||  第35讲：阻塞队列包含哪些常用的方法？add、offer、put 等方法的区别？  ||  fcf64958786141f48835dcac8e1c6a40
274  ||  已发布  ||  第36讲：有哪几种常见的阻塞队列？  ||  40b9cb0fc7cf48b09c1a1f2137a8cecd
275  ||  已发布  ||  第37讲：阻塞和非阻塞队列的并发安全原理是什么？  ||  4eed92ead5a6477e881a9bedfd81b700
276  ||  已发布  ||  第38讲：如何选择适合自己的阻塞队列？  ||  a105095778fb4a8db9fe1e1c306665d2
277  ||  已发布  ||  第39讲：原子类是如何利用 CAS 保证线程安全的？  ||  0c72949df506421ca405bf2902160e5f
278  ||  已发布  ||  第40讲：AtomicInteger 在高并发下性能不好，如何解决？为什么？  ||  1d8cc1830e764e22894aad33498d13f5
279  ||  已发布  ||  第41讲：原子类和 volatile 有什么异同？  ||  3ba9e12e0c7643ae831470ac1c0fb9b0
280  ||  已发布  ||  第42讲：AtomicInteger 和 synchronized 的异同点？  ||  4f9eb57952e345cebaea33f80c8f0c94
281  ||  已发布  ||  第43讲：Java 8 中 Adder 和 Accumulator 有什么区别？  ||  5a0979026b5c41308cf6e49b0b7b1353
282  ||  已发布  ||  第44讲：ThreadLocal 适合用在哪些实际生产的场景中？  ||  289fe08d365b4956a909ad288f87ebd0
283  ||  已发布  ||  第45讲：ThreadLocal 是用来解决共享资源的多线程访问的问题吗？  ||  e389e7d8c6e04a4f884e429b99bdf771
284  ||  已发布  ||  第46讲：多个 ThreadLocal 在 Thread 中的 threadlocals 里是怎么存储的？  ||  2e85afecfec54e809d7f26968f071c6c
285  ||  已发布  ||  第47讲：内存泄漏——为何每次用完 ThreadLocal 都要调用 remove()？  ||  bd62e71499234f6ca4d1419ae09e35f4
286  ||  已发布  ||  第48讲：Callable 和 Runnable 的不同？  ||  8ce2d1760c0c4f6e88da6f91e35bb63e
288  ||  已发布  ||  第49讲：Future 的主要功能是什么？  ||  4f2c62756aef4e16a4b778fdc107cadd
287  ||  已发布  ||  第50讲：使用 Future 有哪些注意点？Future 产生新的线程了吗？  ||  62b0f73bcd2d4c0eb97a26ac49ac4a05
289  ||  已发布  ||  第51讲：如何利用 CompletableFuture 实现“旅游平台”问题？  ||  ee69d278203d4c10a818f39be7255a31
290  ||  已发布  ||  第52讲：信号量能被 FixedThreadPool 替代吗？  ||  b6d1fb1cdf654c739b29944d793213d3
291  ||  已发布  ||  第53讲：CountDownLatch 是如何安排线程执行顺序的？  ||  c2c9147e7bd94db39f0bb16ca5d2c2f0
292  ||  已发布  ||  第54讲：CyclicBarrier 和 CountdownLatch 有什么异同？  ||  f3f87cc6e7c745639f516c5dfad6865b
293  ||  已发布  ||  第55讲：Condition、object.wait() 和 notify() 的关系？  ||  275e1081a328490288fbd3703607df1e
294  ||  已发布  ||  第56讲：讲一讲什么是 Java 内存模型？  ||  be276d6bdc1e4af8a8cb65d6e8f720e1
295  ||  已发布  ||  第57讲：什么是指令重排序？为什么要重排序？  ||  8968496152a84a889b4f07a57dcb4229
296  ||  已发布  ||  第58讲：Java 中的原子操作有哪些注意事项？  ||  c301cde6788e431386032197d2dcdfb0
297  ||  已发布  ||  第59讲：什么是“内存可见性”问题？  ||  dcaedcba07d64c3eab9f1ab8234d6d63
298  ||  已发布  ||  第60讲：主内存和工作内存的关系？  ||  7c6bf3447fe34f7a89b5301f0d88cc9e
299  ||  已发布  ||  第61讲：什么是 happens-before 规则？  ||  1af362c216634f409b1e48269622da99
300  ||  已发布  ||  第62讲：volatile 的作用是什么？与 synchronized 有什么异同？  ||  218edfbc8849496ab579d1d76e5cb135
301  ||  已发布  ||  第63讲：单例模式的双重检查锁模式为什么必须加 volatile？  ||  c1f17e2c2a8343a69889cae7cc36b27c
302  ||  已发布  ||  第64讲：你知道什么是 CAS 吗？  ||  791da679a8994382a5c410f738f1c0e4
303  ||  已发布  ||  第65讲：CAS 和乐观锁的关系，什么时候会用到 CAS？  ||  4f17d8e6546140949838d3e65fdbabed
304  ||  已发布  ||  第66讲：CAS 有什么缺点？  ||  6fd5c874103f4db189903f4594a6ca7e
305  ||  已发布  ||  第67讲：如何写一个必然死锁的例子？  ||  b4b2dbbfebb64e2a82ab1c74a1c816a9
306  ||  已发布  ||  第68讲：发生死锁必须满足哪 4 个条件？  ||  afea25035e384140aeeac634ee32b46e
307  ||  已发布  ||  第69讲：如何用命令行和代码定位死锁？  ||  3d8791889d214142bb8a31d48b408718
308  ||  已发布  ||  第70讲：有哪些解决死锁问题的策略？  ||  815be991a28e48b99b7f70ffebfd95df
309  ||  已发布  ||  第71讲：讲一讲经典的哲学家就餐问题  ||  6df853148c114fc8ab8ea40ef318339f
310  ||  已发布  ||  第72讲：final 的三种用法是什么？  ||  9fea94a059c74b5586e72a9be24cffcc
311  ||  已发布  ||  第73讲：为什么加了 final 却依然无法拥有“不变性”？  ||  9fd0ae21987a401d8b1635442a7bc065
312  ||  已发布  ||  第74讲：为什么 String 被设计为是不可变的？  ||  07ad556550ac4b71938e9835aad8f1b0
313  ||  已发布  ||  第75讲：为什么需要 AQS？AQS 的作用和重要性是什么？  ||  6370e387a9884ea9bdf37d5c7a786bc2
314  ||  已发布  ||  第76讲：AQS 的内部原理是什么样的？  ||  e2cfda98ed06432083c74021fe113bb4
315  ||  已发布  ||  第77讲：AQS 在 CountDownLatch 等类中的应用原理是什么？  ||  09926bd649aa4c2c881da5b493aec1f0
316  ||  已发布  ||  第78讲：一份独家的 Java 并发工具图谱  ||  741de87e3c99452f800d8a0f2474dc8e
8723  ||  已发布  ||  参考文献、版权声明、致谢  ||  942680909aa04013b9dc7ef6b7786c6a
