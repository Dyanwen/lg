<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">在本课时我们主要学习线程池内部结构，以及线程池中最常见的阻塞队列类型。</span></p>
<h2 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 22px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"></h2>
<h3 style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">线程池内部结构</span></h3>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;"> &nbsp; &nbsp; &nbsp; &nbsp;<img style="border-style: none; margin: 0px; padding: 0px; outline: invert; width: 350px; height: 250px; box-sizing: border-box;" src="https://s0.lgstatic.com/i/image3/M01/54/39/CgpOIF3nUryAHhreAAA4T0DXzFI487.png"> &nbsp; &nbsp; &nbsp;</span></p>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">线程池的内部结构主要由四部分组成，如图所示。</span></p>
<ul style="list-style-type: disc;">
 <li><p style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第一部分是线程池管理器，它主要负责管理线程池的创建、销毁、添加任务等管理操作，它是整个线程池的管家。</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第二部分是工作线程，也就是图中的线程 t0~t9，这些线程勤勤恳恳地从任务队列中获取任务并执行。</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第三部分是任务队列，作为一种缓冲机制，线程池会把当下没有处理的任务放入任务队列中，由于多线程同时从任务队列中获取任务是并发场景，此时就需要任务队列满足线程安全的要求，所以线程池中任务队列采用 BlockingQueue 来保障线程安全。</span></p></li>
 <li><p style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第四部分是任务，任务要求实现统一的接口，以便工作线程可以处理和执行。</span></p></li>
</ul>
<h2 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 22px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"></h2>
<h3 style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">阻塞队列</span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;"><br></span></h3>
<h2 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 22px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"><p style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;"><img style="border-style: none; margin: 0px; padding: 0px; outline: invert; width: 450px; height: 206px; box-sizing: border-box;" src="https://s0.lgstatic.com/i/image3/M01/54/39/Cgq2xl3nUryAJBkpAAA0_WFSrB8184.png"></span></p></h2>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">线程池中的这四个主要组成部分最值得我们关注的就是阻塞队列了，如表格所示，不同的线程池会选用不同的阻塞队列。</span></p>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;"><br></span></p>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">表格左侧是线程池，右侧为它们对应的阻塞队列，你可以看到 5 种线程池对应了 3 种阻塞队列，我们接下来对它们进行逐一的介绍。 </span></p>
<h3 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 17.13px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"></h3>
<h3 style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">LinkedBlockingQueue &nbsp; &nbsp;&nbsp;</span></h3>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">对于 FixedThreadPool 和 SingleThreadExector 而言，它们使用的阻塞队列是容量为 Integer.MAX_VALUE 的 LinkedBlockingQueue，可以认为是无界队列。由于 FixedThreadPool 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。这里需要注意，由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</span></p>
<h3 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 17.13px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"></h3>
<h3 style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">SynchronousQueue &nbsp; &nbsp; &nbsp;</span></h3>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。</span></p>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;"><br></span></p>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。<br></span></p>
<h3 style="box-sizing: border-box; color: rgb(0, 0, 0); font-family: -apple-system,BlinkMacSystemFont,PingFang SC,Helvetica,Tahoma,Arial,&amp;quot;Hiragino Sans GB&amp;quot;,&amp;quot;Microsoft YaHei&amp;quot;,&amp;quot;微软雅黑&amp;quot;,sans-serif; font-size: 17.13px; font-style: normal; font-variant: normal; font-weight: 700; letter-spacing: normal; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px; orphans: 2; outline-color: invert; outline-style: none; outline-width: medium; padding-bottom: 0px; padding-left: 0px; padding-right: 0px; padding-top: 0px; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px;"></h3>
<h3 style="text-align: justify; line-height: 1.75em;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">DelayedWorkQueue &nbsp; &nbsp; &nbsp;&nbsp;</span></h3>
<p style="margin: 0pt 0px; padding: 0px; outline: invert; text-align: justify; color: rgb(73, 73, 73); text-transform: none; line-height: 1.75em; text-indent: 0px; letter-spacing: normal; font-size: 11pt; font-style: normal; font-variant: normal; font-weight: 400; text-decoration: none; word-spacing: 0px; white-space: normal; box-sizing: border-box; orphans: 2; -webkit-text-stroke-width: 0px;"><span style="color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;"><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 </span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 12pt; box-sizing: border-box;">ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。</span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">DelayedWorkQueue </span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 12pt; box-sizing: border-box;">的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 </span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; box-sizing: border-box;">DelayedWorkQueue</span><span style="margin: 0px; padding: 0px; outline: invert; color: rgb(63, 63, 63); font-family: 微软雅黑,Microsoft YaHei; font-size: 12pt; box-sizing: border-box;">，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</span></span><br></p>

---

### 精选评论

##### *祥：
> ForkJoinPool用的是哪一种？它自己及fork出来的子线程的队列都没有上限吗？

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 用的是ForkJoinPoo的内部类WorkQueue，有上限，上限在源码中规定了：
static final int MAXIMUM_QUEUE_CAPACITY = 1 << 26; // 64M

##### **夜雨：
> 我也看源码了，确实SynchronousQueue队列的长队始终为0，那么队列既然始终为零，为啥还要这个队列存在呢。不理解，希望作者看到能回复我一下，谢谢

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 直接把任务递交，效率较高。

##### **威：
> SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中获取了队列中存储的元素。百度才知道，这篇完全没讲哇

 ###### &nbsp;&nbsp;&nbsp; 讲师回复：
> &nbsp;&nbsp;&nbsp; 你百度的内容，是不正确的。 实际上，SynchronousQueue队列的容量为0，实际不存储任何任务。

##### **栓：
> 讲的很棒，通俗易懂！希望学完可以轻松应对面试！！

##### **滔：
> 线程池的阻塞队列：LinkedBlockingQueue：容量大小为 Integer.MAX_Value，无界队列。对应线程池有 FixedThreaPool、SingleThreadPool；SynchronousQueue：容量大小为0。对应线程池有ChachedThreadPool(可理解线程数无限扩展);DelayedQueue: 延迟队列。队列中的任务不是按照任务存放的先后顺序放的，而是按照延迟时间的先后存放的。对应线程池有ScheduledThreadPool、SingleThreadScheduledPool。

##### *博：
> SynchronousQueue队列的长度应该是1实际不存储任务是因为ThreadPoolExecutor直接调用offer(E task)把刚放进去唯一的任务取走了SynchronousQueue本身是可以存放一条数据的pull/take

##### *桃：
> 线程组成:线程池管理器、工作线程、任务队列、任务。阻塞队列:LinkedBlockingQueueSynchronousQueueDelayedWorkQueue

